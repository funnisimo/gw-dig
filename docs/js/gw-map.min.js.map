{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/actor.js","../js/effect/effect.js","../js/tile/tile.js","../js/tile/index.js","../js/effect/handlers/emit.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/tile.js","../js/effect/handlers/clear.js","../js/effect/handlers/spawn.js","../js/effect/feature.js","../js/effect/handlers/feature.js","../js/map/cell.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/actorLayer.js","../js/layer/itemLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/draw/basic.js","../js/map/map.js","../js/memory/memory.js","../js/memory/system.js","../js/actor/kind.js","../js/actor/make.js","../js/item/item.js","../js/item/kind.js","../js/item/make.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/path.js","../js/horde/horde.js","../js/horde/make.js","../js/fx/fx.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nlet lastId = 0;\nexport class Entity {\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    addToMap(map, x, y) {\n        if (this.hasEntityFlag(Flags.Entity.L_ON_MAP)) {\n            throw new Error('Entity is currently on a map!');\n        }\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawStatus(buffer, bounds) {\n        return this.kind.drawStatus(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    toString() {\n        return `${this.constructor.name}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requiredTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requiredTileTags) {\n            if (typeof config.requiredTileTags === 'string') {\n                this.requiredTileTags = config.requiredTileTags\n                    .split(/[,|]/)\n                    .map((t) => t.trim());\n            }\n            else {\n                this.requiredTileTags = config.requiredTileTags\n                    .slice()\n                    .map((t) => t.trim());\n            }\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAllTileTags(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    avoidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAnyTileTag(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawStatus(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), 'purple');\n        return 1;\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.next = null;\n        this.leader = null;\n        this.items = null;\n        this.fov = null;\n        this.memory = null;\n        this.visionDistance = 99;\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.fov = other.fov;\n        this.memory = other.memory;\n        this.visionDistance = other.visionDistance;\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        if (this.fov) {\n            return this.fov.isDirectlyVisible(x, y);\n        }\n        else if (this.map) {\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.fov) {\n            return this.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// INVENTORY\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport class Effect {\n    constructor(config) {\n        this.id = '';\n        this.chance = 100 * 100; // 100%\n        this.bolt = null;\n        this.beam = false;\n        this.range = 0;\n        this.ball = null;\n        this.radius = 0;\n        this.center = false;\n        this.good = false;\n        this.seen = false;\n        if (typeof config.effects === 'string') {\n            config.effects = [config.effects];\n        }\n        else if (typeof config.effects === 'function') {\n            config.effects = [config.effects];\n        }\n        this.aim = config.aim || 'actor';\n        if (typeof config.chance === 'string') {\n            // '20%' becomes 2000\n            config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n        }\n        this.chance = config.chance || 100 * 100;\n        const type = config.type || 'self';\n        const parts = type.split(':');\n        if (type.startsWith('bolt') || type.startsWith('beam')) {\n            // bolt:range:sprite\n            this.type = parts[0];\n            this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n            this.bolt = parts[1] || 'missile';\n            this.beam = type.startsWith('beam');\n        }\n        else if (type.startsWith('ball') ||\n            type.startsWith('burst') ||\n            type.startsWith('aura')) {\n            this.type = parts[0];\n            this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n            this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n            this.ball = parts[3] || 'explosion';\n            this.center = !type.startsWith('aura');\n        }\n        else {\n            this.type = 'self';\n        }\n        if (typeof config.effects === 'string') {\n            config.effects = [config.effects];\n        }\n        else if (typeof config.effects === 'function') {\n            config.effects = [config.effects];\n        }\n        if (Array.isArray(config.effects)) {\n            this.effects = config.effects.map((e) => {\n                if (typeof e === 'function')\n                    return e;\n                return effectFnFromString(e);\n            });\n        }\n        else {\n            this.effects = [];\n            Object.entries(config.effects).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler) {\n                    this.effects.push(handler(value));\n                }\n                else if (typeof value === 'function') {\n                    this.effects.push(value);\n                }\n                else {\n                    throw new Error('Unknown effect: ' + key);\n                }\n            });\n        }\n        if (this.effects.length === 0)\n            throw new Error('No effects!');\n    }\n    clone() {\n        const other = new this.constructor(this);\n        return other;\n    }\n    fire(map, x, y, ctx = {}) {\n        const fctx = ctx;\n        fctx.good = this.good;\n        fctx.seen = this.seen;\n        if (!this.chance || map.rng.chance(this.chance, 10000)) {\n            // fire\n            for (let effect of this.effects) {\n                if (GWU.data.gameHasEnded)\n                    break;\n                fctx.map = map;\n                fctx.x = x;\n                fctx.y = y;\n                if (effect(fctx)) {\n                    fctx.didSomething = true;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        if (ctx.aware && fctx.didSomething) {\n            this.seen = true;\n        }\n        this.good = fctx.good;\n        return fctx;\n    }\n    reset() {\n        this.seen = false;\n    }\n}\nexport function effectFnFromString(e) {\n    const parts = e.split(':');\n    if (parts.length === 0)\n        throw new Error('Invalid effect string.');\n    // @ts-ignore\n    const name = parts.shift().toLowerCase();\n    const handler = handlers[name] || null;\n    if (!handler) {\n        throw new Error('Failed to find effect handler: ' + name);\n    }\n    return handler(parts);\n}\n//////////////////////\n// MAKE\nexport function make(opts) {\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    let config = {};\n    if (typeof opts === 'string') {\n        config = { type: 'self', effects: [opts] };\n    }\n    else if (typeof opts === 'function') {\n        config = { type: 'self', effects: [opts] };\n    }\n    else if (Array.isArray(opts)) {\n        config = { type: 'self', effects: opts };\n    }\n    else {\n        // object only\n        if (!opts.effects) {\n            config.effects = {};\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n        else {\n            Object.assign(config, opts);\n        }\n    }\n    return new Effect(config);\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (opts instanceof Effect)\n        return opts;\n    if (typeof opts === 'string') {\n        const effect = effects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\nexport function resetAll() {\n    Object.values(effects).forEach((e) => e.reset());\n}\nexport const effects = {};\nexport function install(id, config) {\n    const effect = config instanceof Effect ? config.clone() : make(config);\n    effects[id] = effect;\n    effect.id = id;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/effect';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string' && !value.includes(':')) {\n                effects[key] = value;\n                return;\n            }\n            effects[key] = makeEffect(value);\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function makeEmitHandler(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitEffect.bind(undefined, config);\n}\nexport function emitEffect(id, ctx) {\n    GWU.events.emit(id, ctx.x, ctx.y, ctx);\n    return true;\n}\ninstallHandler('emit', makeEmitHandler);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function makeMessageHandler(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageEffect.bind(undefined, info);\n}\nexport function messageEffect(info, ctx) {\n    const seen = ctx.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        ctx.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(ctx.x, ctx.y, msg, ctx);\n        ctx.didSomething = true;\n    }\n    return true; // always return true to not block other effects\n}\ninstallHandler('msg', makeMessageHandler);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function makeActivateMachine() {\n    return activateMachine;\n}\nexport function activateMachine(ctx) {\n    const cell = ctx.map.cell(ctx.x, ctx.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return false;\n    return ctx.map.activateMachine(machine, ctx.x, ctx.y, ctx);\n}\ninstallHandler('activateMachine', makeActivateMachine);\n","import { installHandler } from '../effect';\nexport function makeTileHandler(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    opts.id = opts.id.replace(/[!~]*/g, '');\n    return tileEffect.bind(opts);\n}\nexport function tileEffect(ctx) {\n    ctx.didSomething = ctx.map.setTile(ctx.x, ctx.y, this.id, this);\n    return ctx.didSomething;\n}\ninstallHandler('tile', makeTileHandler);\n","import * as Flags from '../../flags';\nimport { installHandler } from '../effect';\nexport function makeClearHandler(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearEffect.bind(undefined, layers);\n}\nexport function clearEffect(layers, ctx) {\n    if (!layers)\n        return false;\n    const cell = ctx.map.cell(ctx.x, ctx.y);\n    return cell.clearDepth(layers);\n}\ninstallHandler('clear', makeClearHandler);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../../flags';\nimport * as Tile from '../../tile';\nimport { installHandler } from '../effect';\nexport function makeSpawnHandler(parts) {\n    if (!parts)\n        throw new Error('Spawn effect needs configuration.');\n    const info = makeSpawnInfo(parts);\n    return spawnEffect.bind(undefined, info);\n}\nexport function makeSpawnInfo(parts) {\n    if (Array.isArray(parts)) {\n        parts = {\n            tile: parts[0],\n            grow: Number.parseInt(parts[1] || 0),\n            decrement: Number.parseInt(parts[2] || 100),\n            flags: parts[3] || '',\n        };\n    }\n    if (typeof parts === 'string') {\n        parts = parts.split(':').map((t) => t.trim());\n        parts = {\n            tile: parts[0],\n            grow: Number.parseInt(parts[1] || 0),\n            decrement: Number.parseInt(parts[2] || 100),\n            flags: parts[3] || '',\n        };\n    }\n    parts.flags = GWU.flag.from(Flags.Effect, parts.flags);\n    if (parts.tile.includes('!')) {\n        parts.flags |= Flags.Effect.E_SUPERPRIORITY;\n    }\n    if (parts.tile.includes('~')) {\n        parts.flags |=\n            Flags.Effect.E_BLOCKED_BY_ACTORS | Flags.Effect.E_BLOCKED_BY_ITEMS;\n    }\n    parts.tile = parts.tile.replace(/[!~]*/g, '');\n    return parts;\n}\nexport function spawnEffect(config, ctx) {\n    const id = config.tile;\n    const tile = Tile.tiles[id] || null;\n    if (!tile) {\n        throw new Error('Failed to find tile for effect: ' + id);\n    }\n    const abortIfBlocking = !!(config.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n    const isBlocking = !!(abortIfBlocking &&\n        !(config.flags & Flags.Effect.E_PERMIT_BLOCKING) &&\n        (tile.blocksPathing() ||\n            config.flags & Flags.Effect.E_TREAT_AS_BLOCKING));\n    let didSomething = false;\n    const spawnMap = ctx.changed || GWU.grid.alloc(ctx.map.width, ctx.map.height);\n    didSomething = computeSpawnMap(config, ctx, spawnMap);\n    if (!didSomething) {\n        !ctx.changed && GWU.grid.free(spawnMap);\n        return false;\n    }\n    if (abortIfBlocking && isBlocking && mapDisruptedBy(ctx.map, spawnMap)) {\n        !ctx.changed && GWU.grid.free(spawnMap);\n        return false;\n    }\n    if (config.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(ctx.map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n    if (config.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(ctx.map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n    if (config.flags & Flags.Effect.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(ctx.map, spawnMap, config.flags)) {\n            didSomething = true;\n        }\n    }\n    const spawned = spawnTiles(config.flags, spawnMap, ctx.map, tile, 0, ctx.machine || 0);\n    !ctx.changed && GWU.grid.free(spawnMap);\n    ctx.didSomething = spawned || didSomething;\n    return ctx.didSomething;\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\ninstallHandler('spawn', makeSpawnHandler);\n// tick\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0, machine) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = !!(flags & Flags.Effect.E_BLOCKED_BY_OTHER_LAYERS);\n    const superpriority = !!(flags & Flags.Effect.E_SUPERPRIORITY);\n    const blockedByActors = !!(flags & Flags.Effect.E_BLOCKED_BY_ACTORS);\n    const blockedByItems = !!(flags & Flags.Effect.E_BLOCKED_BY_ITEMS);\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.hasTile(tile)) {\n                // If the new cell already contains the fill terrain,\n                // if (tile.depth == Flags.Depth.GAS) {\n                //     spawnMap[i][j] = 1;\n                //     cell.gasVolume += volume;\n                // } else if (tile.depth == Flags.Depth.LIQUID) {\n                //     spawnMap[i][j] = 1;\n                //     cell.liquidVolume += volume;\n                // }\n            }\n            else if (map.setTile(i, j, tile, {\n                volume,\n                superpriority,\n                blockedByOtherLayers,\n                blockedByActors,\n                blockedByItems,\n                machine,\n            })) {\n                // if the fill won't violate the priority of the most important terrain in this cell:\n                spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                // map.redrawCell(cell);\n                // if (volume && cell.gas) {\n                //     cell.volume += (feat.volume || 0);\n                // }\n                cell.flags.cell |= Flags.Cell.EVENT_FIRED_THIS_TURN;\n                if (flags & Flags.Effect.E_PROTECTED) {\n                    cell.flags.cell |= Flags.Cell.EVENT_PROTECTED;\n                }\n                accomplishedSomething = true;\n                // debug('- tile', i, j, 'tile=', tile.id);\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.setMapFlag(Flags.Map.MAP_CHANGED);\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(config, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !config.matchTile && !isStart) {\n        return false;\n    }\n    if (config.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (config.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (config.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (config.matchTile && !isStart && !cell.hasTile(config.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(config, ctx, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    let startProb = config.grow || 0;\n    let probDec = config.decrement || 0;\n    const map = ctx.map;\n    spawnMap.fill(0);\n    if (!cellIsOk(config, ctx.map, ctx.x, ctx.y, true)) {\n        return false;\n    }\n    spawnMap[ctx.x][ctx.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(config, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as Spawn from './handlers/spawn';\nimport * as Flags from '../flags';\nexport class Feature {\n    constructor(config) {\n        this.id = config.id || '';\n        this.spawn =\n            typeof config.spawn === 'function'\n                ? config.spawn\n                : Spawn.makeSpawnInfo(config.spawn);\n        this.spawn.flags = GWU.flag.from(Flags.Effect, this.spawn.flags, config.flags || 0);\n        this.next = null;\n        if (config.next) {\n            this.next = Spawn.makeSpawnInfo(config.next);\n        }\n    }\n    fire(map, x, y, ctx) {\n        const fctx = ctx;\n        fctx.map = map;\n        fctx.x = x;\n        fctx.y = y;\n        const grid = (fctx.changed = GWU.grid.alloc(map.width, map.height));\n        const success = Spawn.spawnEffect(this.spawn, fctx);\n        if (this.next &&\n            (success || this.spawn.flags & Flags.Effect.E_NEXT_ALWAYS)) {\n            delete fctx.changed;\n            if (this.spawn.flags & Flags.Effect.E_NEXT_EVERYWHERE) {\n                for (let x = 0; x < grid.width; ++x) {\n                    for (let y = 0; y < grid.height; ++y) {\n                        if (grid[x][y]) {\n                            fctx.x = x;\n                            fctx.y = y;\n                            Spawn.spawnEffect(this.next, fctx);\n                        }\n                    }\n                }\n            }\n            else {\n                Spawn.spawnEffect(this.next, fctx);\n            }\n        }\n        GWU.grid.free(grid);\n        return ctx;\n    }\n}\nexport function makeFeature(config) {\n    return new Feature(config);\n}\nexport const features = {};\nexport function installFeature(id, config) {\n    if (!(config instanceof Feature)) {\n        config = makeFeature(config);\n    }\n    features[id] = config;\n    config.id = id;\n    return config;\n}\n","import { installHandler } from '../effect';\nimport * as Feature from '../feature';\nexport function makeFeatureHandler(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureEffect.bind(undefined, id);\n}\nexport function featureEffect(id, ctx) {\n    const feat = Feature.features[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    const result = feat.fire(ctx.map, ctx.x, ctx.y, ctx);\n    return result.didSomething;\n}\ninstallHandler('feature', makeFeatureHandler);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nGWU.color.install('cellStatusName', 'light_blue');\n// class CellEntities {\n//     cell: Cell;\n//     constructor(cell: Cell) {\n//         this.cell = cell;\n//     }\n//     eachItem(cb: EachCb<Item>): void {\n//         let object: Item | null = this.cell._item;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     eachActor(cb: EachCb<Actor>): void {\n//         let object: Actor | null = this.cell._actor;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     forEach(cb: EachCb<Entity>): void {\n//         this.eachItem(cb);\n//         this.eachActor(cb);\n//     }\n//     some(cb: MatchCb<Entity>): boolean {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         return false;\n//     }\n//     reduce(cb: ReduceCb<Entity>, start?: any): any {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         return start;\n//     }\n// }\nexport class Cell {\n    // toFire: Partial<Effect.EffectCtx>[] = [];\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n            this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n            this.map.needsRedraw = true;\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return this.tiles.some((t) => t && t.blocksPathing());\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const ground = this.depthTile(Flags.Depth.GROUND);\n            if (!ground || ground === TILE.tiles.NULL) {\n                this.tiles[0] = TILE.get(tile.groundTile);\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR) !==\n            tile.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithEffect(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasEffect(name)) || null;\n    }\n    fireEvent(event, ctx = {}) {\n        // ctx.cell = this;\n        let didSomething = false;\n        // console.log('fire event - %s', event);\n        for (const tile of this.tiles) {\n            if (!tile || !tile.effects)\n                continue;\n            const ev = tile.effects[event];\n            if (ev) {\n                const r = this._activate(ev, ctx);\n                if (r.didSomething) {\n                    didSomething = true;\n                }\n            }\n        }\n        return didSomething;\n    }\n    _activate(effect, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            return effect.fire(this.map, this.x, this.y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return ctx;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    addItem(item, withEffects = false) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        item.addToMap(this.map, this.x, this.y);\n        this.map.items.push(item);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (withEffects) {\n            if (item.key &&\n                item.key.matches(this.x, this.y) &&\n                this.hasEffect('key')) {\n                const tile = this.tileWithEffect('key');\n                this.map.queueEvent(this.x, this.y, 'key', {\n                    key: item,\n                    item,\n                    tile,\n                });\n            }\n            else if (this.hasEffect('add_item')) {\n                const tile = this.tileWithEffect('add_item');\n                this.map.queueEvent(this.x, this.y, 'add_item', {\n                    key: item,\n                    item,\n                    tile,\n                });\n            }\n        }\n        return true;\n    }\n    removeItem(item, withEffects = false) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.map.items.splice(foundIndex, 1); // delete the item\n        item.removeFromMap();\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (withEffects) {\n            if (item.isKey(this.x, this.y) && this.hasEffect('no_key')) {\n                const tile = this.tileWithEffect('no_key');\n                this.map.queueEvent(this.x, this.y, 'no_key', {\n                    key: item,\n                    item,\n                    tile,\n                });\n            }\n            else if (this.hasEffect('remove_item')) {\n                const tile = this.tileWithEffect('remove_item');\n                this.map.queueEvent(this.x, this.y, 'remove_item', {\n                    key: item,\n                    item,\n                    tile,\n                });\n            }\n        }\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    addActor(actor, withEffects = false) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        actor.addToMap(this.map, this.x, this.y);\n        this.map.actors.push(actor);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (withEffects) {\n            if (actor.isKey(this.x, this.y) && this.hasEffect('key')) {\n                const tile = this.tileWithEffect('key');\n                this.map.queueEvent(this.x, this.y, 'key', {\n                    key: actor,\n                    actor,\n                    tile,\n                });\n            }\n            else if (actor.isPlayer() && this.hasEffect('add_player')) {\n                const tile = this.tileWithEffect('add_player');\n                this.map.queueEvent(this.x, this.y, 'add_player', {\n                    player: actor,\n                    actor,\n                    tile,\n                });\n            }\n            else if (this.hasEffect('add_actor')) {\n                const tile = this.tileWithEffect('add_actor');\n                this.map.queueEvent(this.x, this.y, 'add_actor', {\n                    actor,\n                    tile,\n                });\n            }\n        }\n        return true;\n    }\n    removeActor(actor, withEffects = false) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        actor.removeFromMap();\n        this.map.actors.splice(foundIndex, 1); // delete the actor\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (withEffects) {\n            if (actor.isKey(this.x, this.y) && this.hasEffect('no_key')) {\n                const tile = this.tileWithEffect('no_key');\n                this.map.queueEvent(this.x, this.y, 'no_key', {\n                    key: actor,\n                    actor,\n                    tile,\n                    cell: this,\n                });\n            }\n            else if (actor.isPlayer() && this.hasEffect('remove_player')) {\n                const tile = this.tileWithEffect('remove_player');\n                this.map.queueEvent(this.x, this.y, 'remove_player', {\n                    actor,\n                    player: actor,\n                    tile,\n                    cell: this,\n                });\n            }\n            else if (this.hasEffect('remove_actor')) {\n                const tile = this.tileWithEffect('remove_actor');\n                this.map.queueEvent(this.x, this.y, 'remove_actor', {\n                    actor,\n                    tile,\n                    cell: this,\n                });\n            }\n        }\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawStatus(buffer, bounds) {\n        const lines = buffer.wrapText(bounds.x + 1, bounds.y, bounds.width - 1, this.getName(), 'cellStatusName');\n        return lines;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","// import * as GWU from 'gw-utils';\nimport { MapLayer } from './mapLayer';\nexport class ActorLayer extends MapLayer {\n    constructor(map, name = 'actor') {\n        super(map, name);\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class ItemLayer extends MapLayer {\n    constructor(map, name = 'item') {\n        super(map, name);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            cell.fireEvent(event, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport class BasicDrawer {\n    isAnyKindOfVisible(_cell) {\n        return true;\n    }\n    drawInto(dest, map, opts = {}) {\n        const buffer = dest instanceof GWU.buffer.Buffer ? dest : dest.buffer;\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, cell, opts.fov);\n                    buffer.drawSprite(x, y, mixer);\n                }\n            }\n        }\n    }\n    drawCell(dest, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n        }\n        this.applyLight(dest, cell, fov);\n        if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT |\n            Flags.Entity.L_LIST_IN_SIDEBAR, true)) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, cell) {\n        const ground = cell.tiles[Flags.Depth.GROUND];\n        const surface = cell.tiles[Flags.Depth.SURFACE];\n        const liquid = cell.tiles[Flags.Depth.LIQUID];\n        const gas = cell.tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (cell.hasItem()) {\n            const item = cell.map.itemAt(cell.x, cell.y);\n            if (item)\n                item.drawInto(dest);\n        }\n        if (cell.hasActor()) {\n            const actor = cell.map.actorAt(cell.x, cell.y);\n            if (actor)\n                actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = cell.map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake();\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (isRevealed) {\n                dest.scale(50);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\n// import { CellMemory } from './cellMemory';\nimport * as Effect from '../effect';\nimport { BasicDrawer } from '../draw/basic';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        // _memory: GWU.grid.Grid<CellMemory>;\n        this.machineCount = 0;\n        this._seed = 0;\n        this.rng = GWU.rng.random;\n        this.id = 'MAP';\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this._animations = [];\n        this._queuedEvents = [];\n        this.width = width;\n        this.height = height;\n        this.flags = { map: 0 };\n        this.layers = [];\n        if (opts.id) {\n            this.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this._seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        // this.fov = new GWU.fov.FovSystem(this, opts);\n        this.properties = {};\n        this.initLayers();\n    }\n    get seed() {\n        return this._seed;\n    }\n    set seed(v) {\n        this._seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n        this.addLayer(Flags.Depth.ITEM, new Layer.ItemLayer(this, 'item'));\n        this.addLayer(Flags.Depth.ACTOR, new Layer.ActorLayer(this, 'actor'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        return cell.addItem(item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this.cell(item.x, item.y);\n        return cell.removeItem(item, fireEffects);\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        return cell.addActor(actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this.cell(actor.x, actor.y);\n        return cell.removeActor(actor, fireEffects);\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    tick(dt) {\n        let didSomething = false;\n        this._animations.forEach((a) => {\n            didSomething = a.tick(dt) || didSomething;\n        });\n        this._animations = this._animations.filter((a) => a.isRunning());\n        didSomething = this.fireAll('tick') || didSomething;\n        for (let layer of this.layers) {\n            if (layer && layer.tick(dt)) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.machineCount = src.machineCount;\n        this._seed = src._seed;\n        this.properties = Object.assign({}, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    queueEvent(x, y, event, ctx) {\n        this._queuedEvents.push({ event, x, y, ctx });\n    }\n    fireQueuedEvents() {\n        for (let i = 0; i < this._queuedEvents.length; ++i) {\n            const info = this._queuedEvents[i];\n            const cell = this.cell(info.x, info.y);\n            cell.fireEvent(info.event, info.ctx);\n        }\n        this._queuedEvents.length = 0;\n    }\n    fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fireEvent(event, ctx);\n    }\n    fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.fireEvent(event, {\n                        force: true,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.fireEvent('machine', ctx) || didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    // Animator\n    addAnimation(a) {\n        this._animations.push(a);\n    }\n    removeAnimation(a) {\n        GWU.arrayDelete(this._animations, a);\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Map } from '../map/map';\nimport * as Flags from '../flags';\nexport class Memory extends Map {\n    constructor(map) {\n        super(map.width, map.height);\n        // this.actor = actor;\n        this.source = map;\n        this.cells.forEach((c) => c.setCellFlag(Flags.Cell.STABLE_MEMORY));\n    }\n    cell(x, y) {\n        let cell = this.cells[x][y];\n        if (!cell.hasCellFlag(Flags.Cell.STABLE_MEMORY)) {\n            cell = this.source.cell(x, y);\n        }\n        return cell;\n    }\n    memory(x, y) {\n        return this.cells[x][y];\n    }\n    isMemory(x, y) {\n        return this.cells[x][y].hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    setTile() {\n        throw new Error('Cannot set tiles on memory.');\n    }\n    addItem() {\n        throw new Error('Cannot add Items to memory!');\n    }\n    removeItem() {\n        throw new Error('Cannot remove Items from memory!');\n    }\n    //  moveItem(): boolean {\n    //     throw new Error('Cannot move Items on memory!');\n    // }\n    eachItem(cb) {\n        this.source.eachItem((i) => {\n            if (!this.isMemory(i.x, i.y)) {\n                cb(i);\n                const i2 = this.items.find((other) => other.id == i.id);\n                if (i2) {\n                    const mem = this.cell(i2.x, i2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ITEM | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.items, i2);\n                }\n            }\n        });\n        this.items.forEach(cb);\n    }\n    addActor() {\n        throw new Error('Cannot add Actors to memory!');\n    }\n    removeActor() {\n        throw new Error('Cannot remove Actors from memory!');\n    }\n    //  moveActor(): boolean {\n    //     throw new Error('Cannot move Actors on memory!');\n    // }\n    eachActor(cb) {\n        this.source.eachActor((a) => {\n            if (!this.isMemory(a.x, a.y)) {\n                cb(a);\n                const a2 = this.actors.find((other) => other.id == a.id);\n                if (a2) {\n                    const mem = this.cell(a2.x, a2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.actors, a2);\n                }\n            }\n        });\n        this.actors.forEach(cb);\n    }\n    storeMemory(x, y) {\n        const mem = this.cells[x][y];\n        const currentList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        const cell = this.source.cell(x, y);\n        mem.copy(cell);\n        mem.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        mem.map = this; // so that drawing this cell results in using the right map\n        let newList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR);\n        // add any current items+actors\n        if (cell.hasItem()) {\n            const item = this.source.itemAt(x, y);\n            if (item) {\n                const copy = item.clone();\n                copy._map = this; // memory is map\n                this.items.push(copy);\n                if (copy.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n                    newList = true;\n                }\n            }\n        }\n        if (cell.hasActor()) {\n            const actor = this.source.actorAt(x, y);\n            if (actor) {\n                const copy = actor.clone();\n                copy._map = this; // memory is map\n                this.actors.push(copy);\n                if (copy.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n                    newList = true;\n                }\n            }\n        }\n        if (currentList != newList) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        this.light.setLight(x, y, this.source.light.getLight(x, y));\n    }\n    forget(x, y) {\n        const mem = this.memory(x, y);\n        const currentList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        mem.clearCellFlag(Flags.Cell.STABLE_MEMORY);\n        let newList = this.source\n            .cell(x, y)\n            .hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        if (currentList != newList) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.forget(x, y);\n        }\n    }\n}\n","import { Memory } from './memory';\nconst cache = {};\nexport function store(actor, map, memory) {\n    let actorMemory = cache[actor.id];\n    if (!actorMemory) {\n        cache[actor.id] = actorMemory = {};\n    }\n    actorMemory[map.id] = memory;\n}\nexport function get(actor, map) {\n    let actorMemory = cache[actor.id];\n    if (actorMemory) {\n        const memory = actorMemory[map.id];\n        if (memory)\n            return memory;\n    }\n    return new Memory(map);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as Memory from '../memory';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        if (options.fov) {\n            actor.fov = options.fov;\n        }\n        if (options.memory) {\n            actor.memory = options.memory;\n        }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n            actor.memory = Memory.get(actor, map);\n        }\n        if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n            actor.fov = new GWU.fov.FovSystem(map);\n            actor.fov.follow = actor;\n            if (actor.memory) {\n                actor.fov.callback = actor.memory;\n            }\n        }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        if (actor._map && actor.memory) {\n            Memory.store(actor, actor._map, actor.memory);\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~Flags.Cell\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\n","import * as GWU from 'gw-utils';\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\n// export class SpriteFX extends FX {\n//     sprite: GWU.sprite.SpriteConfig;\n//     stepCount: number;\n//     x: number;\n//     y: number;\n//     constructor(\n//         map: Map,\n//         sprite: string | GWU.sprite.SpriteConfig,\n//         x: number,\n//         y: number,\n//         opts: SpriteFxOptions = {}\n//     ) {\n//         const count = opts.blink || 1;\n//         const duration = opts.duration || 1000;\n//         opts.speed = opts.speed || duration / (2 * count - 1);\n//         super(map, opts);\n//         if (typeof sprite === 'string') {\n//             const name = sprite;\n//             sprite = GWU.sprite.sprites[sprite];\n//             if (!sprite) throw new Error('Cannot find sprite! ' + name);\n//         }\n//         this.sprite = sprite;\n//         this.x = x || 0;\n//         this.y = y || 0;\n//         this.stepCount = 2 * count - 1;\n//     }\n//     start() {\n//         this.map.addFx(this.x, this.y, this.sprite);\n//         return super.start();\n//     }\n//     step() {\n//         --this.stepCount;\n//         if (this.stepCount <= 0) return this.stop();\n//         if (this.stepCount % 2 == 0) {\n//             this.map.removeFx(this);\n//         } else {\n//             this.map.addFx(this.x, this.y, this);\n//         }\n//     }\n//     stop(result?: any) {\n//         this.map.removeFx(this);\n//         return super.stop(result);\n//     }\n//     moveDir(dx: number, dy: number) {\n//         return this.moveTo(this.x + dx, this.y + dy);\n//     }\n//     moveTo(x: number, y: number) {\n//         this.map.moveFx(x, y, this);\n//         return true;\n//     }\n// }\nexport async function flashSprite(map, x, y, sprite, duration = 100, count = 1, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    // realTime\n    animator = animator || GWU.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nGWU.sprite.install('bump', 'white', 50);\nexport async function hit(map, target, sprite, duration, animator) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport async function miss(map, target, sprite, duration, animator) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport async function fadeInOut(map, x, y, sprite, duration = 100, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    animator = animator || GWU.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport async function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    const animator = opts.animator || map;\n    animator.addAnimation(tween);\n    return tween.start().then(() => entity);\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport async function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    const animator = opts.animator || map;\n    const promises = [];\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            promises.push(fadeInOut(map, loc[0], loc[1], sprite, opts.fade, animator));\n        }\n    });\n    animator.addAnimation(tween);\n    return tween\n        .start()\n        .then(() => {\n        return Promise.all(promises);\n    })\n        .then(() => {\n        const loc = line[line.length - 1];\n        return { x: loc[0], y: loc[1] };\n    });\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    opts.animator = opts.animator || map;\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const promises = [];\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        promises.push(fadeInOut(map, x1, y1, sprite, opts.fade, opts.animator));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(() => {\n        GWU.grid.free(grid);\n    });\n    opts.animator.addAnimation(tween);\n    return tween.start().then(() => {\n        return Promise.all(promises);\n    });\n}\n/*\nexport function explosionFor(\n    map: Map,\n    grid: GWU.grid.NumGrid,\n    x: number,\n    y: number,\n    radius: number,\n    sprite: string | GWU.sprite.SpriteConfig,\n    opts: ExplosionOptions = {}\n) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    const animation = new ExplosionFX(\n        map,\n        grid,\n        x,\n        y,\n        radius,\n        sprite,\n        opts.speed,\n        opts.fade,\n        opts.shape,\n        opts.center,\n        opts.stepFn\n    );\n    return opts.playFn!(animation);\n}\n*/\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            effects: 'TILE:DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: 'EMIT:UP_STAIRS',\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: 'EMIT:DOWN_STAIRS',\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([5, 8, 20]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(6, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    depth: 'SURFACE',\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_LIST_IN_SIDEBAR","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","lastId","kind","_map","key","machineHome","depth","light","flags","entity","next","id","map","hasEntityFlag","Flags.Entity","L_ON_MAP","Error","setEntityFlag","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","L_DESTROYED","other","constructor","copy","Object","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","opts","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawStatus","dest","_observer","drawSprite","name","EntityKind","config","requiredTileTags","flavor","description","make","split","t","trim","slice","init","_entity","length","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","makeOpts","Entity.Entity","super","leader","items","fov","memory","visionDistance","actor","Flags.Depth","ACTOR","hasActorFlag","Flags.Actor","IS_PLAYER","canSee","isAbleToSee","isDirectlyVisible","xy","distanceBetween","forLineBetween","i","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","item","pickupItem","dropItem","handlers","installHandler","handler","toLowerCase","chance","bolt","beam","range","ball","radius","center","good","seen","effects","aim","Math","floor","Number","parseFloat","type","parts","startsWith","parseInt","Array","isArray","e","effectFnFromString","entries","forEach","value","push","ctx","fctx","rng","effect","data","gameHasEnded","didSomething","aware","shift","undefined","from","install","clone","_a","_b","_c","_d","index","dissipate","priority","groundTile","article","tile","tileMech","hasEffect","Flags.Tile","T_IS_FLAMMABLE","arraysIntersect","every","blocksMove","hasTileFlag","T_PATHING_BLOCKER","arg","color","result","fg","toString","options","_e","_f","base","extends","tiles","text","replace","search","substring","delta","makeEffect","Flags.TileMech","ch","bg","opacity","all","get","args","makeEmitHandler","emitEffect","bind","events","emit","makeMessageHandler","src","info","msg","messageEffect","message","addAt","makeActivateMachine","activateMachine","machine","machineId","makeTileHandler","superpriority","blockedByActors","blockedByItems","tileEffect","setTile","makeClearHandler","layers","JSON","stringify","reduce","out","v","ALL_LAYERS","clearEffect","clearDepth","makeSpawnHandler","makeSpawnInfo","spawnEffect","grow","decrement","Flags.Effect","E_SUPERPRIORITY","Tile.tiles","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","blocksPathing","E_TREAT_AS_BLOCKING","spawnMap","changed","grid","alloc","height","computeSpawnMap","free","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","spawned","spawnTiles","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","volume","accomplishedSomething","blockedByOtherLayers","E_BLOCKED_BY_OTHER_LAYERS","hasTile","Flags.Cell","EVENT_FIRED_THIS_TURN","E_PROTECTED","EVENT_PROTECTED","setMapFlag","Flags.Map","MAP_CHANGED","cellIsOk","isStart","hasXY","hasCellFlag","blocksEffects","matchTile","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","dir","x2","y2","madeChange","startProb","probDec","fill","count","DIRS","clearAll","clear","GAS","LIQUID","SURFACE","GROUND","blockingMap","eachActor","a","loc","matchingLocNear","c","removeActor","addActor","eachItem","removeItem","addItem","Feature","spawn","Spawn.makeSpawnInfo","success","Spawn.spawnEffect","E_NEXT_ALWAYS","E_NEXT_EVERYWHERE","makeFeature","features","makeFeatureHandler","featureEffect","feat","Feature.features","fire","values","reset","chokeCount","TILE.tiles","NULL","snapshot","makeMixer","TILE.get","hasStableSnapshot","STABLE_SNAPSHOT","hasStableMemory","getSnapshot","checkEntities","some","hasItem","hasActor","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","needsRedraw","CHANGED","max","TILE.Tile","highestPriorityTile","cb","find","TILE.flags","T_BLOCKS_OTHER_LAYERS","hasAllEntityFlags","L_BLOCKS_EVERYTHING","L_SECRETLY_PASSABLE","current","blocksLayer","highestPriority","ground","depthTile","glowLightChanged","MAP_SIDEBAR_TILES_CHANGED","setCellFlag","CAUGHT_FIRE_THIS_TURN","blackOut","tileFlag","tileMechFlag","hasTileMechFlag","event","ev","_activate","Effect.effects","itemAt","withEffects","tileWithEffect","queueEvent","hasItems","foundIndex","obj","clearCellFlag","splice","isKey","actorAt","isPlayer","actors","player","HAS_FX","fx","fxAt","_fx","MapLayer","properties","_other","_x","_y","_tile","_actor","_item","_dt","TileLayer","ActorLayer","ItemLayer","GasLayer","startingVolume","spread","update","d","clearTile","min","total","highestVolume","startingTile","highestTile","updateCellVolume","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","TM_EXPLOSIVE_PROMOTE","x0","y0","n","fireEvent","force","BasicDrawer","_cell","Buffer","offsetX","offsetY","drawCell","needSnapshot","getAppearance","putSnapshot","applyLight","L_VISUALLY_DISTINCT","separate","surface","liquid","gas","drawInto","cosmetic","number","hasFx","dances","COLORS_DANCE","bake","isVisible","isRevealed","getLight","multiply","isCursor","invert","scale","machineCount","_seed","random","_animations","_queuedEvents","drawer","cells","seed","LightSystem","initLayers","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","ITEM","Layer.ItemLayer","Layer.ActorLayer","layer","isAt","fireEffects","hasPlayer","_addFx","updated","_removeFx","arrayDelete","fmt","log","console","dump","hasMapFlag","MAP_NEEDS_REDRAW","clearMapFlag","l","boundary","isBoundaryXY","clearTiles","dt","tick","filter","isRunning","fireAll","willFire","promoteChance","w","originX","originY","eachGlowLight","_cb","isDark","h","Memory","source","isMemory","i2","a2","mem","currentList","newList","setLight","forget","storeMemory","cache","store","actorMemory","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","HAS_MEMORY","Memory.get","USES_FOV","FovSystem","follow","callback","Memory.store","action","list","remove","makeOptions","kinds","makeKind","randomKind","match","forbidTags","k","made","quantity","ItemKind","Flags.Item","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","newX","newY","cellCount","floodFillCount","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","eachCell","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","prefab","charToTile","isStringArray","len","line","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","getCellPathCost","path","OBSTRUCTION","FORBIDDEN","fillCostMap","costMap","_v","x1","y1","distanceMap","calculateDistances","eightWays","straightDistanceBetween","getPath","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","matchingLoc","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","async","flashSprite","duration","animator","Entity.make","addFx","tween","visible","to","repeat","repeatDelay","onUpdate","removeFx","loop","addAnimation","start","fadeInOut","yoyo","onFinish","moveSprite","target","ceil","maxAxisFromTo","speed","isLoc","vals","stepFn","stopBeforeWalls","moveFx","stop","then","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","dirFromTo","fade","stopAtWalls","forLineFromTo","promises","lastIndex","Promise","checkExplosionOpts","FOV","isBlocked","calculate","r","minX","minY","maxX","maxY","rand","enter","open","close","dance"],"mappings":"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"}
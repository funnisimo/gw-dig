{"version":3,"file":"gw-dig.min.js","sources":["../js/site.js","../js/utils.js","../js/types.js","../js/hall.js","../js/room.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nexport const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const DEEP = 4;\nexport const SHALLOW = 5;\nexport const BRIDGE = 6;\nexport const UP_STAIRS = 7;\nexport const DOWN_STAIRS = 17;\nexport const IMPREGNABLE = 8;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport const SEQ = [];\nexport function initSeqence(length) {\n    SEQ.length = length;\n    for (let i = 0; i < length; ++i) {\n        SEQ[i] = i;\n    }\n    GW.random.shuffle(SEQ);\n}\nexport function fillCostGrid(source, costGrid) {\n    source.forEach((_v, x, y) => {\n        costGrid[x][y] = isPassable(source, x, y) ? 1 : GW.path.OBSTRUCTION;\n    });\n}\nexport function isPassable(grid, x, y) {\n    return (isFloor(grid, x, y) ||\n        isDoor(grid, x, y) ||\n        isBridge(grid, x, y) ||\n        isStairs(grid, x, y) ||\n        isShallow(grid, x, y));\n}\nexport function isNothing(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === NOTHING;\n}\nexport function isDiggable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === NOTHING;\n}\nexport function isFloor(grid, x, y) {\n    return grid.get(x, y) == FLOOR;\n}\nexport function isDoor(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === DOOR;\n}\nexport function isBridge(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === BRIDGE;\n}\nexport function isWall(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === WALL || v === IMPREGNABLE;\n}\nexport function isObstruction(grid, x, y) {\n    return isNothing(grid, x, y) || isWall(grid, x, y);\n}\nexport function isStairs(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === UP_STAIRS || v === DOWN_STAIRS;\n}\nexport function isDeep(grid, x, y) {\n    return grid.get(x, y) === DEEP;\n}\nexport function isShallow(grid, x, y) {\n    return grid.get(x, y) === SHALLOW;\n}\nexport function isAnyWater(grid, x, y) {\n    return isDeep(grid, x, y) || isShallow(grid, x, y);\n}\nexport function setGrid(grid, x, y, v) {\n    if (grid.hasXY(x, y))\n        grid[x][y] = v;\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nconst DIRS = GW.utils.DIRS;\nexport function attachRoom(map, roomGrid, room, opts) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (!(map.get(x, y) == SITE.NOTHING))\n            continue;\n        const dir = directionOfDoorSite(map, x, y);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door)\n                continue;\n            const offsetX = x - door[0];\n            const offsetY = y - door[1];\n            if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // TYPES.Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                attachDoor(map, room, opts, x, y, oppDir);\n                // door[0] = -1;\n                // door[1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachDoor(map, room, opts, x, y, dir) {\n    if (opts.door === 0)\n        return; // no door at all\n    const tile = opts.door || SITE.DOOR;\n    map[x][y] = tile; // Door site.\n    // most cases...\n    if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n        return;\n    }\n    if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x - k, y) === 0) {\n                if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n                    map[x - k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x + k, y) === 0) {\n                if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n                    map[x + k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n    else {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x, y - k) === 0) {\n                if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n                    map[x][y - k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x, y + k) === 0) {\n                if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n                    map[x][y + k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === SITE.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(grid, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (grid.hasXY(oppX, oppY) &&\n            grid.hasXY(newX, newY) &&\n            SITE.isFloor(grid, oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = directionOfDoorSite(roomGrid, x, y);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? SITE.DOOR\n                        : opts.room.door;\n                    map[xy[0]][xy[1]] = door; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // TYPES.Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.room.tile || SITE.FLOOR;\n            });\n            attachDoor(map, room, opts, x, y, oppDir);\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(grid, floorTile) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    floorTile = floorTile || SITE.FLOOR;\n    const DOORS = [[], [], [], []];\n    // const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = grid.height;\n    const w = grid.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (!grid[i][j]) {\n                dir = directionOfDoorSite(grid, i, j);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GW.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GW.grid.free(grid);\n    return doorSites;\n}\n","import * as GW from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\nexport var halls = {};\nexport function install(id, fn, config = {}) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    halls[id] = data;\n    return data;\n}\ninstall('DEFAULT', dig, { chance: 15 });\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLengthRange(dir, opts) {\n    if (!opts.length)\n        opts.length = [];\n    if (Array.isArray(opts.length)) {\n        if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n            return GW.range.make(opts.length[1] || [2, 9]);\n        }\n        else {\n            return GW.range.make(opts.length[0] || [9, 15]);\n        }\n    }\n    else {\n        return GW.range.make(opts.length);\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickLengthRange(dir, opts).hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digWide(opts, grid, room) {\n    opts = opts || {};\n    if (!opts.width) {\n        opts.width = 2;\n    }\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const width = pickWidth(opts) || 2;\n    const door = room.doors[dir];\n    const tile = opts.tile || SITE.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = GW.utils.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = GW.utils.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = GW.utils.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new TYPES.Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = GW.utils.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new TYPES.Hall([door[0], y0], dir, length, width);\n    }\n    hall.doors = hallDoors;\n    hall.width = width;\n    return hall;\n}\nexport function dig(opts, grid, room) {\n    opts = opts || {};\n    opts.width = 1;\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || SITE.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new TYPES.Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\n","import * as GW from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    rooms[id] = data;\n    return data;\n}\ninstall('DEFAULT', rectangular);\nexport function checkConfig(config, expected) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                return GW.utils.ERROR('Missing required config for digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GW.grid.free(blobGrid);\n    return new TYPES.Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GW.random.item.bind(GW.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GW.random.weighted.bind(GW.random, config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of room ids or map - ex: { ROOM_ID: weight }');\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        GW.utils.ERROR('Missing digger choice: ' + id);\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new TYPES.Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new TYPES.Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n    // if (height % 2 == 0 && minorWidth > 2) {\n    //     minorWidth -= 1;\n    // }\n    let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new TYPES.Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new TYPES.Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new TYPES.Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GW.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new TYPES.Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new TYPES.Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nclass Lakes {\n    constructor(width, height, disruptsFn, passableFn) {\n        this.width = width;\n        this.height = height;\n        this.disruptsFn = disruptsFn;\n        this.passableFn = passableFn;\n    }\n    create(setFn, opts = {}) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = opts.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = opts.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = opts.minSize || 5;\n        tries = opts.tries || 20;\n        maxCount = opts.count || 1;\n        canDisrupt = opts.canDisrupt || false;\n        const wreath = opts.wreath || 0; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const wreathTile = opts.wreathTile || SITE.SHALLOW;\n        const tile = opts.tile || SITE.DEEP;\n        const lakeGrid = GW.grid.alloc(this.width, this.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            lakeGrid.fill(SITE.NOTHING);\n            const bounds = lakeGrid.fillBlob(5, 4, 4, width, height, 55, 'ffffftttt', 'ffffttttt');\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                setFn(sx, sy, tile);\n                                if (wreath) {\n                                    GW.utils.forCircle(sx, sy, wreath, (i, j) => {\n                                        if (this.passableFn(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            setFn(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GW.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GW.grid.alloc(this.width, this.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GW.utils.forRect(this.width, this.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (this.disruptsFn(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (this.passableFn(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GW.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\nexport function digLakes(map, opts = {}) {\n    const digger = new Lakes(map.width, map.height, SITE.isStairs.bind(SITE, map), SITE.isPassable.bind(SITE, map));\n    return digger.create(SITE.setGrid.bind(SITE, map), opts);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(width, height, isAnyWaterFn, passableFn, bridgeFn) {\n        this.width = width;\n        this.height = height;\n        this.isAnyWaterFn = isAnyWaterFn;\n        this.isBridgeFn = bridgeFn;\n        this.isPassableFn = passableFn;\n    }\n    create(setFn, opts = {}) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxConnectionLength = opts.maxConnectionLength || 5;\n        const minimumPathingDistance = opts.minimumPathingDistance || 20;\n        const pathGrid = GW.grid.alloc(this.width, this.height);\n        const costGrid = GW.grid.alloc(this.width, this.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => this.isPassableFn(x, y) ? 1 : GW.path.OBSTRUCTION);\n        const SEQ = GW.random.sequence(this.width * this.height);\n        for (i = 0; i < SEQ.length; i++) {\n            x = Math.floor(SEQ[i] / this.height);\n            y = SEQ[i] % this.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            this.isPassableFn(x, y) &&\n                !this.isAnyWaterFn(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxConnectionLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (this.isAnyWaterFn(newX, newY)) {\n                        for (j = 0; j < maxConnectionLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!this.isAnyWaterFn(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    this.isPassableFn(newX, newY) &&\n                        j < maxConnectionLength) {\n                        GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minimumPathingDistance &&\n                            pathGrid[x][y] < GW.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(x, y, bridgeDir)) {\n                                    setFn(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    setFn(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(x, y, bridgeDir) {\n        if (this.isBridgeFn(x, y))\n            return true;\n        if (!this.isAnyWaterFn(x, y))\n            return false;\n        if (!this.isAnyWaterFn(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!this.isAnyWaterFn(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digBridges(map, minimumPathingDistance, maxConnectionLength) {\n    const builder = new Bridges(map.width, map.height, SITE.isAnyWater.bind(SITE, map), SITE.isPassable.bind(SITE, map), SITE.isBridge.bind(SITE, map));\n    return builder.create(SITE.setGrid.bind(SITE, map), {\n        minimumPathingDistance,\n        maxConnectionLength,\n    });\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(width, height, isFloorFn, isDiggableFn) {\n        this.width = width;\n        this.height = height;\n        this.isFloorFn = isFloorFn;\n        this.isDiggableFn = isDiggableFn;\n    }\n    create(setFn, opts = {}) {\n        let needUp = opts.up !== false;\n        let needDown = opts.down !== false;\n        const minDistance = opts.minDistance ||\n            Math.floor(Math.max(this.width, this.height) / 2);\n        const isValidLoc = opts.isValidXY || this.isStairXY.bind(this);\n        const setupFn = opts.setup || this.setupStairs.bind(this);\n        const locations = {};\n        let upLoc;\n        let downLoc;\n        if (opts.start && typeof opts.start !== 'string') {\n            let start = opts.start;\n            if (start === true) {\n                start = GW.random.matchingXY(this.width, this.height, isValidLoc);\n            }\n            else {\n                start = GW.random.matchingXYNear(GW.utils.x(start), GW.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(opts.up) && Array.isArray(opts.down)) {\n            const up = opts.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            const down = opts.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(opts.up) && !Array.isArray(opts.down)) {\n            const up = opts.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(this.width, this.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(opts.down) && !Array.isArray(opts.up)) {\n            const down = opts.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GW.random.matchingXY(this.width, this.height, (x, y) => {\n                    if (GW.utils.distanceBetween(x, y, \n                    // @ts-ignore\n                    downLoc[0], \n                    // @ts-ignore\n                    downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GW.random.matchingXY(this.width, this.height, isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(this.width, this.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GW.random.matchingXY(this.width, this.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            setupFn(upLoc[0], upLoc[1], setFn, opts.upTile || SITE.UP_STAIRS, opts.wall || SITE.IMPREGNABLE);\n            if (opts.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc !== undefined) {\n            locations.down = downLoc.slice();\n            setupFn(downLoc[0], downLoc[1], setFn, opts.downTile || SITE.DOWN_STAIRS, opts.wall || SITE.IMPREGNABLE);\n            if (opts.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= this.width || y >= this.height)\n            return false;\n        return true;\n    }\n    isStairXY(x, y) {\n        let count = 0;\n        if (!this.hasXY(x, y) || !this.isDiggableFn(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GW.utils.DIRS[i];\n            if (!this.hasXY(x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(x - dir[0], y - dir[1]))\n                return false;\n            if (this.isFloorFn(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!this.isDiggableFn(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!this.isDiggableFn(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!this.isDiggableFn(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(x, y, setFn, tile, wall) {\n        const indexes = GW.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GW.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (this.isFloorFn(x0, y0)) {\n                if (this.isDiggableFn(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GW.utils.ERROR('No stair direction found!');\n        setFn(x, y, tile);\n        const dirIndex = GW.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        for (let i = 0; i < GW.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GW.utils.CLOCK_DIRS[i];\n            setFn(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\nexport function addStairs(map, opts = {}) {\n    const stairs = new Stairs(map.width, map.height, SITE.isFloor.bind(SITE, map), SITE.isDiggable.bind(SITE, map));\n    return stairs.create(SITE.setGrid.bind(SITE, map), opts);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nimport * as HALL from './hall';\nimport * as ROOM from './room';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\n// import * as MAP from 'gw-map.js';\nexport * from './site';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport * as hall_1 from './hall';\nexport { hall_1 as hall };\nimport * as lake_1 from './lake';\nexport { lake_1 as lake };\nimport * as bridge_1 from './bridge';\nexport { bridge_1 as bridge };\nimport * as stairs_1 from './stairs';\nexport { stairs_1 as stairs };\nimport * as utils_1 from './utils';\nexport { utils_1 as utils };\nexport * from './types';\nexport function start(map) {\n    SITE.initSeqence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function addRoom(map, opts) {\n    opts = opts || { room: 'DEFAULT', hall: 'DEFAULT', tries: 10 };\n    if (typeof opts === 'string') {\n        opts = { room: opts };\n    }\n    if (opts.loc) {\n        opts.locs = [opts.loc];\n    }\n    if (!opts.room)\n        opts.room = 'DEFAULT';\n    if (typeof opts.room === 'function')\n        opts.room = { fn: opts.room };\n    if (typeof opts.room === 'string') {\n        const name = opts.room;\n        opts.room = ROOM.rooms[name];\n        if (!opts.room) {\n            GW.utils.ERROR('Failed to find room: ' + name);\n        }\n    }\n    const roomConfig = opts.room;\n    let hallConfig = null;\n    if (opts.hall === true)\n        opts.hall = 'DEFAULT';\n    if (opts.hall !== false && !opts.hall)\n        opts.hall = 'DEFAULT';\n    if (typeof opts.hall === 'function')\n        opts.hall = { fn: opts.hall };\n    if (typeof opts.hall === 'string') {\n        const name = opts.hall;\n        opts.hall = HALL.halls[name];\n        if (!opts.hall) {\n            GW.utils.ERROR('Failed to find hall: ' + name);\n            return null;\n        }\n        hallConfig = opts.hall;\n    }\n    else {\n        if (opts.hall && opts.hall.fn) {\n            hallConfig = opts.hall;\n        }\n    }\n    if (opts.door === false) {\n        opts.door = 0;\n    }\n    else if (opts.door === true) {\n        opts.door = SITE.DOOR;\n    }\n    else if (typeof opts.door === 'number') {\n        opts.door = GW.random.chance(opts.door) ? SITE.DOOR : SITE.FLOOR;\n    }\n    else {\n        opts.door = SITE.FLOOR;\n    }\n    let locs = opts.locs || null;\n    // @ts-ignore\n    if (locs && locs.doors)\n        locs = locs.doors;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(SITE.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        // @ts-ignore\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const digger = opts.room;\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    let attachHall = false;\n    if (hallConfig) {\n        let hallChance = hallConfig.chance !== undefined ? hallConfig.chance : 15;\n        attachHall = GW.random.chance(hallChance);\n    }\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(SITE.NOTHING);\n        // dig the room in the center\n        room = digger.fn(roomConfig, roomGrid);\n        // TODO - Allow choice of floor tile...\n        room.doors = UTILS.chooseRandomDoorSites(roomGrid, SITE.FLOOR);\n        if (attachHall && hallConfig) {\n            room.hall = hallConfig.fn(hallConfig, roomGrid, room);\n        }\n        if (locs) {\n            // try the doors first\n            result = UTILS.attachRoomAtMapDoor(map, locs, roomGrid, room, opts);\n        }\n        else {\n            result = UTILS.attachRoom(map, roomGrid, room, opts);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function addLoops(grid, minimumPathingDistance, maxConnectionLength) {\n    let startX, startY, endX, endY;\n    let i, j, d, x, y;\n    minimumPathingDistance =\n        minimumPathingDistance ||\n            Math.floor(Math.min(grid.width, grid.height) / 2);\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const siteGrid = grid;\n    const pathGrid = GW.grid.alloc(grid.width, grid.height);\n    const costGrid = GW.grid.alloc(grid.width, grid.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(grid, costGrid);\n    function isValidTunnelStart(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return false;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return false;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return false;\n        return true;\n    }\n    function isValidTunnelEnd(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return true;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return true;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return true;\n        return false;\n    }\n    for (i = 0; i < SITE.SEQ.length; i++) {\n        x = Math.floor(SITE.SEQ[i] / siteGrid.height);\n        y = SITE.SEQ[i] % siteGrid.height;\n        const cell = siteGrid[x][y];\n        if (!cell) {\n            for (d = 0; d <= 1; d++) {\n                // Try a horizontal door, and then a vertical door.\n                let dir = dirCoords[d];\n                if (!isValidTunnelStart(x, y, dir))\n                    continue;\n                j = maxConnectionLength;\n                // check up/left\n                if (grid.hasXY(x + dir[0], y + dir[1]) &&\n                    SITE.isPassable(grid, x + dir[0], y + dir[1])) {\n                    // just can't build directly into a door\n                    if (!grid.hasXY(x - dir[0], y - dir[1]) ||\n                        SITE.isDoor(grid, x - dir[0], y - dir[1])) {\n                        continue;\n                    }\n                }\n                else if (grid.hasXY(x - dir[0], y - dir[1]) &&\n                    SITE.isPassable(grid, x - dir[0], y - dir[1])) {\n                    if (!grid.hasXY(x + dir[0], y + dir[1]) ||\n                        SITE.isDoor(grid, x + dir[0], y + dir[1])) {\n                        continue;\n                    }\n                    dir = dir.map((v) => -1 * v);\n                }\n                else {\n                    continue; // not valid start for tunnel\n                }\n                startX = x + dir[0];\n                startY = y + dir[1];\n                endX = x;\n                endY = y;\n                for (j = 0; j < maxConnectionLength; ++j) {\n                    endX -= dir[0];\n                    endY -= dir[1];\n                    // if (grid.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                    if (isValidTunnelEnd(endX, endY, dir)) {\n                        break;\n                    }\n                }\n                if (j < maxConnectionLength) {\n                    GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[startX][startY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[endX][endY] > minimumPathingDistance &&\n                        pathGrid[endX][endY] < 30000) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Loop',\n                        //     startX,\n                        //     startY,\n                        //     ' => ',\n                        //     endX,\n                        //     endY,\n                        //     ' : ',\n                        //     pathGrid[endX][endY]\n                        // );\n                        while (endX !== startX || endY !== startY) {\n                            if (grid.get(endX, endY) == 0) {\n                                grid[endX][endY] = SITE.FLOOR;\n                                costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                            }\n                            endX += dir[0];\n                            endY += dir[1];\n                        }\n                        // TODO - Door is optional\n                        grid[x][y] = SITE.DOOR; // then turn the tile into a doorway.\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GW.grid.free(pathGrid);\n    GW.grid.free(costGrid);\n}\nexport function addLakes(map, opts) {\n    return LAKE.digLakes(map, opts);\n}\nexport function addBridges(map, minimumPathingDistance, maxConnectionLength) {\n    return BRIDGE.digBridges(map, minimumPathingDistance, maxConnectionLength);\n}\nexport function addStairs(map, opts = {}) {\n    return STAIRS.addStairs(map, opts);\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (SITE.isPassable(grid, i + k, j) &&\n                        !SITE.isPassable(grid, i + (1 - k), j) &&\n                        SITE.isObstruction(grid, i + (1 - k), j) &&\n                        !SITE.isPassable(grid, i + k, j + 1) &&\n                        SITE.isObstruction(grid, i + k, j + 1) &&\n                        SITE.isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = SITE.FLOOR; // todo - pick one of the passable tiles around it...\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        // todo - isDoorway...\n        if (cell == SITE.DOOR) {\n            if (\n            // TODO - isPassable\n            (grid.get(x + 1, y) == SITE.FLOOR ||\n                grid.get(x - 1, y) == SITE.FLOOR) &&\n                (grid.get(x, y + 1) == SITE.FLOOR ||\n                    grid.get(x, y - 1) == SITE.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor value\n            }\n            else if (\n            // todo - isPassable\n            (grid.get(x + 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== SITE.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor\n            }\n        }\n    });\n}\nexport function finishWalls(grid, tile = SITE.WALL) {\n    grid.forEach((cell, i, j) => {\n        if (cell == SITE.NOTHING) {\n            grid[i][j] = tile;\n        }\n    });\n}\n"],"names":["TILEMAP","0","1","2","3","8","4","5","6","7","17","SEQ","initSeqence","length","i","GW.random","shuffle","fillCostGrid","source","costGrid","forEach","_v","x","y","isPassable","GW.path","OBSTRUCTION","grid","isFloor","isDoor","isBridge","isStairs","isShallow","isNothing","get","isDiggable","isWall","v","isObstruction","isDeep","isAnyWater","setGrid","hasXY","DIRS","GW.utils","attachRoom","map","roomGrid","room","opts","doorSites","hall","doors","SITE.SEQ","Math","floor","height","dir","directionOfDoorSite","NO_DIRECTION","oppDir","door","offsetX","offsetY","roomFitsAt","GW.grid","offsetZip","_d","_s","j","tile","attachDoor","translate","width","UP","DOWN","didSomething","k","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","solutionDir","newX","newY","oppX","oppY","SITE.isFloor","attachRoomAtMapDoor","mapDoors","doorIndexes","sequence","attachRoomAtXY","dirs","offX","offY","chooseRandomDoorSites","floorTile","doorSiteFailed","DOORS","h","w","push","loc","item","xy","dx","dy","Hall","[object Object]","this","d","x2","y2","Room","digger","cx","cy","halls","install","id","fn","config","data","pickWidth","clamp","undefined","Array","isArray","weighted","GW.range","make","value","Number","parseInt","_pickWidth","pickLengthRange","pickHallDirection","hi","pickHallExits","obliqueChance","firstOpt","allowObliqueHallwayExit","chance","hallDoors","dir2","dig","DIR","TYPES.Hall","x0","y0","LEFT","rooms","checkConfig","expected","Object","entries","key","expect","have","ERROR","range","rectangular","fill","fillRect","TYPES.Room","destX","destY","blobGrid","alloc","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","free","choices","bind","digConfig","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","min","max","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","count","minX","maxX","minY","maxY","chunkCount","valueBounds","Lakes","disruptsFn","passableFn","setFn","lakeMaxHeight","lakeMaxWidth","lakeMinSize","tries","maxCount","canDisrupt","minSize","wreath","wreathTile","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","forCircle","lakeToMapX","lakeToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","first","floodFill","digLakes","SITE.isStairs","SITE","SITE.isPassable","create","SITE.setGrid","Bridges","isAnyWaterFn","bridgeFn","isBridgeFn","isPassableFn","maxConnectionLength","minimumPathingDistance","pathGrid","dirCoords","update","bridgeDir","calculateDistances","NO_PATH","isBridgeCandidate","digBridges","SITE.isAnyWater","SITE.isBridge","Stairs","isFloorFn","isDiggableFn","needUp","up","needDown","down","minDistance","isValidLoc","isValidXY","isStairXY","setupFn","setup","setupStairs","locations","upLoc","downLoc","start","matchingXY","matchingXYNear","distanceBetween","slice","upTile","wall","downTile","indexes","dirIndex","CLOCK_DIRS","findIndex","l","r","addStairs","SITE.isDiggable","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","SITE.isObstruction","finishDoors","cell","finishWalls","SITE.initSeqence","locs","name","ROOM.rooms","roomConfig","hallConfig","HALL.halls","attachHall","hallChance","result","UTILS.chooseRandomDoorSites","UTILS.attachRoomAtMapDoor","UTILS.attachRoom","startX","startY","endX","endY","siteGrid","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.isDoor","LAKE.digLakes","BRIDGE.digBridges","STAIRS.addStairs"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/digger.js","../js/dig.js","../js/gw.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, doors) {\n        this.width = 1;\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.x2 = this.x + length * d[0];\n        this.y2 = this.y + length * d[1];\n        this.dir = dir;\n        this.length = length;\n        this.doors = doors;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var diggers = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    diggers[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    if (!config.width || !config.height)\n        GW.utils.ERROR('All diggers require config to include width and height.');\n    Object.entries(opts).forEach(([key, expect]) => {\n        const have = config[key];\n        if (expect === true) {\n            // needs to be a number > 0\n            if (typeof have !== 'number') {\n                GW.utils.ERROR('Invalid configuration for digger: ' +\n                    key +\n                    ' expected number received ' +\n                    typeof have);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            const have = config[key];\n            if (typeof have !== 'number') {\n                config[key] = expect; // provide default\n            }\n        }\n        else if (Array.isArray(expect)) {\n            // needs to be an array with this size, these are the defaults\n            if (typeof have === 'number') {\n                config[key] = new Array(expect.length).fill(have);\n            }\n            else if (!Array.isArray(have)) {\n                GW.utils.WARN('Received unexpected config for digger : ' +\n                    key +\n                    ' expected array, received ' +\n                    typeof have +\n                    ', using defaults.');\n                config[key] = expect.slice();\n            }\n            else if (expect.length > have.length) {\n                for (let i = have.length; i < expect.length; ++i) {\n                    have[i] = expect[i];\n                }\n            }\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n        }\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * config.width); // 6\n    const maxWidth = config.width;\n    const minHeight = Math.floor(0.5 * config.height); // 4\n    const maxHeight = config.height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, CONST.FLOOR);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = config.choices;\n    }\n    else if (typeof config.choices == 'object') {\n        choices = Object.keys(config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    for (let choice of choices) {\n        if (!diggers[choice]) {\n            GW.utils.ERROR('Missing digger choice: ' + choice);\n        }\n    }\n    if (!grid)\n        return config;\n    let id;\n    if (Array.isArray(config.choices)) {\n        id = GW.random.item(config.choices);\n    }\n    else {\n        id = GW.random.weighted(config.choices);\n    }\n    const digger = diggers[id];\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entranceRoom(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.floor(0.4 * config.width); // 8\n    const roomHeight = config.height;\n    const roomWidth2 = config.width;\n    const roomHeight2 = Math.floor(0.5 * config.height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function crossRoom(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.max(2, Math.floor((config.width * GW.random.range(15, 60)) / 100)); // [3,12]\n    const roomWidth2 = Math.max(2, Math.floor((config.width * GW.random.range(20, 100)) / 100)); // [4,20]\n    const roomHeight = Math.max(2, Math.floor((config.height * GW.random.range(50, 100)) / 100)); // [3,7]\n    const roomHeight2 = Math.max(2, Math.floor((config.height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomX = GW.random.range(Math.max(0, Math.floor(grid.width / 2) - (roomWidth - 1)), Math.min(grid.width, Math.floor(grid.width / 2)));\n    const roomX2 = roomX +\n        Math.floor(roomWidth / 2) +\n        GW.random.range(0, 2) +\n        GW.random.range(0, 2) -\n        3 -\n        Math.floor(roomWidth2 / 2);\n    const roomY = Math.floor(grid.height / 2 - roomHeight);\n    const roomY2 = Math.floor(grid.height / 2 -\n        roomHeight2 -\n        (GW.random.range(0, 2) + GW.random.range(0, 1)));\n    grid.fill(0);\n    grid.fillRect(roomX - 5, roomY + 5, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2 - 5, roomY2 + 5, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2) - 5, Math.min(roomY, roomY2) - 5, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCrossRoom(config, grid) {\n    config = checkConfig(config, { width: 8, height: 5 });\n    if (!grid)\n        return config;\n    let majorWidth = Math.floor((config.width * GW.random.range(50, 100)) / 100); // [4,8]\n    let majorHeight = Math.floor((config.height * GW.random.range(75, 100)) / 100); // [4,5]\n    let minorWidth = Math.max(2, Math.floor((config.width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (majorHeight % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(2, Math.floor((config.height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    if (majorWidth % 2 == 0 && minorHeight > 2) {\n        minorHeight -= 1;\n    }\n    grid.fill(0);\n    const x = Math.floor((grid.width - majorWidth) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, majorWidth, minorHeight, CONST.FLOOR);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - majorHeight) / 2);\n    grid.fillRect(x2, y2, minorWidth, majorHeight, CONST.FLOOR);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(majorWidth, minorWidth), Math.max(majorHeight, minorHeight));\n}\nexport function rectangularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 4, minPct: 50 });\n    if (!grid)\n        return config;\n    const width = Math.floor((config.width * GW.random.range(config.minPct, 100)) / 100); // [3,6]\n    const height = Math.floor((config.height * GW.random.range(config.minPct, 100)) / 100); // [2,4]\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, CONST.FLOOR);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 6 });\n    if (!grid)\n        return config;\n    const radius = Math.floor(((Math.min(config.width, config.height) - 1) *\n        GW.random.range(75, 100)) /\n        200); // [3,4]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, CONST.FLOOR);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        width: 10,\n        height: 10,\n        altChance: 5,\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = Math.floor((Math.min(config.width, config.height) * GW.random.range(75, 100)) / 100); // [5,10]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, CONST.FLOOR);\n    if (radius > config.ringMinWidth + config.holeMinSize &&\n        GW.random.chance(config.holeChance)) {\n        grid.fillCircle(x, y, GW.random.range(config.holeMinSize, radius - config.holeMinSize), 0);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, { count: 8 });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = Math.floor((config.count * GW.random.range(25, 100)) / 100); // [2,8]\n    minX = Math.floor(grid.width / 2) - Math.floor(config.width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(config.width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(config.height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(config.height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, CONST.FLOOR);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, CONST.FLOOR);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    return new Room(config.id, minX, minY, maxX - minX + 1, maxY - minY + 1);\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nexport * from './digger';\nimport { diggers as DIGGERS, Hall } from './digger';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = config.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(config, roomGrid);\n        const attachHall = GW.random.chance(hallChance);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = attachHallway(roomGrid, room, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoors(map, locs, roomGrid, room, config);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, config);\n        }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts = {}) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                // doorSites[oppDir][0] = -1;\n                // doorSites[oppDir][1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function fitRoomAtMapLoc(map, xy, roomGrid, room, opts = {}) {\n    // console.log('fitRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoors(map, mapDoors, roomGrid, room, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoors', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const x = mapDoors[index][0];\n        const y = mapDoors[index][1];\n        return attachRoomAtXY(map, x, y, roomGrid, room, opts);\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts = {}) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        if (doorSites[oppDir][0] != -1 &&\n            roomFitsAt(map, roomGrid, x - doorSites[oppDir][0], y - doorSites[oppDir][1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - doorSites[oppDir][0];\n            const offY = y - doorSites[oppDir][1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function attachHallway(grid, room, opts) {\n    let i, x, y, newX, newY;\n    let dir, dir2;\n    opts = opts || {};\n    const tile = opts.tile || CONST.FLOOR;\n    const horizontalLength = GW.utils.firstOpt('horizontalHallLength', opts, [\n        9,\n        15,\n    ]);\n    const verticalLength = GW.utils.firstOpt('verticalHallLength', opts, [\n        2,\n        9,\n    ]);\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const doors = room.doors;\n    // Pick a direction.\n    dir = opts.dir;\n    if (dir === undefined) {\n        const dirs = GW.random.sequence(4);\n        for (i = 0; i < 4; i++) {\n            dir = dirs[i];\n            if (doors[dir][0] != -1 &&\n                doors[dir][1] != -1 &&\n                grid.hasXY(doors[dir][0] +\n                    Math.floor(DIRS[dir][0] * horizontalLength[1]), doors[dir][1] + Math.floor(DIRS[dir][1] * verticalLength[1]))) {\n                break; // That's our direction!\n            }\n        }\n        if (i == 4) {\n            return null; // No valid direction for hallways.\n        }\n    }\n    let maxLength = 0;\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        maxLength = GW.random.range(verticalLength[0], verticalLength[1]);\n    }\n    else {\n        maxLength = GW.random.range(horizontalLength[0], horizontalLength[1]);\n    }\n    x = doors[dir][0];\n    y = doors[dir][1];\n    const attachLoc = [x - DIRS[dir][0], y - DIRS[dir][1]];\n    let length = 0;\n    for (length = 0; length < maxLength; length++) {\n        if (grid.hasXY(x, y)) {\n            grid[x][y] = tile;\n        }\n        else {\n            break;\n        }\n        x += DIRS[dir][0];\n        y += DIRS[dir][1];\n    }\n    if (length < 2)\n        return null;\n    x = GW.utils.clamp(x - DIRS[dir][0], 0, grid.width - 1);\n    y = GW.utils.clamp(y - DIRS[dir][1], 0, grid.height - 1); // Now (x, y) points at the last interior cell of the hallway.\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n    ];\n    for (dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            hallDoors[dir2][0] = -1;\n            hallDoors[dir2][1] = -1;\n        }\n        else {\n            hallDoors[dir2][0] = newX;\n            hallDoors[dir2][1] = newY;\n        }\n    }\n    return new Hall(attachLoc, dir, length, hallDoors);\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n"],"names":["Hall","[object Object]","loc","dir","length","doors","this","width","x","y","d","GW.utils","DIRS","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","diggers","checkConfig","config","opts","ERROR","Object","entries","key","expect","have","Array","isArray","fill","i","WARN","slice","SEQ","attachRoom","map","roomGrid","room","doorSites","get","GW.grid","directionOfDoorSite","NO_DIRECTION","oppDir","offsetX","offsetY","roomFitsAt","offsetZip","_d","_s","j","tile","door","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","hasXY","isBoundaryXY","attachRoomAtMapDoors","mapDoors","doorIndexes","GW.random","sequence","index","attachRoomAtXY","dirs","offX","offY","chooseRandomDoorSites","sourceGrid","k","newX","newY","doorSiteFailed","grid","alloc","copy","randomMatchingLoc","free","attachHallway","dir2","horizontalLength","firstOpt","verticalLength","obliqueChance","undefined","maxLength","UP","DOWN","range","attachLoc","clamp","allowObliqueHallwayExit","chance","hallDoors","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","diggerId","id","DIGGERS","locs","count","assign","hallChance","hallway","result","tries","fn","attachHall","xy","destX","destY","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","choices","keys","choice","item","weighted","digConfig","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","min","max","majorWidth","majorHeight","minorWidth","minorHeight","minPct","radius","fillCircle","altChance","ringMinWidth","holeMinSize","holeChance","minX","maxX","minY","maxY","chunkCount"],"mappings":"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"}
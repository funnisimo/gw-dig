{"version":3,"file":"gw-dig.min.js","sources":["../js/room.js","../js/gw.js","../js/hall.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    rooms[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    Object.entries(opts).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                GW.utils.WARN('Missing required config for digger: ' + key);\n                return;\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n            return;\n        }\n        const range = GW.range.make(have);\n        if (!range) {\n            GW.utils.ERROR('Invalid configuration for digger: ' + key);\n        }\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GW.random.item.bind(GW.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GW.random.weighted.bind(GW.random, config.choices);\n    }\n    else {\n        return GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        return GW.utils.ERROR('Missing digger choice: ' + id);\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (height % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GW.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nexport function pickHallWidth(opts = {}) {\n    return GW.utils.clamp(_pickHallWidth(opts), 1, 3);\n}\nfunction _pickHallWidth(opts) {\n    if (typeof opts === 'number')\n        return opts;\n    if (!opts)\n        return 1;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLengthRange(dir, opts) {\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return GW.range.make(opts.yLength || opts.length || [2, 9]);\n    }\n    else {\n        return GW.range.make(opts.xLength || opts.length || [9, 15]);\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickLengthRange(dir, opts).hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digWide(grid, room, opts) {\n    opts = opts || {};\n    if (!opts.width) {\n        opts.width = 2;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    console.log('dir', dir);\n    const length = pickLengthRange(dir, opts).value();\n    console.log('length', length);\n    const width = pickHallWidth(opts) || 2;\n    const door = room.doors[dir];\n    const tile = opts.tile || CONST.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new Hall([door[0], y0], dir, length, width);\n    }\n    hall.doors = hallDoors;\n    hall.width = width;\n    return hall;\n}\nexport function dig(grid, room, opts) {\n    opts = opts || {};\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    console.log('dir', dir);\n    const length = pickLengthRange(dir, opts).value();\n    console.log('length', length);\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || CONST.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport * as HALL from './hall';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport { rooms as ROOM_DIGGERS, Room, Hall } from './room';\nexport { Room, Hall };\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = ROOM_DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    const attachHall = GW.random.chance(hallChance);\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = config.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(config, roomGrid);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = HALL.dig(roomGrid, room, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, config);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, config);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts = {}) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                // doorSites[oppDir][0] = -1;\n                // doorSites[oppDir][1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts = {}) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts = {}) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n"],"names":["Hall","[object Object]","loc","dir","length","width","this","doors","x","y","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","rooms","checkConfig","config","opts","Object","entries","key","expect","have","undefined","WARN","Array","isArray","range","GW.range","make","ERROR","id","fn","grid","destX","destY","blobGrid","value","tile","GW.grid","alloc","minWidth","maxWidth","minHeight","maxHeight","fill","bounds","fillBlob","offsetZip","free","choices","GW.random","item","bind","weighted","digConfig","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","min","max","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","chance","count","i","minX","maxX","minY","maxY","chunkCount","valueBounds","pickLengthRange","yLength","xLength","dig","room","NO_DIRECTION","dirs","sequence","hi","door","hasXY","pickHallDirection","console","log","DIR","newX","newY","obliqueChance","firstOpt","allowObliqueHallwayExit","hallDoors","dir2","pickHallExits","SEQ","attachRoom","map","roomGrid","doorSites","get","directionOfDoorSite","oppDir","offsetX","offsetY","roomFitsAt","_d","_s","j","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","attachRoomAtMapDoor","mapDoors","doorIndexes","attachRoomAtXY","offX","offY","chooseRandomDoorSites","sourceGrid","k","doorSiteFailed","copy","randomMatchingLoc","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","diggerId","ROOM_DIGGERS","locs","hallChance","hallway","attachHall","result","tries","HALL.dig","xy"],"mappings":"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"}
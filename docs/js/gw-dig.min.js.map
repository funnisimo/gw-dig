{"version":3,"file":"gw-dig.min.js","sources":["../js/site.js","../js/utils.js","../js/types.js","../js/hall.js","../js/room.js","../js/lake.js","../js/stairs.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nexport const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const DEEP = 4;\nexport const SHALLOW = 5;\nexport const BRIDGE = 6;\nexport const UP_STAIRS = 7;\nexport const DOWN_STAIRS = 17;\nexport const IMPREGNABLE = 8;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport const SEQ = [];\nexport function initSeqence(length) {\n    SEQ.length = length;\n    for (let i = 0; i < length; ++i) {\n        SEQ[i] = i;\n    }\n    GW.random.shuffle(SEQ);\n}\nexport function fillCostGrid(source, costGrid) {\n    source.forEach((_v, x, y) => {\n        costGrid[x][y] = isPassable(source, x, y) ? 1 : GW.path.OBSTRUCTION;\n    });\n}\nexport function isPassable(grid, x, y) {\n    return (isFloor(grid, x, y) ||\n        isDoor(grid, x, y) ||\n        isBridge(grid, x, y) ||\n        isStairs(grid, x, y) ||\n        isShallow(grid, x, y));\n}\nexport function isNothing(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === NOTHING;\n}\nexport function isFloor(grid, x, y) {\n    return grid.get(x, y) == FLOOR;\n}\nexport function isDoor(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === DOOR;\n}\nexport function isBridge(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === BRIDGE;\n}\nexport function isWall(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === WALL || v === IMPREGNABLE;\n}\nexport function isObstruction(grid, x, y) {\n    return isNothing(grid, x, y) || isWall(grid, x, y);\n}\nexport function isStairs(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === UP_STAIRS || v === DOWN_STAIRS;\n}\nexport function isDeep(grid, x, y) {\n    return grid.get(x, y) === DEEP;\n}\nexport function isShallow(grid, x, y) {\n    return grid.get(x, y) === SHALLOW;\n}\nexport function isAnyWater(grid, x, y) {\n    return isDeep(grid, x, y) || isShallow(grid, x, y);\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nconst DIRS = GWU.xy.DIRS;\nexport function attachRoom(map, roomGrid, room, opts) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (!(map.get(x, y) == SITE.NOTHING))\n            continue;\n        const dir = directionOfDoorSite(map, x, y, SITE.FLOOR);\n        if (dir != GWU.xy.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door)\n                continue;\n            const offsetX = x - door[0];\n            const offsetY = y - door[1];\n            if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // TYPES.Room fits here.\n                GWU.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                attachDoor(map, room, opts, x, y, oppDir);\n                // door[0] = -1;\n                // door[1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachDoor(map, room, opts, x, y, dir) {\n    if (opts.door === 0)\n        return; // no door at all\n    const tile = opts.door || SITE.DOOR;\n    map[x][y] = tile; // Door site.\n    // most cases...\n    if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n        return;\n    }\n    if (dir === GWU.xy.UP || dir === GWU.xy.DOWN) {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x - k, y) === 0) {\n                if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n                    map[x - k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x + k, y) === 0) {\n                if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n                    map[x + k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n    else {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x, y - k) === 0) {\n                if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n                    map[x][y - k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x, y + k) === 0) {\n                if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n                    map[x][y + k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === SITE.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(grid, x, y, isOpen) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    const fnOpen = typeof isOpen === 'function'\n        ? isOpen\n        : (v) => v == isOpen;\n    solutionDir = GWU.xy.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (grid.hasXY(oppX, oppY) &&\n            grid.hasXY(newX, newY) &&\n            fnOpen(grid[oppX][oppY], oppX, oppY, grid)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GWU.xy.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GWU.xy.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = directionOfDoorSite(roomGrid, x, y, SITE.FLOOR);\n        if (dir != GWU.xy.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GWU.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? SITE.DOOR\n                        : opts.room.door;\n                    map[xy[0]][xy[1]] = door; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts) {\n    const doorIndexes = GWU.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GWU.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // TYPES.Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GWU.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.room.tile || SITE.FLOOR;\n            });\n            attachDoor(map, room, opts, x, y, oppDir);\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.xy.Loc;\n            //     return [x0, y0] as GW.xy.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid, floorTile) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    floorTile = floorTile || SITE.FLOOR;\n    const grid = GWU.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = directionOfDoorSite(grid, i, j, floorTile);\n                if (dir != GWU.xy.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GWU.grid.free(grid);\n    return doorSites;\n}\n","import * as GWU from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GWU.xy.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GWU.xy.UP || dir === GWU.xy.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GW.xy.DIRS;\nexport var halls = {};\nexport function install(id, fn, config = {}) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    halls[id] = data;\n    return data;\n}\ninstall('DEFAULT', dig, { chance: 15 });\nexport function pickWidth(opts = {}) {\n    return GW.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = GW.random.weighted(width);\n        if (typeof width === 'string') {\n            width = Number.parseInt(width);\n        }\n    }\n    return width;\n}\nexport function pickLengthRange(dir, opts) {\n    if (!opts.length)\n        opts.length = [];\n    if (Array.isArray(opts.length)) {\n        if (dir == GW.xy.UP || dir == GW.xy.DOWN) {\n            return GW.range.make(opts.length[1] || [2, 9]);\n        }\n        else {\n            return GW.range.make(opts.length[0] || [9, 15]);\n        }\n    }\n    else {\n        return GW.range.make(opts.length);\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.xy.NO_DIRECTION;\n    if (dir == GW.xy.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickLengthRange(dir, opts).hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.xy.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.object.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digWide(opts, grid, room) {\n    opts = opts || {};\n    if (!opts.width) {\n        opts.width = 2;\n    }\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.xy.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const width = pickWidth(opts) || 2;\n    const door = room.doors[dir];\n    const tile = opts.tile || SITE.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.xy.UP) {\n        x0 = GW.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.xy.DOWN) {\n        x0 = GW.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.xy.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = GW.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new TYPES.Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = GW.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new TYPES.Hall([door[0], y0], dir, length, width);\n    }\n    hall.doors = hallDoors;\n    hall.width = width;\n    return hall;\n}\nexport function dig(opts, grid, room) {\n    opts = opts || {};\n    opts.width = 1;\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.xy.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || SITE.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new TYPES.Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\n","import * as GWU from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    rooms[id] = data;\n    return data;\n}\ninstall('DEFAULT', rectangular);\nexport function checkConfig(config, expected) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                return GWU.ERROR('Missing required config for digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GWU.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    blobGrid = GWU.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = GWU.blob.fillBlob(blobGrid, {\n        rounds: 5,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        percentSeeded: 55,\n    });\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GWU.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GWU.grid.free(blobGrid);\n    return new TYPES.Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GWU.random.item.bind(GWU.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GWU.random.weighted.bind(GWU.random, config.choices);\n    }\n    else {\n        GWU.ERROR('Expected choices to be either array of room ids or map - ex: { ROOM_ID: weight }');\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        GWU.ERROR('Missing digger choice: ' + id);\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new TYPES.Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GWU.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GWU.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GWU.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new TYPES.Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GWU.random.range(25, 50)) / 100)); // [2,4]\n    // if (height % 2 == 0 && minorWidth > 2) {\n    //     minorWidth -= 1;\n    // }\n    let minorHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new TYPES.Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new TYPES.Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new TYPES.Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || SITE.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GWU.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GWU.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new TYPES.Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || SITE.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GWU.random.range(minX, maxX);\n        y = GWU.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new TYPES.Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport function digLakes(map, opts = {}) {\n    let i, j, k;\n    let x, y;\n    let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n    let count = 0;\n    lakeMaxHeight = opts.height || 15; // TODO - Make this a range \"5-15\"\n    lakeMaxWidth = opts.width || 30; // TODO - Make this a range \"5-30\"\n    lakeMinSize = opts.minSize || 5;\n    tries = opts.tries || 20;\n    maxCount = opts.count || 1;\n    canDisrupt = opts.canDisrupt || false;\n    const wreath = opts.wreath || 0; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n    const wreathTile = opts.wreathTile || SITE.SHALLOW;\n    const tile = opts.tile || SITE.DEEP;\n    const lakeGrid = GWU.grid.alloc(map.width, map.height, 0);\n    let attempts = 0;\n    while (attempts < maxCount && count < maxCount) {\n        // lake generations\n        const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n            maxCount) + lakeMinSize;\n        const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n            maxCount) + lakeMinSize;\n        lakeGrid.fill(SITE.NOTHING);\n        const bounds = GWU.blob.fillBlob(lakeGrid, {\n            rounds: 5,\n            minWidth: 4,\n            minHeight: 4,\n            maxWidth: width,\n            maxHeight: height,\n            percentSeeded: 55,\n        });\n        // lakeGrid.dump();\n        let success = false;\n        for (k = 0; k < tries && !success; k++) {\n            // placement attempts\n            // propose a position for the top-left of the lakeGrid in the dungeon\n            x = GWU.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n            y = GWU.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n            if (canDisrupt || !lakeDisruptsPassability(map, lakeGrid, -x, -y)) {\n                // level with lake is completely connected\n                //   dungeon.debug(\"Placed a lake!\", x, y);\n                success = true;\n                // copy in lake\n                for (i = 0; i < bounds.width; i++) {\n                    // skip boundary\n                    for (j = 0; j < bounds.height; j++) {\n                        // skip boundary\n                        if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                            const sx = i + bounds.x + x;\n                            const sy = j + bounds.y + y;\n                            map[sx][sy] = tile;\n                            if (wreath) {\n                                map.forCircle(sx, sy, wreath, (v, i, j) => {\n                                    if (v === SITE.FLOOR || v === SITE.DOOR) {\n                                        map[i][j] = wreathTile;\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        if (success) {\n            ++count;\n        }\n        else {\n            ++attempts;\n        }\n    }\n    GWU.grid.free(lakeGrid);\n    return count;\n}\nfunction lakeDisruptsPassability(map, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    map.forEach((v, i, j) => {\n        const lakeX = i + lakeToMapX;\n        const lakeY = j + lakeToMapY;\n        if (!v) {\n            return; // not walkable\n        }\n        else if (SITE.isStairs(map, i, j)) {\n            if (lakeGrid.get(lakeX, lakeY)) {\n                disrupts = true;\n            }\n            else {\n                walkableGrid[i][j] = 1;\n            }\n        }\n        else if (SITE.isPassable(map, i, j)) {\n            if (lakeGrid.get(lakeX, lakeY))\n                return;\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nfunction isBridgeCandidate(map, x, y, bridgeDir) {\n    if (map.get(x, y) === SITE.BRIDGE)\n        return true;\n    if (!SITE.isAnyWater(map, x, y))\n        return false;\n    if (!SITE.isAnyWater(map, x + bridgeDir[1], y + bridgeDir[0]))\n        return false;\n    if (!SITE.isAnyWater(map, x - bridgeDir[1], y - bridgeDir[0]))\n        return false;\n    return true;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digBridges(map, minimumPathingDistance, maxConnectionLength) {\n    let newX, newY;\n    let i, j, d, x, y;\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const siteGrid = map;\n    const pathGrid = GWU.grid.alloc(map.width, map.height);\n    const costGrid = GWU.grid.alloc(map.width, map.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(map, costGrid);\n    const SEQ = GWU.random.sequence(map.width * map.height);\n    for (i = 0; i < SEQ.length; i++) {\n        x = Math.floor(SEQ[i] / siteGrid.height);\n        y = SEQ[i] % siteGrid.height;\n        if (map.hasXY(x, y) &&\n            map.get(x, y) &&\n            SITE.isPassable(map, x, y) &&\n            !SITE.isAnyWater(map, x, y)) {\n            for (d = 0; d <= 1; d++) {\n                // Try right, then down\n                const bridgeDir = dirCoords[d];\n                newX = x + bridgeDir[0];\n                newY = y + bridgeDir[1];\n                j = maxConnectionLength;\n                if (!map.hasXY(newX, newY))\n                    continue;\n                // check for line of lake tiles\n                // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                if (SITE.isAnyWater(map, newX, newY)) {\n                    for (j = 0; j < maxConnectionLength; ++j) {\n                        newX += bridgeDir[0];\n                        newY += bridgeDir[1];\n                        // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                        if (!SITE.isAnyWater(map, newX, newY)) {\n                            break;\n                        }\n                    }\n                }\n                if (map.get(newX, newY) &&\n                    SITE.isPassable(map, newX, newY) &&\n                    j < maxConnectionLength) {\n                    GWU.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[newX][newY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[x][y] > minimumPathingDistance &&\n                        pathGrid[x][y] < GWU.path.NO_PATH) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Bridge',\n                        //     x,\n                        //     y,\n                        //     ' => ',\n                        //     newX,\n                        //     newY\n                        // );\n                        while (x !== newX || y !== newY) {\n                            if (isBridgeCandidate(map, x, y, bridgeDir)) {\n                                map[x][y] = SITE.BRIDGE;\n                                costGrid[x][y] = 1; // (Cost map also needs updating.)\n                            }\n                            else {\n                                map[x][y] = SITE.FLOOR;\n                                costGrid[x][y] = 1;\n                            }\n                            x += bridgeDir[0];\n                            y += bridgeDir[1];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(pathGrid);\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport function isValidStairLoc(_v, x, y, map) {\n    let count = 0;\n    if (!SITE.isObstruction(map, x, y))\n        return false;\n    for (let i = 0; i < 4; ++i) {\n        const dir = GWU.xy.DIRS[i];\n        if (!map.hasXY(x + dir[0], y + dir[1]))\n            return false;\n        if (!map.hasXY(x - dir[0], y - dir[1]))\n            return false;\n        if (SITE.isFloor(map, x + dir[0], y + dir[1])) {\n            count += 1;\n            if (!SITE.isObstruction(map, x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                return false;\n            if (!SITE.isObstruction(map, x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                return false;\n        }\n        else if (!SITE.isObstruction(map, x + dir[0], y + dir[1])) {\n            return false;\n        }\n    }\n    return count == 1;\n}\nexport function setupStairs(map, x, y, tile) {\n    const indexes = GWU.random.sequence(4);\n    let dir = null;\n    for (let i = 0; i < indexes.length; ++i) {\n        dir = GWU.xy.DIRS[i];\n        const x0 = x + dir[0];\n        const y0 = y + dir[1];\n        if (SITE.isFloor(map, x0, y0)) {\n            if (SITE.isObstruction(map, x - dir[0], y - dir[1]))\n                break;\n        }\n        dir = null;\n    }\n    if (!dir)\n        GWU.ERROR('No stair direction found!');\n    map.set(x, y, tile);\n    const dirIndex = GWU.xy.CLOCK_DIRS.findIndex(\n    // @ts-ignore\n    (d) => d[0] == dir[0] && d[1] == dir[1]);\n    for (let i = 0; i < GWU.xy.CLOCK_DIRS.length; ++i) {\n        const l = i ? i - 1 : 7;\n        const r = (i + 1) % 8;\n        if (i == dirIndex || l == dirIndex || r == dirIndex)\n            continue;\n        const d = GWU.xy.CLOCK_DIRS[i];\n        map.set(x + d[0], y + d[1], SITE.WALL);\n        // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n    }\n    // dungeon.debug('setup stairs', x, y, tile);\n    return true;\n}\nexport function addStairs(map, opts = {}) {\n    let needUp = opts.up !== false;\n    let needDown = opts.down !== false;\n    const minDistance = opts.minDistance || Math.floor(Math.max(map.width, map.height) / 2);\n    const isValidLoc = opts.isValid || isValidStairLoc;\n    const setupFn = opts.setup || setupStairs;\n    let upLoc = Array.isArray(opts.up) ? opts.up : null;\n    let downLoc = Array.isArray(opts.down) ? opts.down : null;\n    const locations = {};\n    if (opts.start && typeof opts.start !== 'string') {\n        let start = opts.start;\n        if (start === true) {\n            start = map.randomMatchingLoc(isValidLoc);\n        }\n        else {\n            start = map.matchingLocNear(GWU.xy.x(start), GWU.xy.y(start), isValidLoc);\n        }\n        locations.start = start;\n    }\n    if (upLoc && downLoc) {\n        upLoc = map.matchingLocNear(GWU.xy.x(upLoc), GWU.xy.y(upLoc), isValidLoc);\n        downLoc = map.matchingLocNear(GWU.xy.x(downLoc), GWU.xy.y(downLoc), isValidLoc);\n    }\n    else if (upLoc && !downLoc) {\n        upLoc = map.matchingLocNear(GWU.xy.x(upLoc), GWU.xy.y(upLoc), isValidLoc);\n        if (needDown) {\n            downLoc = map.randomMatchingLoc((v, x, y) => {\n                if (GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                    minDistance)\n                    return false;\n                return isValidLoc(v, x, y, map);\n            });\n        }\n    }\n    else if (downLoc && !upLoc) {\n        downLoc = map.matchingLocNear(GWU.xy.x(downLoc), GWU.xy.y(downLoc), isValidLoc);\n        if (needUp) {\n            upLoc = map.randomMatchingLoc((v, x, y) => {\n                if (GWU.xy.distanceBetween(x, y, downLoc[0], downLoc[1]) <\n                    minDistance)\n                    return false;\n                return isValidStairLoc(v, x, y, map);\n            });\n        }\n    }\n    else if (needUp) {\n        upLoc = map.randomMatchingLoc(isValidLoc);\n        if (needDown) {\n            downLoc = map.randomMatchingLoc((v, x, y) => {\n                if (GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                    minDistance)\n                    return false;\n                return isValidStairLoc(v, x, y, map);\n            });\n        }\n    }\n    else if (needDown) {\n        downLoc = map.randomMatchingLoc(isValidLoc);\n    }\n    if (upLoc) {\n        locations.up = upLoc.slice();\n        setupFn(map, upLoc[0], upLoc[1], opts.upTile || SITE.UP_STAIRS);\n        if (opts.start === 'up')\n            locations.start = locations.up;\n    }\n    if (downLoc) {\n        locations.down = downLoc.slice();\n        setupFn(map, downLoc[0], downLoc[1], opts.downTile || SITE.DOWN_STAIRS);\n        if (opts.start === 'down')\n            locations.start = locations.down;\n    }\n    return upLoc || downLoc ? locations : null;\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nimport * as HALL from './hall';\nimport * as ROOM from './room';\nimport * as LAKE from './lake';\nimport * as STAIRS from './stairs';\n// import * as MAP from 'gw-map.js';\nexport * from './site';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport * as hall_1 from './hall';\nexport { hall_1 as hall };\nimport * as lake_1 from './lake';\nexport { lake_1 as lake };\nimport * as stairs_1 from './stairs';\nexport { stairs_1 as stairs };\nimport * as utils_1 from './utils';\nexport { utils_1 as utils };\nexport * from './types';\nexport function start(map) {\n    SITE.initSeqence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function addRoom(map, opts) {\n    opts = opts || { room: 'DEFAULT', hall: 'DEFAULT', tries: 10 };\n    if (typeof opts === 'string') {\n        opts = { room: opts };\n    }\n    if (opts.loc) {\n        opts.locs = [opts.loc];\n    }\n    if (!opts.room)\n        opts.room = 'DEFAULT';\n    if (typeof opts.room === 'function')\n        opts.room = { fn: opts.room };\n    if (typeof opts.room === 'string') {\n        const name = opts.room;\n        opts.room = ROOM.rooms[name];\n        if (!opts.room) {\n            GWU.ERROR('Failed to find room: ' + name);\n        }\n    }\n    const roomConfig = opts.room;\n    let hallConfig = null;\n    if (opts.hall === true)\n        opts.hall = 'DEFAULT';\n    if (opts.hall !== false && !opts.hall)\n        opts.hall = 'DEFAULT';\n    if (typeof opts.hall === 'function')\n        opts.hall = { fn: opts.hall };\n    if (typeof opts.hall === 'string') {\n        const name = opts.hall;\n        opts.hall = HALL.halls[name];\n        if (!opts.hall) {\n            GWU.ERROR('Failed to find hall: ' + name);\n            return null;\n        }\n        hallConfig = opts.hall;\n    }\n    else {\n        if (opts.hall && opts.hall.fn) {\n            hallConfig = opts.hall;\n        }\n    }\n    if (opts.door === false) {\n        opts.door = 0;\n    }\n    else if (opts.door === true) {\n        opts.door = SITE.DOOR;\n    }\n    else if (typeof opts.door === 'number') {\n        opts.door = GWU.random.chance(opts.door) ? SITE.DOOR : SITE.FLOOR;\n    }\n    else {\n        opts.door = SITE.FLOOR;\n    }\n    let locs = opts.locs || null;\n    // @ts-ignore\n    if (locs && locs.doors)\n        locs = locs.doors;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(SITE.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        // @ts-ignore\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const digger = opts.room;\n    const roomGrid = GWU.grid.alloc(map.width, map.height);\n    let attachHall = false;\n    if (hallConfig) {\n        let hallChance = hallConfig.chance !== undefined ? hallConfig.chance : 15;\n        attachHall = GWU.random.chance(hallChance);\n    }\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(SITE.NOTHING);\n        // dig the room in the center\n        room = digger.fn(roomConfig, roomGrid);\n        // TODO - Allow choice of floor tile...\n        room.doors = UTILS.chooseRandomDoorSites(roomGrid, SITE.FLOOR);\n        if (attachHall && hallConfig) {\n            room.hall = hallConfig.fn(hallConfig, roomGrid, room);\n        }\n        if (locs) {\n            // try the doors first\n            result = UTILS.attachRoomAtMapDoor(map, locs, roomGrid, room, opts);\n        }\n        else {\n            result = UTILS.attachRoom(map, roomGrid, room, opts);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GWU.grid.free(roomGrid);\n    return room && result ? room : null;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function addLoops(grid, minimumPathingDistance, maxConnectionLength) {\n    let startX, startY, endX, endY;\n    let i, j, d, x, y;\n    minimumPathingDistance =\n        minimumPathingDistance ||\n            Math.floor(Math.min(grid.width, grid.height) / 2);\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const siteGrid = grid;\n    const pathGrid = GWU.grid.alloc(grid.width, grid.height);\n    const costGrid = GWU.grid.alloc(grid.width, grid.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(grid, costGrid);\n    function isValidTunnelStart(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return false;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return false;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return false;\n        return true;\n    }\n    function isValidTunnelEnd(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return true;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return true;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return true;\n        return false;\n    }\n    for (i = 0; i < SITE.SEQ.length; i++) {\n        x = Math.floor(SITE.SEQ[i] / siteGrid.height);\n        y = SITE.SEQ[i] % siteGrid.height;\n        const cell = siteGrid[x][y];\n        if (!cell) {\n            for (d = 0; d <= 1; d++) {\n                // Try a horizontal door, and then a vertical door.\n                let dir = dirCoords[d];\n                if (!isValidTunnelStart(x, y, dir))\n                    continue;\n                j = maxConnectionLength;\n                // check up/left\n                if (grid.hasXY(x + dir[0], y + dir[1]) &&\n                    SITE.isPassable(grid, x + dir[0], y + dir[1])) {\n                    // just can't build directly into a door\n                    if (!grid.hasXY(x - dir[0], y - dir[1]) ||\n                        SITE.isDoor(grid, x - dir[0], y - dir[1])) {\n                        continue;\n                    }\n                }\n                else if (grid.hasXY(x - dir[0], y - dir[1]) &&\n                    SITE.isPassable(grid, x - dir[0], y - dir[1])) {\n                    if (!grid.hasXY(x + dir[0], y + dir[1]) ||\n                        SITE.isDoor(grid, x + dir[0], y + dir[1])) {\n                        continue;\n                    }\n                    dir = dir.map((v) => -1 * v);\n                }\n                else {\n                    continue; // not valid start for tunnel\n                }\n                startX = x + dir[0];\n                startY = y + dir[1];\n                endX = x;\n                endY = y;\n                for (j = 0; j < maxConnectionLength; ++j) {\n                    endX -= dir[0];\n                    endY -= dir[1];\n                    // if (grid.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                    if (isValidTunnelEnd(endX, endY, dir)) {\n                        break;\n                    }\n                }\n                if (j < maxConnectionLength) {\n                    GWU.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[startX][startY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[endX][endY] > minimumPathingDistance &&\n                        pathGrid[endX][endY] < 30000) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Loop',\n                        //     startX,\n                        //     startY,\n                        //     ' => ',\n                        //     endX,\n                        //     endY,\n                        //     ' : ',\n                        //     pathGrid[endX][endY]\n                        // );\n                        while (endX !== startX || endY !== startY) {\n                            if (grid.get(endX, endY) == 0) {\n                                grid[endX][endY] = SITE.FLOOR;\n                                costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                            }\n                            endX += dir[0];\n                            endY += dir[1];\n                        }\n                        // TODO - Door is optional\n                        grid[x][y] = SITE.DOOR; // then turn the tile into a doorway.\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(pathGrid);\n    GWU.grid.free(costGrid);\n}\nexport function addLakes(map, opts = {}) {\n    return LAKE.digLakes(map, opts);\n}\nexport function addBridges(map, minimumPathingDistance, maxConnectionLength) {\n    return LAKE.digBridges(map, minimumPathingDistance, maxConnectionLength);\n}\nexport function addStairs(map, opts = {}) {\n    return STAIRS.addStairs(map, opts);\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (SITE.isPassable(grid, i + k, j) &&\n                        !SITE.isPassable(grid, i + (1 - k), j) &&\n                        SITE.isObstruction(grid, i + (1 - k), j) &&\n                        !SITE.isPassable(grid, i + k, j + 1) &&\n                        SITE.isObstruction(grid, i + k, j + 1) &&\n                        SITE.isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GWU.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = SITE.FLOOR; // todo - pick one of the passable tiles around it...\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        // todo - isDoorway...\n        if (cell == SITE.DOOR) {\n            if (\n            // TODO - isPassable\n            (grid.get(x + 1, y) == SITE.FLOOR ||\n                grid.get(x - 1, y) == SITE.FLOOR) &&\n                (grid.get(x, y + 1) == SITE.FLOOR ||\n                    grid.get(x, y - 1) == SITE.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor value\n            }\n            else if (\n            // todo - isPassable\n            (grid.get(x + 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== SITE.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor\n            }\n        }\n    });\n}\nexport function finishWalls(grid, tile = SITE.WALL) {\n    grid.forEach((cell, i, j) => {\n        if (cell == SITE.NOTHING) {\n            grid[i][j] = tile;\n        }\n    });\n}\n"],"names":["TILEMAP","0","1","2","3","8","4","5","6","7","17","SEQ","initSeqence","length","i","GW","random","shuffle","fillCostGrid","source","costGrid","forEach","_v","x","y","isPassable","path","OBSTRUCTION","grid","isFloor","isDoor","isBridge","isStairs","isShallow","isNothing","get","isWall","v","isObstruction","isDeep","isAnyWater","DIRS","GWU","xy","attachRoom","map","roomGrid","room","opts","doorSites","hall","doors","SITE.SEQ","Math","floor","height","dir","directionOfDoorSite","NO_DIRECTION","oppDir","door","offsetX","offsetY","roomFitsAt","offsetZip","_d","_s","j","tile","attachDoor","translate","width","UP","DOWN","didSomething","k","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","hasXY","isBoundaryXY","isOpen","solutionDir","newX","newY","oppX","oppY","fnOpen","attachRoomAtMapDoor","mapDoors","doorIndexes","sequence","attachRoomAtXY","dirs","offX","offY","chooseRandomDoorSites","sourceGrid","floorTile","doorSiteFailed","alloc","copy","loc","randomMatchingLoc","free","dx","dy","Hall","[object Object]","this","d","x2","y2","Room","digger","cx","cy","halls","install","id","fn","config","data","pickWidth","clamp","undefined","Array","isArray","weighted","range","make","value","Number","parseInt","_pickWidth","pickLengthRange","pickHallDirection","hi","pickHallExits","obliqueChance","object","firstOpt","allowObliqueHallwayExit","chance","hallDoors","dir2","dig","DIR","TYPES.Hall","x0","y0","LEFT","rooms","checkConfig","expected","Object","entries","key","expect","have","ERROR","rectangular","fill","fillRect","TYPES.Room","digLakes","lakeMaxHeight","lakeMaxWidth","lakeMinSize","tries","maxCount","canDisrupt","count","minSize","wreath","wreathTile","lakeGrid","attempts","round","bounds","blob","fillBlob","rounds","minWidth","minHeight","maxWidth","maxHeight","percentSeeded","success","lakeDisruptsPassability","sx","sy","forCircle","lakeToMapX","lakeToMapY","walkableGrid","disrupts","lakeX","lakeY","SITE.isStairs","SITE.isPassable","first","floodFill","isBridgeCandidate","bridgeDir","SITE.isAnyWater","digBridges","minimumPathingDistance","maxConnectionLength","siteGrid","pathGrid","dirCoords","SITE.fillCostGrid","calculateDistances","NO_PATH","isValidStairLoc","SITE.isObstruction","SITE.isFloor","setupStairs","indexes","set","dirIndex","CLOCK_DIRS","findIndex","l","r","addStairs","needUp","up","needDown","down","minDistance","max","isValidLoc","isValid","setupFn","setup","upLoc","downLoc","locations","start","matchingLocNear","distanceBetween","slice","upTile","downTile","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","destX","destY","blobGrid","choices","item","bind","digConfig","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","min","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","minX","maxX","minY","maxY","chunkCount","valueBounds","SITE.initSeqence","locs","name","ROOM.rooms","roomConfig","hallConfig","HALL.halls","attachHall","hallChance","result","UTILS.chooseRandomDoorSites","UTILS.attachRoomAtMapDoor","UTILS.attachRoom","startX","startY","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.isDoor","LAKE.digLakes","LAKE.digBridges","STAIRS.addStairs"],"mappings":"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"}
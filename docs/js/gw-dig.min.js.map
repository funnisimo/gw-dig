{"version":3,"file":"gw-dig.min.js","sources":["../js/digger.js","../js/dig.js","../js/gw.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport var diggers = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    diggers[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    if (!config.width || !config.height)\n        GW.utils.ERROR('All diggers require config to include width and height.');\n    Object.entries(opts).forEach(([key, expect]) => {\n        const have = config[key];\n        if (expect === true) {\n            // needs to be a number > 0\n            if (typeof have !== 'number') {\n                GW.utils.ERROR('Invalid configuration for digger: ' +\n                    key +\n                    ' expected number received ' +\n                    typeof have);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            const have = config[key];\n            if (typeof have !== 'number') {\n                config[key] = expect; // provide default\n            }\n        }\n        else if (Array.isArray(expect)) {\n            // needs to be an array with this size, these are the defaults\n            if (typeof have === 'number') {\n                config[key] = new Array(expect.length).fill(have);\n            }\n            else if (!Array.isArray(have)) {\n                GW.utils.WARN('Received unexpected config for digger : ' +\n                    key +\n                    ' expected array, received ' +\n                    typeof have +\n                    ', using defaults.');\n                config[key] = expect.slice();\n            }\n            else if (expect.length > have.length) {\n                for (let i = have.length; i < expect.length; ++i) {\n                    have[i] = expect[i];\n                }\n            }\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n        }\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * config.width); // 6\n    const maxWidth = config.width;\n    const minHeight = Math.floor(0.5 * config.height); // 4\n    const maxHeight = config.height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, CONST.FLOOR);\n    GW.grid.free(blobGrid);\n    return config.id;\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = config.choices;\n    }\n    else if (typeof config.choices == 'object') {\n        choices = Object.keys(config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    for (let choice of choices) {\n        if (!diggers[choice]) {\n            GW.utils.ERROR('Missing digger choice: ' + choice);\n        }\n    }\n    if (!grid)\n        return config;\n    let id;\n    if (Array.isArray(config.choices)) {\n        id = GW.random.item(config.choices);\n    }\n    else {\n        id = GW.random.weighted(config.choices);\n    }\n    const digger = diggers[id];\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    digger.fn(digConfig, grid);\n    return id;\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entranceRoom(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.floor(0.4 * config.width); // 8\n    const roomHeight = config.height;\n    const roomWidth2 = config.width;\n    const roomHeight2 = Math.floor(0.5 * config.height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, CONST.FLOOR);\n    return config.id;\n}\nexport function crossRoom(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.max(2, Math.floor((config.width * GW.random.range(15, 60)) / 100)); // [3,12]\n    const roomWidth2 = Math.max(2, Math.floor((config.width * GW.random.range(20, 100)) / 100)); // [4,20]\n    const roomHeight = Math.max(2, Math.floor((config.height * GW.random.range(50, 100)) / 100)); // [3,7]\n    const roomHeight2 = Math.max(2, Math.floor((config.height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomX = GW.random.range(Math.max(0, Math.floor(grid.width / 2) - (roomWidth - 1)), Math.min(grid.width, Math.floor(grid.width / 2)));\n    const roomX2 = roomX +\n        Math.floor(roomWidth / 2) +\n        GW.random.range(0, 2) +\n        GW.random.range(0, 2) -\n        3 -\n        Math.floor(roomWidth2 / 2);\n    const roomY = Math.floor(grid.height / 2 - roomHeight);\n    const roomY2 = Math.floor(grid.height / 2 -\n        roomHeight2 -\n        (GW.random.range(0, 2) + GW.random.range(0, 1)));\n    grid.fill(0);\n    grid.fillRect(roomX - 5, roomY + 5, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2 - 5, roomY2 + 5, roomWidth2, roomHeight2, CONST.FLOOR);\n    return config.id;\n}\nexport function symmetricalCrossRoom(config, grid) {\n    config = checkConfig(config, { width: 8, height: 5 });\n    if (!grid)\n        return config;\n    let majorWidth = Math.floor((config.width * GW.random.range(50, 100)) / 100); // [4,8]\n    let majorHeight = Math.floor((config.height * GW.random.range(75, 100)) / 100); // [4,5]\n    let minorWidth = Math.max(2, Math.floor((config.width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (majorHeight % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(2, Math.floor((config.height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    if (majorWidth % 2 == 0 && minorHeight > 2) {\n        minorHeight -= 1;\n    }\n    grid.fill(0);\n    grid.fillRect(Math.floor((grid.width - majorWidth) / 2), Math.floor((grid.height - minorHeight) / 2), majorWidth, minorHeight, CONST.FLOOR);\n    grid.fillRect(Math.floor((grid.width - minorWidth) / 2), Math.floor((grid.height - majorHeight) / 2), minorWidth, majorHeight, CONST.FLOOR);\n    return config.id;\n}\nexport function rectangularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 4, minPct: 50 });\n    if (!grid)\n        return config;\n    const width = Math.floor((config.width * GW.random.range(config.minPct, 100)) / 100); // [3,6]\n    const height = Math.floor((config.height * GW.random.range(config.minPct, 100)) / 100); // [2,4]\n    grid.fill(0);\n    grid.fillRect(Math.floor((grid.width - width) / 2), Math.floor((grid.height - height) / 2), width, height, CONST.FLOOR);\n    return config.id;\n}\nexport function circularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 6 });\n    if (!grid)\n        return config;\n    const radius = Math.floor(((Math.min(config.width, config.height) - 1) *\n        GW.random.range(75, 100)) /\n        200); // [3,4]\n    grid.fill(0);\n    if (radius > 1) {\n        grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), radius, CONST.FLOOR);\n    }\n    return config.id;\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        width: 10,\n        height: 10,\n        altChance: 5,\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = Math.floor((Math.min(config.width, config.height) * GW.random.range(75, 100)) / 100); // [5,10]\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), radius, CONST.FLOOR);\n    if (radius > config.ringMinWidth + config.holeMinSize &&\n        GW.random.chance(config.holeChance)) {\n        grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), GW.random.range(config.holeMinSize, radius - config.holeMinSize), 0);\n    }\n    return config.id;\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, { count: 8 });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = Math.floor((config.count * GW.random.range(25, 100)) / 100); // [2,8]\n    minX = Math.floor(grid.width / 2) - Math.floor(config.width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(config.width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(config.height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(config.height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, CONST.FLOOR);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, CONST.FLOOR);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    return config.id;\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nexport * from './digger';\nimport { diggers as DIGGERS } from './digger';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    let result = false;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        digger.fn(config, roomGrid);\n        const doors = chooseRandomDoorSites(roomGrid);\n        if (GW.random.chance(hallChance)) {\n            attachHallway(roomGrid, doors, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoors(map, locs, roomGrid, doors, config);\n            if (!result) {\n                // otherwise try everywhere\n                for (let i = 0; i < locs.length && !result; ++i) {\n                    if (locs[i][0] > 0) {\n                        result = fitRoomAtXY(map, locs[i], roomGrid, doors, config);\n                    }\n                }\n            }\n        }\n        else {\n            result = fitRoomToMap(map, roomGrid, doors, config);\n        }\n    }\n    GW.grid.free(roomGrid);\n    return result;\n}\nexport function fitRoomToMap(map, roomGrid, doorSites, opts = {}) {\n    console.log('fitRoomToMap');\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomAttachesAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                doorSites[oppDir][0] = -1;\n                doorSites[oppDir][1] = -1;\n                for (let i = 0; i < doorSites.length; ++i) {\n                    if (doorSites[i][0] > 0) {\n                        doorSites[i][0] += offsetX;\n                        doorSites[i][1] += offsetY;\n                    }\n                }\n                return doorSites;\n            }\n        }\n    }\n    return false;\n}\nexport function roomAttachesAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    console.log('roomAttachesAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    console.log('- YES');\n    return true;\n}\nexport function fitRoomAtXY(map, xy, roomGrid, doors, opts = {}) {\n    console.log('fitRoomAtXY', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            if (roomAttachesAt(map, roomGrid, xy[0] - x, xy[1] - y)) {\n                GW.grid.offsetZip(map, roomGrid, xy[0] - x, xy[1] - y, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                doors[dir][0] = -1;\n                doors[dir][1] = -1;\n                for (let i = 0; i < doors.length; ++i) {\n                    if (doors[i][0] > 0) {\n                        doors[i][0] += xy[0] - x;\n                        doors[i][1] += xy[1] - y;\n                    }\n                }\n                return doors;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoors(map, mapDoors, roomGrid, roomDoors, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    console.log('attachRoomAtMapDoors', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const x = mapDoors[index][0];\n        const y = mapDoors[index][1];\n        const doors = attachRoomAtXY(map, x, y, roomGrid, roomDoors, opts);\n        if (doors)\n            return doors;\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, doorSites, opts = {}) {\n    const dirs = GW.random.sequence(4);\n    console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        if (doorSites[oppDir][0] != -1 &&\n            roomAttachesAt(map, roomGrid, x - doorSites[oppDir][0], y - doorSites[oppDir][1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - doorSites[oppDir][0];\n            const offY = y - doorSites[oppDir][1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            const newDoors = doorSites.map((site) => {\n                const x0 = site[0] + offX;\n                const y0 = site[1] + offY;\n                if (x0 == x && y0 == y)\n                    return [-1, -1];\n                return [x0, y0];\n            });\n            return newDoors;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function attachHallway(grid, doorSitesArray, opts) {\n    let i, x, y, newX, newY;\n    let length;\n    let dir, dir2;\n    let allowObliqueHallwayExit;\n    opts = opts || {};\n    const tile = opts.tile || CONST.FLOOR;\n    const horizontalLength = GW.utils.firstOpt('horizontalHallLength', opts, [\n        9,\n        15,\n    ]);\n    const verticalLength = GW.utils.firstOpt('verticalHallLength', opts, [\n        2,\n        9,\n    ]);\n    // Pick a direction.\n    dir = opts.dir;\n    if (dir === undefined) {\n        const dirs = GW.random.sequence(4);\n        for (i = 0; i < 4; i++) {\n            dir = dirs[i];\n            if (doorSitesArray[dir][0] != -1 &&\n                doorSitesArray[dir][1] != -1 &&\n                grid.hasXY(doorSitesArray[dir][0] +\n                    Math.floor(DIRS[dir][0] * horizontalLength[1]), doorSitesArray[dir][1] +\n                    Math.floor(DIRS[dir][1] * verticalLength[1]))) {\n                break; // That's our direction!\n            }\n        }\n        if (i == 4) {\n            return; // No valid direction for hallways.\n        }\n    }\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        length = GW.random.range(verticalLength[0], verticalLength[1]);\n    }\n    else {\n        length = GW.random.range(horizontalLength[0], horizontalLength[1]);\n    }\n    x = doorSitesArray[dir][0];\n    y = doorSitesArray[dir][1];\n    const attachLoc = [x - DIRS[dir][0], y - DIRS[dir][1]];\n    for (i = 0; i < length; i++) {\n        if (grid.hasXY(x, y)) {\n            grid[x][y] = tile;\n        }\n        x += DIRS[dir][0];\n        y += DIRS[dir][1];\n    }\n    x = GW.utils.clamp(x - DIRS[dir][0], 0, grid.width - 1);\n    y = GW.utils.clamp(y - DIRS[dir][1], 0, grid.height - 1); // Now (x, y) points at the last interior cell of the hallway.\n    allowObliqueHallwayExit = GW.random.chance(15);\n    for (dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            doorSitesArray[dir2][0] = -1;\n            doorSitesArray[dir2][1] = -1;\n        }\n        else {\n            doorSitesArray[dir2][0] = newX;\n            doorSitesArray[dir2][1] = newY;\n        }\n    }\n    return attachLoc;\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n"],"names":["diggers","checkConfig","config","opts","width","height","GW.utils","ERROR","Object","entries","forEach","key","expect","have","Array","isArray","length","fill","i","WARN","slice","DIRS","SEQ","fitRoomToMap","map","roomGrid","doorSites","console","log","x","Math","floor","y","get","dir","GW.grid","directionOfDoorSite","NO_DIRECTION","oppDir","offsetX","offsetY","roomAttachesAt","offsetZip","_d","_s","j","tile","door","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","hasXY","isBoundaryXY","fitRoomAtXY","xy","doors","attachRoomAtMapDoors","mapDoors","roomDoors","doorIndexes","GW.random","sequence","join","index","attachRoomAtXY","dirs","offX","offY","site","x0","y0","chooseRandomDoorSites","sourceGrid","k","newX","newY","doorSiteFailed","grid","alloc","copy","loc","randomMatchingLoc","free","attachHallway","doorSitesArray","dir2","allowObliqueHallwayExit","horizontalLength","firstOpt","verticalLength","undefined","UP","DOWN","range","attachLoc","clamp","chance","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","digger","diggerId","id","DIGGERS","locs","count","assign","hallChance","hallway","result","tries","fn","destX","destY","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","choices","keys","choice","item","weighted","digConfig","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","max","min","majorWidth","majorHeight","minorWidth","minorHeight","minPct","radius","fillCircle","altChance","ringMinWidth","holeMinSize","holeChance","minX","maxX","minY","maxY","chunkCount"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/site.js","../js/utils.js","../js/types.js","../js/hall.js","../js/blob.js","../js/room.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nexport const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const DEEP = 4;\nexport const SHALLOW = 5;\nexport const BRIDGE = 6;\nexport const UP_STAIRS = 7;\nexport const DOWN_STAIRS = 17;\nexport const IMPREGNABLE = 8;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport const SEQ = [];\nexport function initSeqence(length) {\n    SEQ.length = length;\n    for (let i = 0; i < length; ++i) {\n        SEQ[i] = i;\n    }\n    GW.random.shuffle(SEQ);\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n}\nexport class GridSite {\n    constructor(grid) {\n        this.grid = grid;\n    }\n    get width() {\n        return this.grid.width;\n    }\n    get height() {\n        return this.grid.height;\n    }\n    hasXY(x, y) {\n        return this.grid.hasXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.grid.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.grid.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.grid.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.grid.get(x, y);\n        return v === DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.grid.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.grid.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    isObstruction(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.grid.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.grid.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.grid.get(x, y) === SHALLOW;\n    }\n    isAnyWater(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.grid.get(x, y) || 0) > 0;\n    }\n    setTile(x, y, tile) {\n        if (this.grid.hasXY(x, y))\n            this.grid[x][y] = tile;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nconst DIRS = GW.utils.DIRS;\nexport function attachRoom(map, roomGrid, room, opts) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const site = new SITE.GridSite(map);\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (!(map.get(x, y) == SITE.NOTHING))\n            continue;\n        const dir = directionOfDoorSite(site, x, y);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door)\n                continue;\n            const offsetX = x - door[0];\n            const offsetY = y - door[1];\n            if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // TYPES.Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                attachDoor(map, room, opts, x, y, oppDir);\n                // door[0] = -1;\n                // door[1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachDoor(map, room, opts, x, y, dir) {\n    if (opts.door === 0)\n        return; // no door at all\n    const tile = opts.door || SITE.DOOR;\n    map[x][y] = tile; // Door site.\n    // most cases...\n    if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n        return;\n    }\n    if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x - k, y) === 0) {\n                if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n                    map[x - k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x + k, y) === 0) {\n                if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n                    map[x + k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n    else {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x, y - k) === 0) {\n                if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n                    map[x][y - k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x, y + k) === 0) {\n                if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n                    map[x][y + k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === SITE.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GW.utils.DIRS[dir][0];\n                    newY = j + GW.utils.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GW.utils.DIRS[dir][0];\n                        newY += GW.utils.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GW.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GW.grid.free(grid);\n    return doorSites;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts) {\n    // console.log('forceRoomAtMapLoc', xy);\n    const site = new SITE.GridSite(map);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SITE.SEQ.length; i++) {\n        const x = Math.floor(SITE.SEQ[i] / map.height);\n        const y = SITE.SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = directionOfDoorSite(site, x, y);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? SITE.DOOR\n                        : opts.room.door;\n                    map[xy[0]][xy[1]] = door; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // TYPES.Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.room.tile || SITE.FLOOR;\n            });\n            attachDoor(map, room, opts, x, y, oppDir);\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\n","import * as GW from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        // console.log('Hall', loc, d, length, width);\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        // console.log(' - ', [this.x2, this.y2]);\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room extends GW.utils.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nimport * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GW.range.make(1),\n            length: [GW.range.make('9-15'), GW.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GW.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GW.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || UTILS.chooseRandomDoorSites(site);\n        if (!GW.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GW.utils.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = new TYPES.Hall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GW.utils.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = new TYPES.Hall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GW from 'gw-utils';\nexport class Blob {\n    constructor(opts = {}) {\n        this.options = {\n            roundCount: 5,\n            minBlobWidth: 10,\n            minBlobHeight: 10,\n            maxBlobWidth: 40,\n            maxBlobHeight: 20,\n            percentSeeded: 50,\n            birthParameters: 'ffffffttt',\n            survivalParameters: 'ffffttttt',\n        };\n        Object.assign(this.options, opts);\n        this.options.birthParameters = this.options.birthParameters.toLowerCase();\n        this.options.survivalParameters = this.options.survivalParameters.toLowerCase();\n        if (this.options.minBlobWidth >= this.options.maxBlobWidth) {\n            this.options.minBlobWidth = Math.round(0.75 * this.options.maxBlobWidth);\n            this.options.maxBlobWidth = Math.round(1.25 * this.options.maxBlobWidth);\n        }\n        if (this.options.minBlobHeight >= this.options.maxBlobHeight) {\n            this.options.minBlobHeight = Math.round(0.75 * this.options.maxBlobHeight);\n            this.options.maxBlobHeight = Math.round(1.25 * this.options.maxBlobHeight);\n        }\n    }\n    carve(width, height, setFn) {\n        let i, j, k;\n        let blobNumber, blobSize, topBlobNumber, topBlobSize;\n        let bounds = new GW.utils.Bounds(0, 0, 0, 0);\n        const dest = GW.grid.alloc(width, height);\n        const left = Math.floor((dest.width - this.options.maxBlobWidth) / 2);\n        const top = Math.floor((dest.height - this.options.maxBlobHeight) / 2);\n        let tries = 10;\n        // Generate blobs until they satisfy the minBlobWidth and minBlobHeight restraints\n        do {\n            // Clear buffer.\n            dest.fill(0);\n            // Fill relevant portion with noise based on the percentSeeded argument.\n            for (i = 0; i < this.options.maxBlobWidth; i++) {\n                for (j = 0; j < this.options.maxBlobHeight; j++) {\n                    dest[i + left][j + top] = GW.random.chance(this.options.percentSeeded)\n                        ? 1\n                        : 0;\n                }\n            }\n            // Some iterations of cellular automata\n            for (k = 0; k < this.options.roundCount; k++) {\n                if (!this._cellularAutomataRound(dest)) {\n                    k = this.options.roundCount; // cellularAutomataRound did not make any changes\n                }\n            }\n            // Now to measure the result. These are best-of variables; start them out at worst-case values.\n            topBlobSize = 0;\n            topBlobNumber = 0;\n            // Fill each blob with its own number, starting with 2 (since 1 means floor), and keeping track of the biggest:\n            blobNumber = 2;\n            for (i = 0; i < dest.width; i++) {\n                for (j = 0; j < dest.height; j++) {\n                    if (dest[i][j] == 1) {\n                        // an unmarked blob\n                        // Mark all the cells and returns the total size:\n                        blobSize = dest.floodFill(i, j, 1, blobNumber);\n                        if (blobSize > topBlobSize) {\n                            // if this blob is a new record\n                            topBlobSize = blobSize;\n                            topBlobNumber = blobNumber;\n                        }\n                        blobNumber++;\n                    }\n                }\n            }\n            // Figure out the top blob's height and width:\n            dest.valueBounds(topBlobNumber, bounds);\n        } while ((bounds.width < this.options.minBlobWidth ||\n            bounds.height < this.options.minBlobHeight ||\n            topBlobNumber == 0) &&\n            --tries);\n        // Replace the winning blob with 1's, and everything else with 0's:\n        for (i = 0; i < dest.width; i++) {\n            for (j = 0; j < dest.height; j++) {\n                if (dest[i][j] == topBlobNumber) {\n                    setFn(i, j);\n                }\n            }\n        }\n        GW.grid.free(dest);\n        // Populate the returned variables.\n        return bounds;\n    }\n    _cellularAutomataRound(grid) {\n        let i, j, nbCount, newX, newY;\n        let dir;\n        let buffer2;\n        buffer2 = GW.grid.alloc(grid.width, grid.height);\n        buffer2.copy(grid); // Make a backup of this in buffer2, so that each generation is isolated.\n        let didSomething = false;\n        for (i = 0; i < grid.width; i++) {\n            for (j = 0; j < grid.height; j++) {\n                nbCount = 0;\n                for (dir = 0; dir < GW.utils.DIRS.length; dir++) {\n                    newX = i + GW.utils.DIRS[dir][0];\n                    newY = j + GW.utils.DIRS[dir][1];\n                    if (grid.hasXY(newX, newY) && buffer2[newX][newY]) {\n                        nbCount++;\n                    }\n                }\n                if (!buffer2[i][j] &&\n                    this.options.birthParameters[nbCount] == 't') {\n                    grid[i][j] = 1; // birth\n                    didSomething = true;\n                }\n                else if (buffer2[i][j] &&\n                    this.options.survivalParameters[nbCount] == 't') {\n                    // survival\n                }\n                else {\n                    grid[i][j] = 0; // death\n                    didSomething = true;\n                }\n            }\n        }\n        GW.grid.free(buffer2);\n        return didSomething;\n    }\n}\nexport function fillBlob(grid, opts = {}) {\n    const blob = new Blob(opts);\n    return blob.carve(grid.width, grid.height, (x, y) => (grid[x][y] = 1));\n}\n","import * as GW from 'gw-utils';\nimport * as TYPES from './types';\nimport * as UTILS from './utils';\nimport * as SITE from './site';\nimport * as BLOB from './blob';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            result.doors = UTILS.chooseRandomDoorSites(site);\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GW.random.item.bind(GW.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GW.random.weighted.bind(GW.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GW.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, grid) {\n    grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GW.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new BLOB.Blob({\n            roundCount: 5,\n            minBlobWidth: minWidth,\n            minBlobHeight: minHeight,\n            maxBlobWidth: maxWidth,\n            maxBlobHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GW.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, grid) {\n    grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(new SITE.GridSite(grid));\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class Entrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function entrance(config, grid) {\n    grid.fill(0);\n    const digger = new Entrance(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, grid) {\n    grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GW.utils.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, grid) {\n    grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, grid) {\n    grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, grid) {\n    grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GW.random.chance(this.options.holeChance.value())) {\n            GW.utils.forCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, grid) {\n    grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GW.utils.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GW.random.range(minX, maxX);\n            y = GW.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GW.utils.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, grid) {\n    grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(new SITE.GridSite(grid));\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as BLOB from './blob';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreath: 0,\n            wreathTile: SITE.SHALLOW,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const wreath = this.options.wreath || 0; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GW.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new BLOB.Blob({\n                roundCount: 5,\n                minBlobWidth: 4,\n                minBlobHeight: 4,\n                maxBlobWidth: width,\n                maxBlobHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (wreath) {\n                                    GW.utils.forCircle(sx, sy, wreath, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GW.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GW.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GW.utils.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GW.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minimumPathingDistance: 20,\n            maxConnectionLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxConnectionLength = this.options.maxConnectionLength;\n        const minimumPathingDistance = this.options.minimumPathingDistance;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n        const SEQ = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < SEQ.length; i++) {\n            x = Math.floor(SEQ[i] / site.height);\n            y = SEQ[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyWater(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxConnectionLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyWater(newX, newY)) {\n                        for (j = 0; j < maxConnectionLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyWater(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxConnectionLength) {\n                        GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minimumPathingDistance &&\n                            pathGrid[x][y] < GW.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyWater(x, y))\n            return false;\n        if (!site.isAnyWater(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyWater(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc;\n        let downLoc;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GW.random.matchingXY(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GW.random.matchingXYNear(GW.utils.x(start), GW.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (GW.utils.distanceBetween(x, y, \n                    // @ts-ignore\n                    downLoc[0], \n                    // @ts-ignore\n                    downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GW.random.matchingXY(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GW.random.matchingXY(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc !== undefined) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GW.utils.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GW.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GW.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GW.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GW.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GW.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GW.utils.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nimport * as HALL from './hall';\nimport * as ROOM from './room';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\n// import * as MAP from 'gw-map.js';\nexport * from './site';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport * as hall_1 from './hall';\nexport { hall_1 as hall };\nimport * as lake_1 from './lake';\nexport { lake_1 as lake };\nimport * as bridge_1 from './bridge';\nexport { bridge_1 as bridge };\nimport * as stairs_1 from './stairs';\nexport { stairs_1 as stairs };\nimport * as utils_1 from './utils';\nexport { utils_1 as utils };\nexport * from './types';\nexport function start(map) {\n    SITE.initSeqence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function addRoom(map, opts) {\n    opts = opts || { room: 'DEFAULT', hall: 'DEFAULT', tries: 10 };\n    if (typeof opts === 'string') {\n        opts = { room: opts };\n    }\n    if (opts.loc) {\n        opts.locs = [opts.loc];\n    }\n    let roomDigger;\n    if (typeof opts.room === 'function')\n        opts.room = opts.room();\n    if (!opts.room)\n        roomDigger = ROOM.rooms.DEFAULT;\n    else if (typeof opts.room === 'string') {\n        const name = opts.room;\n        roomDigger = ROOM.rooms[name];\n        if (!roomDigger) {\n            throw new Error('Failed to find room: ' + name);\n        }\n    }\n    else if (opts.room instanceof ROOM.RoomDigger) {\n        roomDigger = opts.room;\n    }\n    else {\n        throw new Error('No room to build!');\n    }\n    // const roomConfig = opts.room as TYPES.RoomConfig;\n    let hallConfig = null;\n    if (opts.hall === true)\n        opts.hall = 'DEFAULT';\n    if (opts.hall !== false && !opts.hall)\n        opts.hall = 'DEFAULT';\n    if (typeof opts.hall === 'function')\n        opts.hall = { fn: opts.hall };\n    if (typeof opts.hall === 'string') {\n        const name = opts.hall;\n        opts.hall = HALL.halls[name];\n        if (!opts.hall) {\n            GW.utils.ERROR('Failed to find hall: ' + name);\n            return null;\n        }\n        hallConfig = opts.hall;\n    }\n    else {\n        if (opts.hall && opts.hall.fn) {\n            hallConfig = opts.hall;\n        }\n    }\n    if (opts.door === false) {\n        opts.door = 0;\n    }\n    else if (opts.door === true) {\n        opts.door = SITE.DOOR;\n    }\n    else if (typeof opts.door === 'number') {\n        opts.door = GW.random.chance(opts.door) ? SITE.DOOR : SITE.FLOOR;\n    }\n    else {\n        opts.door = SITE.FLOOR;\n    }\n    let locs = opts.locs || null;\n    // @ts-ignore\n    if (locs && locs.doors)\n        locs = locs.doors;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(SITE.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        // @ts-ignore\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const site = new SITE.GridSite(roomGrid);\n    let attachHall = false;\n    if (hallConfig) {\n        let hallChance = hallConfig.chance !== undefined ? hallConfig.chance : 15;\n        attachHall = GW.random.chance(hallChance);\n    }\n    // const force = config.force || false;\n    let room = null;\n    let result = false;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(SITE.NOTHING);\n        // dig the room in the center\n        room = roomDigger.create(site);\n        // optionally add a hall\n        if (attachHall) {\n            const hallDigger = new HALL.HallDigger();\n            room.hall = hallDigger.create(site, room.doors);\n        }\n        if (locs) {\n            // try the doors first\n            result = UTILS.attachRoomAtMapDoor(map, locs, roomGrid, room, opts);\n        }\n        else {\n            result = UTILS.attachRoom(map, roomGrid, room, opts);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function addLoops(grid, minimumPathingDistance, maxConnectionLength) {\n    let startX, startY, endX, endY;\n    let i, j, d, x, y;\n    minimumPathingDistance =\n        minimumPathingDistance ||\n            Math.floor(Math.min(grid.width, grid.height) / 2);\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const site = new SITE.GridSite(grid);\n    const siteGrid = grid;\n    const pathGrid = GW.grid.alloc(grid.width, grid.height);\n    const costGrid = GW.grid.alloc(grid.width, grid.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(site, costGrid);\n    function isValidTunnelStart(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return false;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return false;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return false;\n        return true;\n    }\n    function isValidTunnelEnd(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return true;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return true;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return true;\n        return false;\n    }\n    for (i = 0; i < SITE.SEQ.length; i++) {\n        x = Math.floor(SITE.SEQ[i] / siteGrid.height);\n        y = SITE.SEQ[i] % siteGrid.height;\n        const cell = siteGrid[x][y];\n        if (!cell) {\n            for (d = 0; d <= 1; d++) {\n                // Try a horizontal door, and then a vertical door.\n                let dir = dirCoords[d];\n                if (!isValidTunnelStart(x, y, dir))\n                    continue;\n                j = maxConnectionLength;\n                // check up/left\n                if (site.hasXY(x + dir[0], y + dir[1]) &&\n                    site.isPassable(x + dir[0], y + dir[1])) {\n                    // just can't build directly into a door\n                    if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                        site.isDoor(x - dir[0], y - dir[1])) {\n                        continue;\n                    }\n                }\n                else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                    site.isPassable(x - dir[0], y - dir[1])) {\n                    if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                        site.isDoor(x + dir[0], y + dir[1])) {\n                        continue;\n                    }\n                    dir = dir.map((v) => -1 * v);\n                }\n                else {\n                    continue; // not valid start for tunnel\n                }\n                startX = x + dir[0];\n                startY = y + dir[1];\n                endX = x;\n                endY = y;\n                for (j = 0; j < maxConnectionLength; ++j) {\n                    endX -= dir[0];\n                    endY -= dir[1];\n                    // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                    if (isValidTunnelEnd(endX, endY, dir)) {\n                        break;\n                    }\n                }\n                if (j < maxConnectionLength) {\n                    GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[startX][startY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[endX][endY] > minimumPathingDistance &&\n                        pathGrid[endX][endY] < 30000) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Loop',\n                        //     startX,\n                        //     startY,\n                        //     ' => ',\n                        //     endX,\n                        //     endY,\n                        //     ' : ',\n                        //     pathGrid[endX][endY]\n                        // );\n                        while (endX !== startX || endY !== startY) {\n                            if (grid.get(endX, endY) == 0) {\n                                grid[endX][endY] = SITE.FLOOR;\n                                costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                            }\n                            endX += dir[0];\n                            endY += dir[1];\n                        }\n                        // TODO - Door is optional\n                        grid[x][y] = SITE.DOOR; // then turn the tile into a doorway.\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GW.grid.free(pathGrid);\n    GW.grid.free(costGrid);\n}\nexport function addLakes(map, opts = {}) {\n    const lakes = new LAKE.Lakes(opts);\n    const site = new SITE.GridSite(map);\n    return lakes.create(site);\n}\nexport function addBridges(grid, opts = {}) {\n    const bridges = new BRIDGE.Bridges(opts);\n    const site = new SITE.GridSite(grid);\n    return bridges.create(site);\n}\nexport function addStairs(grid, opts = {}) {\n    const stairs = new STAIRS.Stairs(opts);\n    const site = new SITE.GridSite(grid);\n    return stairs.create(site);\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    const site = new SITE.GridSite(grid);\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (site.isPassable(i + k, j) &&\n                        !site.isPassable(i + (1 - k), j) &&\n                        site.isObstruction(i + (1 - k), j) &&\n                        !site.isPassable(i + k, j + 1) &&\n                        site.isObstruction(i + k, j + 1) &&\n                        site.isPassable(i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = SITE.FLOOR; // todo - pick one of the passable tiles around it...\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        // todo - isDoorway...\n        if (cell == SITE.DOOR) {\n            if (\n            // TODO - isPassable\n            (grid.get(x + 1, y) == SITE.FLOOR ||\n                grid.get(x - 1, y) == SITE.FLOOR) &&\n                (grid.get(x, y + 1) == SITE.FLOOR ||\n                    grid.get(x, y - 1) == SITE.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor value\n            }\n            else if (\n            // todo - isPassable\n            (grid.get(x + 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== SITE.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor\n            }\n        }\n    });\n}\nexport function finishWalls(grid, tile = SITE.WALL) {\n    grid.forEach((cell, i, j) => {\n        if (cell == SITE.NOTHING) {\n            grid[i][j] = tile;\n        }\n    });\n}\n"],"names":["TILEMAP","0","1","2","3","8","4","5","6","7","17","SEQ","initSeqence","length","i","GW.random","shuffle","fillCostGrid","source","costGrid","update","_v","x","y","isPassable","GW.path","OBSTRUCTION","GridSite","[object Object]","grid","this","width","height","hasXY","isFloor","isDoor","isBridge","isStairs","isShallow","get","v","isNothing","isWall","isDeep","tile","DIRS","GW.utils","attachRoom","map","roomGrid","room","opts","doorSites","hall","doors","site","SITE.GridSite","SITE.SEQ","Math","floor","dir","directionOfDoorSite","NO_DIRECTION","oppDir","door","offsetX","offsetY","roomFitsAt","GW.grid","offsetZip","_d","_s","j","attachDoor","translate","UP","DOWN","didSomething","k","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","solutionDir","newX","newY","oppX","oppY","chooseRandomDoorSites","doorSiteFailed","DOORS","h","w","isDiggable","isSet","push","loc","item","attachRoomAtMapDoor","mapDoors","doorIndexes","sequence","attachRoomAtXY","dirs","offX","offY","xy","dx","dy","Hall","d","x2","y2","forEach","Room","Bounds","super","cx","cy","isDoorLoc","pickLength","lengths","value","pickHallDirection","hi","pickHallExits","obliqueChance","allowObliqueHallwayExit","chance","hallDoors","dir2","HallDigger","options","config","GW.range","make","_setOptions","l","UTILS.chooseRandomDoorSites","doorLoc","dig","digWide","setTile","DIR","_digLine","TYPES.Hall","lower","higher","actual","startX","startY","min","halls","install","id","clamp","undefined","Array","isArray","weighted","Number","parseInt","_pickWidth","create","Blob","roundCount","minBlobWidth","minBlobHeight","maxBlobWidth","maxBlobHeight","percentSeeded","birthParameters","survivalParameters","Object","assign","toLowerCase","round","setFn","blobNumber","blobSize","topBlobNumber","topBlobSize","bounds","dest","alloc","left","top","tries","fill","_cellularAutomataRound","floodFill","valueBounds","free","nbCount","buffer2","copy","carve","checkConfig","expected","entries","key","expect","have","Error","range","RoomDigger","result","rooms","ChoiceRoom","choices","randomRoom","bind","ERROR","Cavern","blobGrid","minWidth","maxWidth","minHeight","BLOB.Blob","destX","destY","TYPES.Room","Entrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","forRect","max","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","ChunkyRoom","count","chunkCount","minX","maxX","minY","maxY","right","bottom","Lakes","minSize","canDisrupt","wreath","wreathTile","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","lakeGrid","attempts","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","walkableGrid","disrupts","lakeX","lakeY","first","Bridges","minimumPathingDistance","maxConnectionLength","pathGrid","dirCoords","isAnyWater","bridgeDir","calculateDistances","NO_PATH","isBridgeCandidate","Stairs","up","down","minDistance","start","upTile","downTile","wall","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingXY","matchingXYNear","distanceBetween","slice","setupStairs","indexes","x0","y0","dirIndex","CLOCK_DIRS","findIndex","r","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","isObstruction","finishDoors","cell","finishWalls","SITE.initSeqence","roomDigger","locs","name","ROOM.rooms","ROOM.RoomDigger","DEFAULT","hallConfig","fn","HALL.halls","attachHall","hallChance","hallDigger","HALL.HallDigger","UTILS.attachRoomAtMapDoor","UTILS.attachRoom","endX","endY","siteGrid","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","lakes","LAKE.Lakes","bridges","BRIDGE.Bridges","stairs","STAIRS.Stairs"],"mappings":"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"}
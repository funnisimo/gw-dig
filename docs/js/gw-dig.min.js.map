{"version":3,"file":"gw-dig.min.js","sources":["../js/room.js","../js/gw.js","../js/hall.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    rooms[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    Object.entries(opts).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                GW.utils.WARN('Missing required config for digger: ' + key);\n                return;\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n            return;\n        }\n        const range = GW.range.make(have);\n        if (!range) {\n            GW.utils.ERROR('Invalid configuration for digger: ' + key);\n        }\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GW.random.item.bind(GW.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GW.random.weighted.bind(GW.random, config.choices);\n    }\n    else {\n        return GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        return GW.utils.ERROR('Missing digger choice: ' + id);\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (height % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GW.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nexport function pickHallWidth(opts = {}) {\n    return GW.utils.clamp(_pickHallWidth(opts), 1, 3);\n}\nfunction _pickHallWidth(opts) {\n    if (typeof opts === 'number')\n        return opts;\n    if (!opts)\n        return 1;\n    if (opts.hallWidth === undefined)\n        return 1;\n    let width = opts.hallWidth;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else {\n        width = GW.random.weighted(width);\n    }\n    if (typeof width === 'string')\n        return Number.parseInt(width);\n    return width;\n}\nexport function pickHallLength(dir, opts) {\n    const horizontalLength = GW.utils.firstOpt('horizontalHallLength', opts, [\n        9,\n        15,\n    ]);\n    const verticalLength = GW.utils.firstOpt('verticalHallLength', opts, [\n        2,\n        9,\n    ]);\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return verticalLength;\n    }\n    else {\n        return horizontalLength;\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickHallLength(dir, opts)[1]; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digHall(grid, dir, length, room, opts) {\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || CONST.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\nexport function digHallTwo(grid, dir, length, room, opts) {\n    const door = room.doors[dir];\n    const tile = opts.tile || CONST.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + 2; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + 2; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + 2; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + 2; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    hall.doors = hallDoors;\n    hall.width = 2;\n    return hall;\n}\nexport function attachHallway(grid, room, opts) {\n    opts = opts || {};\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    console.log('dir', dir);\n    const length = GW.random.range(...pickHallLength(dir, opts));\n    console.log('length', length);\n    const width = opts.width || 1;\n    console.log('width', width);\n    if (width > 1) {\n        return digHallTwo(grid, dir, length, room, opts);\n    }\n    return digHall(grid, dir, length, room, opts);\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { attachHallway } from './hall';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport { rooms as ROOM_DIGGERS, Room, Hall } from './room';\nexport { Room, Hall };\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = ROOM_DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    const attachHall = GW.random.chance(hallChance);\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = config.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(config, roomGrid);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = attachHallway(roomGrid, room, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, config);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, config);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts = {}) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                // doorSites[oppDir][0] = -1;\n                // doorSites[oppDir][1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts = {}) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts = {}) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n"],"names":["Hall","[object Object]","loc","dir","length","width","this","doors","x","y","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","rooms","checkConfig","config","opts","Object","entries","key","expect","have","undefined","WARN","Array","isArray","range","GW.range","make","ERROR","id","fn","grid","destX","destY","blobGrid","value","tile","GW.grid","alloc","minWidth","maxWidth","minHeight","maxHeight","fill","bounds","fillBlob","offsetZip","free","choices","GW.random","item","bind","weighted","digConfig","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","min","max","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","chance","count","i","minX","maxX","minY","maxY","chunkCount","valueBounds","pickHallLength","horizontalLength","firstOpt","verticalLength","digHall","room","door","DIR","newX","newY","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","hasXY","pickHallExits","attachHallway","NO_DIRECTION","dirs","sequence","pickHallDirection","console","log","x0","y0","LEFT","digHallTwo","SEQ","attachRoom","map","roomGrid","doorSites","get","directionOfDoorSite","oppDir","offsetX","offsetY","roomFitsAt","_d","_s","j","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","attachRoomAtMapDoor","mapDoors","doorIndexes","attachRoomAtXY","offX","offY","chooseRandomDoorSites","sourceGrid","k","doorSiteFailed","copy","randomMatchingLoc","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","diggerId","ROOM_DIGGERS","locs","hallChance","hallway","attachHall","result","tries","xy"],"mappings":"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"}
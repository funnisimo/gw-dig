!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";const e={0:"NULL",1:"FLOOR",2:"DOOR",3:"WALL",8:"IMPREGNABLE",4:"LAKE",5:"SHALLOW",6:"BRIDGE",7:"UP_STAIRS",17:"DOWN_STAIRS"},o=[];function r(t){o.length=t;for(let i=0;i<t;++i)o[i]=i;i.random.shuffle(o)}function s(t,e){e.update(((e,o,r)=>t.isPassable(o,r)?1:i.path.OBSTRUCTION))}class n{constructor(t){this.grid=t}get width(){return this.grid.width}get height(){return this.grid.height}hasXY(t,i){return this.grid.hasXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return 0===this.grid.get(t,i)}isDiggable(t,i){return 0===this.grid.get(t,i)}isFloor(t,i){return 1==this.grid.get(t,i)}isDoor(t,i){return 2===this.grid.get(t,i)}isBridge(t,i){return 6===this.grid.get(t,i)}isWall(t,i){const e=this.grid.get(t,i);return 3===e||8===e}isObstruction(t,i){return this.isNothing(t,i)||this.isWall(t,i)}isStairs(t,i){const e=this.grid.get(t,i);return 7===e||17===e}isDeep(t,i){return 4===this.grid.get(t,i)}isShallow(t,i){return 5===this.grid.get(t,i)}isAnyWater(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.grid.get(t,i)||0)>0}setTile(t,i,e){this.grid.hasXY(t,i)&&(this.grid[t][i]=e)}}const h=i.utils.DIRS;function a(t,e,r,s){const h=r.hall?r.hall.doors:r.doors,a=new n(t);for(let n=0;n<o.length;n++){const f=Math.floor(o[n]/t.height),d=o[n]%t.height;if(0!=t.get(f,d))continue;const g=u(a,f,d);if(g!=i.utils.NO_DIRECTION){const o=(g+2)%4,n=h[o];if(!n)continue;const a=f-n[0],u=d-n[1];if(-1!=n[0]&&c(t,e,a,u))return i.grid.offsetZip(t,e,a,u,((i,e,o,r)=>{t[o][r]=s.room.tile||1})),l(t,r,s,f,d,o),r.translate(a,u),!0}}return!1}function l(t,e,o,r,s,n){if(0===o.door)return;const h=o.door||2;if(t[r][s]=h,e.hall&&e.hall.width>1&&e.hall.dir===n)if(n===i.utils.UP||n===i.utils.DOWN){let i=!0,e=1;for(;i;)i=!1,0===t.get(r-e,s)&&t.get(r-e,s-1)&&t.get(r-e,s+1)&&(t[r-e][s]=h,i=!0),0===t.get(r+e,s)&&t.get(r+e,s-1)&&t.get(r+e,s+1)&&(t[r+e][s]=h,i=!0),++e}else{let i=!0,e=1;for(;i;)i=!1,0===t.get(r,s-e)&&t.get(r-1,s-e)&&t.get(r+1,s-e)&&(t[r][s-e]=o.door,i=!0),0===t.get(r,s+e)&&t.get(r-1,s+e)&&t.get(r+1,s+e)&&(t[r][s+e]=o.door,i=!0),++e}}function c(t,i,e,o){let r,s,n,h,a,l;for(r=0;r<i.width;r++)for(s=0;s<i.height;s++)if(i[r][s])for(n=r+e,h=s+o,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||0!==t.get(a,l))return!1;return!0}function u(t,e,o){let r,s,n,a,l,c;for(s=i.utils.NO_DIRECTION,r=0;r<4;r++)if(n=e+h[r][0],a=o+h[r][1],l=e-h[r][0],c=o-h[r][1],t.hasXY(l,c)&&t.hasXY(n,a)&&t.isFloor(l,c)){if(s!=i.utils.NO_DIRECTION)return i.utils.NO_DIRECTION;s=r}return s}function f(t){let e,o,r,s,n,h,a;const l=[[],[],[],[]],c=t.height,f=t.width;for(e=0;e<f;e++)for(o=0;o<c;o++)if(t.isDiggable(e,o)&&(h=u(t,e,o),h!=i.utils.NO_DIRECTION)){for(s=e+i.utils.DIRS[h][0],n=o+i.utils.DIRS[h][1],a=!1,r=0;r<10&&t.hasXY(s,n)&&!a;r++)t.isSet(s,n)&&(a=!0),s+=i.utils.DIRS[h][0],n+=i.utils.DIRS[h][1];a||l[h].push([e,o])}let d=[];for(h=0;h<4;h++){const t=i.random.item(l[h])||[-1,-1];d[h]=[t[0],t[1]]}return d}function d(t,e,o,r,s){const n=i.random.sequence(e.length);for(let i=0;i<n.length;i++){const h=e[n[i]];if(!h)continue;if(g(t,h[0],h[1],o,r,s))return!0}return!1}function g(t,e,o,r,s,n){const h=s.hall?s.hall.doors:s.doors,a=i.random.sequence(4);for(let u of a){const a=(u+2)%4,f=h[a];if(f&&(-1!=f[0]&&c(t,r,e-f[0],o-f[1]))){const h=e-f[0],c=o-f[1];return i.grid.offsetZip(t,r,h,c,((i,e,o,r)=>{t[o][r]=n.room.tile||1})),l(t,s,n,e,o,a),s.translate(h,c),!0}}return!1}var m={__proto__:null,attachRoom:a,attachDoor:l,roomFitsAt:c,directionOfDoorSite:u,chooseRandomDoorSites:f,forceRoomAtMapLoc:function(t,e,r,s,h){const a=new n(t);for(let n=0;n<o.length;n++){const l=Math.floor(o[n]/t.height),f=o[n]%t.height;if(r[l][f])continue;if(u(a,l,f)!=i.utils.NO_DIRECTION){const o=e[0]-l,n=e[1]-f;if(c(t,r,o,n)){if(i.grid.offsetZip(t,r,o,n,((i,e,o,r)=>{t[o][r]=h.room.tile||1})),!1!==h.room.door){const i=!0!==h.room.door&&h.room.door?h.room.door:2;t[e[0]][e[1]]=i}return s.translate(o,n),!0}}}return!1},attachRoomAtMapDoor:d};class p{constructor(t,e,o,r=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const s=i.utils.DIRS[e];this.length=o,this.width=r,e===i.utils.UP||e===i.utils.DOWN?(this.x2=this.x+(r-1),this.y2=this.y+(o-1)*s[1]):(this.x2=this.x+(o-1)*s[0],this.y2=this.y+(r-1)),this.dir=e}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}class w extends i.utils.Bounds{constructor(t,i,e,o){super(t,i,e,o),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}const M=i.utils.DIRS;function D(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const o=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(o[0],o[1])&&!!t.isFloor(o[0],o[1])}function y(t,e){return t==i.utils.UP||t==i.utils.DOWN?e[1].value():e[0].value()}function b(t,e,o){let r=i.utils.NO_DIRECTION;if(r==i.utils.NO_DIRECTION){const s=i.random.sequence(4);for(let n=0;n<4;n++){r=s[n];const h=o[(n+1)%2].hi,a=e[r];if(a&&-1!=a[0]&&-1!=a[1]){const i=a[0]+Math.floor(M[r][0]*h),e=a[1]+Math.floor(M[r][1]*h);if(t.hasXY(i,e))break}r=i.utils.NO_DIRECTION}}return r}function R(t,e,o,r,s){let n,h;const a=i.random.chance(s),l=[];for(let i=0;i<4;i++)n=e+M[i][0],h=o+M[i][1],i!=r&&!a||!t.hasXY(n,h)||t.isSet(n,h)||(l[i]=[n,h]);return l}class O{constructor(t={}){this.config={width:i.range.make(1),length:[i.range.make("9-15"),i.range.make("2-9")],tile:1,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=i.range.make(t.width)),t.length&&"number"==typeof t.length){const e=i.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile)}create(t,e=[]){if(e=e||f(t),!i.random.chance(this.config.chance))return null;const o=b(t,e,this.config.length);if(o===i.utils.NO_DIRECTION)return null;if(!e[o])return null;const r=this.config.width.value(),s=y(o,this.config.length),n=e[o];return 1==r?this.dig(t,o,n,s):this.digWide(t,o,n,s,r)}_digLine(t,i,e,o){let r=i[0],s=i[1];const n=this.config.tile;for(let i=0;i<o;i++)t.setTile(r,s,n),r+=e[0],s+=e[1];return r-=e[0],s-=e[1],[r,s]}dig(t,i,e,o){const r=M[i],[s,n]=this._digLine(t,e,r,o),h=new p(e,i,o);return h.doors=R(t,s,n,i,this.config.obliqueChance),h}digWide(t,e,o,r,s){const n=i.utils.DIRS[e],h=[o[0]-n[1],o[1]-n[0]],a=[o[0]+n[1],o[1]+n[0]];this._digLine(t,o,n,r);let l=1,c=o[0],u=o[1];l<s&&D(t,h,n)&&(this._digLine(t,h,n,r),c=Math.min(h[0],c),u=Math.min(h[1],u),++l),l<s&&D(t,a,n)&&(this._digLine(t,a,n,r),c=Math.min(a[0],c),u=Math.min(a[1],u),++l);const f=new p([c,u],e,r,s);return f.doors=[],f.doors[e]=[o[0]+r*n[0],o[1]+r*n[1]],f.width=s,f}}var _={};function x(t,i){return _[t]=i,i}x("DEFAULT",new O({chance:15}));var S={__proto__:null,isDoorLoc:D,pickWidth:function(t={}){return i.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let e=t.width;if("number"==typeof e)return e;e=Array.isArray(e)?i.random.weighted(e)+1:"string"==typeof e?i.range.make(e).value():Number.parseInt(i.random.weighted(e));return e}(t),1,3)},pickLength:y,pickHallDirection:b,pickHallExits:R,HallDigger:O,dig:function(t,i,e){return new O(t).create(i,e)},halls:_,install:x};function T(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,o])=>{let r=t[e];if("tile"===e)return void(void 0===r&&(t[e]=o));if(!0===o){if(!r)throw new Error("Missing required config for room digger: "+e)}else r=("number"==typeof o||Array.isArray(o),r||o);const s=i.range.make(r);t[e]=s})),t}class v{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=T(t,i)}create(t){const i=this.carve(t);return i&&(i.doors=f(t)),i}}var A={};class I extends v{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const o=t.choices||e.choices;if(Array.isArray(o))this.randomRoom=i.random.item.bind(i.random,o);else{if("object"!=typeof o)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=i.random.weighted.bind(i.random,o)}}carve(t){let e=this.randomRoom();const o=A[e];return o||i.utils.ERROR("Missing room digger choice: "+e),o.create(t)}}class C extends v{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,s=i.grid.alloc(t.width,t.height,0),n=Math.floor(.5*e),h=e,a=Math.floor(.5*o),l=o,c=new i.blob.Blob({roundCount:5,minBlobWidth:n,minBlobHeight:a,maxBlobWidth:h,maxBlobHeight:l,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(s.width,s.height,((t,i)=>s[t][i]=1)),u=Math.floor((t.width-c.width)/2),f=u-c.x,d=Math.floor((t.height-c.height)/2),g=d-c.y;return s.forEach(((i,e,o)=>{i&&t.setTile(e+f,o+g,r)})),i.grid.free(s),new w(u,d,c.width,c.height)}}class E extends v{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,s=Math.floor(.4*e),n=o,h=e,a=Math.floor(.5*o),l=Math.floor(t.width/2-s/2-1),c=t.height-n-2,u=Math.floor(t.width/2-h/2-1),f=t.height-a-2;return i.utils.forRect(l,c,s,n,((i,e)=>t.setTile(i,e,r))),i.utils.forRect(u,f,h,a,((i,e)=>t.setTile(i,e,r))),new w(Math.min(l,u),Math.min(c,f),Math.max(s,h),Math.max(n,a))}}class L extends v{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,s=e,n=Math.max(3,Math.floor(e*i.random.range(25,75)/100)),h=Math.max(3,Math.floor(o*i.random.range(25,75)/100)),a=o,l=Math.floor((t.width-s)/2),c=l+i.random.range(2,Math.max(2,s-n-2)),u=Math.floor((t.height-a)/2),f=u+i.random.range(2,Math.max(2,a-h-2));return i.utils.forRect(l,f,s,h,((i,e)=>t.setTile(i,e,r))),i.utils.forRect(c,u,n,a,((i,e)=>t.setTile(i,e,r))),new w(l,u,Math.max(s,n),Math.max(h,a))}}class N extends v{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1;let s=Math.max(3,Math.floor(e*i.random.range(25,50)/100)),n=Math.max(3,Math.floor(o*i.random.range(25,50)/100));const h=Math.floor((t.width-e)/2),a=Math.floor((t.height-n)/2);i.utils.forRect(h,a,e,n,((i,e)=>t.setTile(i,e,r)));const l=Math.floor((t.width-s)/2),c=Math.floor((t.height-o)/2);return i.utils.forRect(l,c,s,o,((i,e)=>t.setTile(i,e,r))),new w(Math.min(h,l),Math.min(a,c),Math.max(e,s),Math.max(o,n))}}class X extends v{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,s=Math.floor((t.width-e)/2),n=Math.floor((t.height-o)/2);return i.utils.forRect(s,n,e,o,((i,e)=>t.setTile(i,e,r))),new w(s,n,e,o)}}class Y extends v{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(),o=this.options.tile||1,r=Math.floor(t.width/2),s=Math.floor(t.height/2);return e>1&&i.utils.forCircle(r,s,e,((i,e)=>t.setTile(i,e,o))),new w(r-e,s-e,2*e+1,2*e+1)}}class P extends v{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(),o=this.options.ringMinWidth.value(),r=this.options.holeMinSize.value(),s=this.options.tile||1,n=Math.floor(t.width/2),h=Math.floor(t.height/2);return i.utils.forCircle(n,h,e,((i,e)=>t.setTile(i,e,s))),e>o+r&&i.random.chance(this.options.holeChance.value())&&i.utils.forCircle(n,h,i.random.range(r,e-r),((i,e)=>t.setTile(i,e,0))),new w(n-e,h-e,2*e+1,2*e+1)}}class B extends v{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,o,r,s=this.options.count.value();const n=this.options.width.value(),h=this.options.height.value(),a=this.options.tile||1,l=Math.floor(t.width/2)-Math.floor(n/2),c=Math.floor(t.width/2)+Math.floor(n/2),u=Math.floor(t.height/2)-Math.floor(h/2),f=Math.floor(t.height/2)+Math.floor(h/2);let d=Math.floor(t.width/2),g=d,m=Math.floor(t.height/2),p=m;for(i.utils.forCircle(d,m,2,((i,e)=>t.setTile(i,e,a))),d-=2,g+=2,m-=2,p+=2,e=0;e<s;)if(o=i.random.range(l,c),r=i.random.range(u,f),t.isSet(o,r)){if(o-2<l)continue;if(o+2>c)continue;if(r-2<u)continue;if(r+2>f)continue;d=Math.min(o-2,d),g=Math.max(o+2,g),m=Math.min(r-2,m),p=Math.max(r+2,p),i.utils.forCircle(o,r,2,((i,e)=>t.setTile(i,e,a))),e++}return new w(d,m,g-d+1,p-m+1)}}function W(t,i){return A[t]=i,i}W("DEFAULT",new X);var k={__proto__:null,checkConfig:T,RoomDigger:v,rooms:A,ChoiceRoom:I,choiceRoom:function(t,i){return i.fill(0),new I(t).create(new n(i))},Cavern:C,cavern:function(t,i){return i.fill(0),new C(t).create(new n(i))},Entrance:E,entrance:function(t,i){return i.fill(0),new E(t).create(new n(i))},Cross:L,cross:function(t,i){return i.fill(0),new L(t).create(new n(i))},SymmetricalCross:N,symmetricalCross:function(t,i){return i.fill(0),new N(t).create(new n(i))},Rectangular:X,rectangular:function(t,i){return i.fill(0),new X(t).create(new n(i))},Circular:Y,circular:function(t,i){return i.fill(0),new Y(t).create(new n(i))},BrogueDonut:P,brogueDonut:function(t,i){return i.fill(0),new P(t).create(new n(i))},ChunkyRoom:B,chunkyRoom:function(t,i){return i.fill(0),new B(t).create(new n(i))},install:W};class F{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreath:0,wreathTile:5,tile:4},Object.assign(this.options,t)}create(t){let e,o,r,s,n,h,a,l,c,u,f,d=0;h=this.options.height||15,a=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,u=this.options.count||1,f=this.options.canDisrupt||!1;const g=this.options.wreath||0,m=this.options.wreathTile||5,p=this.options.tile||4,w=i.grid.alloc(t.width,t.height,0);let M=0;for(;M<u&&d<u;){const D=Math.round((a-l)*(u-M)/u)+l,y=Math.round((h-l)*(u-M)/u)+l,b=new i.blob.Blob({roundCount:5,minBlobWidth:4,minBlobHeight:4,maxBlobWidth:D,maxBlobHeight:y,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(w.width,w.height,((t,i)=>w[t][i]=1));let R=!1;for(r=0;r<c&&!R;r++)if(s=i.random.range(1-b.x,w.width-b.width-b.x-2),n=i.random.range(1-b.y,w.height-b.height-b.y-2),f||!this.isDisruptedBy(t,w,-s,-n)){for(R=!0,e=0;e<b.width;e++)for(o=0;o<b.height;o++)if(w[e+b.x][o+b.y]){const r=e+b.x+s,h=o+b.y+n;t.setTile(r,h,p),g&&i.utils.forCircle(r,h,g,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,m)}))}break}R?++d:++M}return i.grid.free(w),d}isDisruptedBy(t,e,o=0,r=0){const s=i.grid.alloc(t.width,t.height);let n=!1;i.utils.forRect(t.width,t.height,((i,h)=>{const a=i+o,l=h+r;e.get(a,l)?t.isStairs(i,h)&&(n=!0):t.isPassable(i,h)&&(s[i][h]=1)}));let h=!0;for(let t=0;t<s.width&&!n;++t)for(let i=0;i<s.height&&!n;++i)1==s[t][i]&&(h?(s.floodFill(t,i,1,2),h=!1):n=!0);return i.grid.free(s),n}}var U={__proto__:null,Lakes:F};class H{constructor(t={}){this.options={minimumPathingDistance:20,maxConnectionLength:5},Object.assign(this.options,t)}create(t){let e,o,r,s,n,h,a,l=0;const c=this.options.maxConnectionLength,u=this.options.minimumPathingDistance,f=i.grid.alloc(t.width,t.height),d=i.grid.alloc(t.width,t.height),g=[[1,0],[0,1]];d.update(((e,o,r)=>t.isPassable(o,r)?1:i.path.OBSTRUCTION));const m=i.random.sequence(t.width*t.height);for(r=0;r<m.length;r++)if(h=Math.floor(m[r]/t.height),a=m[r]%t.height,t.isPassable(h,a)&&!t.isAnyWater(h,a))for(n=0;n<=1;n++){const r=g[n];if(e=h+r[0],o=a+r[1],s=c,t.isAnyWater(e,o))for(s=0;s<c&&(e+=r[0],o+=r[1],t.isAnyWater(e,o));++s);if(t.isPassable(e,o)&&s<c&&(i.path.calculateDistances(f,e,o,d,!1),f[h][a]>u&&f[h][a]<i.path.NO_PATH)){for(;h!==e||a!==o;)this.isBridgeCandidate(t,h,a,r)?(t.setTile(h,a,6),d[h][a]=1):(t.setTile(h,a,1),d[h][a]=1),h+=r[0],a+=r[1];++l;break}}return i.grid.free(f),i.grid.free(d),l}isBridgeCandidate(t,i,e,o){return!!t.isBridge(i,e)||!!t.isAnyWater(i,e)&&(!!t.isAnyWater(i+o[1],e+o[0])&&!!t.isAnyWater(i-o[1],e-o[0]))}}var q={__proto__:null,Bridges:H};class G{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:7,downTile:17,wall:8},Object.assign(this.options,t)}create(t){let e=!1!==this.options.up,o=!1!==this.options.down;const r=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),s={};let n,h;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?i.random.matchingXY(t.width,t.height,a):i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),s.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;n=i.random.matchingXYNear(i.utils.x(t),i.utils.y(t),a);const e=this.options.down;h=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;n=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),o&&(h=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,n[0],n[1])<r)&&a(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const o=this.options.down;h=i.random.matchingXYNear(i.utils.x(o),i.utils.y(o),a),e&&(n=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,h[0],h[1])<r)&&a(t,e))))}else e?(n=i.random.matchingXY(t.width,t.height,a),o&&(h=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,n[0],n[1])<r)&&a(t,e))))):o&&(h=i.random.matchingXY(t.width,t.height,a));return n&&(s.up=n.slice(),this.setupStairs(t,n[0],n[1],this.options.upTile),"up"===this.options.start&&(s.start=s.up)),void 0!==h&&(s.down=h.slice(),this.setupStairs(t,h[0],h[1],this.options.downTile),"down"===this.options.start&&(s.start=s.down)),n||h?s:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,e,o){let r=0;if(!this.hasXY(t,e,o)||!t.isDiggable(e,o))return!1;for(let s=0;s<4;++s){const n=i.utils.DIRS[s];if(!this.hasXY(t,e+n[0],o+n[1]))return!1;if(!this.hasXY(t,e-n[0],o-n[1]))return!1;if(t.isFloor(e+n[0],o+n[1])){if(r+=1,!t.isDiggable(e-n[0]+n[1],o-n[1]+n[0]))return!1;if(!t.isDiggable(e-n[0]-n[1],o-n[1]-n[0]))return!1}else if(!t.isDiggable(e+n[0],o+n[1]))return!1}return 1==r}setupStairs(t,e,o,r){const s=i.random.sequence(4);let n=null;for(let r=0;r<s.length;++r){n=i.utils.DIRS[r];const s=e+n[0],h=o+n[1];if(t.isFloor(s,h)&&t.isDiggable(e-n[0],o-n[1]))break;n=null}n||i.utils.ERROR("No stair direction found!"),t.setTile(e,o,r);const h=i.utils.CLOCK_DIRS.findIndex((t=>t[0]==n[0]&&t[1]==n[1])),a=this.options.wall;for(let r=0;r<i.utils.CLOCK_DIRS.length;++r){const s=r?r-1:7,n=(r+1)%8;if(r==h||s==h||n==h)continue;const l=i.utils.CLOCK_DIRS[r];t.setTile(e+l[0],o+l[1],a)}return!0}}var j={__proto__:null,Stairs:G};class z{constructor(t={}){this.options={minimumPathingDistance:100,maxConnectionLength:1},Object.assign(this.options,t)}create(t){let e,r,n,h,a,l,c,u,f;const d=Math.min(this.options.minimumPathingDistance,Math.floor(Math.max(t.width,t.height)/2)),g=this.options.maxConnectionLength,m=i.grid.alloc(t.width,t.height),p=i.grid.alloc(t.width,t.height),w=[[1,0],[0,1]];function M(i,e,o){return!!t.hasXY(i,e)&&(!!t.hasXY(i+o[1],e+o[0])&&(!!t.hasXY(i-o[1],e-o[0])&&(!t.isSet(i,e)&&(!t.isSet(i+o[1],e+o[0])&&!t.isSet(i-o[1],e-o[0])))))}function D(i,e,o){return!!t.hasXY(i,e)&&(!!t.hasXY(i+o[1],e+o[0])&&(!!t.hasXY(i-o[1],e-o[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+o[1],e+o[0])||!!t.isSet(i-o[1],e-o[0])))))}s(t,p);let y=0;for(a=0;a<o.length;a++)if(u=Math.floor(o[a]/t.height),f=o[a]%t.height,!t.isSet(u,f))for(c=0;c<=1;c++){let o=w[c];if(M(u,f,o)){if(l=g,t.hasXY(u+o[0],f+o[1])&&t.isPassable(u+o[0],f+o[1])){if(!t.hasXY(u-o[0],f-o[1])||t.isDoor(u-o[0],f-o[1]))continue}else{if(!t.hasXY(u-o[0],f-o[1])||!t.isPassable(u-o[0],f-o[1]))continue;if(!t.hasXY(u+o[0],f+o[1])||t.isDoor(u+o[0],f+o[1]))continue;o=o.map((t=>-1*t))}for(e=u+o[0],r=f+o[1],n=u,h=f,l=0;l<g&&(n-=o[0],h-=o[1],!D(n,h,o));++l);if(l<g&&(i.path.calculateDistances(m,e,r,p,!1),m[n][h]>d&&m[n][h]<3e4)){for(;n!==e||h!==r;)t.isNothing(n,h)&&(t.setTile(n,h,1),p[n][h]=1),n+=o[0],h+=o[1];t.setTile(u,f,2),++y;break}}}return i.grid.free(m),i.grid.free(p),y}}function K(t,i={}){const e=new z(i),o=new n(t);return e.create(o)}function Z(t){let e,o,r,s,h,a;const l=new n(t);do{for(a=!1,e=0;e<t.width-1;e++)for(o=0;o<t.height-1;o++)for(r=0;r<=1;r++)l.isPassable(e+r,o)&&!l.isPassable(e+(1-r),o)&&l.isObstruction(e+(1-r),o)&&!l.isPassable(e+r,o+1)&&l.isObstruction(e+r,o+1)&&l.isPassable(e+(1-r),o+1)&&(i.random.chance(50)?(s=e+(1-r),h=o):(s=e+r,h=o+1),a=!0,t[s][h]=1)}while(1==a)}function Q(t){t.forEach(((i,e,o)=>{t.isBoundaryXY(e,o)||2==i&&(1!=t.get(e+1,o)&&1!=t.get(e-1,o)||1!=t.get(e,o+1)&&1!=t.get(e,o-1)?(1!==t.get(e+1,o)?1:0)+(1!==t.get(e-1,o)?1:0)+(1!==t.get(e,o+1)?1:0)+(1!==t.get(e,o-1)?1:0)>=3&&(t[e][o]=1):t[e][o]=1)}))}function J(t,i=3){t.forEach(((e,o,r)=>{0==e&&(t[o][r]=i)}))}var V={__proto__:null,room:k,hall:S,lake:U,bridge:q,stairs:j,utils:m,loop:{__proto__:null,LoopDigger:z,digLoops:K},start:function(t){r(t.width*t.height),t.fill(0)},finish:function(t){Z(t),J(t),Q(t)},addRoom:function(t,e){let o;if("string"==typeof(e=e||{room:"DEFAULT",hall:"DEFAULT",tries:10})&&(e={room:e}),e.loc&&(e.locs=[e.loc]),"function"==typeof e.room&&(e.room=e.room()),e.room)if("string"==typeof e.room){const t=e.room;if(o=A[t],!o)throw new Error("Failed to find room: "+t)}else{if(!(e.room instanceof v))throw new Error("No room to build!");o=e.room}else o=A.DEFAULT;let r=null;if(!0===e.hall&&(e.hall="DEFAULT"),!1===e.hall||e.hall||(e.hall="DEFAULT"),"function"==typeof e.hall&&(e.hall={fn:e.hall}),"string"==typeof e.hall){const t=e.hall;if(e.hall=_[t],!e.hall)return i.utils.ERROR("Failed to find hall: "+t),null;r=e.hall}else e.hall&&e.hall.fn&&(r=e.hall);!1===e.door?e.door=0:!0===e.door?e.door=2:"number"==typeof e.door?e.door=i.random.chance(e.door)?2:1:e.door=1;let s=e.locs||null;if(s&&s.doors&&(s=s.doors),s&&Array.isArray(s))s&&s.length&&2==s.length&&"number"==typeof s[0]?s=[s]:0==s.length&&(s=null);else if(s=null,0===t.count(1)){s=[[Math.floor(t.width/2),t.height-2]]}const h=i.grid.alloc(t.width,t.height),l=new n(h);let c=!1;if(r){let t=void 0!==r.chance?r.chance:15;c=i.random.chance(t)}let u=null,f=!1,g=e.tries||10;for(;--g>=0&&!f;){if(h.fill(0),u=o.create(l),c){const t=new O;u.hall=t.create(l,u.doors)}f=s?d(t,s,h,u,e):a(t,h,u,e)}return i.grid.free(h),u&&f?u:null},addLoops:function(t,i,e){return K(t,{minimumPathingDistance:i,maxConnectionLength:e})},addLakes:function(t,i={}){const e=new F(i),o=new n(t);return e.create(o)},addBridges:function(t,i={}){const e=new H(i),o=new n(t);return e.create(o)},addStairs:function(t,i={}){const e=new G(i),o=new n(t);return e.create(o)},removeDiagonalOpenings:Z,finishDoors:Q,finishWalls:J,NOTHING:0,FLOOR:1,DOOR:2,WALL:3,DEEP:4,SHALLOW:5,BRIDGE:6,UP_STAIRS:7,DOWN_STAIRS:17,IMPREGNABLE:8,TILEMAP:e,SEQ:o,initSeqence:r,fillCostGrid:s,GridSite:n,Hall:p,Room:w};t.dig=V,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";const e={0:"NULL",1:"FLOOR",2:"DOOR",3:"WALL",8:"IMPREGNABLE",4:"LAKE",5:"SHALLOW",6:"BRIDGE",7:"UP_STAIRS",17:"DOWN_STAIRS"},s=[];function o(t){s.length=t;for(let i=0;i<t;++i)s[i]=i;i.random.shuffle(s)}function r(t,e){e.update(((e,s,o)=>t.isPassable(s,o)?1:i.path.OBSTRUCTION))}class n{constructor(t){this.grid=t}get width(){return this.grid.width}get height(){return this.grid.height}hasXY(t,i){return this.grid.hasXY(t,i)}isBoundaryXY(t,i){return this.grid.isBoundaryXY(t,i)}get(t,i){return this.grid.get(t,i)||0}copy(t,i=0,e=0){this.grid.forEach(((s,o,r)=>{const n=o-i,h=r-e,a=t.get(n,h);a&&this.grid.set(o,r,a)}))}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return 0===this.grid.get(t,i)}isDiggable(t,i){return 0===this.grid.get(t,i)}isFloor(t,i){return 1==this.grid.get(t,i)}isDoor(t,i){return 2===this.grid.get(t,i)}isBridge(t,i){return 6===this.grid.get(t,i)}isWall(t,i){const e=this.grid.get(t,i);return 3===e||8===e}isObstruction(t,i){return this.isNothing(t,i)||this.isWall(t,i)}isStairs(t,i){const e=this.grid.get(t,i);return 7===e||17===e}isDeep(t,i){return 4===this.grid.get(t,i)}isShallow(t,i){return 5===this.grid.get(t,i)}isAnyWater(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.grid.get(t,i)||0)>0}setTile(t,i,e){this.grid.hasXY(t,i)&&(this.grid[t][i]=e)}}const h=i.utils.DIRS;function a(t,e,o,r){const h=o.hall?o.hall.doors:o.doors,a=new n(t);for(let n=0;n<s.length;n++){const d=Math.floor(s[n]/t.height),f=s[n]%t.height;if(0!=t.get(d,f))continue;const g=u(a,d,f);if(g!=i.utils.NO_DIRECTION){const s=(g+2)%4,n=h[s];if(!n)continue;const a=d-n[0],u=f-n[1];if(-1!=n[0]&&c(t,e,a,u))return i.grid.offsetZip(t,e,a,u,((i,e,s,o)=>{t[s][o]=r.room.tile||1})),l(t,o,r,d,f,s),o.translate(a,u),!0}}return!1}function l(t,e,s,o,r,n){if(0===s.door)return;const h=s.door||2;if(t[o][r]=h,e.hall&&e.hall.width>1&&e.hall.dir===n)if(n===i.utils.UP||n===i.utils.DOWN){let i=!0,e=1;for(;i;)i=!1,0===t.get(o-e,r)&&t.get(o-e,r-1)&&t.get(o-e,r+1)&&(t[o-e][r]=h,i=!0),0===t.get(o+e,r)&&t.get(o+e,r-1)&&t.get(o+e,r+1)&&(t[o+e][r]=h,i=!0),++e}else{let i=!0,e=1;for(;i;)i=!1,0===t.get(o,r-e)&&t.get(o-1,r-e)&&t.get(o+1,r-e)&&(t[o][r-e]=s.door,i=!0),0===t.get(o,r+e)&&t.get(o-1,r+e)&&t.get(o+1,r+e)&&(t[o][r+e]=s.door,i=!0),++e}}function c(t,i,e,s){let o,r,n,h,a,l;for(o=0;o<i.width;o++)for(r=0;r<i.height;r++)if(i[o][r])for(n=o+e,h=r+s,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||0!==t.get(a,l))return!1;return!0}function u(t,e,s){let o,r,n,a,l,c;for(r=i.utils.NO_DIRECTION,o=0;o<4;o++)if(n=e+h[o][0],a=s+h[o][1],l=e-h[o][0],c=s-h[o][1],t.hasXY(l,c)&&t.hasXY(n,a)&&t.isFloor(l,c)){if(r!=i.utils.NO_DIRECTION)return i.utils.NO_DIRECTION;r=o}return r}function d(t){let e,s,o,r,n,h,a;const l=[[],[],[],[]],c=t.height,d=t.width;for(e=0;e<d;e++)for(s=0;s<c;s++)if(t.isDiggable(e,s)&&(h=u(t,e,s),h!=i.utils.NO_DIRECTION)){for(r=e+i.utils.DIRS[h][0],n=s+i.utils.DIRS[h][1],a=!1,o=0;o<10&&t.hasXY(r,n)&&!a;o++)t.isSet(r,n)&&(a=!0),r+=i.utils.DIRS[h][0],n+=i.utils.DIRS[h][1];a||l[h].push([e,s])}let f=[];for(h=0;h<4;h++){const t=i.random.item(l[h])||[-1,-1];f[h]=[t[0],t[1]]}return f}function f(t,e,s,o,r){const n=i.random.sequence(e.length);for(let i=0;i<n.length;i++){const h=e[n[i]];if(!h)continue;if(g(t,h[0],h[1],s,o,r))return!0}return!1}function g(t,e,s,o,r,n){const h=r.hall?r.hall.doors:r.doors,a=i.random.sequence(4);for(let u of a){const a=(u+2)%4,d=h[a];if(d&&(-1!=d[0]&&c(t,o,e-d[0],s-d[1]))){const h=e-d[0],c=s-d[1];return i.grid.offsetZip(t,o,h,c,((i,e,s,o)=>{t[s][o]=n.room.tile||1})),l(t,r,n,e,s,a),r.translate(h,c),!0}}return!1}var m={__proto__:null,attachRoom:a,attachDoor:l,roomFitsAt:c,directionOfDoorSite:u,chooseRandomDoorSites:d,forceRoomAtMapLoc:function(t,e,o,r,h){const a=new n(t);for(let n=0;n<s.length;n++){const l=Math.floor(s[n]/t.height),d=s[n]%t.height;if(o[l][d])continue;if(u(a,l,d)!=i.utils.NO_DIRECTION){const s=e[0]-l,n=e[1]-d;if(c(t,o,s,n)){if(i.grid.offsetZip(t,o,s,n,((i,e,s,o)=>{t[s][o]=h.room.tile||1})),!1!==h.room.door){const i=!0!==h.room.door&&h.room.door?h.room.door:2;t[e[0]][e[1]]=i}return r.translate(s,n),!0}}}return!1},attachRoomAtMapDoor:f};class w{constructor(t,e,s,o=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const r=i.utils.DIRS[e];this.length=s,this.width=o,e===i.utils.UP||e===i.utils.DOWN?(this.x2=this.x+(o-1),this.y2=this.y+(s-1)*r[1]):(this.x2=this.x+(s-1)*r[0],this.y2=this.y+(o-1)),this.dir=e}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}class p extends i.utils.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}const D=i.utils.DIRS;function b(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function M(t,e){return t==i.utils.UP||t==i.utils.DOWN?e[1].value():e[0].value()}function y(t,e,s){let o=i.utils.NO_DIRECTION;if(o==i.utils.NO_DIRECTION){const r=i.random.sequence(4);for(let n=0;n<4;n++){o=r[n];const h=s[(n+1)%2].hi,a=e[o];if(a&&-1!=a[0]&&-1!=a[1]){const i=a[0]+Math.floor(D[o][0]*h),e=a[1]+Math.floor(D[o][1]*h);if(t.hasXY(i,e))break}o=i.utils.NO_DIRECTION}}return o}function O(t,e,s,o,r){let n,h;const a=i.random.chance(r),l=[];for(let i=0;i<4;i++)n=e+D[i][0],h=s+D[i][1],i!=o&&!a||!t.hasXY(n,h)||t.isSet(n,h)||(l[i]=[n,h]);return l}class T{constructor(t={}){this.config={width:i.range.make(1),length:[i.range.make("2-15"),i.range.make("2-9")],tile:1,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=i.range.make(t.width)),t.length&&"number"==typeof t.length){const e=i.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile)}create(t,e=[]){if(e=e||d(t),!i.random.chance(this.config.chance))return null;const s=y(t,e,this.config.length);if(s===i.utils.NO_DIRECTION)return null;if(!e[s])return null;const o=this.config.width.value(),r=M(s,this.config.length),n=e[s];return 1==o?this.dig(t,s,n,r):this.digWide(t,s,n,r,o)}_digLine(t,i,e,s){let o=i[0],r=i[1];const n=this.config.tile;for(let i=0;i<s;i++)t.setTile(o,r,n),o+=e[0],r+=e[1];return o-=e[0],r-=e[1],[o,r]}dig(t,i,e,s){const o=D[i],[r,n]=this._digLine(t,e,o,s),h=new w(e,i,s);return h.doors=O(t,r,n,i,this.config.obliqueChance),h}digWide(t,e,s,o,r){const n=i.utils.DIRS[e],h=[s[0]-n[1],s[1]-n[0]],a=[s[0]+n[1],s[1]+n[0]];this._digLine(t,s,n,o);let l=1,c=s[0],u=s[1];l<r&&b(t,h,n)&&(this._digLine(t,h,n,o),c=Math.min(h[0],c),u=Math.min(h[1],u),++l),l<r&&b(t,a,n)&&(this._digLine(t,a,n,o),c=Math.min(a[0],c),u=Math.min(a[1],u),++l);const d=new w([c,u],e,o,r);return d.doors=[],d.doors[e]=[s[0]+o*n[0],s[1]+o*n[1]],d.width=r,d}}function R(t,i,e){return new T(t).create(i,e)}var S={};function _(t,i){return S[t]=i,i}_("DEFAULT",new T({chance:15}));var L={__proto__:null,isDoorLoc:b,pickWidth:function(t={}){return i.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let e=t.width;if("number"==typeof e)return e;e=Array.isArray(e)?i.random.weighted(e)+1:"string"==typeof e?i.range.make(e).value():Number.parseInt(i.random.weighted(e));return e}(t),1,3)},pickLength:M,pickHallDirection:y,pickHallExits:O,HallDigger:T,dig:R,halls:S,install:_};function v(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,s])=>{let o=t[e];if("tile"===e)return void(void 0===o&&(t[e]=s));if(!0===s){if(!o)throw new Error("Missing required config for room digger: "+e)}else o=("number"==typeof s||Array.isArray(s),o||s);const r=i.range.make(o);t[e]=r})),t}class x{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=v(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=d(t))),i}}var A={};class E extends x{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const s=t.choices||e.choices;if(Array.isArray(s))this.randomRoom=i.random.item.bind(i.random,s);else{if("object"!=typeof s)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=i.random.weighted.bind(i.random,s)}}carve(t){let e=this.randomRoom();const s=A[e];return s||i.utils.ERROR("Missing room digger choice: "+e),s.create(t)}}class N extends x{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),o=this.options.tile||1,r=i.grid.alloc(t.width,t.height,0),n=Math.floor(.5*e),h=e,a=Math.floor(.5*s),l=s,c=new i.blob.Blob({roundCount:5,minBlobWidth:n,minBlobHeight:a,maxBlobWidth:h,maxBlobHeight:l,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(r.width,r.height,((t,i)=>r[t][i]=1)),u=Math.floor((t.width-c.width)/2),d=u-c.x,f=Math.floor((t.height-c.height)/2),g=f-c.y;return r.forEach(((i,e,s)=>{i&&t.setTile(e+d,s+g,o)})),i.grid.free(r),new p(u,f,c.width,c.height)}}class I extends x{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),o=this.options.tile||1,r=Math.floor(.4*e),n=s,h=e,a=Math.floor(.5*s),l=Math.floor(t.width/2-r/2-1),c=t.height-n-2,u=Math.floor(t.width/2-h/2-1),d=t.height-a-2;i.utils.forRect(l,c,r,n,((i,e)=>t.setTile(i,e,o))),i.utils.forRect(u,d,h,a,((i,e)=>t.setTile(i,e,o)));const f=new p(Math.min(l,u),Math.min(c,d),Math.max(r,h),Math.max(n,a));return f.doors[i.utils.DOWN]=[Math.floor(t.width/2),t.height-2],f}}class X extends x{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),o=this.options.tile||1,r=e,n=Math.max(3,Math.floor(e*i.random.range(25,75)/100)),h=Math.max(3,Math.floor(s*i.random.range(25,75)/100)),a=s,l=Math.floor((t.width-r)/2),c=l+i.random.range(2,Math.max(2,r-n-2)),u=Math.floor((t.height-a)/2),d=u+i.random.range(2,Math.max(2,a-h-2));return i.utils.forRect(l,d,r,h,((i,e)=>t.setTile(i,e,o))),i.utils.forRect(c,u,n,a,((i,e)=>t.setTile(i,e,o))),new p(l,u,Math.max(r,n),Math.max(h,a))}}class Y extends x{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),o=this.options.tile||1;let r=Math.max(3,Math.floor(e*i.random.range(25,50)/100)),n=Math.max(3,Math.floor(s*i.random.range(25,50)/100));const h=Math.floor((t.width-e)/2),a=Math.floor((t.height-n)/2);i.utils.forRect(h,a,e,n,((i,e)=>t.setTile(i,e,o)));const l=Math.floor((t.width-r)/2),c=Math.floor((t.height-s)/2);return i.utils.forRect(l,c,r,s,((i,e)=>t.setTile(i,e,o))),new p(Math.min(h,l),Math.min(a,c),Math.max(e,r),Math.max(s,n))}}class C extends x{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),o=this.options.tile||1,r=Math.floor((t.width-e)/2),n=Math.floor((t.height-s)/2);return i.utils.forRect(r,n,e,s,((i,e)=>t.setTile(i,e,o))),new p(r,n,e,s)}}class B extends x{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(),s=this.options.tile||1,o=Math.floor(t.width/2),r=Math.floor(t.height/2);return e>1&&i.utils.forCircle(o,r,e,((i,e)=>t.setTile(i,e,s))),new p(o-e,r-e,2*e+1,2*e+1)}}class k extends x{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(),s=this.options.ringMinWidth.value(),o=this.options.holeMinSize.value(),r=this.options.tile||1,n=Math.floor(t.width/2),h=Math.floor(t.height/2);return i.utils.forCircle(n,h,e,((i,e)=>t.setTile(i,e,r))),e>s+o&&i.random.chance(this.options.holeChance.value())&&i.utils.forCircle(n,h,i.random.range(o,e-o),((i,e)=>t.setTile(i,e,0))),new p(n-e,h-e,2*e+1,2*e+1)}}class W extends x{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,s,o,r=this.options.count.value();const n=this.options.width.value(),h=this.options.height.value(),a=this.options.tile||1,l=Math.floor(t.width/2)-Math.floor(n/2),c=Math.floor(t.width/2)+Math.floor(n/2),u=Math.floor(t.height/2)-Math.floor(h/2),d=Math.floor(t.height/2)+Math.floor(h/2);let f=Math.floor(t.width/2),g=f,m=Math.floor(t.height/2),w=m;for(i.utils.forCircle(f,m,2,((i,e)=>t.setTile(i,e,a))),f-=2,g+=2,m-=2,w+=2,e=0;e<r;)if(s=i.random.range(l,c),o=i.random.range(u,d),t.isSet(s,o)){if(s-2<l)continue;if(s+2>c)continue;if(o-2<u)continue;if(o+2>d)continue;f=Math.min(s-2,f),g=Math.max(s+2,g),m=Math.min(o-2,m),w=Math.max(o+2,w),i.utils.forCircle(s,o,2,((i,e)=>t.setTile(i,e,a))),e++}return new p(f,m,g-f+1,w-m+1)}}function F(t,i){return A[t]=i,i}F("DEFAULT",new C);var P={__proto__:null,checkConfig:v,RoomDigger:x,rooms:A,ChoiceRoom:E,choiceRoom:function(t,i){return i.fill(0),new E(t).create(new n(i))},Cavern:N,cavern:function(t,i){return i.fill(0),new N(t).create(new n(i))},BrogueEntrance:I,brogueEntrance:function(t,i){return i.fill(0),new I(t).create(new n(i))},Cross:X,cross:function(t,i){return i.fill(0),new X(t).create(new n(i))},SymmetricalCross:Y,symmetricalCross:function(t,i){return i.fill(0),new Y(t).create(new n(i))},Rectangular:C,rectangular:function(t,i){return i.fill(0),new C(t).create(new n(i))},Circular:B,circular:function(t,i){return i.fill(0),new B(t).create(new n(i))},BrogueDonut:k,brogueDonut:function(t,i){return i.fill(0),new k(t).create(new n(i))},ChunkyRoom:W,chunkyRoom:function(t,i){return i.fill(0),new W(t).create(new n(i))},install:F};class U{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreath:0,wreathTile:5,tile:4},Object.assign(this.options,t)}create(t){let e,s,o,r,n,h,a,l,c,u,d,f=0;h=this.options.height||15,a=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,u=this.options.count||1,d=this.options.canDisrupt||!1;const g=this.options.wreath||0,m=this.options.wreathTile||5,w=this.options.tile||4,p=i.grid.alloc(t.width,t.height,0);let D=0;for(;D<u&&f<u;){const b=Math.round((a-l)*(u-D)/u)+l,M=Math.round((h-l)*(u-D)/u)+l,y=new i.blob.Blob({roundCount:5,minBlobWidth:4,minBlobHeight:4,maxBlobWidth:b,maxBlobHeight:M,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(p.width,p.height,((t,i)=>p[t][i]=1));let O=!1;for(o=0;o<c&&!O;o++)if(r=i.random.range(1-y.x,p.width-y.width-y.x-2),n=i.random.range(1-y.y,p.height-y.height-y.y-2),d||!this.isDisruptedBy(t,p,-r,-n)){for(O=!0,e=0;e<y.width;e++)for(s=0;s<y.height;s++)if(p[e+y.x][s+y.y]){const o=e+y.x+r,h=s+y.y+n;t.setTile(o,h,w),g&&i.utils.forCircle(o,h,g,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,m)}))}break}O?++f:++D}return i.grid.free(p),f}isDisruptedBy(t,e,s=0,o=0){const r=i.grid.alloc(t.width,t.height);let n=!1;i.utils.forRect(t.width,t.height,((i,h)=>{const a=i+s,l=h+o;e.get(a,l)?t.isStairs(i,h)&&(n=!0):t.isPassable(i,h)&&(r[i][h]=1)}));let h=!0;for(let t=0;t<r.width&&!n;++t)for(let i=0;i<r.height&&!n;++i)1==r[t][i]&&(h?(r.floodFill(t,i,1,2),h=!1):n=!0);return i.grid.free(r),n}}var q={__proto__:null,Lakes:U};class H{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let e,s,o,r,n,h,a,l=0;const c=this.options.maxLength,u=this.options.minDistance,d=i.grid.alloc(t.width,t.height),f=i.grid.alloc(t.width,t.height),g=[[1,0],[0,1]];f.update(((e,s,o)=>t.isPassable(s,o)?1:i.path.OBSTRUCTION));const m=i.random.sequence(t.width*t.height);for(o=0;o<m.length;o++)if(h=Math.floor(m[o]/t.height),a=m[o]%t.height,t.isPassable(h,a)&&!t.isAnyWater(h,a))for(n=0;n<=1;n++){const o=g[n];if(e=h+o[0],s=a+o[1],r=c,t.isAnyWater(e,s))for(r=0;r<c&&(e+=o[0],s+=o[1],t.isAnyWater(e,s));++r);if(t.isPassable(e,s)&&r<c&&(i.path.calculateDistances(d,e,s,f,!1),d[h][a]>u&&d[h][a]<i.path.NO_PATH)){for(;h!==e||a!==s;)this.isBridgeCandidate(t,h,a,o)?(t.setTile(h,a,6),f[h][a]=1):(t.setTile(h,a,1),f[h][a]=1),h+=o[0],a+=o[1];++l;break}}return i.grid.free(d),i.grid.free(f),l}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyWater(i,e)&&(!!t.isAnyWater(i+s[1],e+s[0])&&!!t.isAnyWater(i-s[1],e-s[0]))}}var j={__proto__:null,Bridges:H};class G{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:7,downTile:17,wall:8},Object.assign(this.options,t)}create(t){let e=!1!==this.options.up,s=!1!==this.options.down;const o=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),r={};let n,h;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?i.random.matchingXY(t.width,t.height,a):i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),r.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;n=i.random.matchingXYNear(i.utils.x(t),i.utils.y(t),a);const e=this.options.down;h=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;n=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),s&&(h=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,n[0],n[1])<o)&&a(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const s=this.options.down;h=i.random.matchingXYNear(i.utils.x(s),i.utils.y(s),a),e&&(n=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,h[0],h[1])<o)&&a(t,e))))}else e?(n=i.random.matchingXY(t.width,t.height,a),s&&(h=i.random.matchingXY(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,n[0],n[1])<o)&&a(t,e))))):s&&(h=i.random.matchingXY(t.width,t.height,a));return n&&(r.up=n.slice(),this.setupStairs(t,n[0],n[1],this.options.upTile),"up"===this.options.start&&(r.start=r.up)),void 0!==h&&(r.down=h.slice(),this.setupStairs(t,h[0],h[1],this.options.downTile),"down"===this.options.start&&(r.start=r.down)),n||h?r:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,e,s){let o=0;if(!this.hasXY(t,e,s)||!t.isDiggable(e,s))return!1;for(let r=0;r<4;++r){const n=i.utils.DIRS[r];if(!this.hasXY(t,e+n[0],s+n[1]))return!1;if(!this.hasXY(t,e-n[0],s-n[1]))return!1;if(t.isFloor(e+n[0],s+n[1])){if(o+=1,!t.isDiggable(e-n[0]+n[1],s-n[1]+n[0]))return!1;if(!t.isDiggable(e-n[0]-n[1],s-n[1]-n[0]))return!1}else if(!t.isDiggable(e+n[0],s+n[1]))return!1}return 1==o}setupStairs(t,e,s,o){const r=i.random.sequence(4);let n=null;for(let o=0;o<r.length;++o){n=i.utils.DIRS[o];const r=e+n[0],h=s+n[1];if(t.isFloor(r,h)&&t.isDiggable(e-n[0],s-n[1]))break;n=null}n||i.utils.ERROR("No stair direction found!"),t.setTile(e,s,o);const h=i.utils.CLOCK_DIRS.findIndex((t=>t[0]==n[0]&&t[1]==n[1])),a=this.options.wall;for(let o=0;o<i.utils.CLOCK_DIRS.length;++o){const r=o?o-1:7,n=(o+1)%8;if(o==h||r==h||n==h)continue;const l=i.utils.CLOCK_DIRS[o];t.setTile(e+l[0],s+l[1],a)}return!0}}var z={__proto__:null,Stairs:G};class K{constructor(t={}){this.options={minDistance:100,maxLength:1},Object.assign(this.options,t)}create(t){let e,o,n,h,a,l,c,u,d;const f=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),g=this.options.maxLength,m=i.grid.alloc(t.width,t.height),w=i.grid.alloc(t.width,t.height),p=[[1,0],[0,1]];function D(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function b(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}r(t,w);let M=0;for(a=0;a<s.length;a++)if(u=Math.floor(s[a]/t.height),d=s[a]%t.height,!t.isSet(u,d))for(c=0;c<=1;c++){let s=p[c];if(D(u,d,s)){if(l=g,t.hasXY(u+s[0],d+s[1])&&t.isPassable(u+s[0],d+s[1])){if(!t.hasXY(u-s[0],d-s[1])||t.isDoor(u-s[0],d-s[1]))continue}else{if(!t.hasXY(u-s[0],d-s[1])||!t.isPassable(u-s[0],d-s[1]))continue;if(!t.hasXY(u+s[0],d+s[1])||t.isDoor(u+s[0],d+s[1]))continue;s=s.map((t=>-1*t))}for(e=u+s[0],o=d+s[1],n=u,h=d,l=0;l<g&&(n-=s[0],h-=s[1],!b(n,h,s));++l);if(l<g&&(i.path.calculateDistances(m,e,o,w,!1),m[n][h]>f&&m[n][h]<3e4)){for(;n!==e||h!==o;)t.isNothing(n,h)&&(t.setTile(n,h,1),w[n][h]=1),n+=s[0],h+=s[1];t.setTile(u,d,2),++M;break}}}return i.grid.free(m),i.grid.free(w),M}}function Z(t,i={}){const e=new K(i),s=new n(t);return e.create(s)}var Q={__proto__:null,LoopDigger:K,digLoops:Z};function J(t){let e,s,o,r,h,a;const l=new n(t);do{for(a=!1,e=0;e<t.width-1;e++)for(s=0;s<t.height-1;s++)for(o=0;o<=1;o++)l.isPassable(e+o,s)&&!l.isPassable(e+(1-o),s)&&l.isObstruction(e+(1-o),s)&&!l.isPassable(e+o,s+1)&&l.isObstruction(e+o,s+1)&&l.isPassable(e+(1-o),s+1)&&(i.random.chance(50)?(r=e+(1-o),h=s):(r=e+o,h=s+1),a=!0,t[r][h]=1)}while(1==a)}function V(t){t.forEach(((i,e,s)=>{t.isBoundaryXY(e,s)||2==i&&(1!=t.get(e+1,s)&&1!=t.get(e-1,s)||1!=t.get(e,s+1)&&1!=t.get(e,s-1)?(1!==t.get(e+1,s)?1:0)+(1!==t.get(e-1,s)?1:0)+(1!==t.get(e,s+1)?1:0)+(1!==t.get(e,s-1)?1:0)>=3&&(t[e][s]=1):t[e][s]=1)}))}function $(t,i=3){t.forEach(((e,s,o)=>{0==e&&(t[s][o]=i)}))}class tt{constructor(t,e,s={}){this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.height=e,this.width=t,s.seed&&i.random.seed(s.seed),i.utils.setOptions(this.rooms,s.rooms),i.utils.setOptions(this.halls,s.halls),i.utils.setOptions(this.loops,s.loops),i.utils.setOptions(this.lakes,s.lakes),i.utils.setOptions(this.bridges,s.bridges),i.utils.setOptions(this.stairs,s.stairs),i.utils.setOptions(this.doors,s.doors),this.startLoc=s.startLoc||[Math.floor(t/2),e-2],this.endLoc=s.endLoc||[-1,-1]}makeSite(t){return new n(t)}create(t){const e=i.grid.alloc(this.width,this.height,0),s=this.makeSite(e);this.start(s),this.addFirstRoom(s);let o=0;for(;o<20;)this.addRoom(s)?o=0:++o;return this.addLoops(s,this.loops),this.addLakes(s,this.lakes),this.addBridges(s,this.bridges),this.addStairs(s,this.stairs),this.finish(s),e.forEach(((i,e,s)=>{i&&t(e,s,i)})),i.grid.free(e),!0}start(t){o(this.width*this.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof x)return t;if("string"==typeof t){const i=A[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new E(t)}addFirstRoom(t){const e=i.grid.alloc(t.width,t.height),s=this.makeSite(e);let o=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(s);return o&&!this._attachRoomAtLoc(t,s,o,this.startLoc)&&(o=null),i.grid.free(e),o}addRoom(t){const e=i.grid.alloc(t.width,t.height),s=this.makeSite(e);let o=this.getDigger(this.rooms.digger||"DEFAULT").create(s);if(this.halls.chance){let t=R(this.halls,s,o.doors);t&&(o.hall=t)}return o&&!this._attachRoom(t,s,o)&&(o=null),i.grid.free(e),o}_attachRoom(t,e,o){const r=o.hall?o.hall.doors:o.doors;for(let n=0;n<s.length;n++){const h=Math.floor(s[n]/this.height),a=s[n]%this.height;if(!t.isNothing(h,a))continue;const l=u(t,h,a);if(l!=i.utils.NO_DIRECTION){const i=(l+2)%4,s=r[i];if(!s)continue;const n=h-s[0],c=a-s[1];if(-1!=s[0]&&this._roomFitsAt(t,e,n,c))return t.copy(e,n,c),this._attachDoor(t,o,h,a,i),o.translate(n,c),!0}}return!1}_attachRoomAtLoc(t,e,s,o){const[r,n]=o,h=s.hall?s.hall.doors:s.doors,a=i.random.sequence(4);for(let i of a){const o=h[(i+2)%4];if(!o||-1==o[0])continue;const a=r-o[0],l=n-o[1];if(this._roomFitsAt(t,e,a,l))return t.copy(e,a,l),s.translate(a,l),!0}return!1}_roomFitsAt(t,i,e,s){let o,r,n,h,a,l;for(o=0;o<i.width;o++)for(r=0;r<i.height;r++)if(i.isSet(o,r))for(n=o+e,h=r+s,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||!t.isNothing(a,l))return!1;return!0}_attachDoor(t,e,s,o,r){const n=this.doors;if(0===n.chance)return;const h=n.chance&&i.random.chance(n.chance)?n.tile||2:1;if(t.setTile(s,o,h),e.hall&&e.hall.width>1&&e.hall.dir===r)if(r===i.utils.UP||r===i.utils.DOWN){let i=!0,e=1;for(;i;)i=!1,t.isNothing(s-e,o)&&t.isSet(s-e,o-1)&&t.isSet(s-e,o+1)&&(t.setTile(s-e,o,h),i=!0),t.isNothing(s+e,o)&&t.isSet(s+e,o-1)&&t.isSet(s+e,o+1)&&(t.setTile(s+e,o,h),i=!0),++e}else{let i=!0,e=1;for(;i;)i=!1,t.isNothing(s,o-e)&&t.isSet(s-1,o-e)&&t.isSet(s+1,o-e)&&(t.setTile(s,o-e,h),i=!0),t.isNothing(s,o+e)&&t.isSet(s-1,o+e)&&t.isSet(s+1,o+e)&&(t.setTile(s,o+e,h),i=!0),++e}}addLoops(t,i){return new K(i).create(t)}addLakes(t,i){return new U(i).create(t)}addBridges(t,i){return new H(i).create(t)}addStairs(t,i){return new G(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let e,s,o,r,n,h;do{for(h=!1,e=0;e<this.width-1;e++)for(s=0;s<this.height-1;s++)for(o=0;o<=1;o++)t.isPassable(e+o,s)&&!t.isPassable(e+(1-o),s)&&t.isObstruction(e+(1-o),s)&&!t.isPassable(e+o,s+1)&&t.isObstruction(e+o,s+1)&&t.isPassable(e+(1-o),s+1)&&(i.random.chance(50)?(r=e+(1-o),n=s):(r=e+o,n=s+1),h=!0,t.setTile(r,n,1))}while(1==h)}_finishDoors(t){i.utils.forRect(this.width,this.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.isObstruction(i+1,e)?1:0)+(t.isObstruction(i-1,e)?1:0)+(t.isObstruction(i,e+1)?1:0)+(t.isObstruction(i,e-1)?1:0)>=3)&&t.setTile(i,e,1)}))}_finishWalls(t){const e=this.boundary?8:3;i.utils.forRect(this.width,this.height,((i,s)=>{t.isNothing(i,s)&&(t.isBoundaryXY(i,s)?t.setTile(i,s,e):t.setTile(i,s,3))}))}}var it={__proto__:null,room:P,hall:L,lake:q,bridge:j,stairs:z,utils:m,loop:Q,start:function(t){o(t.width*t.height),t.fill(0)},finish:function(t){J(t),$(t),V(t)},addRoom:function(t,e){let s;if("string"==typeof(e=e||{room:"DEFAULT",hall:"DEFAULT",tries:10})&&(e={room:e}),e.loc&&(e.locs=[e.loc]),"function"==typeof e.room&&(e.room=e.room()),e.room)if("string"==typeof e.room){const t=e.room;if(s=A[t],!s)throw new Error("Failed to find room: "+t)}else{if(!(e.room instanceof x))throw new Error("No room to build!");s=e.room}else s=A.DEFAULT;let o=null;if(!0===e.hall&&(e.hall="DEFAULT"),!1===e.hall||e.hall||(e.hall="DEFAULT"),"function"==typeof e.hall&&(e.hall={fn:e.hall}),"string"==typeof e.hall){const t=e.hall;if(e.hall=S[t],!e.hall)return i.utils.ERROR("Failed to find hall: "+t),null;o=e.hall}else e.hall&&e.hall.fn&&(o=e.hall);!1===e.door?e.door=0:!0===e.door?e.door=2:"number"==typeof e.door?e.door=i.random.chance(e.door)?2:1:e.door=1;let r=e.locs||null;if(r&&r.doors&&(r=r.doors),r&&Array.isArray(r))r&&r.length&&2==r.length&&"number"==typeof r[0]?r=[r]:0==r.length&&(r=null);else if(r=null,0===t.count(1)){r=[[Math.floor(t.width/2),t.height-2]]}const h=i.grid.alloc(t.width,t.height),l=new n(h);let c=!1;if(o){let t=void 0!==o.chance?o.chance:15;c=i.random.chance(t)}let u=null,d=!1,g=e.tries||10;for(;--g>=0&&!d;){if(h.fill(0),u=s.create(l),c){const t=new T;u.hall=t.create(l,u.doors)}d=r?f(t,r,h,u,e):a(t,h,u,e)}return i.grid.free(h),u&&d?u:null},addLoops:function(t,i,e){return Z(t,{minDistance:i,maxLength:e})},addLakes:function(t,i={}){const e=new U(i),s=new n(t);return e.create(s)},addBridges:function(t,i={}){const e=new H(i),s=new n(t);return e.create(s)},addStairs:function(t,i={}){const e=new G(i),s=new n(t);return e.create(s)},removeDiagonalOpenings:J,finishDoors:V,finishWalls:$,Level:tt,Dungeon:class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],i.utils.setOptions(this.config,t),this.config.seed&&i.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=i.random.number()}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const e=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let s=0;s<this.config.levels;++s){const s=i.random.matchingXY(this.config.width,this.config.height,((s,o)=>i.utils.distanceBetween(t[0],t[1],s,o)>e));this.stairLocs.push([[t[0],t[1]],[s[0],s[1]]]),t=s}}getLevel(t,e){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);i.random.seed(this.seeds[t]);const[s,o]=this.stairLocs[t],r=Object.assign({},this.config.stairs);this.config.goesUp?(r.down=s,r.up=o,0==t&&this.config.startTile&&(r.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.upTile=this.config.endTile)):(r.down=o,r.up=s,0==t&&this.config.startTile&&(r.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.downTile=this.config.endTile));const n=Object.assign({},this.config.rooms);0===t&&n.entrance&&(n.first=n.entrance);const h={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:n,stairs:r,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,h,e)}makeLevel(t,e,s){const o=new tt(this.config.width,this.config.height,e),r=o.create(s);return i.utils.equalsXY(o.endLoc,e.endLoc)&&i.utils.equalsXY(o.startLoc,e.startLoc)||(this.stairLocs[t]=[o.startLoc,o.endLoc]),r}},NOTHING:0,FLOOR:1,DOOR:2,WALL:3,DEEP:4,SHALLOW:5,BRIDGE:6,UP_STAIRS:7,DOWN_STAIRS:17,IMPREGNABLE:8,TILEMAP:e,SEQ:s,initSeqence:o,fillCostGrid:r,GridSite:n,Hall:w,Room:p};t.dig=it,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

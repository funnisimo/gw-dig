!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";const o={0:"NULL",1:"FLOOR",2:"DOOR",3:"WALL",8:"IMPREGNABLE",4:"LAKE",5:"SHALLOW",6:"BRIDGE",7:"UP_STAIRS",17:"DOWN_STAIRS"},e=[];function r(t){e.length=t;for(let i=0;i<t;++i)e[i]=i;i.random.shuffle(e)}function s(t,o){o.update(((o,e,r)=>t.isPassable(e,r)?1:i.path.OBSTRUCTION))}class n{constructor(t){this.grid=t}get width(){return this.grid.width}get height(){return this.grid.height}hasXY(t,i){return this.grid.hasXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return 0===this.grid.get(t,i)}isDiggable(t,i){return 0===this.grid.get(t,i)}isFloor(t,i){return 1==this.grid.get(t,i)}isDoor(t,i){return 2===this.grid.get(t,i)}isBridge(t,i){return 6===this.grid.get(t,i)}isWall(t,i){const o=this.grid.get(t,i);return 3===o||8===o}isObstruction(t,i){return this.isNothing(t,i)||this.isWall(t,i)}isStairs(t,i){const o=this.grid.get(t,i);return 7===o||17===o}isDeep(t,i){return 4===this.grid.get(t,i)}isShallow(t,i){return 5===this.grid.get(t,i)}isAnyWater(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.grid.get(t,i)||0)>0}setTile(t,i,o){this.grid.hasXY(t,i)&&(this.grid[t][i]=o)}}const h=i.utils.DIRS;function a(t,o,r,s){const h=r.hall?r.hall.doors:r.doors,a=new n(t);for(let n=0;n<e.length;n++){const d=Math.floor(e[n]/t.height),f=e[n]%t.height;if(0!=t.get(d,f))continue;const g=u(a,d,f);if(g!=i.utils.NO_DIRECTION){const e=(g+2)%4,n=h[e];if(!n)continue;const a=d-n[0],u=f-n[1];if(-1!=n[0]&&c(t,o,a,u))return i.grid.offsetZip(t,o,a,u,((i,o,e,r)=>{t[e][r]=s.room.tile||1})),l(t,r,s,d,f,e),r.translate(a,u),!0}}return!1}function l(t,o,e,r,s,n){if(0===e.door)return;const h=e.door||2;if(t[r][s]=h,o.hall&&o.hall.width>1&&o.hall.dir===n)if(n===i.utils.UP||n===i.utils.DOWN){let i=!0,o=1;for(;i;)i=!1,0===t.get(r-o,s)&&t.get(r-o,s-1)&&t.get(r-o,s+1)&&(t[r-o][s]=h,i=!0),0===t.get(r+o,s)&&t.get(r+o,s-1)&&t.get(r+o,s+1)&&(t[r+o][s]=h,i=!0),++o}else{let i=!0,o=1;for(;i;)i=!1,0===t.get(r,s-o)&&t.get(r-1,s-o)&&t.get(r+1,s-o)&&(t[r][s-o]=e.door,i=!0),0===t.get(r,s+o)&&t.get(r-1,s+o)&&t.get(r+1,s+o)&&(t[r][s+o]=e.door,i=!0),++o}}function c(t,i,o,e){let r,s,n,h,a,l;for(r=0;r<i.width;r++)for(s=0;s<i.height;s++)if(i[r][s])for(n=r+o,h=s+e,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||0!==t.get(a,l))return!1;return!0}function u(t,o,e){let r,s,n,a,l,c;for(s=i.utils.NO_DIRECTION,r=0;r<4;r++)if(n=o+h[r][0],a=e+h[r][1],l=o-h[r][0],c=e-h[r][1],t.hasXY(l,c)&&t.hasXY(n,a)&&t.isFloor(l,c)){if(s!=i.utils.NO_DIRECTION)return i.utils.NO_DIRECTION;s=r}return s}function d(t){let o,e,r,s,n,h,a;const l=[[],[],[],[]],c=t.height,d=t.width;for(o=0;o<d;o++)for(e=0;e<c;e++)if(t.isDiggable(o,e)&&(h=u(t,o,e),h!=i.utils.NO_DIRECTION)){for(s=o+i.utils.DIRS[h][0],n=e+i.utils.DIRS[h][1],a=!1,r=0;r<10&&t.hasXY(s,n)&&!a;r++)t.isSet(s,n)&&(a=!0),s+=i.utils.DIRS[h][0],n+=i.utils.DIRS[h][1];a||l[h].push([o,e])}let f=[];for(h=0;h<4;h++){const t=i.random.item(l[h])||[-1,-1];f[h]=[t[0],t[1]]}return f}function f(t,o,e,r,s){const n=i.random.sequence(o.length);for(let i=0;i<n.length;i++){const h=o[n[i]];if(!h)continue;if(g(t,h[0],h[1],e,r,s))return!0}return!1}function g(t,o,e,r,s,n){const h=s.hall?s.hall.doors:s.doors,a=i.random.sequence(4);for(let u of a){const a=(u+2)%4,d=h[a];if(d&&(-1!=d[0]&&c(t,r,o-d[0],e-d[1]))){const h=o-d[0],c=e-d[1];return i.grid.offsetZip(t,r,h,c,((i,o,e,r)=>{t[e][r]=n.room.tile||1})),l(t,s,n,o,e,a),s.translate(h,c),!0}}return!1}var m={__proto__:null,attachRoom:a,attachDoor:l,roomFitsAt:c,directionOfDoorSite:u,chooseRandomDoorSites:d,forceRoomAtMapLoc:function(t,o,r,s,h){const a=new n(t);for(let n=0;n<e.length;n++){const l=Math.floor(e[n]/t.height),d=e[n]%t.height;if(r[l][d])continue;if(u(a,l,d)!=i.utils.NO_DIRECTION){const e=o[0]-l,n=o[1]-d;if(c(t,r,e,n)){if(i.grid.offsetZip(t,r,e,n,((i,o,e,r)=>{t[e][r]=h.room.tile||1})),!1!==h.room.door){const i=!0!==h.room.door&&h.room.door?h.room.door:2;t[o[0]][o[1]]=i}return s.translate(e,n),!0}}}return!1},attachRoomAtMapDoor:f};class p{constructor(t,o,e,r=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const s=i.utils.DIRS[o];this.length=e,this.width=r,o===i.utils.UP||o===i.utils.DOWN?(this.x2=this.x+(r-1),this.y2=this.y+(e-1)*s[1]):(this.x2=this.x+(e-1)*s[0],this.y2=this.y+(r-1)),this.dir=o}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((o=>{o&&(o[0]<0||o[1]<0||(o[0]+=t,o[1]+=i))}))}}class w extends i.utils.Bounds{constructor(t,i,o,e){super(t,i,o,e),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((o=>{o&&(o[0]<0||o[1]<0||(o[0]+=t,o[1]+=i))})),this.hall&&this.hall.translate(t,i)}}const b=i.utils.DIRS;function M(t,i,o){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const e=[i[0]-o[0],i[1]-o[1]];return!!t.hasXY(e[0],e[1])&&!!t.isFloor(e[0],e[1])}function D(t,o){return t==i.utils.UP||t==i.utils.DOWN?o[1].value():o[0].value()}function y(t,o,e){let r=i.utils.NO_DIRECTION;if(r==i.utils.NO_DIRECTION){const s=i.random.sequence(4);for(let n=0;n<4;n++){r=s[n];const h=e[(n+1)%2].hi,a=o[r];if(a&&-1!=a[0]&&-1!=a[1]){const i=a[0]+Math.floor(b[r][0]*h),o=a[1]+Math.floor(b[r][1]*h);if(t.hasXY(i,o))break}r=i.utils.NO_DIRECTION}}return r}function R(t,o,e,r,s){let n,h;const a=i.random.chance(s),l=[];for(let i=0;i<4;i++)n=o+b[i][0],h=e+b[i][1],i!=r&&!a||!t.hasXY(n,h)||t.isSet(n,h)||(l[i]=[n,h]);return l}class x{constructor(t={}){this.config={width:i.range.make(1),length:[i.range.make("9-15"),i.range.make("2-9")],tile:1,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=i.range.make(t.width)),t.length&&"number"==typeof t.length){const o=i.range.make(t.length);this.config.length=[o,o]}t.tile&&(this.config.tile=t.tile)}create(t,o=[]){if(o=o||d(t),!i.random.chance(this.config.chance))return null;const e=y(t,o,this.config.length);if(e===i.utils.NO_DIRECTION)return null;if(!o[e])return null;const r=this.config.width.value(),s=D(e,this.config.length),n=o[e];return 1==r?this.dig(t,e,n,s):this.digWide(t,e,n,s,r)}_digLine(t,i,o,e){let r=i[0],s=i[1];const n=this.config.tile;for(let i=0;i<e;i++)t.setTile(r,s,n),r+=o[0],s+=o[1];return r-=o[0],s-=o[1],[r,s]}dig(t,i,o,e){const r=b[i],[s,n]=this._digLine(t,o,r,e),h=new p(o,i,e);return h.doors=R(t,s,n,i,this.config.obliqueChance),h}digWide(t,o,e,r,s){const n=i.utils.DIRS[o],h=[e[0]-n[1],e[1]-n[0]],a=[e[0]+n[1],e[1]+n[0]];this._digLine(t,e,n,r);let l=1,c=e[0],u=e[1];l<s&&M(t,h,n)&&(this._digLine(t,h,n,r),c=Math.min(h[0],c),u=Math.min(h[1],u),++l),l<s&&M(t,a,n)&&(this._digLine(t,a,n,r),c=Math.min(a[0],c),u=Math.min(a[1],u),++l);const d=new p([c,u],o,r,s);return d.doors=[],d.doors[o]=[e[0]+r*n[0],e[1]+r*n[1]],d.width=s,d}}var v={};function O(t,i){return v[t]=i,i}O("DEFAULT",new x({chance:15}));var _={__proto__:null,isDoorLoc:M,pickWidth:function(t={}){return i.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let o=t.width;if("number"==typeof o)return o;o=Array.isArray(o)?i.random.weighted(o)+1:"string"==typeof o?i.range.make(o).value():Number.parseInt(i.random.weighted(o));return o}(t),1,3)},pickLength:D,pickHallDirection:y,pickHallExits:R,HallDigger:x,dig:function(t,i,o){return new x(t).create(i,o)},halls:v,install:O};class S{constructor(t={}){this.options={roundCount:5,minBlobWidth:10,minBlobHeight:10,maxBlobWidth:40,maxBlobHeight:20,percentSeeded:50,birthParameters:"ffffffttt",survivalParameters:"ffffttttt"},Object.assign(this.options,t),this.options.birthParameters=this.options.birthParameters.toLowerCase(),this.options.survivalParameters=this.options.survivalParameters.toLowerCase(),this.options.minBlobWidth>=this.options.maxBlobWidth&&(this.options.minBlobWidth=Math.round(.75*this.options.maxBlobWidth),this.options.maxBlobWidth=Math.round(1.25*this.options.maxBlobWidth)),this.options.minBlobHeight>=this.options.maxBlobHeight&&(this.options.minBlobHeight=Math.round(.75*this.options.maxBlobHeight),this.options.maxBlobHeight=Math.round(1.25*this.options.maxBlobHeight))}carve(t,o,e){let r,s,n,h,a,l,c,u=new i.utils.Bounds(0,0,0,0);const d=i.grid.alloc(t,o),f=Math.floor((d.width-this.options.maxBlobWidth)/2),g=Math.floor((d.height-this.options.maxBlobHeight)/2);let m=10;do{for(d.fill(0),r=0;r<this.options.maxBlobWidth;r++)for(s=0;s<this.options.maxBlobHeight;s++)d[r+f][s+g]=i.random.chance(this.options.percentSeeded)?1:0;for(n=0;n<this.options.roundCount;n++)this._cellularAutomataRound(d)||(n=this.options.roundCount);for(c=0,l=0,h=2,r=0;r<d.width;r++)for(s=0;s<d.height;s++)1==d[r][s]&&(a=d.floodFill(r,s,1,h),a>c&&(c=a,l=h),h++);d.valueBounds(l,u)}while((u.width<this.options.minBlobWidth||u.height<this.options.minBlobHeight||0==l)&&--m);for(r=0;r<d.width;r++)for(s=0;s<d.height;s++)d[r][s]==l&&e(r,s);return i.grid.free(d),u}_cellularAutomataRound(t){let o,e,r,s,n,h,a;a=i.grid.alloc(t.width,t.height),a.copy(t);let l=!1;for(o=0;o<t.width;o++)for(e=0;e<t.height;e++){for(r=0,h=0;h<i.utils.DIRS.length;h++)s=o+i.utils.DIRS[h][0],n=e+i.utils.DIRS[h][1],t.hasXY(s,n)&&a[s][n]&&r++;a[o][e]||"t"!=this.options.birthParameters[r]?a[o][e]&&"t"==this.options.survivalParameters[r]||(t[o][e]=0,l=!0):(t[o][e]=1,l=!0)}return i.grid.free(a),l}}var T={__proto__:null,Blob:S,fillBlob:function(t,i={}){return new S(i).carve(t.width,t.height,((i,o)=>t[i][o]=1))}};function B(t,o={}){return t=t||{},o=o||{},Object.entries(o).forEach((([o,e])=>{let r=t[o];if("tile"===o)return void(void 0===r&&(t[o]=e));if(!0===e){if(!r)throw new Error("Missing required config for room digger: "+o)}else r=("number"==typeof e||Array.isArray(e),r||e);const s=i.range.make(r);t[o]=s})),t}class A{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=B(t,i)}create(t){const i=this.carve(t);return i&&(i.doors=d(t)),i}}var I={};class C extends A{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,o={}){const e=t.choices||o.choices;if(Array.isArray(e))this.randomRoom=i.random.item.bind(i.random,e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=i.random.weighted.bind(i.random,e)}}carve(t){let o=this.randomRoom();const e=I[o];return e||i.utils.ERROR("Missing room digger choice: "+o),e.create(t)}}class E extends A{constructor(t={}){super(t,{width:12,height:8})}carve(t){const o=this.options.width.value(),e=this.options.height.value(),r=this.options.tile||1,s=i.grid.alloc(t.width,t.height,0),n=Math.floor(.5*o),h=o,a=Math.floor(.5*e),l=new S({roundCount:5,minBlobWidth:n,minBlobHeight:a,maxBlobWidth:h,maxBlobHeight:e,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(s.width,s.height,((t,i)=>s[t][i]=1)),c=Math.floor((t.width-l.width)/2),u=c-l.x,d=Math.floor((t.height-l.height)/2),f=d-l.y;return s.forEach(((i,o,e)=>{i&&t.setTile(o+u,e+f,r)})),i.grid.free(s),new w(c,d,l.width,l.height)}}class N extends A{constructor(t={}){super(t,{width:20,height:10})}carve(t){const o=this.options.width.value(),e=this.options.height.value(),r=this.options.tile||1,s=Math.floor(.4*o),n=e,h=o,a=Math.floor(.5*e),l=Math.floor(t.width/2-s/2-1),c=t.height-n-2,u=Math.floor(t.width/2-h/2-1),d=t.height-a-2;return i.utils.forRect(l,c,s,n,((i,o)=>t.setTile(i,o,r))),i.utils.forRect(u,d,h,a,((i,o)=>t.setTile(i,o,r))),new w(Math.min(l,u),Math.min(c,d),Math.max(s,h),Math.max(n,a))}}class L extends A{constructor(t={}){super(t,{width:12,height:20})}carve(t){const o=this.options.width.value(),e=this.options.height.value(),r=this.options.tile||1,s=o,n=Math.max(3,Math.floor(o*i.random.range(25,75)/100)),h=Math.max(3,Math.floor(e*i.random.range(25,75)/100)),a=e,l=Math.floor((t.width-s)/2),c=l+i.random.range(2,Math.max(2,s-n-2)),u=Math.floor((t.height-a)/2),d=u+i.random.range(2,Math.max(2,a-h-2));return i.utils.forRect(l,d,s,h,((i,o)=>t.setTile(i,o,r))),i.utils.forRect(c,u,n,a,((i,o)=>t.setTile(i,o,r))),new w(l,u,Math.max(s,n),Math.max(h,a))}}class W extends A{constructor(t={}){super(t,{width:7,height:7})}carve(t){const o=this.options.width.value(),e=this.options.height.value(),r=this.options.tile||1;let s=Math.max(3,Math.floor(o*i.random.range(25,50)/100)),n=Math.max(3,Math.floor(e*i.random.range(25,50)/100));const h=Math.floor((t.width-o)/2),a=Math.floor((t.height-n)/2);i.utils.forRect(h,a,o,n,((i,o)=>t.setTile(i,o,r)));const l=Math.floor((t.width-s)/2),c=Math.floor((t.height-e)/2);return i.utils.forRect(l,c,s,e,((i,o)=>t.setTile(i,o,r))),new w(Math.min(h,l),Math.min(a,c),Math.max(o,s),Math.max(e,n))}}class X extends A{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const o=this.options.width.value(),e=this.options.height.value(),r=this.options.tile||1,s=Math.floor((t.width-o)/2),n=Math.floor((t.height-e)/2);return i.utils.forRect(s,n,o,e,((i,o)=>t.setTile(i,o,r))),new w(s,n,o,e)}}class Y extends A{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const o=this.options.radius.value(),e=this.options.tile||1,r=Math.floor(t.width/2),s=Math.floor(t.height/2);return o>1&&i.utils.forCircle(r,s,o,((i,o)=>t.setTile(i,o,e))),new w(r-o,s-o,2*o+1,2*o+1)}}class P extends A{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const o=this.options.radius.value(),e=this.options.ringMinWidth.value(),r=this.options.holeMinSize.value(),s=this.options.tile||1,n=Math.floor(t.width/2),h=Math.floor(t.height/2);return i.utils.forCircle(n,h,o,((i,o)=>t.setTile(i,o,s))),o>e+r&&i.random.chance(this.options.holeChance.value())&&i.utils.forCircle(n,h,i.random.range(r,o-r),((i,o)=>t.setTile(i,o,0))),new w(n-o,h-o,2*o+1,2*o+1)}}class H extends A{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let o,e,r,s=this.options.count.value();const n=this.options.width.value(),h=this.options.height.value(),a=this.options.tile||1,l=Math.floor(t.width/2)-Math.floor(n/2),c=Math.floor(t.width/2)+Math.floor(n/2),u=Math.floor(t.height/2)-Math.floor(h/2),d=Math.floor(t.height/2)+Math.floor(h/2);let f=Math.floor(t.width/2),g=f,m=Math.floor(t.height/2),p=m;for(i.utils.forCircle(f,m,2,((i,o)=>t.setTile(i,o,a))),f-=2,g+=2,m-=2,p+=2,o=0;o<s;)if(e=i.random.range(l,c),r=i.random.range(u,d),t.isSet(e,r)){if(e-2<l)continue;if(e+2>c)continue;if(r-2<u)continue;if(r+2>d)continue;f=Math.min(e-2,f),g=Math.max(e+2,g),m=Math.min(r-2,m),p=Math.max(r+2,p),i.utils.forCircle(e,r,2,((i,o)=>t.setTile(i,o,a))),o++}return new w(f,m,g-f+1,p-m+1)}}function k(t,i){return I[t]=i,i}k("DEFAULT",new X);var F={__proto__:null,checkConfig:B,RoomDigger:A,rooms:I,ChoiceRoom:C,choiceRoom:function(t,i){return i.fill(0),new C(t).create(new n(i))},Cavern:E,cavern:function(t,i){return i.fill(0),new E(t).create(new n(i))},Entrance:N,entrance:function(t,i){return i.fill(0),new N(t).create(new n(i))},Cross:L,cross:function(t,i){return i.fill(0),new L(t).create(new n(i))},SymmetricalCross:W,symmetricalCross:function(t,i){return i.fill(0),new W(t).create(new n(i))},Rectangular:X,rectangular:function(t,i){return i.fill(0),new X(t).create(new n(i))},Circular:Y,circular:function(t,i){return i.fill(0),new Y(t).create(new n(i))},BrogueDonut:P,brogueDonut:function(t,i){return i.fill(0),new P(t).create(new n(i))},ChunkyRoom:H,chunkyRoom:function(t,i){return i.fill(0),new H(t).create(new n(i))},install:k};class U{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreath:0,wreathTile:5,tile:4},Object.assign(this.options,t)}create(t){let o,e,r,s,n,h,a,l,c,u,d,f=0;h=this.options.height||15,a=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,u=this.options.count||1,d=this.options.canDisrupt||!1;const g=this.options.wreath||0,m=this.options.wreathTile||5,p=this.options.tile||4,w=i.grid.alloc(t.width,t.height,0);let b=0;for(;b<u&&f<u;){const M=Math.round((a-l)*(u-b)/u)+l,D=Math.round((h-l)*(u-b)/u)+l,y=new S({roundCount:5,minBlobWidth:4,minBlobHeight:4,maxBlobWidth:M,maxBlobHeight:D,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(w.width,w.height,((t,i)=>w[t][i]=1));let R=!1;for(r=0;r<c&&!R;r++)if(s=i.random.range(1-y.x,w.width-y.width-y.x-2),n=i.random.range(1-y.y,w.height-y.height-y.y-2),d||!this.isDisruptedBy(t,w,-s,-n)){for(R=!0,o=0;o<y.width;o++)for(e=0;e<y.height;e++)if(w[o+y.x][e+y.y]){const r=o+y.x+s,h=e+y.y+n;t.setTile(r,h,p),g&&i.utils.forCircle(r,h,g,((i,o)=>{t.isPassable(i,o)&&t.setTile(i,o,m)}))}break}R?++f:++b}return i.grid.free(w),f}isDisruptedBy(t,o,e=0,r=0){const s=i.grid.alloc(t.width,t.height);let n=!1;i.utils.forRect(t.width,t.height,((i,h)=>{const a=i+e,l=h+r;o.get(a,l)?t.isStairs(i,h)&&(n=!0):t.isPassable(i,h)&&(s[i][h]=1)}));let h=!0;for(let t=0;t<s.width&&!n;++t)for(let i=0;i<s.height&&!n;++i)1==s[t][i]&&(h?(s.floodFill(t,i,1,2),h=!1):n=!0);return i.grid.free(s),n}}var q={__proto__:null,Lakes:U};class G{constructor(t={}){this.options={minimumPathingDistance:20,maxConnectionLength:5},Object.assign(this.options,t)}create(t){let o,e,r,s,n,h,a,l=0;const c=this.options.maxConnectionLength,u=this.options.minimumPathingDistance,d=i.grid.alloc(t.width,t.height),f=i.grid.alloc(t.width,t.height),g=[[1,0],[0,1]];f.update(((o,e,r)=>t.isPassable(e,r)?1:i.path.OBSTRUCTION));const m=i.random.sequence(t.width*t.height);for(r=0;r<m.length;r++)if(h=Math.floor(m[r]/t.height),a=m[r]%t.height,t.isPassable(h,a)&&!t.isAnyWater(h,a))for(n=0;n<=1;n++){const r=g[n];if(o=h+r[0],e=a+r[1],s=c,t.isAnyWater(o,e))for(s=0;s<c&&(o+=r[0],e+=r[1],t.isAnyWater(o,e));++s);if(t.isPassable(o,e)&&s<c&&(i.path.calculateDistances(d,o,e,f,!1),d[h][a]>u&&d[h][a]<i.path.NO_PATH)){for(;h!==o||a!==e;)this.isBridgeCandidate(t,h,a,r)?(t.setTile(h,a,6),f[h][a]=1):(t.setTile(h,a,1),f[h][a]=1),h+=r[0],a+=r[1];++l;break}}return i.grid.free(d),i.grid.free(f),l}isBridgeCandidate(t,i,o,e){return!!t.isBridge(i,o)||!!t.isAnyWater(i,o)&&(!!t.isAnyWater(i+e[1],o+e[0])&&!!t.isAnyWater(i-e[1],o-e[0]))}}var j={__proto__:null,Bridges:G};class z{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:7,downTile:17,wall:8},Object.assign(this.options,t)}create(t){let o=!1!==this.options.up,e=!1!==this.options.down;const r=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),s={};let n,h;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let o=this.options.start;o=!0===o?i.random.matchingXY(t.width,t.height,a):i.random.matchingXYNear(i.utils.x(o),i.utils.y(o),a),s.start=o}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;n=i.random.matchingXYNear(i.utils.x(t),i.utils.y(t),a);const o=this.options.down;h=i.random.matchingXYNear(i.utils.x(o),i.utils.y(o),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const o=this.options.up;n=i.random.matchingXYNear(i.utils.x(o),i.utils.y(o),a),e&&(h=i.random.matchingXY(t.width,t.height,((t,o)=>!(i.utils.distanceBetween(t,o,n[0],n[1])<r)&&a(t,o))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;h=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),o&&(n=i.random.matchingXY(t.width,t.height,((t,o)=>!(i.utils.distanceBetween(t,o,h[0],h[1])<r)&&a(t,o))))}else o?(n=i.random.matchingXY(t.width,t.height,a),e&&(h=i.random.matchingXY(t.width,t.height,((t,o)=>!(i.utils.distanceBetween(t,o,n[0],n[1])<r)&&a(t,o))))):e&&(h=i.random.matchingXY(t.width,t.height,a));return n&&(s.up=n.slice(),this.setupStairs(t,n[0],n[1],this.options.upTile),"up"===this.options.start&&(s.start=s.up)),void 0!==h&&(s.down=h.slice(),this.setupStairs(t,h[0],h[1],this.options.downTile),"down"===this.options.start&&(s.start=s.down)),n||h?s:null}hasXY(t,i,o){return!(i<0||o<0)&&!(i>=t.width||o>=t.height)}isStairXY(t,o,e){let r=0;if(!this.hasXY(t,o,e)||!t.isDiggable(o,e))return!1;for(let s=0;s<4;++s){const n=i.utils.DIRS[s];if(!this.hasXY(t,o+n[0],e+n[1]))return!1;if(!this.hasXY(t,o-n[0],e-n[1]))return!1;if(t.isFloor(o+n[0],e+n[1])){if(r+=1,!t.isDiggable(o-n[0]+n[1],e-n[1]+n[0]))return!1;if(!t.isDiggable(o-n[0]-n[1],e-n[1]-n[0]))return!1}else if(!t.isDiggable(o+n[0],e+n[1]))return!1}return 1==r}setupStairs(t,o,e,r){const s=i.random.sequence(4);let n=null;for(let r=0;r<s.length;++r){n=i.utils.DIRS[r];const s=o+n[0],h=e+n[1];if(t.isFloor(s,h)&&t.isDiggable(o-n[0],e-n[1]))break;n=null}n||i.utils.ERROR("No stair direction found!"),t.setTile(o,e,r);const h=i.utils.CLOCK_DIRS.findIndex((t=>t[0]==n[0]&&t[1]==n[1])),a=this.options.wall;for(let r=0;r<i.utils.CLOCK_DIRS.length;++r){const s=r?r-1:7,n=(r+1)%8;if(r==h||s==h||n==h)continue;const l=i.utils.CLOCK_DIRS[r];t.setTile(o+l[0],e+l[1],a)}return!0}}function K(t){let o,e,r,s,h,a;const l=new n(t);do{for(a=!1,o=0;o<t.width-1;o++)for(e=0;e<t.height-1;e++)for(r=0;r<=1;r++)l.isPassable(o+r,e)&&!l.isPassable(o+(1-r),e)&&l.isObstruction(o+(1-r),e)&&!l.isPassable(o+r,e+1)&&l.isObstruction(o+r,e+1)&&l.isPassable(o+(1-r),e+1)&&(i.random.chance(50)?(s=o+(1-r),h=e):(s=o+r,h=e+1),a=!0,t[s][h]=1)}while(1==a)}function Z(t){t.forEach(((i,o,e)=>{t.isBoundaryXY(o,e)||2==i&&(1!=t.get(o+1,e)&&1!=t.get(o-1,e)||1!=t.get(o,e+1)&&1!=t.get(o,e-1)?(1!==t.get(o+1,e)?1:0)+(1!==t.get(o-1,e)?1:0)+(1!==t.get(o,e+1)?1:0)+(1!==t.get(o,e-1)?1:0)>=3&&(t[o][e]=1):t[o][e]=1)}))}function Q(t,i=3){t.forEach(((o,e,r)=>{0==o&&(t[e][r]=i)}))}var J={__proto__:null,room:F,hall:_,lake:q,bridge:j,stairs:{__proto__:null,Stairs:z},utils:m,start:function(t){r(t.width*t.height),t.fill(0)},finish:function(t){K(t),Q(t),Z(t)},addRoom:function(t,o){let e;if("string"==typeof(o=o||{room:"DEFAULT",hall:"DEFAULT",tries:10})&&(o={room:o}),o.loc&&(o.locs=[o.loc]),"function"==typeof o.room&&(o.room=o.room()),o.room)if("string"==typeof o.room){const t=o.room;if(e=I[t],!e)throw new Error("Failed to find room: "+t)}else{if(!(o.room instanceof A))throw new Error("No room to build!");e=o.room}else e=I.DEFAULT;let r=null;if(!0===o.hall&&(o.hall="DEFAULT"),!1===o.hall||o.hall||(o.hall="DEFAULT"),"function"==typeof o.hall&&(o.hall={fn:o.hall}),"string"==typeof o.hall){const t=o.hall;if(o.hall=v[t],!o.hall)return i.utils.ERROR("Failed to find hall: "+t),null;r=o.hall}else o.hall&&o.hall.fn&&(r=o.hall);!1===o.door?o.door=0:!0===o.door?o.door=2:"number"==typeof o.door?o.door=i.random.chance(o.door)?2:1:o.door=1;let s=o.locs||null;if(s&&s.doors&&(s=s.doors),s&&Array.isArray(s))s&&s.length&&2==s.length&&"number"==typeof s[0]?s=[s]:0==s.length&&(s=null);else if(s=null,0===t.count(1)){s=[[Math.floor(t.width/2),t.height-2]]}const h=i.grid.alloc(t.width,t.height),l=new n(h);let c=!1;if(r){let t=void 0!==r.chance?r.chance:15;c=i.random.chance(t)}let u=null,d=!1,g=o.tries||10;for(;--g>=0&&!d;){if(h.fill(0),u=e.create(l),c){const t=new x;u.hall=t.create(l,u.doors)}d=s?f(t,s,h,u,o):a(t,h,u,o)}return i.grid.free(h),u&&d?u:null},addLoops:function(t,o,r){let h,a,l,c,u,d,f,g,m;o=o||Math.floor(Math.min(t.width,t.height)/2),r=r||1;const p=new n(t),w=t,b=i.grid.alloc(t.width,t.height),M=i.grid.alloc(t.width,t.height),D=[[1,0],[0,1]];function y(i,o,e){return!!t.hasXY(i,o)&&(!!t.hasXY(i+e[1],o+e[0])&&(!!t.hasXY(i-e[1],o-e[0])&&(!t.get(i,o)&&(!t.get(i+e[1],o+e[0])&&!t.get(i-e[1],o-e[0])))))}function R(i,o,e){return!!t.hasXY(i,o)&&(!!t.hasXY(i+e[1],o+e[0])&&(!!t.hasXY(i-e[1],o-e[0])&&(!!t.get(i,o)||(!!t.get(i+e[1],o+e[0])||!!t.get(i-e[1],o-e[0])))))}for(s(p,M),u=0;u<e.length;u++){g=Math.floor(e[u]/w.height),m=e[u]%w.height;if(!w[g][m])for(f=0;f<=1;f++){let e=D[f];if(y(g,m,e)){if(d=r,p.hasXY(g+e[0],m+e[1])&&p.isPassable(g+e[0],m+e[1])){if(!p.hasXY(g-e[0],m-e[1])||p.isDoor(g-e[0],m-e[1]))continue}else{if(!p.hasXY(g-e[0],m-e[1])||!p.isPassable(g-e[0],m-e[1]))continue;if(!p.hasXY(g+e[0],m+e[1])||p.isDoor(g+e[0],m+e[1]))continue;e=e.map((t=>-1*t))}for(h=g+e[0],a=m+e[1],l=g,c=m,d=0;d<r&&(l-=e[0],c-=e[1],!R(l,c,e));++d);if(d<r&&(i.path.calculateDistances(b,h,a,M,!1),b[l][c]>o&&b[l][c]<3e4)){for(;l!==h||c!==a;)0==t.get(l,c)&&(t[l][c]=1,M[l][c]=1),l+=e[0],c+=e[1];t[g][m]=2;break}}}}i.grid.free(b),i.grid.free(M)},addLakes:function(t,i={}){const o=new U(i),e=new n(t);return o.create(e)},addBridges:function(t,i={}){const o=new G(i),e=new n(t);return o.create(e)},addStairs:function(t,i={}){const o=new z(i),e=new n(t);return o.create(e)},removeDiagonalOpenings:K,finishDoors:Z,finishWalls:Q,NOTHING:0,FLOOR:1,DOOR:2,WALL:3,DEEP:4,SHALLOW:5,BRIDGE:6,UP_STAIRS:7,DOWN_STAIRS:17,IMPREGNABLE:8,TILEMAP:o,SEQ:e,initSeqence:r,fillCostGrid:s,GridSite:n,Hall:p,Room:w};t.blob=T,t.dig=J,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

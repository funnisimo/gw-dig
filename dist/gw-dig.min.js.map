{"version":3,"file":"gw-dig.min.js","sources":["../js/site/digSite.js","../js/site/buildSite.js","../js/site/utils.js","../js/types.js","../js/room.js","../js/hall.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/loop.js","../js/level.js","../js/build/buildStep.js","../js/blueprint.js","../js/build/builder.js","../js/dungeon.js"],"sourcesContent":["var _a, _b;\nimport * as GW from 'gw-utils';\nexport const NOTHING = GW.tile.get('NULL').index;\nexport const FLOOR = GW.tile.get('FLOOR').index;\nexport const DOOR = GW.tile.get('DOOR').index;\nexport const SECRET_DOOR = (_b = (_a = GW.tile.get('DOOR_SECRET')) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;\nexport const WALL = GW.tile.get('WALL').index;\nexport const DEEP = GW.tile.get('LAKE').index;\nexport const SHALLOW = GW.tile.get('SHALLOW').index;\nexport const BRIDGE = GW.tile.get('BRIDGE').index;\nexport const UP_STAIRS = GW.tile.get('UP_STAIRS').index;\nexport const DOWN_STAIRS = GW.tile.get('DOWN_STAIRS').index;\nexport const IMPREGNABLE = GW.tile.get('IMPREGNABLE').index;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport class GridSite {\n    constructor(width, height) {\n        this.tiles = GW.grid.alloc(width, height);\n    }\n    free() {\n        GW.grid.free(this.tiles);\n    }\n    get width() {\n        return this.tiles.width;\n    }\n    get height() {\n        return this.tiles.height;\n    }\n    hasXY(x, y) {\n        return this.tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.tiles.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === DOOR;\n    }\n    isSecretDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === SECRET_DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    blocksMove(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y) || this.isDeep(x, y);\n    }\n    blocksDiagonal(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksPathing(x, y) {\n        return (this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y));\n    }\n    blocksVision(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksItems(x, y) {\n        return this.blocksPathing(x, y) || this.blocksPathing(x, y);\n    }\n    blocksEffects(x, y) {\n        return this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.tiles.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.tiles.get(x, y) === SHALLOW;\n    }\n    isAnyLiquid(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.tiles.get(x, y) || 0) > 0;\n    }\n    getTileIndex(x, y) {\n        return this.tiles.get(x, y) || 0;\n    }\n    setTile(x, y, tile) {\n        if (tile instanceof GW.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GW.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        if (!this.tiles.hasXY(x, y))\n            return false;\n        this.tiles[x][y] = tile;\n        return true;\n    }\n    hasTile(x, y, tile) {\n        if (tile instanceof GW.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GW.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        return this.tiles.hasXY(x, y) && this.tiles[x][y] == tile;\n    }\n    tileBlocksMove(tile) {\n        return (tile === WALL ||\n            tile === DEEP ||\n            tile === IMPREGNABLE ||\n            tile === NOTHING);\n    }\n}\n","import * as GW from 'gw-utils';\nconst Flags = GW.map.flags.Cell;\nexport class MapSite extends GW.map.Map {\n    constructor(width, height) {\n        super(width, height);\n        this.machineCount = 0;\n        this.machineId = new GW.grid.NumGrid(width, height);\n    }\n    hasItem(x, y) {\n        return this.cellInfo(x, y).hasItem();\n    }\n    isPassable(x, y) {\n        return !this.cellInfo(x, y).blocksMove();\n    }\n    blocksMove(x, y) {\n        return this.cellInfo(x, y).blocksMove();\n    }\n    isWall(x, y) {\n        return this.cellInfo(x, y).isWall();\n    }\n    isStairs(x, y) {\n        return this.cellInfo(x, y).isStairs();\n    }\n    hasTile(x, y, tile) {\n        return this.cellInfo(x, y).hasTile(tile);\n    }\n    free() { }\n    isSet(x, y) {\n        return this.hasXY(x, y) && !this.cell(x, y).isEmpty();\n    }\n    isDiggable(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.isEmpty())\n            return true;\n        if (cell.isWall())\n            return true;\n        return false;\n    }\n    isNothing(x, y) {\n        return this.hasXY(x, y) && this.cell(x, y).isEmpty();\n    }\n    isFloor(x, y) {\n        return this.isPassable(x, y);\n    }\n    isBridge(x, y) {\n        return this.cellInfo(x, y).hasTileFlag(GW.tile.flags.Tile.T_BRIDGE);\n    }\n    isDoor(x, y) {\n        return this.cellInfo(x, y).hasTileFlag(GW.tile.flags.Tile.T_IS_DOOR);\n    }\n    isSecretDoor(x, y) {\n        return this.cellInfo(x, y).hasObjectFlag(GW.gameObject.flags.GameObject.L_SECRETLY_PASSABLE);\n    }\n    blocksDiagonal(x, y) {\n        return this.cellInfo(x, y).hasObjectFlag(GW.gameObject.flags.GameObject.L_BLOCKS_DIAGONAL);\n    }\n    blocksPathing(x, y) {\n        const info = this.cellInfo(x, y);\n        return (info.hasObjectFlag(GW.gameObject.flags.GameObject.L_BLOCKS_MOVE) ||\n            info.hasTileFlag(GW.tile.flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksItems(x, y) {\n        return this.cellInfo(x, y).hasObjectFlag(GW.gameObject.flags.GameObject.L_BLOCKS_ITEMS);\n    }\n    blocksEffects(x, y) {\n        return this.cellInfo(x, y).hasObjectFlag(GW.gameObject.flags.GameObject.L_BLOCKS_EFFECTS);\n    }\n    isDeep(x, y) {\n        return this.cellInfo(x, y).hasTileFlag(GW.tile.flags.Tile.T_DEEP_WATER);\n    }\n    isShallow(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        return (!!cell.depthTile(GW.gameObject.flags.Depth.LIQUID) &&\n            !cell.hasTileFlag(GW.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    isAnyLiquid(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        return (cell.hasDepthTile(GW.gameObject.flags.Depth.LIQUID) ||\n            cell.hasTileFlag(GW.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    getTileIndex(x, y) {\n        if (!this.hasXY(x, y))\n            return 0;\n        const cell = this.cell(x, y);\n        const tile = cell.highestPriorityTile();\n        return tile.index;\n    }\n    tileBlocksMove(tile) {\n        return GW.tile.get(tile).blocksMove();\n    }\n    backup() {\n        const backup = new MapSite(this.width, this.height);\n        backup.copy(this);\n        backup.machineId.copy(this.machineId);\n        backup.machineCount = this.machineCount;\n        return backup;\n    }\n    restore(backup) {\n        this.copy(backup);\n        this.machineId.copy(backup.machineId);\n        this.machineCount = backup.machineCount;\n    }\n    getChokeCount(x, y) {\n        return this.cell(x, y).chokeCount;\n    }\n    setChokeCount(x, y, count) {\n        this.cell(x, y).chokeCount = count;\n    }\n    isOccupied(x, y) {\n        return this.hasItem(x, y) || this.hasActor(x, y);\n    }\n    analyze() {\n        GW.map.analyze(this);\n    }\n    nextMachineId() {\n        return ++this.machineCount;\n    }\n    getMachine(x, y) {\n        return this.machineId[x][y];\n    }\n    setMachine(x, y, id, isRoom = true) {\n        this.machineId[x][y] = id;\n        if (id == 0) {\n            this.clearCellFlag(x, y, Flags.IS_IN_MACHINE);\n        }\n        else {\n            this.setCellFlag(x, y, isRoom ? Flags.IS_IN_ROOM_MACHINE : Flags.IS_IN_AREA_MACHINE);\n        }\n    }\n}\n","import * as GW from 'gw-utils';\n// import * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\n// export function attachRoom(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GW.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GW.utils.DIRS[dir][0];\n                    newY = j + GW.utils.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GW.utils.DIRS[dir][0];\n                        newY += GW.utils.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GW.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GW.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GW.grid.NumGrid,\n//     xy: GW.utils.Loc,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GW.grid.NumGrid,\n//     mapDoors: GW.utils.Loc[],\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorIndexes = GW.random.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GW.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = GW.random.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n//             //     return [x0, y0] as GW.utils.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function copySite(dest, source, offsetX = 0, offsetY = 0) {\n    GW.utils.forRect(dest.width, dest.height, (x, y) => {\n        const otherX = x - offsetX;\n        const otherY = y - offsetY;\n        const v = source.getTileIndex(otherX, otherY);\n        if (!v)\n            return;\n        dest.setTile(x, y, v);\n    });\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n}\nexport function siteDisruptedBy(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GW.grid.alloc(site.width, site.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GW.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GW.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function siteDisruptedSize(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GW.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n    // Get all walkable locations after lake added\n    GW.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (disrupts)\n        return disrupts;\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                }\n                else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GW.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function computeDistanceMap(site, distanceMap, originX, originY, maxDistance) {\n    const costGrid = GW.grid.alloc(site.width, site.height);\n    fillCostGrid(site, costGrid);\n    GW.path.calculateDistances(distanceMap, originX, originY, costGrid, false, maxDistance + 1 // max distance is the same as max size of this blueprint\n    );\n    GW.grid.free(costGrid);\n}\n","import * as GW from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        // console.log('Hall', loc, d, length, width);\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        // console.log(' - ', [this.x2, this.y2]);\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room extends GW.utils.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GW.utils.Loc[] | null;\n//     door: number;\n// }\n","import * as GW from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = SITE.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GW.random.item.bind(GW.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GW.random.weighted.bind(GW.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GW.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GW.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GW.blob.Blob({\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GW.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GW.utils.DOWN] = [\n            Math.floor(site.width / 2),\n            site.height - 2,\n        ];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GW.utils.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GW.random.chance(this.options.holeChance.value())) {\n            GW.utils.forCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GW.utils.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GW.random.range(minX, maxX);\n            y = GW.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GW.utils.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GW.range.make(1),\n            length: [GW.range.make('2-15'), GW.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GW.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GW.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || SITE.chooseRandomDoorSites(site);\n        if (!GW.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GW.utils.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = new TYPES.Hall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GW.utils.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = new TYPES.Hall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: SITE.SHALLOW,\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = GW.random.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GW.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GW.blob.Blob({\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    GW.utils.forCircle(sx, sy, wreathSize, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GW.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GW.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GW.utils.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GW.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n        const seq = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyLiquid(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyLiquid(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyLiquid(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GW.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyLiquid(x, y))\n            return false;\n        if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc;\n        let downLoc;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GW.random.matchingLocNear(GW.utils.x(start), GW.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingLocNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GW.random.matchingLocNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingLocNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GW.random.matchingLocNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (GW.utils.distanceBetween(x, y, \n                    // @ts-ignore\n                    downLoc[0], \n                    // @ts-ignore\n                    downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc !== undefined) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GW.utils.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GW.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GW.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GW.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GW.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GW.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GW.utils.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        SITE.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        const seq = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, SITE.FLOOR);\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            site.setTile(x, y, SITE.DOOR); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nexport class Level {\n    constructor(width, height, options = {}) {\n        this.rooms = {};\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        this.startLoc = [-1, -1];\n        this.endLoc = [-1, -1];\n        this.height = height;\n        this.width = width;\n        if (options.seed) {\n            GW.random.seed(options.seed);\n        }\n        this.seq = GW.random.sequence(width * height);\n        GW.utils.setOptions(this.rooms, options.rooms);\n        GW.utils.setOptions(this.halls, options.halls);\n        GW.utils.setOptions(this.loops, options.loops);\n        GW.utils.setOptions(this.lakes, options.lakes);\n        GW.utils.setOptions(this.bridges, options.bridges);\n        GW.utils.setOptions(this.stairs, options.stairs);\n        GW.utils.setOptions(this.doors, options.doors);\n        this.startLoc = options.startLoc || [Math.floor(width / 2), height - 2];\n        this.endLoc = options.endLoc || [-1, -1];\n    }\n    makeSite(width, height) {\n        return new SITE.GridSite(width, height);\n    }\n    create(setFn) {\n        const site = this.makeSite(this.width, this.height);\n        this.start(site);\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        let fails = 0;\n        while (fails < 20) {\n            if (this.addRoom(site)) {\n                fails = 0;\n            }\n            else {\n                ++fails;\n            }\n        }\n        this.addLoops(site, this.loops);\n        this.addLakes(site, this.lakes);\n        this.addBridges(site, this.bridges);\n        this.addStairs(site, this.stairs);\n        this.finish(site);\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            const t = site.getTileIndex(x, y);\n            if (t)\n                setFn(x, y, t);\n        });\n        site.free();\n        return true;\n    }\n    start(_site) { }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addFirstRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.startLoc)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        if (room && !this._attachRoom(site, roomSite, room)) {\n            room = null;\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (let i = 0; i < this.seq.length; i++) {\n            const x = Math.floor(this.seq[i] / this.height);\n            const y = this.seq[i] % this.height;\n            if (!site.isNothing(x, y))\n                continue;\n            const dir = SITE.directionOfDoorSite(site, x, y);\n            if (dir != GW.utils.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    SITE.copySite(site, roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = GW.random.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                SITE.copySite(site, roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n                //     return [x0, y0] as GW.utils.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n            for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.hasXY(i, j) ||\n                                map.isBoundaryXY(i, j) ||\n                                !map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(map, room, x, y, dir) {\n        const opts = this.doors;\n        if (opts.chance === 0)\n            return; // no door at all\n        const isDoor = opts.chance && GW.random.chance(opts.chance); // did not pass chance\n        const tile = isDoor ? opts.tile || SITE.DOOR : SITE.FLOOR;\n        map.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n            return;\n        }\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x - k, y)) {\n                    if (map.isSet(x - k, y - 1) && map.isSet(x - k, y + 1)) {\n                        map.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x + k, y)) {\n                    if (map.isSet(x + k, y - 1) && map.isSet(x + k, y + 1)) {\n                        map.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x, y - k)) {\n                    if (map.isSet(x - 1, y - k) && map.isSet(x + 1, y - k)) {\n                        map.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x, y + k)) {\n                    if (map.isSet(x - 1, y + k) && map.isSet(x + 1, y + k)) {\n                        map.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        return digger.create(site);\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < this.width - 1; i++) {\n                for (j = 0; j < this.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (!site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)) {\n                            if (GW.random.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, SITE.FLOOR); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                if (\n                // TODO - isPassable\n                (site.isFloor(x + 1, y) || site.isFloor(x - 1, y)) &&\n                    (site.isFloor(x, y + 1) || site.isFloor(x, y - 1))) {\n                    // If there's passable terrain to the left or right, and there's passable terrain\n                    // above or below, then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                }\n                else if ((site.blocksPathing(x + 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x - 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x, y + 1) ? 1 : 0) +\n                    (site.blocksPathing(x, y - 1) ? 1 : 0) >=\n                    3) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? SITE.IMPREGNABLE : SITE.WALL;\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, SITE.WALL);\n                }\n            }\n        });\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nimport { Flags } from '../blueprint';\nconst Fl = GW.flag.fl;\nexport var StepFlags;\n(function (StepFlags) {\n    // BF_GENERATE_ITEM\t\t\t\t= Fl(0),\t// feature entails generating an item (overridden if the machine is adopting an item)\n    // BF_GENERATE_HORDE\t\t\t= Fl(5),\t// generate a monster horde that has all of the horde flags\n    // BF_NO_THROWING_WEAPONS\t    = Fl(4),\t// the generated item cannot be a throwing weapon\n    // BF_REQUIRE_GOOD_RUNIC\t\t= Fl(18),\t// generated item must be uncursed runic\n    StepFlags[StepFlags[\"BF_OUTSOURCE_ITEM_TO_MACHINE\"] = Fl(1)] = \"BF_OUTSOURCE_ITEM_TO_MACHINE\";\n    StepFlags[StepFlags[\"BF_BUILD_VESTIBULE\"] = Fl(2)] = \"BF_BUILD_VESTIBULE\";\n    StepFlags[StepFlags[\"BF_ADOPT_ITEM\"] = Fl(3)] = \"BF_ADOPT_ITEM\";\n    StepFlags[StepFlags[\"BF_BUILD_AT_ORIGIN\"] = Fl(6)] = \"BF_BUILD_AT_ORIGIN\";\n    // unused                   = Fl(7),\t//\n    StepFlags[StepFlags[\"BF_PERMIT_BLOCKING\"] = Fl(8)] = \"BF_PERMIT_BLOCKING\";\n    StepFlags[StepFlags[\"BF_TREAT_AS_BLOCKING\"] = Fl(9)] = \"BF_TREAT_AS_BLOCKING\";\n    StepFlags[StepFlags[\"BF_NEAR_ORIGIN\"] = Fl(10)] = \"BF_NEAR_ORIGIN\";\n    StepFlags[StepFlags[\"BF_FAR_FROM_ORIGIN\"] = Fl(11)] = \"BF_FAR_FROM_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_VIEW_OF_ORIGIN\"] = Fl(25)] = \"BF_IN_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_PASSABLE_VIEW_OF_ORIGIN\"] = Fl(26)] = \"BF_IN_PASSABLE_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_MONSTER_TAKE_ITEM\"] = Fl(12)] = \"BF_MONSTER_TAKE_ITEM\";\n    StepFlags[StepFlags[\"BF_MONSTER_SLEEPING\"] = Fl(13)] = \"BF_MONSTER_SLEEPING\";\n    StepFlags[StepFlags[\"BF_MONSTER_FLEEING\"] = Fl(14)] = \"BF_MONSTER_FLEEING\";\n    StepFlags[StepFlags[\"BF_MONSTERS_DORMANT\"] = Fl(19)] = \"BF_MONSTERS_DORMANT\";\n    StepFlags[StepFlags[\"BF_ITEM_IS_KEY\"] = Fl(0)] = \"BF_ITEM_IS_KEY\";\n    StepFlags[StepFlags[\"BF_ITEM_IDENTIFIED\"] = Fl(5)] = \"BF_ITEM_IDENTIFIED\";\n    StepFlags[StepFlags[\"BF_ITEM_PLAYER_AVOIDS\"] = Fl(4)] = \"BF_ITEM_PLAYER_AVOIDS\";\n    StepFlags[StepFlags[\"BF_EVERYWHERE\"] = Fl(15)] = \"BF_EVERYWHERE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE\"] = Fl(16)] = \"BF_ALTERNATIVE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE_2\"] = Fl(17)] = \"BF_ALTERNATIVE_2\";\n    // unused                       = Fl(20),\t//\n    StepFlags[StepFlags[\"BF_BUILD_IN_WALLS\"] = Fl(21)] = \"BF_BUILD_IN_WALLS\";\n    StepFlags[StepFlags[\"BF_BUILD_ANYWHERE_ON_LEVEL\"] = Fl(22)] = \"BF_BUILD_ANYWHERE_ON_LEVEL\";\n    StepFlags[StepFlags[\"BF_REPEAT_UNTIL_NO_PROGRESS\"] = Fl(23)] = \"BF_REPEAT_UNTIL_NO_PROGRESS\";\n    StepFlags[StepFlags[\"BF_IMPREGNABLE\"] = Fl(24)] = \"BF_IMPREGNABLE\";\n    StepFlags[StepFlags[\"BF_NOT_IN_HALLWAY\"] = Fl(27)] = \"BF_NOT_IN_HALLWAY\";\n    StepFlags[StepFlags[\"BF_NOT_ON_LEVEL_PERIMETER\"] = Fl(28)] = \"BF_NOT_ON_LEVEL_PERIMETER\";\n    StepFlags[StepFlags[\"BF_SKELETON_KEY\"] = Fl(29)] = \"BF_SKELETON_KEY\";\n    StepFlags[StepFlags[\"BF_KEY_DISPOSABLE\"] = Fl(30)] = \"BF_KEY_DISPOSABLE\";\n})(StepFlags || (StepFlags = {}));\nexport class BuildStep {\n    constructor(cfg = {}) {\n        this.tile = 0;\n        this.flags = 0;\n        this.pad = 0;\n        this.item = null;\n        this.horde = null;\n        this.effect = null;\n        this.chance = 0;\n        this.id = 'n/a';\n        if (cfg.tile) {\n            if (typeof cfg.tile === 'string') {\n                const t = GW.tile.tiles[cfg.tile];\n                if (!t) {\n                    throw new Error('Failed to find tile: ' + cfg.tile);\n                }\n                this.tile = t.index;\n            }\n            else {\n                this.tile = cfg.tile;\n            }\n        }\n        if (cfg.flags) {\n            this.flags = GW.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GW.range.make(cfg.count || 1);\n        this.item = cfg.item || null;\n        this.horde = cfg.horde || null;\n        if (cfg.effect) {\n            this.effect = GW.effect.make(cfg.effect);\n        }\n    }\n    cellIsCandidate(builder, blueprint, x, y, distanceBound) {\n        const site = builder.site;\n        // No building in the hallway if it's prohibited.\n        // This check comes before the origin check, so an area machine will fail altogether\n        // if its origin is in a hallway and the feature that must be built there does not permit as much.\n        if (this.flags & StepFlags.BF_NOT_IN_HALLWAY &&\n            GW.utils.arcCount(x, y, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n            return false;\n        }\n        // No building along the perimeter of the level if it's prohibited.\n        if (this.flags & StepFlags.BF_NOT_ON_LEVEL_PERIMETER &&\n            (x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1)) {\n            return false;\n        }\n        // The origin is a candidate if the feature is flagged to be built at the origin.\n        // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n        if (this.flags & StepFlags.BF_BUILD_AT_ORIGIN) {\n            return x == builder.originX && y == builder.originY ? true : false;\n        }\n        else if (blueprint.isRoom &&\n            x == builder.originX &&\n            y == builder.originY) {\n            return false;\n        }\n        // No building in another feature's personal space!\n        if (builder.occupied[x][y]) {\n            return false;\n        }\n        // Must be in the viewmap if the appropriate flag is set.\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n            !builder.viewMap[x][y]) {\n            return false;\n        }\n        // Do a distance check if the feature requests it.\n        let distance = 10000;\n        if (site.isWall(x, y)) {\n            // Distance is calculated for walls too.\n            GW.utils.eachNeighbor(x, y, (i, j) => {\n                if (!builder.distanceMap.hasXY(i, j))\n                    return;\n                if (!site.blocksPathing(i, j) &&\n                    distance > builder.distanceMap[i][j] + 1) {\n                    distance = builder.distanceMap[i][j] + 1;\n                }\n            }, true);\n        }\n        else {\n            distance = builder.distanceMap[x][y];\n        }\n        if (distance > distanceBound[1] || // distance exceeds max\n            distance < distanceBound[0]) {\n            // distance falls short of min\n            return false;\n        }\n        if (this.flags & StepFlags.BF_BUILD_IN_WALLS) {\n            // If we're supposed to build in a wall...\n            const cellMachine = site.getMachine(x, y);\n            if (!builder.interior[x][y] &&\n                (!cellMachine || cellMachine == builder.machineNumber) &&\n                site.isWall(x, y)) {\n                let ok = false;\n                // ...and this location is a wall that's not already machined...\n                GW.utils.eachNeighbor(x, y, (newX, newY) => {\n                    if (site.hasXY(newX, newY) && // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                        ((builder.interior[newX][newY] &&\n                            !(newX == builder.originX &&\n                                newY == builder.originY)) ||\n                            (this.flags &\n                                StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL &&\n                                !site.blocksPathing(newX, newY) &&\n                                !site.getMachine(newX, newY)))) {\n                        ok = true;\n                    }\n                });\n                return ok;\n            }\n            return false;\n        }\n        else if (site.isWall(x, y)) {\n            // Can't build in a wall unless instructed to do so.\n            return false;\n        }\n        else if (this.flags & StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL) {\n            if ((this.item && site.blocksItems(x, y)) ||\n                site\n                    .cellInfo(x, y)\n                    .hasCellFlag(GW.map.flags.Cell.IS_CHOKEPOINT |\n                    GW.map.flags.Cell.IS_IN_LOOP |\n                    GW.map.flags.Cell.IS_IN_MACHINE)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        else if (builder.interior[x][y]) {\n            return true;\n        }\n        return false;\n    }\n    makePersonalSpace(builder, x, y, candidates) {\n        const personalSpace = this.pad;\n        let count = 0;\n        for (let i = x - personalSpace + 1; i <= x + personalSpace - 1; i++) {\n            for (let j = y - personalSpace + 1; j <= y + personalSpace - 1; j++) {\n                if (builder.site.hasXY(i, j)) {\n                    if (candidates[i][j]) {\n                        candidates[i][j] = 0;\n                        ++count;\n                    }\n                    builder.occupied[i][j] = 1;\n                }\n            }\n        }\n        return count;\n    }\n    get generateEverywhere() {\n        return !!(this.flags &\n            StepFlags.BF_EVERYWHERE &\n            ~StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n    get buildAtOrigin() {\n        return !!(this.flags & StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n    distanceBound(builder) {\n        const distanceBound = [0, 10000];\n        if (this.flags & StepFlags.BF_NEAR_ORIGIN) {\n            distanceBound[1] = builder.distance25;\n        }\n        if (this.flags & StepFlags.BF_FAR_FROM_ORIGIN) {\n            distanceBound[0] = builder.distance75;\n        }\n        return distanceBound;\n    }\n    updateViewMap(builder) {\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN)) {\n            const site = builder.site;\n            if (this.flags & StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) {\n                const fov = new GW.fov.FOV({\n                    isBlocked: (x, y) => {\n                        return site.blocksPathing(x, y);\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            else {\n                const fov = new GW.fov.FOV({\n                    // TileFlags.T_OBSTRUCTS_PASSABILITY |\n                    //     TileFlags.T_OBSTRUCTS_VISION,\n                    isBlocked: (x, y) => {\n                        return (site.blocksPathing(x, y) || site.blocksVision(x, y));\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            builder.viewMap[builder.originX][builder.originY] = 1;\n        }\n    }\n    markCandidates(candidates, builder, blueprint, distanceBound) {\n        let count = 0;\n        candidates.update((_v, i, j) => {\n            if (this.cellIsCandidate(builder, blueprint, i, j, distanceBound)) {\n                count++;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        return count;\n    }\n    build(builder, blueprint) {\n        let instanceCount = 0;\n        let instance = 0;\n        const site = builder.site;\n        const candidates = GW.grid.alloc(site.width, site.height);\n        // Figure out the distance bounds.\n        const distanceBound = this.distanceBound(builder);\n        this.updateViewMap(builder);\n        do {\n            // If the StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n            // Make a master map of candidate locations for this feature.\n            let qualifyingTileCount = this.markCandidates(candidates, builder, blueprint, distanceBound);\n            if (!this.generateEverywhere) {\n                instanceCount = this.count.value();\n            }\n            if (!qualifyingTileCount || qualifyingTileCount < this.count.lo) {\n                console.warn('Only %s qualifying tiles - want at least %s.', qualifyingTileCount, this.count.lo);\n                return 0; // ?? Failed ??\n            }\n            let x = 0, y = 0;\n            for (instance = 0; (this.generateEverywhere || instance < instanceCount) &&\n                qualifyingTileCount > 0;) {\n                // Find a location for the feature.\n                if (this.buildAtOrigin) {\n                    // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                    x = builder.originX;\n                    y = builder.originY;\n                }\n                else {\n                    // Pick our candidate location randomly, and also strike it from\n                    // the candidates map so that subsequent instances of this same feature can't choose it.\n                    [x, y] = GW.random.matchingLoc(candidates.width, candidates.height, (x, y) => candidates[x][y] > 0);\n                }\n                // Don't waste time trying the same place again whether or not this attempt succeeds.\n                candidates[x][y] = 0;\n                qualifyingTileCount--;\n                let DFSucceeded = true;\n                let terrainSucceeded = true;\n                // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n                if (this.effect) {\n                    DFSucceeded = GW.effect.fireSync(this.effect, site, x, y);\n                }\n                // Now try to place the terrain tile, if any.\n                if (DFSucceeded && this.tile) {\n                    let tile = GW.tile.get(this.tile).index;\n                    if (!tile) {\n                        terrainSucceeded = false;\n                        console.error('placing invalid tile', this.tile, x, y);\n                    }\n                    else if (!(this.flags & StepFlags.BF_PERMIT_BLOCKING) &&\n                        (site.tileBlocksMove(tile) ||\n                            this.flags & StepFlags.BF_TREAT_AS_BLOCKING)) {\n                        // Yes, check for blocking.\n                        const blockingMap = GW.grid.alloc(site.width, site.height);\n                        blockingMap[x][y] = 1;\n                        terrainSucceeded = !SITE.siteDisruptedBy(site, blockingMap);\n                        GW.grid.free(blockingMap);\n                    }\n                    if (terrainSucceeded) {\n                        site.setTile(x, y, tile);\n                    }\n                }\n                // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n                // Personal space of 0 means nothing gets cleared, 1 means that only the tile itself gets cleared, and 2 means the 3x3 grid centered on it.\n                if (DFSucceeded && terrainSucceeded) {\n                    qualifyingTileCount -= this.makePersonalSpace(builder, x, y, candidates);\n                    instance++; // we've placed an instance\n                    //DEBUG printf(\"\\nPlaced instance #%i of feature %i at (%i, %i).\", instance, feat, featX, featY);\n                }\n                if (DFSucceeded && terrainSucceeded) {\n                    // Proceed only if the terrain stuff for this instance succeeded.\n                    // Mark the feature location as part of the machine, in case it is not already inside of it.\n                    if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n                        site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n                    }\n                    // Mark the feature location as impregnable if requested.\n                    if (this.flags & StepFlags.BF_IMPREGNABLE) {\n                        site.setCellFlag(x, y, GW.map.flags.Cell.IMPREGNABLE);\n                    }\n                    // let success = RUT.Component.generateAdoptItem(\n                    //     component,\n                    //     blueprint,\n                    //     map,\n                    //     xy.x,\n                    //     xy.y,\n                    //     context\n                    // );\n                    // if (!success) {\n                    //     GW.grid.free(candidates);\n                    //     return false;\n                    // }\n                    // // Generate a horde as necessary.\n                    // success = RUT.Component.generateMonsters(\n                    //     component,\n                    //     blueprint,\n                    //     map,\n                    //     xy.x,\n                    //     xy.y,\n                    //     context\n                    // );\n                    // if (!success) {\n                    //     GW.grid.free(candidates);\n                    //     return false;\n                    // }\n                }\n                // Finished with this instance!\n            }\n        } while (this.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS &&\n            instance <= this.count.lo);\n        //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n        //DEBUG logBuffer(candidates);\n        GW.grid.free(candidates);\n        return instance;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as STEP from './build/buildStep';\nconst Fl = GW.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(10)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(7)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(0)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(2)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(3)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(4)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(5)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(6)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(8)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(9)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(14)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(11)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(12)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(13)] = \"BP_NO_INTERIOR_FLAG\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.size = [-1, -1];\n        this.flags = 0;\n        this.steps = [];\n        this.id = 'n/a';\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GW.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            if (typeof opts.size === 'string') {\n                const parts = opts.size\n                    .split(/-/)\n                    .map((v) => v.trim())\n                    .map((v) => Number.parseInt(v));\n                if (parts.length !== 2)\n                    throw new Error('Blueprint size must be of format: #-#');\n                this.size = [parts[0], parts[1]];\n            }\n            else if (Array.isArray(opts.size)) {\n                if (opts.size.length !== 2)\n                    throw new Error('Blueprint size must be [min, max]');\n                this.size = [opts.size[0], opts.size[1]];\n            }\n            else {\n                throw new Error('size must be string or array.');\n            }\n            if (this.size[0] > this.size[1])\n                throw new Error('Blueprint size must be small to large.');\n        }\n        if (opts.flags) {\n            this.flags = GW.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n        }\n    }\n    getChance(level, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return 0;\n        }\n        return this.frequency(level);\n    }\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n    qualifies(requiredFlags, depth) {\n        if (this.frequency(depth) <= 0 ||\n            // Must have the required flags:\n            ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags) {\n            return false;\n        }\n        return true;\n    }\n    pickLocation(site) {\n        // Find a location and map out the machine interior.\n        if (this.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n            site.analyze(); // Make sure the chokeMap is up to date.\n            const randSite = GW.random.matchingLoc(site.width, site.height, (x, y) => site\n                .cellInfo(x, y)\n                .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE));\n            if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n                // If no suitable sites, abort.\n                console.log('Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint.');\n                return false;\n            }\n            return randSite;\n        }\n        else if (this.isVestiblue) {\n            //  Door machines must have locations passed in. We can't pick one ourselves.\n            console.log('ERROR: Attempted to build a vestiblue without a location being provided.');\n            return false;\n        }\n        // Pick a random origin location.\n        const pos = GW.random.matchingLoc(site.width, site.height, (x, y) => site.isPassable(x, y));\n        if (!pos || pos[0] < 0 || pos[1] < 0)\n            return false;\n        return pos;\n    }\n    // Assume site has been analyzed (aka GateSites and ChokeCounts set)\n    computeInterior(builder) {\n        let failsafe = this.isRoom ? 10 : 20;\n        let tryAgain;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            tryAgain = false;\n            if (--failsafe <= 0) {\n                console.log('Failed to build a machine; failed repeatedly to find a suitable blueprint location.');\n                return false;\n            }\n            interior.fill(0);\n            // Find a location and map out the machine interior.\n            if (this.isRoom) {\n                // If it's a room machine, count up the gates of appropriate\n                // choke size and remember where they are. The origin of the room will be the gate location.\n                // Now map out the interior into interior[][].\n                // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n                // same or lower choke value, ignoring any tiles that are already part of a machine.\n                // If we get false from this, try again. If we've tried too many times already, abort.\n                tryAgain = !this.addTileToInteriorAndIterate(builder, builder.originX, builder.originY);\n            }\n            else if (this.isVestiblue) {\n                if (!this.computeInteriorForVestibuleMachine(builder)) {\n                    // TODO - tryagain = true?\n                    console.error('ERROR: Attempted to build a door machine from blueprint: not enough room.');\n                    return false;\n                }\n                // success\n            }\n            else {\n                // Find a location and map out the interior for a non-room machine.\n                // The strategy here is simply to pick a random location on the map,\n                // expand it along a pathing map by one space in all directions until the size reaches\n                // the chosen size, and then make sure the resulting space qualifies.\n                // If not, try again. If we've tried too many times already, abort.\n                let distanceMap = GW.grid.alloc(interior.width, interior.height);\n                SITE.computeDistanceMap(site, distanceMap, builder.originX, builder.originY, this.size[1]);\n                const seq = GW.random.sequence(site.width * site.height);\n                let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n                let totalFreq = GW.random.range(this.size[0], this.size[1]); // Keeps track of the goal size.\n                for (let k = 0; k < 1000 && qualifyingTileCount < totalFreq; k++) {\n                    for (let n = 0; n < seq.length && qualifyingTileCount < totalFreq; n++) {\n                        const i = Math.floor(seq[n] / site.height);\n                        const j = seq[n] % site.height;\n                        if (distanceMap[i][j] == k) {\n                            interior[i][j] = 1;\n                            qualifyingTileCount++;\n                            if (site.isOccupied(i, j) ||\n                                site\n                                    .cellInfo(i, j)\n                                    .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE)) {\n                                // Abort if we've entered another machine or engulfed another machine's item or monster.\n                                tryAgain = true;\n                                qualifyingTileCount = totalFreq; // This is a hack to drop out of these three for-loops.\n                            }\n                        }\n                    }\n                }\n                // Now make sure the interior map satisfies the machine's qualifications.\n                if (qualifyingTileCount < totalFreq) {\n                    tryAgain = true;\n                    console.log('too small');\n                }\n                else if (this.treatAsBlocking &&\n                    SITE.siteDisruptedBy(site, interior)) {\n                    console.log('disconnected');\n                    tryAgain = true;\n                }\n                else if (this.requireBlocking &&\n                    SITE.siteDisruptedSize(site, interior) < 100) {\n                    console.log('not disconnected enough');\n                    tryAgain = true; // BP_REQUIRE_BLOCKING needs some work to make sure the disconnect is interesting.\n                }\n                // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n                // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n                GW.grid.free(distanceMap);\n            }\n            // Now loop if necessary.\n        } while (tryAgain);\n        // console.log(tryAgain, failsafe);\n        return true;\n    }\n    // Assumes (startX, startY) is in the machine.\n    // Returns true if everything went well, and false if we ran into a machine component\n    // that was already there, as we don't want to build a machine around it.\n    addTileToInteriorAndIterate(builder, startX, startY) {\n        let goodSoFar = true;\n        const interior = builder.interior;\n        const site = builder.site;\n        interior[startX][startY] = 1;\n        const startChokeCount = site.getChokeCount(startX, startY);\n        for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n            const newX = startX + GW.utils.DIRS[dir][0];\n            const newY = startY + GW.utils.DIRS[dir][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            if (interior[newX][newY])\n                continue; // already done\n            if (site.isOccupied(newX, newY) ||\n                (site\n                    .cellInfo(newX, newY)\n                    .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE) &&\n                    !site\n                        .cellInfo(newX, newY)\n                        .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE))) {\n                // Abort if there's an item in the room.\n                // Items haven't been populated yet, so the only way this could happen is if another machine\n                // previously placed an item here.\n                // Also abort if we're touching another machine at any point other than a gate tile.\n                return false;\n            }\n            if (site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n                !site\n                    .cellInfo(newX, newY)\n                    .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE)) {\n                goodSoFar = this.addTileToInteriorAndIterate(builder, newX, newY);\n            }\n        }\n        return goodSoFar;\n    }\n    computeInteriorForVestibuleMachine(builder) {\n        let success = true;\n        const interior = builder.interior;\n        const site = builder.site;\n        interior.fill(0);\n        let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n        const totalFreq = GW.random.range(this.size[0], this.size[1]); // Keeps track of the goal size.\n        const distMap = GW.grid.alloc(site.width, site.height);\n        SITE.computeDistanceMap(site, distMap, builder.originX, builder.originY, this.size[1]);\n        // console.log('DISTANCE MAP', originX, originY);\n        // RUT.Grid.dump(distMap);\n        const cells = GW.random.sequence(site.width * site.height);\n        for (let k = 0; k < 1000 && qualifyingTileCount < totalFreq; k++) {\n            for (let i = 0; i < cells.length && qualifyingTileCount < totalFreq; ++i) {\n                const x = Math.floor(cells[i] / site.height);\n                const y = cells[i] % site.height;\n                const dist = distMap[x][y];\n                if (dist != k)\n                    continue;\n                if (site.isOccupied(x, y)) {\n                    success = false;\n                    qualifyingTileCount = totalFreq;\n                }\n                interior[x][y] = 1;\n                qualifyingTileCount += 1;\n            }\n        }\n        // Now make sure the interior map satisfies the machine's qualifications.\n        if (this.treatAsBlocking && SITE.siteDisruptedBy(site, interior)) {\n            success = false;\n        }\n        else if (this.requireBlocking &&\n            SITE.siteDisruptedSize(site, interior) < 100) {\n            success = false;\n        }\n        GW.grid.free(distMap);\n        return success;\n    }\n    prepareInteriorWithMachineFlags(builder) {\n        const interior = builder.interior;\n        const site = builder.site;\n        // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n        if (this.maximizeInterior) {\n            this.expandMachineInterior(builder, 1);\n        }\n        else if (this.openInterior) {\n            this.expandMachineInterior(builder, 4);\n        }\n        // If requested, cleanse the interior -- no interesting terrain allowed.\n        if (this.purgeInterior) {\n            interior.forEach((v, x, y) => {\n                if (v)\n                    site.setTile(x, y, SITE.FLOOR);\n            });\n        }\n        // If requested, purge pathing blockers -- no traps allowed.\n        if (this.purgeBlockers) {\n            interior.forEach((v, x, y) => {\n                if (!v)\n                    return;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n            });\n        }\n        // If requested, purge the liquid layer in the interior -- no liquids allowed.\n        if (this.purgeLiquids) {\n            interior.forEach((v, x, y) => {\n                if (v && site.isAnyLiquid(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n            });\n        }\n        // Surround with walls if requested.\n        if (this.surroundWithWalls) {\n            interior.forEach((v, x, y) => {\n                if (!v ||\n                    site\n                        .cellInfo(x, y)\n                        .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE))\n                    return;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not valid x,y\n                    if (interior[i][j])\n                        return; // is part of machine\n                    if (site.isWall(i, j))\n                        return; // is already a wall (of some sort)\n                    if (site\n                        .cellInfo(i, j)\n                        .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE))\n                        return; // is a door site\n                    if (site\n                        .cellInfo(i, j)\n                        .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE))\n                        return; // is part of a machine\n                    if (!site.blocksPathing(i, j))\n                        return; // is not a blocker for the player (water?)\n                    site.setTile(i, j, SITE.WALL);\n                }, false);\n            });\n        }\n        // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n        // Then zero out any portion of the interior that is still wall.\n        // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n        //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n        // }\n        // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n        if (this.makeImpregnable) {\n            interior.forEach((v, x, y) => {\n                if (!v ||\n                    site\n                        .cellInfo(x, y)\n                        .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE))\n                    return;\n                site.setCellFlag(x, y, GW.map.flags.Cell.IMPREGNABLE);\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (interior[i][j])\n                        return;\n                    if (site\n                        .cellInfo(i, j)\n                        .hasCellFlag(GW.map.flags.Cell.IS_GATE_SITE))\n                        return;\n                    site.setCellFlag(i, j, GW.map.flags.Cell.IMPREGNABLE);\n                }, false);\n            });\n        }\n        // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n        const machineNumber = builder.machineNumber;\n        interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            site.setMachine(x, y, machineNumber, this.isRoom);\n            // secret doors mess up machines\n            if (site.isSecretDoor(x, y)) {\n                site.setTile(x, y, SITE.DOOR);\n            }\n        });\n    }\n    expandMachineInterior(builder, minimumInteriorNeighbors = 1) {\n        let madeChange;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            madeChange = false;\n            interior.forEach((_v, x, y) => {\n                // if (v && site.isDoor(x, y)) {\n                //     site.setTile(x, y, SITE.FLOOR); // clean out the doors...\n                //     return;\n                // }\n                if (site\n                    .cellInfo(x, y)\n                    .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE))\n                    return;\n                if (!site.blocksPathing(x, y))\n                    return;\n                let nbcount = 0;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not in map\n                    if (interior[i][j] && !site.blocksPathing(i, j)) {\n                        ++nbcount; // in machine and open tile\n                    }\n                }, false);\n                if (nbcount < minimumInteriorNeighbors)\n                    return;\n                nbcount = 0;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // not on map\n                    if (interior[i][j])\n                        return; // already part of machine\n                    if (!site.isWall(i, j) ||\n                        site\n                            .cellInfo(i, j)\n                            .hasCellFlag(GW.map.flags.Cell.IS_IN_MACHINE)) {\n                        ++nbcount; // tile is not a wall or is in a machine\n                    }\n                }, false);\n                if (nbcount)\n                    return;\n                // Eliminate this obstruction; welcome its location into the machine.\n                madeChange = true;\n                interior[x][y] = 1;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (site.isSet(i, j))\n                        return;\n                    site.setTile(i, j, SITE.WALL);\n                });\n            });\n        } while (madeChange);\n    }\n    calcDistances(builder) {\n        builder.distanceMap.fill(0);\n        SITE.computeDistanceMap(builder.site, builder.distanceMap, builder.originX, builder.originY, this.size[1]);\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n        builder.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const dist = builder.distanceMap[x][y];\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            }\n            else {\n                distance25 -= distances[i];\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            }\n            else {\n                distance75 -= distances[i];\n            }\n        }\n        builder.distance25 = distance25;\n        builder.distance75 = distance75;\n    }\n    pickComponents() {\n        const alternativeFlags = [\n            STEP.StepFlags.BF_ALTERNATIVE,\n            STEP.StepFlags.BF_ALTERNATIVE_2,\n        ];\n        const keepFeature = new Array(this.steps.length).fill(true);\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = GW.random.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n    clearInteriorFlag(builder) {\n        builder.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            if (!builder.site\n                .cellInfo(x, y)\n                .hasCellFlag(GW.map.flags.Cell.IS_WIRED |\n                GW.map.flags.Cell.IS_CIRCUIT_BREAKER)) {\n                builder.site.setMachine(x, y, 0);\n            }\n        });\n        // for (i = 0; i < map.width; i++) {\n        //     for (j = 0; j < map.height; j++) {\n        //         const cell = RUT.Map.getCell(map, i, j);\n        //         if (\n        //             cell.machineNumber == map.machineNumber &&\n        //             !RUT.Cell.hasMechFlag(\n        //                 cell,\n        //                 MechFlags.TM_IS_WIRED |\n        //                     MechFlags.TM_IS_CIRCUIT_BREAKER\n        //             )\n        //         ) {\n        //             cell.flags &= ~CellFlags.IS_IN_MACHINE;\n        //             cell.machineNumber = 0;\n        //         }\n        //     }\n        // }\n    }\n}\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\nexport function random(requiredFlags, depth) {\n    const matches = Object.values(blueprints).filter((b) => b.qualifies(requiredFlags, depth));\n    return GW.random.item(matches);\n}\n","import * as GW from 'gw-utils';\nimport * as BLUE from '../blueprint';\nimport { StepFlags } from './buildStep';\nexport class Builder {\n    constructor(site, depth) {\n        this.site = site;\n        this.depth = depth;\n        this.spawnedItems = [];\n        this.spawnedHordes = [];\n        this.originX = -1;\n        this.originY = -1;\n        this.distance25 = -1;\n        this.distance75 = -1;\n        this.machineNumber = 0;\n        this.interior = GW.grid.alloc(site.width, site.height);\n        this.occupied = GW.grid.alloc(site.width, site.height);\n        this.viewMap = GW.grid.alloc(site.width, site.height);\n        this.distanceMap = GW.grid.alloc(site.width, site.height);\n    }\n    free() {\n        GW.grid.free(this.interior);\n        GW.grid.free(this.occupied);\n        GW.grid.free(this.viewMap);\n        GW.grid.free(this.distanceMap);\n    }\n    buildRandom(requiredMachineFlags = BLUE.Flags.BP_ROOM) {\n        let tries = 10;\n        while (tries--) {\n            const blueprint = BLUE.random(requiredMachineFlags, this.depth);\n            if (!blueprint) {\n                continue;\n            }\n            if (this.buildBlueprint(blueprint)) {\n                return true;\n            }\n        }\n        console.log('Failed to find blueprint matching flags: ' +\n            GW.flag.toString(BLUE.Flags, requiredMachineFlags));\n        return false;\n    }\n    buildBlueprint(blueprint) {\n        let tries = 10;\n        while (tries--) {\n            const loc = blueprint.pickLocation(this.site);\n            if (!loc) {\n                continue;\n            }\n            if (this.build(blueprint, loc[0], loc[1])) {\n                return true;\n            }\n        }\n        console.log('Failed to build blueprint.');\n        return false;\n    }\n    //////////////////////////////////////////\n    // Returns true if the machine got built; false if it was aborted.\n    // If empty array spawnedItems or spawnedMonsters is given, will pass those back for deletion if necessary.\n    build(blueprint, originX, originY) {\n        this.interior.fill(0);\n        this.occupied.fill(0);\n        this.viewMap.fill(0);\n        this.distanceMap.fill(0);\n        this.originX = originX;\n        this.originY = originY;\n        if (!blueprint.computeInterior(this)) {\n            return false;\n        }\n        // This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.\n        const levelBackup = this.site.backup();\n        this.machineNumber = this.site.nextMachineId(); // Reserve this machine number, starting with 1.\n        // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.\n        blueprint.prepareInteriorWithMachineFlags(this);\n        // Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)\n        // and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.\n        blueprint.calcDistances(this);\n        // Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.\n        // Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.\n        const components = blueprint.pickComponents();\n        // Keep track of all monsters and items that we spawn -- if we abort, we have to go back and delete them all.\n        // let itemCount = 0, monsterCount = 0;\n        // Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.\n        // Now tick through the features and build them.\n        for (let index = 0; index < components.length; index++) {\n            const component = components[index];\n            // console.log('BUILD COMPONENT', component);\n            const count = component.build(this, blueprint);\n            if (count < component.count.lo &&\n                !(component.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS)) {\n                // failure! abort!\n                console.log('Failed to place blueprint because of feature; needed more instances.');\n                // Restore the map to how it was before we touched it.\n                this.site.restore(levelBackup);\n                // abortItemsAndMonsters(spawnedItems, spawnedMonsters);\n                return false;\n            }\n        }\n        // Clear out the interior flag for all non-wired cells, if requested.\n        if (blueprint.noInteriorFlag) {\n            blueprint.clearInteriorFlag(this);\n        }\n        // if (torchBearer && torch) {\n        // \tif (torchBearer->carriedItem) {\n        // \t\tdeleteItem(torchBearer->carriedItem);\n        // \t}\n        // \tremoveItemFromChain(torch, floorItems);\n        // \ttorchBearer->carriedItem = torch;\n        // }\n        // console.log('Built a machine from blueprint:', originX, originY);\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as LEVEL from './level';\nexport class Dungeon {\n    constructor(options = {}) {\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { count: 20, digger: 'DEFAULT' },\n            halls: {},\n            loops: {},\n            lakes: {},\n            bridges: {},\n            stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GW.utils.setOptions(this.config, options);\n        if (this.config.seed) {\n            GW.random.seed(this.config.seed);\n        }\n        this.initSeeds();\n        this.initStairLocs();\n    }\n    get levels() {\n        return this.config.levels;\n    }\n    initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GW.random.number(2 ** 32);\n        }\n    }\n    initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        for (let i = 0; i < this.config.levels; ++i) {\n            const endLoc = GW.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                return (GW.utils.distanceBetween(startLoc[0], startLoc[1], x, y) > minDistance);\n            });\n            this.stairLocs.push([\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ]);\n            startLoc = endLoc;\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        GW.random.seed(this.seeds[id]);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && rooms.entrance) {\n            rooms.first = rooms.entrance;\n        }\n        const levelOpts = {\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            width: this.config.width,\n            height: this.config.height,\n        };\n        return this.makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    makeLevel(id, opts, cb) {\n        const level = new LEVEL.Level(this.config.width, this.config.height, opts);\n        const result = level.create(cb);\n        if (!GW.utils.equalsXY(level.endLoc, opts.endLoc) ||\n            !GW.utils.equalsXY(level.startLoc, opts.startLoc)) {\n            this.stairLocs[id] = [level.startLoc, level.endLoc];\n        }\n        return result;\n    }\n}\n"],"names":["_a","_b","NOTHING","GW","tile","get","index","FLOOR","DOOR","SECRET_DOOR","WALL","DEEP","SHALLOW","BRIDGE","UP_STAIRS","DOWN_STAIRS","IMPREGNABLE","TILEMAP","[object Object]","GridSite","width","height","this","tiles","grid","alloc","free","x","y","hasXY","isBoundaryXY","isFloor","isDoor","isBridge","isStairs","isShallow","v","isNothing","isWall","isDeep","blocksPathing","Tile","obj","Error","Flags","map","flags","Cell","MapSite","Map","super","machineCount","machineId","NumGrid","cellInfo","hasItem","blocksMove","hasTile","cell","isEmpty","isPassable","hasTileFlag","T_BRIDGE","T_IS_DOOR","hasObjectFlag","gameObject","GameObject","L_SECRETLY_PASSABLE","L_BLOCKS_DIAGONAL","info","L_BLOCKS_MOVE","T_PATHING_BLOCKER","L_BLOCKS_ITEMS","L_BLOCKS_EFFECTS","T_DEEP_WATER","depthTile","Depth","LIQUID","T_IS_DEEP_LIQUID","hasDepthTile","highestPriorityTile","backup","copy","chokeCount","count","hasActor","analyze","id","isRoom","clearCellFlag","IS_IN_MACHINE","setCellFlag","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","DIRS","utils","directionOfDoorSite","site","dir","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","chooseRandomDoorSites","i","j","k","doorSiteFailed","DOORS","h","w","isDiggable","isSet","push","doorSites","loc","random","item","copySite","dest","source","offsetX","offsetY","forRect","otherX","otherY","getTileIndex","setTile","fillCostGrid","costGrid","update","_v","path","OBSTRUCTION","siteDisruptedBy","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","lakeX","lakeY","first","floodFill","siteDisruptedSize","nextId","minSize","disrupted","Math","min","computeDistanceMap","distanceMap","originX","originY","maxDistance","calculateDistances","Hall","length","doors","d","UP","DOWN","x2","y2","dx","dy","forEach","Room","Bounds","hall","cx","floor","cy","translate","checkConfig","config","expected","Object","entries","key","expect","have","undefined","Array","isArray","range","make","RoomDigger","options","_setOptions","result","carve","every","SITE.chooseRandomDoorSites","rooms","ChoiceRoom","choices","randomRoom","bind","weighted","room","ERROR","create","Cavern","value","SITE.FLOOR","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","chance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickLength","lengths","pickHallDirection","dirs","sequence","hi","door","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.Hall","lower","higher","actual","startX","startY","halls","opts","clamp","Number","parseInt","_pickWidth","Lakes","tries","canDisrupt","wreathTile","SITE.SHALLOW","wreathChance","wreathSize","SITE.DEEP","assign","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","dirCoords","seq","isAnyLiquid","bridgeDir","NO_PATH","isBridgeCandidate","SITE.BRIDGE","Stairs","up","down","start","upTile","SITE.UP_STAIRS","downTile","SITE.DOWN_STAIRS","wall","SITE.IMPREGNABLE","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingLoc","matchingLocNear","distanceBetween","slice","setupStairs","indexes","x0","y0","dirIndex","CLOCK_DIRS","findIndex","r","LoopDigger","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.DOOR","Level","loops","lakes","bridges","stairs","boundary","startLoc","endLoc","seed","setOptions","SITE.GridSite","setFn","makeSite","addFirstRoom","fails","addRoom","addLoops","addLakes","addBridges","addStairs","finish","t","_site","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","roomSite","getDigger","_attachRoomAtLoc","HALL.dig","_attachRoom","SITE.directionOfDoorSite","oppDir","_roomFitsAt","SITE.copySite","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","didSomething","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","blocksDiagonal","boundaryTile","SITE.WALL","Fl","flag","fl","StepFlags","BuildStep","cfg","pad","horde","effect","from","builder","blueprint","distanceBound","BF_NOT_IN_HALLWAY","arcCount","BF_NOT_ON_LEVEL_PERIMETER","BF_BUILD_AT_ORIGIN","occupied","BF_IN_VIEW_OF_ORIGIN","BF_IN_PASSABLE_VIEW_OF_ORIGIN","viewMap","distance","eachNeighbor","BF_BUILD_IN_WALLS","cellMachine","getMachine","interior","machineNumber","ok","BF_BUILD_ANYWHERE_ON_LEVEL","blocksItems","hasCellFlag","IS_CHOKEPOINT","IS_IN_LOOP","candidates","personalSpace","generateEverywhere","BF_EVERYWHERE","buildAtOrigin","BF_NEAR_ORIGIN","distance25","BF_FAR_FROM_ORIGIN","distance75","fov","FOV","isBlocked","calculate","blocksVision","cellIsCandidate","instanceCount","instance","updateViewMap","qualifyingTileCount","markCandidates","lo","console","warn","DFSucceeded","terrainSucceeded","fireSync","BF_PERMIT_BLOCKING","tileBlocksMove","BF_TREAT_AS_BLOCKING","blockingMap","SITE.siteDisruptedBy","error","makePersonalSpace","BP_NO_INTERIOR_FLAG","setMachine","BF_IMPREGNABLE","BF_REPEAT_UNTIL_NO_PROGRESS","Blueprint","tags","size","steps","split","trim","frequency","parts","STEP.BuildStep","level","want","includes","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_ADOPT_ITEM","treatAsBlocking","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","requiredFlags","depth","randSite","IS_GATE_SITE","log","pos","tryAgain","failsafe","fill","addTileToInteriorAndIterate","computeInteriorForVestibuleMachine","SITE.computeDistanceMap","totalFreq","n","isOccupied","SITE.siteDisruptedSize","goodSoFar","startChokeCount","getChokeCount","distMap","cells","expandMachineInterior","isSecretDoor","minimumInteriorNeighbors","madeChange","nbcount","distances","dist","alternativeFlags","STEP.StepFlags","BF_ALTERNATIVE","BF_ALTERNATIVE_2","keepFeature","randIndex","filter","_f","IS_WIRED","IS_CIRCUIT_BREAKER","blueprints","matches","values","b","qualifies","spawnedItems","spawnedHordes","requiredMachineFlags","BLUE.Flags","BLUE.random","buildBlueprint","toString","pickLocation","build","computeInterior","levelBackup","nextMachineId","prepareInteriorWithMachineFlags","calcDistances","components","pickComponents","component","restore","clearInteriorFlag","levels","seeds","stairLocs","initSeeds","initStairLocs","number","stairDistance","cb","stairOpts","goesUp","startTile","endTile","entrance","levelOpts","makeLevel","LEVEL.Level","equalsXY"],"mappings":"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"}
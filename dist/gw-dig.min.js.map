{"version":3,"file":"gw-dig.min.js","sources":["../js/site/digSite.js","../js/site/buildSite.js","../js/site/utils.js","../js/types.js","../js/room.js","../js/hall.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/loop.js","../js/level.js","../js/blueprint/blueprint.js","../js/blueprint/buildStep.js","../js/blueprint/builder.js","../js/dungeon.js"],"sourcesContent":["var _a, _b;\nimport * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nexport const NOTHING = GWM.tile.get('NULL').index;\nexport const FLOOR = GWM.tile.get('FLOOR').index;\nexport const DOOR = GWM.tile.get('DOOR').index;\nexport const SECRET_DOOR = (_b = (_a = GWM.tile.get('DOOR_SECRET')) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;\nexport const WALL = GWM.tile.get('WALL').index;\nexport const DEEP = GWM.tile.get('LAKE').index;\nexport const SHALLOW = GWM.tile.get('SHALLOW').index;\nexport const BRIDGE = GWM.tile.get('BRIDGE').index;\nexport const UP_STAIRS = GWM.tile.get('UP_STAIRS').index;\nexport const DOWN_STAIRS = GWM.tile.get('DOWN_STAIRS').index;\nexport const IMPREGNABLE = GWM.tile.get('IMPREGNABLE').index;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport class GridSite {\n    constructor(width, height) {\n        this.tiles = GWU.grid.alloc(width, height);\n    }\n    free() {\n        GWU.grid.free(this.tiles);\n    }\n    clear() {\n        this.tiles.fill(0);\n    }\n    get width() {\n        return this.tiles.width;\n    }\n    get height() {\n        return this.tiles.height;\n    }\n    hasXY(x, y) {\n        return this.tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.tiles.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === DOOR;\n    }\n    isSecretDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === SECRET_DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    blocksMove(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y) || this.isDeep(x, y);\n    }\n    blocksDiagonal(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksPathing(x, y) {\n        return (this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y));\n    }\n    blocksVision(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksItems(x, y) {\n        return this.blocksPathing(x, y) || this.blocksPathing(x, y);\n    }\n    blocksEffects(x, y) {\n        return this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.tiles.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.tiles.get(x, y) === SHALLOW;\n    }\n    isAnyLiquid(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.tiles.get(x, y) || 0) > 0;\n    }\n    getTileIndex(x, y) {\n        return this.tiles.get(x, y) || 0;\n    }\n    setTile(x, y, tile) {\n        if (tile instanceof GWM.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GWM.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        if (!this.tiles.hasXY(x, y))\n            return false;\n        this.tiles[x][y] = tile;\n        return true;\n    }\n    hasTile(x, y, tile) {\n        if (tile instanceof GWM.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GWM.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        return this.tiles.hasXY(x, y) && this.tiles[x][y] == tile;\n    }\n    getMachine(_x, _y) {\n        return 0;\n    }\n}\n","import * as GWM from 'gw-map';\nconst Flags = GWM.flags.Cell;\nexport class MapSite {\n    constructor(map) {\n        this.machineCount = 0;\n        this.map = map;\n    }\n    get width() {\n        return this.map.width;\n    }\n    get height() {\n        return this.map.height;\n    }\n    hasXY(x, y) {\n        return this.map.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.map.isBoundaryXY(x, y);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.map.cellInfo(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.map.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.map.cell(x, y).clearCellFlag(flag);\n    }\n    hasTile(x, y, tile) {\n        return this.map.cellInfo(x, y).hasTile(tile);\n    }\n    setTile(x, y, tile, opts) {\n        return this.map.setTile(x, y, tile, opts);\n    }\n    getTileIndex(x, y) {\n        if (!this.hasXY(x, y))\n            return 0;\n        const cell = this.map.cell(x, y);\n        const tile = cell.highestPriorityTile();\n        return tile.index;\n    }\n    clear() {\n        this.map.cells.forEach((c) => c.clear());\n    }\n    hasItem(x, y) {\n        return this.map.cellInfo(x, y).hasItem();\n    }\n    makeRandomItem(tags) {\n        return GWM.item.makeRandom(tags);\n    }\n    addItem(x, y, item) {\n        return this.map.forceItem(x, y, item);\n    }\n    hasActor(x, y) {\n        return this.map.hasActor(x, y);\n    }\n    blocksMove(x, y) {\n        return this.map.cellInfo(x, y).blocksMove();\n    }\n    blocksVision(x, y) {\n        return this.map.cellInfo(x, y).blocksVision();\n    }\n    blocksDiagonal(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_DIAGONAL);\n    }\n    blocksPathing(x, y) {\n        const info = this.map.cellInfo(x, y);\n        return (info.hasEntityFlag(GWM.flags.Entity.L_BLOCKS_MOVE) ||\n            info.hasTileFlag(GWM.tile.flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksItems(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_ITEMS);\n    }\n    blocksEffects(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isWall(x, y) {\n        return this.map.cellInfo(x, y).isWall();\n    }\n    isStairs(x, y) {\n        return this.map.cellInfo(x, y).isStairs();\n    }\n    isSet(x, y) {\n        return this.hasXY(x, y) && !this.map.cell(x, y).isEmpty();\n    }\n    isDiggable(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.isEmpty())\n            return true;\n        if (cell.isWall())\n            return true;\n        return false;\n    }\n    isNothing(x, y) {\n        return this.hasXY(x, y) && this.map.cell(x, y).isEmpty();\n    }\n    isFloor(x, y) {\n        return this.isPassable(x, y);\n    }\n    isBridge(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_BRIDGE);\n    }\n    isDoor(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_IS_DOOR);\n    }\n    isSecretDoor(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    isDeep(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_DEEP_WATER);\n    }\n    isShallow(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        return (!!cell.depthTile(GWM.flags.Depth.LIQUID) &&\n            !cell.hasTileFlag(GWM.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    isAnyLiquid(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        return (cell.hasDepthTile(GWM.flags.Depth.LIQUID) ||\n            cell.hasTileFlag(GWM.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    isOccupied(x, y) {\n        return this.hasItem(x, y) || this.hasActor(x, y);\n    }\n    isPassable(x, y) {\n        const info = this.map.cellInfo(x, y);\n        return !(info.blocksMove() || info.blocksPathing());\n    }\n    // tileBlocksMove(tile: number): boolean {\n    //     return GWM.tile.get(tile).blocksMove();\n    // }\n    backup() {\n        const site = new MapSite(this.map.clone());\n        site.machineCount = this.machineCount;\n        return site;\n    }\n    restore(backup) {\n        this.map.copy(backup.map);\n        this.machineCount = backup.machineCount;\n    }\n    free() { }\n    getChokeCount(x, y) {\n        return this.map.cell(x, y).chokeCount;\n    }\n    setChokeCount(x, y, count) {\n        this.map.cell(x, y).chokeCount = count;\n    }\n    analyze() {\n        GWM.map.analyze(this.map);\n    }\n    fireEffect(effect, x, y) {\n        return GWM.effect.fireSync(effect, this.map, x, y);\n    }\n    nextMachineId() {\n        return ++this.machineCount;\n    }\n    getMachine(x, y) {\n        return this.map.cell(x, y).machineId;\n    }\n    setMachine(x, y, id, isRoom = true) {\n        this.map.cell(x, y).machineId = id;\n        if (id == 0) {\n            this.map.clearCellFlag(x, y, Flags.IS_IN_MACHINE);\n        }\n        else {\n            this.map.setCellFlag(x, y, isRoom ? Flags.IS_IN_ROOM_MACHINE : Flags.IS_IN_AREA_MACHINE);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\n// import * as TYPES from './types';\nconst DIRS = GWU.utils.DIRS;\n// export function attachRoom(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.utils.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GWU.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GWU.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GWU.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GWU.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GWU.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GWU.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GWU.utils.DIRS[dir][0];\n                    newY = j + GWU.utils.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GWU.utils.DIRS[dir][0];\n                        newY += GWU.utils.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GWU.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GWU.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GWU.grid.NumGrid,\n//     xy: GWU.utils.Loc,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.utils.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GWU.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GWU.grid.NumGrid,\n//     mapDoors: GWU.utils.Loc[],\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.utils.Loc[] {\n//     const doorIndexes = GWU.random.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GWU.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.utils.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = GWU.random.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GWU.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GWU.utils.Loc;\n//             //     return [x0, y0] as GWU.utils.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function copySite(dest, source, offsetX = 0, offsetY = 0) {\n    GWU.utils.forRect(dest.width, dest.height, (x, y) => {\n        const otherX = x - offsetX;\n        const otherY = y - offsetY;\n        const v = source.getTileIndex(otherX, otherY);\n        if (!v)\n            return;\n        dest.setTile(x, y, v);\n    });\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n}\nexport function siteDisruptedBy(site, blockingGrid, options = {}) {\n    var _a, _b, _c;\n    (_a = options.offsetX) !== null && _a !== void 0 ? _a : (options.offsetX = 0);\n    (_b = options.offsetY) !== null && _b !== void 0 ? _b : (options.offsetY = 0);\n    (_c = options.machine) !== null && _c !== void 0 ? _c : (options.machine = 0);\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + options.offsetX;\n        const lakeY = j + options.offsetY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (site.isPassable(i, j) &&\n            (site.getMachine(i, j) == 0 ||\n                site.getMachine(i, j) == options.machine)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function siteDisruptedSize(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n    // Get all walkable locations after lake added\n    GWU.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (disrupts)\n        return disrupts;\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                }\n                else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function computeDistanceMap(site, distanceMap, originX, originY, maxDistance) {\n    const costGrid = GWU.grid.alloc(site.width, site.height);\n    fillCostGrid(site, costGrid);\n    GWU.path.calculateDistances(distanceMap, originX, originY, costGrid, false, maxDistance + 1 // max distance is the same as max size of this blueprint\n    );\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GWU.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        // console.log('Hall', loc, d, length, width);\n        if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        // console.log(' - ', [this.x2, this.y2]);\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room extends GWU.utils.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GWU.utils.Loc[] | null;\n//     door: number;\n// }\n","import * as GWU from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GWU.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = SITE.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GWU.random.item.bind(GWU.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GWU.random.weighted.bind(GWU.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GWU.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GWU.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GWU.blob.Blob({\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GWU.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GWU.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GWU.utils.DOWN] = [\n            Math.floor(site.width / 2),\n            site.height - 2,\n        ];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GWU.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX +\n            GWU.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GWU.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GWU.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GWU.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GWU.utils.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GWU.utils.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GWU.utils.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GWU.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GWU.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GWU.random.chance(this.options.holeChance.value())) {\n            GWU.utils.forCircle(x, y, GWU.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GWU.utils.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GWU.random.range(minX, maxX);\n            y = GWU.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GWU.utils.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GWU.utils.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GWU.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GWU.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GWU.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GWU.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GWU.utils.UP || dir == GWU.utils.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GWU.utils.NO_DIRECTION;\n    if (dir == GWU.utils.NO_DIRECTION) {\n        const dirs = GWU.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GWU.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GWU.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GWU.range.make(1),\n            length: [GWU.range.make('2-15'), GWU.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GWU.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GWU.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || SITE.chooseRandomDoorSites(site);\n        if (!GWU.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GWU.utils.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = new TYPES.Hall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GWU.utils.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = new TYPES.Hall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: SITE.SHALLOW,\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = GWU.random.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GWU.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GWU.blob.Blob({\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GWU.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GWU.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    GWU.utils.forCircle(sx, sy, wreathSize, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GWU.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.utils.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n        const seq = GWU.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyLiquid(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyLiquid(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyLiquid(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GWU.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyLiquid(x, y))\n            return false;\n        if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc = null;\n        let downLoc = null;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GWU.random.matchingLocNear(GWU.utils.x(start), GWU.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GWU.random.matchingLocNear(GWU.utils.x(up), GWU.utils.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GWU.random.matchingLocNear(GWU.utils.x(down), GWU.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GWU.random.matchingLocNear(GWU.utils.x(up), GWU.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GWU.random.matchingLocNear(GWU.utils.x(down), GWU.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (GWU.utils.distanceBetween(x, y, downLoc[0], downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GWU.utils.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GWU.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GWU.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GWU.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GWU.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GWU.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GWU.utils.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n            doorChance: 50,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        SITE.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        const seq = GWU.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, SITE.FLOOR);\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            const tile = GWU.random.chance(this.options.doorChance)\n                                ? SITE.DOOR\n                                : SITE.FLOOR;\n                            site.setTile(x, y, tile); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nexport class Level {\n    constructor(options = {}) {\n        var _a, _b;\n        this.seed = 0;\n        this.rooms = {};\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        this.startLoc = [-1, -1];\n        this.endLoc = [-1, -1];\n        this.seed = options.seed || 0;\n        GWU.utils.setOptions(this.rooms, options.rooms);\n        // Doors\n        if (options.doors === false) {\n            options.doors = { chance: 0 };\n        }\n        else if (options.doors === true) {\n            options.doors = { chance: 100 };\n        }\n        GWU.utils.setOptions(this.doors, options.doors);\n        // Halls\n        if (options.halls === false) {\n            options.halls = { chance: 0 };\n        }\n        else if (options.halls === true) {\n            options.halls = {};\n        }\n        GWU.utils.setOptions(this.halls, options.halls);\n        // Loops\n        if (options.loops === false) {\n            this.loops = null;\n        }\n        else {\n            if (options.loops === true)\n                options.loops = {};\n            options.loops = options.loops || {};\n            options.loops.doorChance =\n                (_a = options.loops.doorChance) !== null && _a !== void 0 ? _a : (_b = options.doors) === null || _b === void 0 ? void 0 : _b.chance;\n            GWU.utils.setOptions(this.loops, options.loops);\n        }\n        // Lakes\n        if (options.lakes === false) {\n            this.lakes = null;\n        }\n        else {\n            if (options.lakes === true)\n                options.lakes = {};\n            GWU.utils.setOptions(this.lakes, options.lakes);\n        }\n        // Bridges\n        if (options.bridges === false) {\n            this.bridges = null;\n        }\n        else {\n            if (options.bridges === true)\n                options.bridges = {};\n            GWU.utils.setOptions(this.bridges, options.bridges);\n        }\n        // Stairs\n        if (options.stairs === false) {\n            this.stairs = null;\n        }\n        else {\n            if (options.stairs === true)\n                options.stairs = {};\n            GWU.utils.setOptions(this.stairs, options.stairs);\n        }\n        this.startLoc = options.startLoc || [-1, -1];\n        this.endLoc = options.endLoc || [-1, -1];\n    }\n    _makeSite(width, height) {\n        return new SITE.GridSite(width, height);\n    }\n    create(...args) {\n        if (args.length == 1 && args[0] instanceof GWM.map.Map) {\n            const map = args[0];\n            this.site = new SITE.MapSite(map);\n        }\n        if (args.length > 1) {\n            const width = args[0];\n            const height = args[1];\n            this.site = new SITE.GridSite(width, height);\n        }\n        const result = this._create(this.site);\n        if (args.length > 1) {\n            const width = args[0];\n            const height = args[1];\n            const cb = args[2];\n            GWU.utils.forRect(width, height, (x, y) => {\n                const t = this.site.getTileIndex(x, y);\n                if (t)\n                    cb(x, y, t);\n            });\n        }\n        this.site.free();\n        return result;\n    }\n    _create(site) {\n        if (this.startLoc[0] < 0 && this.startLoc[0] < 0) {\n            this.startLoc[0] = Math.floor(site.width / 2);\n            this.startLoc[1] = site.height - 2;\n        }\n        this.start(site);\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        let fails = 0;\n        while (fails < 20) {\n            if (this.addRoom(site)) {\n                fails = 0;\n            }\n            else {\n                ++fails;\n            }\n        }\n        if (this.loops)\n            this.addLoops(site, this.loops);\n        if (this.lakes)\n            this.addLakes(site, this.lakes);\n        if (this.bridges)\n            this.addBridges(site, this.bridges);\n        if (this.stairs)\n            this.addStairs(site, this.stairs);\n        this.finish(site);\n        return true;\n    }\n    start(site) {\n        if (this.seed) {\n            GWU.random.seed(this.seed);\n        }\n        site.clear();\n        this.seq = GWU.random.sequence(site.width * site.height);\n    }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addFirstRoom(site) {\n        const roomSite = this._makeSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.startLoc)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this._makeSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        if (room && !this._attachRoom(site, roomSite, room)) {\n            room = null;\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (let i = 0; i < this.seq.length; i++) {\n            const x = Math.floor(this.seq[i] / site.height);\n            const y = this.seq[i] % site.height;\n            if (!site.isNothing(x, y))\n                continue;\n            const dir = SITE.directionOfDoorSite(site, x, y);\n            if (dir != GWU.utils.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    SITE.copySite(site, roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = GWU.random.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                SITE.copySite(site, roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GWU.utils.Loc;\n                //     return [x0, y0] as GWU.utils.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n            for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.hasXY(i, j) ||\n                                map.isBoundaryXY(i, j) ||\n                                !map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(map, room, x, y, dir) {\n        const opts = this.doors;\n        let isDoor = false;\n        if (opts.chance && GWU.random.chance(opts.chance)) {\n            isDoor = true;\n        }\n        const tile = isDoor ? opts.tile || SITE.DOOR : SITE.FLOOR;\n        map.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n            return;\n        }\n        if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x - k, y)) {\n                    if (map.isSet(x - k, y - 1) && map.isSet(x - k, y + 1)) {\n                        map.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x + k, y)) {\n                    if (map.isSet(x + k, y - 1) && map.isSet(x + k, y + 1)) {\n                        map.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x, y - k)) {\n                    if (map.isSet(x - 1, y - k) && map.isSet(x + 1, y - k)) {\n                        map.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x, y + k)) {\n                    if (map.isSet(x - 1, y + k) && map.isSet(x + 1, y + k)) {\n                        map.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        return digger.create(site);\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < site.width - 1; i++) {\n                for (j = 0; j < site.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (!site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)) {\n                            if (GWU.random.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, SITE.FLOOR); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GWU.utils.forRect(site.width, site.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                if (\n                // TODO - isPassable\n                (site.isFloor(x + 1, y) || site.isFloor(x - 1, y)) &&\n                    (site.isFloor(x, y + 1) || site.isFloor(x, y - 1))) {\n                    // If there's passable terrain to the left or right, and there's passable terrain\n                    // above or below, then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                }\n                else if ((site.blocksPathing(x + 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x - 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x, y + 1) ? 1 : 0) +\n                    (site.blocksPathing(x, y - 1) ? 1 : 0) >=\n                    3) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? SITE.IMPREGNABLE : SITE.WALL;\n        GWU.utils.forRect(site.width, site.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, SITE.WALL);\n                }\n            }\n        });\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport * as STEP from './buildStep';\nconst Fl = GWU.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(10)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(7)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(0)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(2)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(3)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(4)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(5)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(6)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(8)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(9)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(14)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(11)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(12)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(13)] = \"BP_NO_INTERIOR_FLAG\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.flags = 0;\n        this.steps = [];\n        this.id = 'n/a';\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GWU.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            this.size = GWU.range.make(opts.size);\n            if (this.size.lo > this.size.hi)\n                throw new Error('Blueprint size must be small to large.');\n        }\n        else {\n            this.size = GWU.range.make([1, 1]); // Anything bigger makes weird things happen\n        }\n        if (opts.flags) {\n            this.flags = GWU.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n        }\n        if (this.flags & Flags.BP_ADOPT_ITEM) {\n            if (!this.steps.some((s) => s.flags & STEP.StepFlags.BF_ADOPT_ITEM)) {\n                throw new Error('Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.');\n            }\n        }\n    }\n    getChance(level, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return 0;\n        }\n        return this.frequency(level);\n    }\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n    qualifies(requiredFlags, depth) {\n        if (this.frequency(depth) <= 0 ||\n            // Must have the required flags:\n            ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags) {\n            return false;\n        }\n        return true;\n    }\n    pickLocation(site) {\n        // Find a location and map out the machine interior.\n        if (this.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n            const randSite = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                return (site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE) &&\n                    this.size.contains(site.getChokeCount(x, y)));\n            });\n            if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n                // If no suitable sites, abort.\n                console.log('Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint.');\n                return false;\n            }\n            return randSite;\n        }\n        else if (this.isVestiblue) {\n            //  Door machines must have locations passed in. We can't pick one ourselves.\n            console.log('ERROR: Attempted to build a vestiblue without a location being provided.');\n            return false;\n        }\n        // Pick a random origin location.\n        const pos = GWU.random.matchingLoc(site.width, site.height, (x, y) => site.isPassable(x, y));\n        if (!pos || pos[0] < 0 || pos[1] < 0)\n            return false;\n        return pos;\n    }\n    // Assume site has been analyzed (aka GateSites and ChokeCounts set)\n    computeInterior(builder) {\n        let failsafe = this.isRoom ? 10 : 20;\n        let tryAgain;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            tryAgain = false;\n            if (--failsafe <= 0) {\n                console.log('Failed to build a machine; failed repeatedly to find a suitable blueprint location.');\n                return false;\n            }\n            interior.fill(0);\n            // Find a location and map out the machine interior.\n            if (this.isRoom) {\n                // If it's a room machine, count up the gates of appropriate\n                // choke size and remember where they are. The origin of the room will be the gate location.\n                // Now map out the interior into interior[][].\n                // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n                // same or lower choke value, ignoring any tiles that are already part of a machine.\n                // If we get false from this, try again. If we've tried too many times already, abort.\n                tryAgain = !this.addTileToInteriorAndIterate(builder, builder.originX, builder.originY);\n            }\n            else if (this.isVestiblue) {\n                if (!this.computeInteriorForVestibuleMachine(builder)) {\n                    // TODO - tryagain = true?\n                    console.error('ERROR: Attempted to build a door machine from blueprint: not enough room.');\n                    return false;\n                }\n                // success\n            }\n            else {\n                // Find a location and map out the interior for a non-room machine.\n                // The strategy here is simply to pick a random location on the map,\n                // expand it along a pathing map by one space in all directions until the size reaches\n                // the chosen size, and then make sure the resulting space qualifies.\n                // If not, try again. If we've tried too many times already, abort.\n                let distanceMap = GWU.grid.alloc(interior.width, interior.height);\n                SITE.computeDistanceMap(site, distanceMap, builder.originX, builder.originY, this.size.hi);\n                const seq = GWU.random.sequence(site.width * site.height);\n                let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n                let totalFreq = this.size.value(); // Keeps track of the goal size.\n                for (let k = 0; k < 1000 && qualifyingTileCount < totalFreq; k++) {\n                    for (let n = 0; n < seq.length && qualifyingTileCount < totalFreq; n++) {\n                        const i = Math.floor(seq[n] / site.height);\n                        const j = seq[n] % site.height;\n                        if (distanceMap[i][j] == k) {\n                            interior[i][j] = 1;\n                            qualifyingTileCount++;\n                            if (site.isOccupied(i, j) ||\n                                site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)) {\n                                // Abort if we've entered another machine or engulfed another machine's item or monster.\n                                tryAgain = true;\n                                qualifyingTileCount = totalFreq; // This is a hack to drop out of these three for-loops.\n                            }\n                        }\n                    }\n                }\n                // Now make sure the interior map satisfies the machine's qualifications.\n                if (qualifyingTileCount < totalFreq) {\n                    tryAgain = true;\n                    console.log('too small');\n                }\n                else if (this.treatAsBlocking &&\n                    SITE.siteDisruptedBy(site, interior, {\n                        machine: site.machineCount,\n                    })) {\n                    console.log('disconnected');\n                    tryAgain = true;\n                }\n                else if (this.requireBlocking &&\n                    SITE.siteDisruptedSize(site, interior) < 100) {\n                    console.log('not disconnected enough');\n                    tryAgain = true; // BP_REQUIRE_BLOCKING needs some work to make sure the disconnect is interesting.\n                }\n                // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n                // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n                GWU.grid.free(distanceMap);\n            }\n            // Now loop if necessary.\n        } while (tryAgain);\n        // console.log(tryAgain, failsafe);\n        return true;\n    }\n    // Assumes (startX, startY) is in the machine.\n    // Returns true if everything went well, and false if we ran into a machine component\n    // that was already there, as we don't want to build a machine around it.\n    addTileToInteriorAndIterate(builder, startX, startY) {\n        let goodSoFar = true;\n        const interior = builder.interior;\n        const site = builder.site;\n        interior[startX][startY] = 1;\n        const startChokeCount = site.getChokeCount(startX, startY);\n        for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n            const newX = startX + GWU.utils.DIRS[dir][0];\n            const newY = startY + GWU.utils.DIRS[dir][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            if (interior[newX][newY])\n                continue; // already done\n            if (site.isOccupied(newX, newY) ||\n                (site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_IN_MACHINE) &&\n                    !site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_GATE_SITE))) {\n                // Abort if there's an item in the room.\n                // Items haven't been populated yet, so the only way this could happen is if another machine\n                // previously placed an item here.\n                // Also abort if we're touching another machine at any point other than a gate tile.\n                return false;\n            }\n            if (site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n                !site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_IN_MACHINE)) {\n                goodSoFar = this.addTileToInteriorAndIterate(builder, newX, newY);\n            }\n        }\n        return goodSoFar;\n    }\n    computeInteriorForVestibuleMachine(builder) {\n        let success = true;\n        const site = builder.site;\n        const interior = builder.interior;\n        interior.fill(0);\n        // console.log('DISTANCE MAP', originX, originY);\n        // RUT.Grid.dump(distMap);\n        const doorChokeCount = site.getChokeCount(builder.originX, builder.originY);\n        const vestibuleLoc = [-1, -1];\n        let vestibuleChokeCount = doorChokeCount;\n        GWU.utils.eachNeighbor(builder.originX, builder.originY, (x, y) => {\n            const count = site.getChokeCount(x, y);\n            if (count == doorChokeCount)\n                return;\n            if (count > 10000)\n                return;\n            if (count < 0)\n                return;\n            vestibuleLoc[0] = x;\n            vestibuleLoc[1] = y;\n            vestibuleChokeCount = count;\n        }, true);\n        const roomSize = vestibuleChokeCount - doorChokeCount;\n        if (this.size.contains(roomSize)) {\n            // The room entirely fits within the vestibule desired size\n            const count = interior.floodFill(vestibuleLoc[0], vestibuleLoc[1], (_v, i, j) => {\n                if (site.isOccupied(i, j)) {\n                    success = false;\n                }\n                return site.getChokeCount(i, j) === vestibuleChokeCount;\n            }, 1);\n            if (success && this.size.contains(count))\n                return true;\n        }\n        let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n        const wantSize = this.size.value(); // Keeps track of the goal size.\n        const distMap = GWU.grid.alloc(site.width, site.height);\n        SITE.computeDistanceMap(site, distMap, builder.originX, builder.originY, this.size.hi);\n        const cells = GWU.random.sequence(site.width * site.height);\n        success = true;\n        for (let k = 0; k < 1000 && qualifyingTileCount < wantSize; k++) {\n            for (let i = 0; i < cells.length && qualifyingTileCount < wantSize; ++i) {\n                const x = Math.floor(cells[i] / site.height);\n                const y = cells[i] % site.height;\n                const dist = distMap[x][y];\n                if (dist != k)\n                    continue;\n                if (site.isOccupied(x, y)) {\n                    success = false;\n                    qualifyingTileCount = wantSize;\n                }\n                if (site.getChokeCount(x, y) <= doorChokeCount)\n                    continue;\n                interior[x][y] = 1;\n                qualifyingTileCount += 1;\n            }\n        }\n        // Now make sure the interior map satisfies the machine's qualifications.\n        if (this.treatAsBlocking &&\n            SITE.siteDisruptedBy(site, interior, { machine: site.machineCount })) {\n            success = false;\n        }\n        else if (this.requireBlocking &&\n            SITE.siteDisruptedSize(site, interior) < 100) {\n            success = false;\n        }\n        GWU.grid.free(distMap);\n        return success;\n    }\n    prepareInteriorWithMachineFlags(builder) {\n        const interior = builder.interior;\n        const site = builder.site;\n        // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n        if (this.maximizeInterior) {\n            this.expandMachineInterior(builder, 1);\n        }\n        else if (this.openInterior) {\n            this.expandMachineInterior(builder, 4);\n        }\n        // If requested, cleanse the interior -- no interesting terrain allowed.\n        if (this.purgeInterior) {\n            interior.forEach((v, x, y) => {\n                if (v)\n                    site.setTile(x, y, SITE.FLOOR);\n            });\n        }\n        // If requested, purge pathing blockers -- no traps allowed.\n        if (this.purgeBlockers) {\n            interior.forEach((v, x, y) => {\n                if (!v)\n                    return;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n            });\n        }\n        // If requested, purge the liquid layer in the interior -- no liquids allowed.\n        if (this.purgeLiquids) {\n            interior.forEach((v, x, y) => {\n                if (v && site.isAnyLiquid(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n            });\n        }\n        // Surround with walls if requested.\n        if (this.surroundWithWalls) {\n            interior.forEach((v, x, y) => {\n                if (!v || site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE))\n                    return;\n                GWU.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not valid x,y\n                    if (interior[i][j])\n                        return; // is part of machine\n                    if (site.isWall(i, j))\n                        return; // is already a wall (of some sort)\n                    if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_GATE_SITE))\n                        return; // is a door site\n                    if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE))\n                        return; // is part of a machine\n                    if (!site.blocksPathing(i, j))\n                        return; // is not a blocker for the player (water?)\n                    site.setTile(i, j, SITE.WALL);\n                }, false);\n            });\n        }\n        // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n        // Then zero out any portion of the interior that is still wall.\n        // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n        //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n        // }\n        // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n        if (this.makeImpregnable) {\n            interior.forEach((v, x, y) => {\n                if (!v || site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE))\n                    return;\n                site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n                GWU.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (interior[i][j])\n                        return;\n                    if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_GATE_SITE))\n                        return;\n                    site.setCellFlag(i, j, GWM.flags.Cell.IMPREGNABLE);\n                }, false);\n            });\n        }\n        // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n        const machineNumber = builder.machineNumber;\n        interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            if (!(this.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n                site.setMachine(x, y, machineNumber, this.isRoom);\n            }\n            // secret doors mess up machines\n            // TODO - is this still true?\n            if (site.isSecretDoor(x, y)) {\n                site.setTile(x, y, SITE.DOOR);\n            }\n        });\n    }\n    expandMachineInterior(builder, minimumInteriorNeighbors = 1) {\n        let madeChange;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            madeChange = false;\n            interior.forEach((_v, x, y) => {\n                // if (v && site.isDoor(x, y)) {\n                //     site.setTile(x, y, SITE.FLOOR); // clean out the doors...\n                //     return;\n                // }\n                if (site.hasCellFlag(x, y, GWM.flags.Cell.IS_IN_MACHINE))\n                    return;\n                if (!site.blocksPathing(x, y))\n                    return;\n                let nbcount = 0;\n                GWU.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not in map\n                    if (interior[i][j] && !site.blocksPathing(i, j)) {\n                        ++nbcount; // in machine and open tile\n                    }\n                }, false);\n                if (nbcount < minimumInteriorNeighbors)\n                    return;\n                nbcount = 0;\n                GWU.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // not on map\n                    if (interior[i][j])\n                        return; // already part of machine\n                    if (!site.isWall(i, j) ||\n                        site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)) {\n                        ++nbcount; // tile is not a wall or is in a machine\n                    }\n                }, false);\n                if (nbcount)\n                    return;\n                // Eliminate this obstruction; welcome its location into the machine.\n                madeChange = true;\n                interior[x][y] = 1;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, SITE.FLOOR);\n                }\n                GWU.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (site.isSet(i, j))\n                        return;\n                    site.setTile(i, j, SITE.WALL);\n                });\n            });\n        } while (madeChange);\n    }\n    calcDistances(builder) {\n        builder.distanceMap.fill(0);\n        SITE.computeDistanceMap(builder.site, builder.distanceMap, builder.originX, builder.originY, this.size.hi);\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n        builder.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const dist = builder.distanceMap[x][y];\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            }\n            else {\n                distance25 -= distances[i];\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            }\n            else {\n                distance75 -= distances[i];\n            }\n        }\n        builder.distance25 = distance25;\n        builder.distance75 = distance75;\n    }\n    pickComponents() {\n        const alternativeFlags = [\n            STEP.StepFlags.BF_ALTERNATIVE,\n            STEP.StepFlags.BF_ALTERNATIVE_2,\n        ];\n        const keepFeature = new Array(this.steps.length).fill(true);\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = GWU.random.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n    clearInteriorFlag(builder) {\n        const site = builder.site;\n        for (let i = 0; i < site.width; i++) {\n            for (let j = 0; j < site.height; j++) {\n                if (site.getMachine(i, j) == builder.machineNumber &&\n                    !site.hasCellFlag(i, j, GWM.flags.Cell.IS_WIRED |\n                        GWM.flags.Cell.IS_CIRCUIT_BREAKER)) {\n                    site.setMachine(i, j, 0);\n                }\n            }\n        }\n    }\n}\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\nexport function random(requiredFlags, depth) {\n    const matches = Object.values(blueprints).filter((b) => b.qualifies(requiredFlags, depth));\n    return GWU.random.item(matches);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport { Flags } from './blueprint';\nconst Fl = GWU.flag.fl;\nexport var StepFlags;\n(function (StepFlags) {\n    StepFlags[StepFlags[\"BF_OUTSOURCE_ITEM_TO_MACHINE\"] = Fl(1)] = \"BF_OUTSOURCE_ITEM_TO_MACHINE\";\n    StepFlags[StepFlags[\"BF_BUILD_VESTIBULE\"] = Fl(2)] = \"BF_BUILD_VESTIBULE\";\n    StepFlags[StepFlags[\"BF_ADOPT_ITEM\"] = Fl(3)] = \"BF_ADOPT_ITEM\";\n    StepFlags[StepFlags[\"BF_BUILD_AT_ORIGIN\"] = Fl(4)] = \"BF_BUILD_AT_ORIGIN\";\n    StepFlags[StepFlags[\"BF_PERMIT_BLOCKING\"] = Fl(5)] = \"BF_PERMIT_BLOCKING\";\n    StepFlags[StepFlags[\"BF_TREAT_AS_BLOCKING\"] = Fl(6)] = \"BF_TREAT_AS_BLOCKING\";\n    StepFlags[StepFlags[\"BF_NEAR_ORIGIN\"] = Fl(7)] = \"BF_NEAR_ORIGIN\";\n    StepFlags[StepFlags[\"BF_FAR_FROM_ORIGIN\"] = Fl(8)] = \"BF_FAR_FROM_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_VIEW_OF_ORIGIN\"] = Fl(9)] = \"BF_IN_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_PASSABLE_VIEW_OF_ORIGIN\"] = Fl(10)] = \"BF_IN_PASSABLE_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_MONSTER_TAKE_ITEM\"] = Fl(11)] = \"BF_MONSTER_TAKE_ITEM\";\n    StepFlags[StepFlags[\"BF_MONSTER_SLEEPING\"] = Fl(12)] = \"BF_MONSTER_SLEEPING\";\n    StepFlags[StepFlags[\"BF_MONSTER_FLEEING\"] = Fl(13)] = \"BF_MONSTER_FLEEING\";\n    StepFlags[StepFlags[\"BF_MONSTERS_DORMANT\"] = Fl(14)] = \"BF_MONSTERS_DORMANT\";\n    StepFlags[StepFlags[\"BF_ITEM_IS_KEY\"] = Fl(15)] = \"BF_ITEM_IS_KEY\";\n    StepFlags[StepFlags[\"BF_ITEM_IDENTIFIED\"] = Fl(16)] = \"BF_ITEM_IDENTIFIED\";\n    StepFlags[StepFlags[\"BF_ITEM_PLAYER_AVOIDS\"] = Fl(17)] = \"BF_ITEM_PLAYER_AVOIDS\";\n    StepFlags[StepFlags[\"BF_EVERYWHERE\"] = Fl(18)] = \"BF_EVERYWHERE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE\"] = Fl(19)] = \"BF_ALTERNATIVE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE_2\"] = Fl(20)] = \"BF_ALTERNATIVE_2\";\n    StepFlags[StepFlags[\"BF_BUILD_IN_WALLS\"] = Fl(21)] = \"BF_BUILD_IN_WALLS\";\n    StepFlags[StepFlags[\"BF_BUILD_ANYWHERE_ON_LEVEL\"] = Fl(22)] = \"BF_BUILD_ANYWHERE_ON_LEVEL\";\n    StepFlags[StepFlags[\"BF_REPEAT_UNTIL_NO_PROGRESS\"] = Fl(23)] = \"BF_REPEAT_UNTIL_NO_PROGRESS\";\n    StepFlags[StepFlags[\"BF_IMPREGNABLE\"] = Fl(24)] = \"BF_IMPREGNABLE\";\n    // TODO - BF_ALLOW_IN_HALLWAY instead?\n    StepFlags[StepFlags[\"BF_NOT_IN_HALLWAY\"] = Fl(27)] = \"BF_NOT_IN_HALLWAY\";\n    // TODO - BF_ALLOW_BOUNDARY instead\n    StepFlags[StepFlags[\"BF_NOT_ON_LEVEL_PERIMETER\"] = Fl(28)] = \"BF_NOT_ON_LEVEL_PERIMETER\";\n    StepFlags[StepFlags[\"BF_SKELETON_KEY\"] = Fl(29)] = \"BF_SKELETON_KEY\";\n    StepFlags[StepFlags[\"BF_KEY_DISPOSABLE\"] = Fl(30)] = \"BF_KEY_DISPOSABLE\";\n})(StepFlags || (StepFlags = {}));\nexport class BuildStep {\n    constructor(cfg = {}) {\n        var _a;\n        this.tile = -1;\n        this.flags = 0;\n        this.pad = 0;\n        this.item = null;\n        this.horde = null;\n        this.effect = null;\n        this.chance = 0;\n        this.id = 'n/a';\n        this.tile = (_a = cfg.tile) !== null && _a !== void 0 ? _a : -1;\n        if (cfg.flags) {\n            this.flags = GWU.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GWU.range.make(cfg.count || 1);\n        this.item = cfg.item || null;\n        this.horde = cfg.horde || null;\n        if (cfg.effect) {\n            this.effect = GWM.effect.from(cfg.effect);\n        }\n        if (this.item && this.flags & StepFlags.BF_ADOPT_ITEM) {\n            throw new Error('Cannot have blueprint step with item and BF_ADOPT_ITEM.');\n        }\n    }\n    get repeatUntilNoProgress() {\n        return !!(this.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS);\n    }\n    cellIsCandidate(builder, blueprint, x, y, distanceBound) {\n        const site = builder.site;\n        // No building in the hallway if it's prohibited.\n        // This check comes before the origin check, so an area machine will fail altogether\n        // if its origin is in a hallway and the feature that must be built there does not permit as much.\n        if (this.flags & StepFlags.BF_NOT_IN_HALLWAY &&\n            GWU.utils.arcCount(x, y, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n            return false;\n        }\n        // No building along the perimeter of the level if it's prohibited.\n        if (this.flags & StepFlags.BF_NOT_ON_LEVEL_PERIMETER &&\n            (x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1)) {\n            return false;\n        }\n        // The origin is a candidate if the feature is flagged to be built at the origin.\n        // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n        if (this.flags & StepFlags.BF_BUILD_AT_ORIGIN) {\n            return x == builder.originX && y == builder.originY ? true : false;\n        }\n        else if (blueprint.isRoom &&\n            x == builder.originX &&\n            y == builder.originY) {\n            return false;\n        }\n        // No building in another feature's personal space!\n        if (builder.occupied[x][y]) {\n            return false;\n        }\n        // Must be in the viewmap if the appropriate flag is set.\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n            !builder.viewMap[x][y]) {\n            return false;\n        }\n        // Do a distance check if the feature requests it.\n        let distance = 10000;\n        if (site.isWall(x, y)) {\n            // Distance is calculated for walls too.\n            GWU.utils.eachNeighbor(x, y, (i, j) => {\n                if (!builder.distanceMap.hasXY(i, j))\n                    return;\n                if (!site.blocksPathing(i, j) &&\n                    distance > builder.distanceMap[i][j] + 1) {\n                    distance = builder.distanceMap[i][j] + 1;\n                }\n            }, true);\n        }\n        else {\n            distance = builder.distanceMap[x][y];\n        }\n        if (distance > distanceBound[1] || // distance exceeds max\n            distance < distanceBound[0]) {\n            // distance falls short of min\n            return false;\n        }\n        if (this.flags & StepFlags.BF_BUILD_IN_WALLS) {\n            // If we're supposed to build in a wall...\n            const cellMachine = site.getMachine(x, y);\n            if (!builder.interior[x][y] &&\n                (!cellMachine || cellMachine == builder.machineNumber) &&\n                site.isWall(x, y)) {\n                let ok = false;\n                // ...and this location is a wall that's not already machined...\n                GWU.utils.eachNeighbor(x, y, (newX, newY) => {\n                    if (site.hasXY(newX, newY) && // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                        ((builder.interior[newX][newY] &&\n                            !(newX == builder.originX &&\n                                newY == builder.originY)) ||\n                            (this.flags &\n                                StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL &&\n                                !site.blocksPathing(newX, newY) &&\n                                !site.getMachine(newX, newY)))) {\n                        ok = true;\n                    }\n                });\n                return ok;\n            }\n            return false;\n        }\n        else if (site.isWall(x, y)) {\n            // Can't build in a wall unless instructed to do so.\n            return false;\n        }\n        else if (this.flags & StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL) {\n            if ((this.item && site.blocksItems(x, y)) ||\n                site.hasCellFlag(x, y, GWM.flags.Cell.IS_CHOKEPOINT |\n                    GWM.flags.Cell.IS_IN_LOOP |\n                    GWM.flags.Cell.IS_IN_MACHINE)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        else if (builder.interior[x][y]) {\n            return true;\n        }\n        return false;\n    }\n    makePersonalSpace(builder, x, y, candidates) {\n        const personalSpace = this.pad;\n        let count = 0;\n        for (let i = x - personalSpace + 1; i <= x + personalSpace - 1; i++) {\n            for (let j = y - personalSpace + 1; j <= y + personalSpace - 1; j++) {\n                if (builder.site.hasXY(i, j)) {\n                    if (candidates[i][j]) {\n                        candidates[i][j] = 0;\n                        ++count;\n                    }\n                    builder.occupied[i][j] = 1;\n                }\n            }\n        }\n        return count;\n    }\n    get generateEverywhere() {\n        return !!(this.flags &\n            StepFlags.BF_EVERYWHERE &\n            ~StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n    get buildAtOrigin() {\n        return !!(this.flags & StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n    distanceBound(builder) {\n        const distanceBound = [0, 10000];\n        if (this.flags & StepFlags.BF_NEAR_ORIGIN) {\n            distanceBound[1] = builder.distance25;\n        }\n        if (this.flags & StepFlags.BF_FAR_FROM_ORIGIN) {\n            distanceBound[0] = builder.distance75;\n        }\n        return distanceBound;\n    }\n    updateViewMap(builder) {\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN)) {\n            const site = builder.site;\n            if (this.flags & StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) {\n                const fov = new GWU.fov.FOV({\n                    isBlocked: (x, y) => {\n                        return site.blocksPathing(x, y);\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            else {\n                const fov = new GWU.fov.FOV({\n                    // TileFlags.T_OBSTRUCTS_PASSABILITY |\n                    //     TileFlags.T_OBSTRUCTS_VISION,\n                    isBlocked: (x, y) => {\n                        return (site.blocksPathing(x, y) || site.blocksVision(x, y));\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            builder.viewMap[builder.originX][builder.originY] = 1;\n        }\n    }\n    markCandidates(candidates, builder, blueprint, distanceBound) {\n        let count = 0;\n        candidates.update((_v, i, j) => {\n            if (this.cellIsCandidate(builder, blueprint, i, j, distanceBound)) {\n                count++;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        return count;\n    }\n    build(builder, blueprint) {\n        let wantCount = 0;\n        let builtCount = 0;\n        const site = builder.site;\n        const candidates = GWU.grid.alloc(site.width, site.height);\n        // Figure out the distance bounds.\n        const distanceBound = this.distanceBound(builder);\n        this.updateViewMap(builder);\n        // If the StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n        // Make a master map of candidate locations for this feature.\n        let qualifyingTileCount = this.markCandidates(candidates, builder, blueprint, distanceBound);\n        if (!this.generateEverywhere) {\n            wantCount = this.count.value();\n        }\n        if (!qualifyingTileCount || qualifyingTileCount < this.count.lo) {\n            console.warn('Only %s qualifying tiles - want at least %s.', qualifyingTileCount, this.count.lo);\n            return false;\n        }\n        let x = 0, y = 0;\n        let success = true;\n        do {\n            success = true;\n            // Find a location for the feature.\n            if (this.buildAtOrigin) {\n                // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                x = builder.originX;\n                y = builder.originY;\n            }\n            else {\n                // Pick our candidate location randomly, and also strike it from\n                // the candidates map so that subsequent instances of this same feature can't choose it.\n                [x, y] = GWU.random.matchingLoc(candidates.width, candidates.height, (x, y) => candidates[x][y] > 0);\n            }\n            // Don't waste time trying the same place again whether or not this attempt succeeds.\n            candidates[x][y] = 0;\n            qualifyingTileCount--;\n            // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n            if (this.effect) {\n                success = site.fireEffect(this.effect, x, y);\n            }\n            // Now try to place the terrain tile, if any.\n            if (success && this.tile !== -1) {\n                const tile = GWM.tile.get(this.tile);\n                if (!(this.flags & StepFlags.BF_PERMIT_BLOCKING) &&\n                    (tile.blocksMove() ||\n                        this.flags & StepFlags.BF_TREAT_AS_BLOCKING)) {\n                    // Yes, check for blocking.\n                    const blockingMap = GWU.grid.alloc(site.width, site.height);\n                    blockingMap[x][y] = 1;\n                    success = !SITE.siteDisruptedBy(site, blockingMap, {\n                        machine: site.machineCount,\n                    });\n                    GWU.grid.free(blockingMap);\n                }\n                if (success) {\n                    site.setTile(x, y, tile);\n                }\n            }\n            // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n            if (success) {\n                qualifyingTileCount -= this.makePersonalSpace(builder, x, y, candidates);\n                builtCount++; // we've placed an instance\n                //DEBUG printf(\"\\nPlaced instance #%i of feature %i at (%i, %i).\", instance, feat, featX, featY);\n            }\n            // Generate an actor, if necessary\n            // Generate an item, if necessary\n            if (success && this.item) {\n                const item = site.makeRandomItem(this.item);\n                if (!item) {\n                    success = false;\n                }\n                if (this.flags & StepFlags.BF_ITEM_IS_KEY) {\n                    item.key = GWM.entity.makeKeyInfo(x, y, !!(this.flags & StepFlags.BF_KEY_DISPOSABLE));\n                }\n                if (this.flags & StepFlags.BF_OUTSOURCE_ITEM_TO_MACHINE) {\n                    success = builder.buildRandom(Flags.BP_ADOPT_ITEM, -1, -1, item);\n                }\n                else {\n                    success = site.addItem(x, y, item);\n                }\n            }\n            else if (success && this.flags & StepFlags.BF_ADOPT_ITEM) {\n                // adopt item if necessary\n                if (!builder.adoptedItem) {\n                    throw new Error('Failed to build blueprint because there is no adopted item.');\n                }\n                if (this.flags & StepFlags.BF_TREAT_AS_BLOCKING) {\n                    // Yes, check for blocking.\n                    const blockingMap = GWU.grid.alloc(site.width, site.height);\n                    blockingMap[x][y] = 1;\n                    success = !SITE.siteDisruptedBy(site, blockingMap);\n                    GWU.grid.free(blockingMap);\n                }\n                success = success && site.addItem(x, y, builder.adoptedItem);\n                if (success) {\n                    builder.adoptedItem = null;\n                }\n            }\n            if (success) {\n                // Proceed only if the terrain stuff for this instance succeeded.\n                // Mark the feature location as part of the machine, in case it is not already inside of it.\n                if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n                    site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n                }\n                // Mark the feature location as impregnable if requested.\n                if (this.flags & StepFlags.BF_IMPREGNABLE) {\n                    site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n                }\n            }\n            // Finished with this instance!\n        } while (qualifyingTileCount > 0 &&\n            (this.generateEverywhere ||\n                builtCount < wantCount ||\n                this.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS));\n        success = builtCount > 0;\n        if (this.flags & StepFlags.BF_BUILD_VESTIBULE) {\n            // Generate a door guard machine.\n            // Try to create a sub-machine that qualifies.\n            success = builder.buildRandom(Flags.BP_VESTIBULE, builder.originX, builder.originY);\n            if (!success) {\n                console.log(`Depth ${builder.depth}: Failed to place blueprint ${blueprint.id} because it requires a vestibule and we couldn't place one.`);\n                // failure! abort!\n                return false;\n            }\n        }\n        //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n        //DEBUG logBuffer(candidates);\n        GWU.grid.free(candidates);\n        return success;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from '../site';\nimport * as BLUE from './blueprint';\n// export interface BuildData {\n//     site: SITE.BuildSite;\n//     spawnedItems: any[];\n//     spawnedHordes: any[];\n//     interior: GWU.grid.NumGrid;\n//     occupied: GWU.grid.NumGrid;\n//     viewMap: GWU.grid.NumGrid;\n//     distanceMap: GWU.grid.NumGrid;\n//     originX: number;\n//     originY: number;\n//     distance25: number;\n//     distance75: number;\n//     machineNumber: number;\n// }\nexport class Builder {\n    constructor(map, depth) {\n        this.map = map;\n        this.depth = depth;\n        this.spawnedItems = [];\n        this.spawnedHordes = [];\n        this.originX = -1;\n        this.originY = -1;\n        this.distance25 = -1;\n        this.distance75 = -1;\n        this.machineNumber = 0;\n        this.adoptedItem = null;\n        this.site = new SITE.MapSite(map);\n        this.interior = GWU.grid.alloc(map.width, map.height);\n        this.occupied = GWU.grid.alloc(map.width, map.height);\n        this.viewMap = GWU.grid.alloc(map.width, map.height);\n        this.distanceMap = GWU.grid.alloc(map.width, map.height);\n    }\n    free() {\n        GWU.grid.free(this.interior);\n        GWU.grid.free(this.occupied);\n        GWU.grid.free(this.viewMap);\n        GWU.grid.free(this.distanceMap);\n    }\n    buildRandom(requiredMachineFlags = BLUE.Flags.BP_ROOM, x = -1, y = -1, adoptedItem = null) {\n        let tries = 10;\n        while (tries--) {\n            const blueprint = BLUE.random(requiredMachineFlags, this.depth);\n            if (!blueprint) {\n                continue;\n            }\n            if (this.build(blueprint, x, y, adoptedItem)) {\n                return true;\n            }\n        }\n        console.log('Failed to find blueprint matching flags: ' +\n            GWU.flag.toString(BLUE.Flags, requiredMachineFlags));\n        return false;\n    }\n    build(blueprint, x = -1, y = -1, adoptedItem = null) {\n        let tries = 10;\n        this.site.analyze();\n        if (x >= 0 && y >= 0) {\n            return this._build(blueprint, x, y, adoptedItem);\n        }\n        while (tries--) {\n            const loc = blueprint.pickLocation(this.site);\n            if (!loc) {\n                continue;\n            }\n            if (this._build(blueprint, loc[0], loc[1], adoptedItem)) {\n                this.adoptedItem = null;\n                return true;\n            }\n        }\n        console.log('Failed to build blueprint.');\n        return false;\n    }\n    //////////////////////////////////////////\n    // Returns true if the machine got built; false if it was aborted.\n    // If empty array spawnedItems or spawnedMonsters is given, will pass those back for deletion if necessary.\n    _build(blueprint, originX, originY, adoptedItem = null) {\n        this.interior.fill(0);\n        this.occupied.fill(0);\n        this.viewMap.fill(0);\n        this.distanceMap.fill(0);\n        this.originX = originX;\n        this.originY = originY;\n        this.adoptedItem = adoptedItem;\n        if (!blueprint.computeInterior(this)) {\n            this.adoptedItem = null;\n            return false;\n        }\n        // This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.\n        const levelBackup = this.site.backup();\n        this.machineNumber = this.site.nextMachineId(); // Reserve this machine number, starting with 1.\n        // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.\n        blueprint.prepareInteriorWithMachineFlags(this);\n        // Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)\n        // and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.\n        blueprint.calcDistances(this);\n        // Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.\n        // Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.\n        const components = blueprint.pickComponents();\n        // Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.\n        // Now tick through the features and build them.\n        for (let index = 0; index < components.length; index++) {\n            const component = components[index];\n            // console.log('BUILD COMPONENT', component);\n            if (!component.build(this, blueprint)) {\n                // failure! abort!\n                console.log('Failed to place blueprint because of step failure.');\n                // Restore the map to how it was before we touched it.\n                this.site.restore(levelBackup);\n                // abortItemsAndMonsters(spawnedItems, spawnedMonsters);\n                this.adoptedItem = null;\n                return false;\n            }\n        }\n        // Clear out the interior flag for all non-wired cells, if requested.\n        if (blueprint.noInteriorFlag) {\n            blueprint.clearInteriorFlag(this);\n        }\n        // if (torchBearer && torch) {\n        // \tif (torchBearer->carriedItem) {\n        // \t\tdeleteItem(torchBearer->carriedItem);\n        // \t}\n        // \tremoveItemFromChain(torch, floorItems);\n        // \ttorchBearer->carriedItem = torch;\n        // }\n        // console.log('Built a machine from blueprint:', originX, originY);\n        this.adoptedItem = null;\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as LEVEL from './level';\nexport class Dungeon {\n    constructor(options = {}) {\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { count: 20, digger: 'DEFAULT' },\n            halls: {},\n            loops: {},\n            lakes: {},\n            bridges: {},\n            stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GWU.utils.setOptions(this.config, options);\n        if (this.config.seed) {\n            GWU.random.seed(this.config.seed);\n        }\n        this.initSeeds();\n        this.initStairLocs();\n    }\n    get levels() {\n        return this.config.levels;\n    }\n    initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GWU.random.number(2 ** 32);\n        }\n    }\n    initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        for (let i = 0; i < this.config.levels; ++i) {\n            const endLoc = GWU.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                return (GWU.utils.distanceBetween(startLoc[0], startLoc[1], x, y) > minDistance);\n            });\n            this.stairLocs.push([\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ]);\n            startLoc = endLoc;\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        GWU.random.seed(this.seeds[id]);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && rooms.entrance) {\n            rooms.first = rooms.entrance;\n        }\n        const levelOpts = {\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            width: this.config.width,\n            height: this.config.height,\n        };\n        return this.makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    makeLevel(id, opts, cb) {\n        const level = new LEVEL.Level(opts);\n        const result = level.create(this.config.width, this.config.height, cb);\n        if (!GWU.utils.equalsXY(level.endLoc, opts.endLoc) ||\n            !GWU.utils.equalsXY(level.startLoc, opts.startLoc)) {\n            this.stairLocs[id] = [level.startLoc, level.endLoc];\n        }\n        return result;\n    }\n}\n"],"names":["_a","_b","NOTHING","GWM","tile","get","index","FLOOR","DOOR","SECRET_DOOR","WALL","DEEP","SHALLOW","BRIDGE","UP_STAIRS","DOWN_STAIRS","IMPREGNABLE","TILEMAP","[object Object]","GridSite","width","height","this","tiles","GWU","grid","alloc","free","fill","x","y","hasXY","isBoundaryXY","isFloor","isDoor","isBridge","isStairs","isShallow","v","isNothing","isWall","isDeep","blocksPathing","Tile","obj","Error","_x","_y","Flags","flags","Cell","MapSite","map","machineCount","flag","cellInfo","hasCellFlag","cell","setCellFlag","clearCellFlag","hasTile","opts","setTile","highestPriorityTile","cells","forEach","c","clear","hasItem","tags","item","makeRandom","forceItem","hasActor","blocksMove","blocksVision","hasEntityFlag","Entity","L_BLOCKS_DIAGONAL","info","L_BLOCKS_MOVE","hasTileFlag","T_PATHING_BLOCKER","L_BLOCKS_ITEMS","L_BLOCKS_EFFECTS","isEmpty","isPassable","T_BRIDGE","T_IS_DOOR","L_SECRETLY_PASSABLE","T_DEEP_WATER","depthTile","Depth","LIQUID","T_IS_DEEP_LIQUID","hasDepthTile","site","clone","backup","copy","chokeCount","count","analyze","effect","fireSync","machineId","id","isRoom","IS_IN_MACHINE","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","DIRS","utils","directionOfDoorSite","dir","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","chooseRandomDoorSites","i","j","k","doorSiteFailed","DOORS","h","w","isDiggable","isSet","push","doorSites","loc","random","copySite","dest","source","offsetX","offsetY","forRect","otherX","otherY","getTileIndex","fillCostGrid","costGrid","update","_v","path","OBSTRUCTION","siteDisruptedBy","blockingGrid","options","_c","machine","walkableGrid","disrupts","lakeX","lakeY","getMachine","first","floodFill","siteDisruptedSize","blockingToMapX","blockingToMapY","nextId","minSize","disrupted","Math","min","computeDistanceMap","distanceMap","originX","originY","maxDistance","calculateDistances","Hall","length","doors","d","UP","DOWN","x2","y2","dx","dy","Room","Bounds","super","hall","cx","floor","cy","translate","checkConfig","config","expected","Object","entries","key","expect","have","undefined","Array","isArray","range","make","RoomDigger","_setOptions","result","carve","every","SITE.chooseRandomDoorSites","rooms","ChoiceRoom","choices","randomRoom","bind","weighted","room","ERROR","create","Cavern","value","SITE.FLOOR","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","chance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickLength","lengths","pickHallDirection","dirs","sequence","hi","door","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.Hall","lower","higher","actual","startX","startY","halls","clamp","Number","parseInt","_pickWidth","Lakes","tries","canDisrupt","wreathTile","SITE.SHALLOW","wreathChance","wreathSize","SITE.DEEP","assign","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","dirCoords","seq","isAnyLiquid","bridgeDir","NO_PATH","isBridgeCandidate","SITE.BRIDGE","Stairs","up","down","start","upTile","SITE.UP_STAIRS","downTile","SITE.DOWN_STAIRS","wall","SITE.IMPREGNABLE","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingLoc","matchingLocNear","distanceBetween","slice","setupStairs","indexes","x0","y0","dirIndex","CLOCK_DIRS","findIndex","r","LoopDigger","doorChance","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.DOOR","Level","seed","loops","lakes","bridges","stairs","boundary","startLoc","endLoc","setOptions","SITE.GridSite","args","Map","SITE.MapSite","_create","cb","t","addFirstRoom","fails","addRoom","addLoops","addLakes","addBridges","addStairs","finish","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","roomSite","_makeSite","getDigger","_attachRoomAtLoc","HALL.dig","_attachRoom","SITE.directionOfDoorSite","oppDir","_roomFitsAt","SITE.copySite","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","didSomething","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","blocksDiagonal","boundaryTile","SITE.WALL","Fl","fl","Blueprint","steps","split","trim","frequency","size","lo","from","cfg","STEP.BuildStep","BP_ADOPT_ITEM","some","s","STEP.StepFlags","BF_ADOPT_ITEM","level","want","includes","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","treatAsBlocking","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","BP_NO_INTERIOR_FLAG","requiredFlags","depth","randSite","IS_GATE_SITE","contains","getChokeCount","console","log","pos","builder","tryAgain","failsafe","interior","addTileToInteriorAndIterate","computeInteriorForVestibuleMachine","error","SITE.computeDistanceMap","qualifyingTileCount","totalFreq","n","isOccupied","SITE.siteDisruptedBy","SITE.siteDisruptedSize","goodSoFar","startChokeCount","doorChokeCount","vestibuleLoc","vestibuleChokeCount","eachNeighbor","roomSize","wantSize","distMap","expandMachineInterior","machineNumber","setMachine","isSecretDoor","minimumInteriorNeighbors","madeChange","nbcount","distances","dist","distance25","distance75","alternativeFlags","BF_ALTERNATIVE","BF_ALTERNATIVE_2","keepFeature","randIndex","filter","_f","IS_WIRED","IS_CIRCUIT_BREAKER","blueprints","matches","values","b","qualifies","StepFlags","BuildStep","pad","horde","repeatUntilNoProgress","BF_REPEAT_UNTIL_NO_PROGRESS","blueprint","distanceBound","BF_NOT_IN_HALLWAY","arcCount","BF_NOT_ON_LEVEL_PERIMETER","BF_BUILD_AT_ORIGIN","occupied","BF_IN_VIEW_OF_ORIGIN","BF_IN_PASSABLE_VIEW_OF_ORIGIN","viewMap","distance","BF_BUILD_IN_WALLS","cellMachine","ok","BF_BUILD_ANYWHERE_ON_LEVEL","blocksItems","IS_CHOKEPOINT","IS_IN_LOOP","candidates","personalSpace","generateEverywhere","BF_EVERYWHERE","buildAtOrigin","BF_NEAR_ORIGIN","BF_FAR_FROM_ORIGIN","fov","FOV","isBlocked","calculate","cellIsCandidate","wantCount","builtCount","updateViewMap","markCandidates","warn","fireEffect","BF_PERMIT_BLOCKING","BF_TREAT_AS_BLOCKING","blockingMap","makePersonalSpace","makeRandomItem","BF_ITEM_IS_KEY","entity","makeKeyInfo","BF_KEY_DISPOSABLE","BF_OUTSOURCE_ITEM_TO_MACHINE","buildRandom","addItem","adoptedItem","BF_IMPREGNABLE","BF_BUILD_VESTIBULE","spawnedItems","spawnedHordes","requiredMachineFlags","BLUE.Flags","BLUE.random","build","toString","_build","pickLocation","computeInterior","levelBackup","nextMachineId","prepareInteriorWithMachineFlags","calcDistances","components","pickComponents","restore","clearInteriorFlag","levels","seeds","stairLocs","initSeeds","initStairLocs","number","stairDistance","stairOpts","goesUp","startTile","endTile","entrance","levelOpts","makeLevel","LEVEL.Level","equalsXY"],"mappings":"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"}
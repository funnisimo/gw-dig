{"version":3,"file":"gw-dig.min.js","sources":["../ts/site/tile.ts","../ts/feature/feature.ts","../ts/feature/tile.ts","../ts/feature/chance.ts","../ts/feature/spread.ts","../ts/site/horde.ts","../ts/site/item.ts","../ts/site/utils.ts","../ts/site/analyze.ts","../ts/site/site.ts","../ts/site/log/logger.ts","../ts/build/buildStep.ts","../ts/site/log/consoleLogger.ts","../ts/types.ts","../ts/room.ts","../ts/hall.ts","../ts/lake.ts","../ts/bridge.ts","../ts/stairs.ts","../ts/loop.ts","../ts/digger.ts","../ts/build/data.ts","../ts/build/blueprint.ts","../ts/build/builder.ts","../ts/dungeon.ts"],"sourcesContent":["import * as GWU from 'gw-utils';\n\nexport { TileId } from '../types';\n// export type ToTileId = (name: TileId) => number;\n\nexport interface TileConfig {\n    blocksMove?: boolean;\n    blocksVision?: boolean;\n    blocksPathing?: boolean;\n\n    connectsLevel?: boolean;\n    secretDoor?: boolean;\n    door?: boolean;\n\n    stairs?: boolean;\n    liquid?: boolean;\n    impregnable?: boolean;\n\n    tags?: string | string[];\n    priority?: number | string;\n    ch?: string;\n\n    extends?: string;\n}\n\nexport interface TileOptions extends TileConfig {\n    id: string;\n}\n\nexport interface TileInfo extends TileOptions {\n    id: string;\n    index: number;\n    priority: number;\n    tags: string[];\n}\n\nexport interface TilePlugin {\n    createTile: (tile: TileInfo, cfg: TileConfig) => void;\n}\n\nexport class TileFactory {\n    plugins: TilePlugin[] = [];\n    tileIds: Record<string, number> = {};\n    allTiles: TileInfo[] = [];\n\n    constructor(withDefaults = true) {\n        if (withDefaults) {\n            installDefaults(this);\n        }\n    }\n\n    use(plugin: TilePlugin) {\n        this.plugins.push(plugin);\n    }\n\n    getTile(name: string | number): TileInfo | null {\n        let id: number;\n        if (typeof name === 'string') {\n            id = this.tileIds[name];\n            if (id === undefined) {\n                // TODO - Log?  Will hit this during default installs.\n                return null;\n            }\n        } else {\n            id = name;\n        }\n        return this.allTiles[id] || null;\n    }\n\n    hasTile(name: string | number): boolean {\n        return this.getTile(name) !== null;\n    }\n\n    tileId(name: string | number): number {\n        if (typeof name === 'number') return name;\n        return this.tileIds[name] ?? -1; // TODO: -1 vs 0?\n    }\n\n    // TODO - Remove?\n    blocksMove(name: string | number): boolean {\n        const info = this.getTile(name);\n        return (!!info && info.blocksMove) || false;\n    }\n\n    install(cfg: TileOptions): TileInfo;\n    install(id: string, opts?: TileConfig): TileInfo;\n    install(id: string | TileOptions, opts: TileConfig = {}): TileInfo {\n        if (typeof id !== 'string') {\n            opts = id;\n            id = id.id;\n        }\n        const base = { id, index: this.allTiles.length, priority: 0, tags: [] };\n\n        opts.extends = opts.extends || id;\n\n        if (opts.extends) {\n            const root = this.getTile(opts.extends);\n            if (root) {\n                Object.assign(base, root);\n            } else if (opts.extends !== id) {\n                throw new Error('Cannot extend tile: ' + opts.extends);\n            }\n        }\n\n        const info: TileInfo = GWU.object.assignOmitting(\n            'priority, extends',\n            base,\n            opts\n        ) as TileInfo;\n\n        info.id = id;\n        info.index = this.allTiles.length;\n\n        if (opts.tags) {\n            info.tags = GWU.tags.make(opts.tags);\n        }\n\n        if (typeof opts.priority === 'string') {\n            let text = opts.priority.replace(/ /g, '');\n            let index = text.search(/[+-]/);\n            if (index == 0) {\n                info.priority = info.priority + Number.parseInt(text);\n            } else if (index == -1) {\n                if (text.search(/[a-zA-Z]/) == 0) {\n                    const tile = getTile(text);\n                    if (!tile)\n                        throw new Error(\n                            'Failed to find tile for priority - ' + text + '.'\n                        );\n                    info.priority = tile.priority;\n                } else {\n                    info.priority = Number.parseInt(text);\n                }\n            } else {\n                const id = text.substring(0, index);\n                const delta = Number.parseInt(text.substring(index));\n                const tile = getTile(id);\n                if (!tile)\n                    throw new Error(\n                        'Failed to find tile for priority - ' + id + '.'\n                    );\n\n                info.priority = tile.priority + delta;\n            }\n        } else if (opts.priority !== undefined) {\n            info.priority = opts.priority;\n        }\n\n        if (info.blocksPathing === undefined) {\n            if (info.blocksMove) {\n                info.blocksPathing = true;\n            }\n        }\n\n        // Do any custom tile setup\n        this.apply(info, opts);\n\n        if (this.tileIds[id]) {\n            info.index = this.tileIds[id];\n            this.allTiles[info.index] = info;\n        } else {\n            this.allTiles.push(info);\n            this.tileIds[id] = info.index;\n        }\n\n        return info;\n    }\n\n    apply(tile: TileInfo, config: TileConfig) {\n        this.plugins.forEach((p) => {\n            if (p.createTile) {\n                p.createTile(tile, config);\n            }\n        });\n    }\n}\n\n// export const tileIds: Record<string, number> = {};\n// export const allTiles: TileInfo[] = [];\n\nexport const tileFactory = new TileFactory(true);\n\nexport function installTile(cfg: TileOptions): TileInfo;\nexport function installTile(id: string, opts?: TileConfig): TileInfo;\nexport function installTile(...args: any[]): TileInfo {\n    if (args.length == 1) {\n        return tileFactory.install(args[0]);\n    }\n    return tileFactory.install(args[0], args[1]);\n}\n\nexport function getTile(name: string | number): TileInfo | null {\n    return tileFactory.getTile(name);\n}\n\nexport function tileId(name: string | number): number {\n    return tileFactory.tileId(name);\n}\n\nexport function blocksMove(name: string | number): boolean {\n    return tileFactory.blocksMove(name);\n}\n\nfunction installDefaults(factory: TileFactory) {\n    factory.tileIds['NOTHING'] = factory.tileIds['NULL'] = factory.install(\n        'NONE',\n        {\n            priority: 0,\n            ch: '',\n        }\n    ).index;\n\n    factory.install('FLOOR', { priority: 10, ch: '.' });\n    factory.install('WALL', {\n        blocksMove: true,\n        blocksVision: true,\n        priority: 50,\n        ch: '#',\n    });\n    factory.install('DOOR', {\n        blocksVision: true,\n        door: true,\n        priority: 60,\n        ch: '+',\n    });\n    factory.install('SECRET_DOOR', {\n        blocksMove: true,\n        secretDoor: true,\n        priority: 70,\n        ch: '%',\n    });\n    factory.install('UP_STAIRS', {\n        stairs: true,\n        priority: 80,\n        ch: '>',\n    });\n    factory.install('DOWN_STAIRS', {\n        stairs: true,\n        priority: 80,\n        ch: '<',\n    });\n    factory.tileIds['DEEP'] = factory.install('LAKE', {\n        priority: 40,\n        liquid: true,\n        ch: '~',\n    }).index;\n    factory.install('SHALLOW', { priority: 30, ch: '`' });\n    factory.install('BRIDGE', { priority: 45, ch: '=' }); // layers help here\n    factory.install('IMPREGNABLE', {\n        priority: 200,\n        ch: '%',\n        impregnable: true,\n        blocksMove: true,\n        blocksVision: true,\n    });\n}\n","import * as GWU from 'gw-utils';\nimport { Site } from '../site';\n\nexport interface FeatureObj {\n    [key: string]: any;\n}\nexport type FeatureConfig = string | FeatureObj;\n\nexport type FeatureFn = (site: Site, x: number, y: number) => boolean;\nexport type MakeFn = (cfg: any) => FeatureFn;\n\nexport const features: Record<string, FeatureFn> = {};\n\nexport function install(name: string, fn: FeatureFn | FeatureConfig) {\n    if (typeof fn !== 'function') {\n        fn = make(fn);\n    }\n    features[name] = fn as FeatureFn;\n}\n\nexport const types: Record<string, MakeFn> = {};\n\nexport function installType(name: string, fn: MakeFn) {\n    types[name] = fn;\n}\n\n// FEATURE TYPE\n\nexport function feature(id: string | string[] | { id: string }): FeatureFn {\n    if (Array.isArray(id)) id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length) throw new Error('Feature effect needs ID');\n\n    return featureFeature.bind(undefined, id);\n}\n\nexport function featureFeature(\n    id: string,\n    site: Site,\n    x: number,\n    y: number\n): boolean {\n    const feat = features[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n\n    return feat(site, x, y);\n}\n\ninstallType('feature', feature);\ninstallType('effect', feature);\ninstallType('id', feature);\n\nexport function make(obj: FeatureConfig): FeatureFn;\nexport function make(id: string, config: FeatureConfig): FeatureFn;\nexport function make(\n    id: string | FeatureConfig,\n    config?: FeatureConfig\n): FeatureFn {\n    if (!id) return GWU.FALSE;\n    if (typeof id === 'string') {\n        if (!id.length)\n            throw new Error('Cannot create effect from empty string.');\n\n        if (!config) {\n            const parts = id.split(':');\n            id = parts.shift()!.toLowerCase();\n            config = parts;\n        }\n        // string with no parameters is interpreted as id of registered feature\n        if (config.length === 0) {\n            config = id;\n            id = 'feature';\n        }\n        const handler = types[id];\n        if (!handler) throw new Error('Failed to find effect - ' + id);\n        return handler(config || {});\n    }\n    let steps: FeatureFn[];\n\n    if (Array.isArray(id)) {\n        steps = id\n            .map((config) => make(config))\n            .filter((a) => a !== null) as FeatureFn[];\n    } else if (typeof id === 'function') {\n        return id as FeatureFn;\n    } else {\n        steps = Object.entries(id)\n            .map(([key, config]) => make(key, config))\n            .filter((a) => a !== null) as FeatureFn[];\n    }\n    if (steps.length === 1) {\n        return steps[0];\n    }\n\n    return (site, x, y) => {\n        return steps.every((step) => step(site, x, y));\n    };\n}\n\nexport function makeArray(cfg: string): FeatureFn[];\nexport function makeArray(obj: FeatureObj): FeatureFn[];\nexport function makeArray(arr: FeatureFn[]): FeatureFn[];\nexport function makeArray(\n    cfg: string | FeatureFn | FeatureObj | FeatureFn[]\n): FeatureFn[] {\n    if (!cfg) return [];\n    if (Array.isArray(cfg)) {\n        return cfg\n            .map((c) => make(c))\n            .filter((fn) => fn !== null) as FeatureFn[];\n    }\n    if (typeof cfg === 'string') {\n        if (!cfg.length)\n            throw new Error('Cannot create effect from empty string.');\n\n        const parts = cfg.split(':');\n        cfg = parts.shift()!.toLowerCase();\n\n        const handler = types[cfg];\n        if (!handler) return [];\n        return [handler(parts)];\n    } else if (typeof cfg === 'function') {\n        return [cfg] as FeatureFn[];\n    }\n\n    const steps = Object.entries(cfg).map(([key, config]) => make(key, config));\n    return steps.filter((s) => s !== null) as FeatureFn[];\n}\n","import { SetTileOptions, Site } from '../site';\nimport { FeatureFn, installType } from './feature';\n\n//////////////////////////////////////////////\n// TILE\n\nexport interface TileOptions extends SetTileOptions {\n    id: string;\n    protected?: boolean;\n}\n\nexport function tile(src: string | TileOptions): FeatureFn {\n    if (!src) throw new Error('Tile effect needs configuration.');\n\n    if (typeof src === 'string') {\n        src = { id: src };\n    } else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    } else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n\n    const opts: TileOptions = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    // if (opts.id.includes('+')) {\n    //     opts.protected = true;\n    // }\n    opts.id = opts.id.replace(/[!~+]*/g, '');\n\n    return tileAction.bind(undefined, opts);\n}\n\nexport function tileAction(\n    cfg: TileOptions,\n    site: Site,\n    x: number,\n    y: number\n): boolean {\n    cfg.machine = 0; // >???<\n    if (site.setTile(x, y, cfg.id, cfg)) {\n        return true;\n    }\n    return false;\n}\n\ninstallType('tile', tile);\n","import { Site } from '../site';\nimport { installType, FeatureFn } from './feature';\n\n//////////////////////////////////////////////\n// chance\n\nexport function chance(opts: any): FeatureFn {\n    if (Array.isArray(opts)) {\n        opts = opts[0];\n    }\n    if (typeof opts === 'object') {\n        opts = opts.chance;\n    }\n    if (typeof opts === 'string') {\n        if (opts.endsWith('%')) {\n            opts = Number.parseFloat(opts) * 100;\n        } else {\n            opts = Number.parseInt(opts || '10000');\n        }\n    }\n    if (typeof opts !== 'number') {\n        throw new Error(\n            'Chance effect config must be number or string that can be a number.'\n        );\n    }\n    return chanceAction.bind(undefined, opts);\n}\n\nexport function chanceAction(cfg: number, site: Site): boolean {\n    return site.rng.chance(cfg, 10000);\n}\n\ninstallType('chance', chance);\n","import * as GWU from 'gw-utils';\nimport { Site, tileId } from '../site';\nimport { FeatureFn, FeatureConfig, installType, makeArray } from './feature';\n\nconst Fl = GWU.flag.fl;\n\n///////////////////////////////////////////////////////\n// TILE EVENT\n\nexport enum Flags {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    // E_NEXT_ALWAYS = Fl(0), // Always fire the next effect, even if no tiles changed.\n    // E_NEXT_EVERYWHERE = Fl(1), // next effect spawns in every cell that this effect spawns in, instead of only the origin\n\n    // E_FIRED = Fl(2), // has already been fired once\n\n    // E_NO_MARK_FIRED = Fl(3), // Do not mark this cell as having fired an effect (so can log messages multiple times)\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    // E_PROTECTED = Fl(4),\n\n    // E_NO_REDRAW_CELL = Fl(),\n    E_TREAT_AS_BLOCKING = Fl(5), // If filling the footprint of this effect with walls would disrupt level connectivity, then abort.\n    E_PERMIT_BLOCKING = Fl(6), // Generate this effect without regard to level connectivity.\n    E_ABORT_IF_BLOCKS_MAP = Fl(7),\n    E_BLOCKED_BY_ITEMS = Fl(8), // Do not fire this effect in a cell that has an item.\n    E_BLOCKED_BY_ACTORS = Fl(9), // Do not fire this effect in a cell that has an item.\n    E_BLOCKED_BY_OTHER_LAYERS = Fl(10), // Will not propagate into a cell if any layer in that cell has a superior priority.\n    E_SUPERPRIORITY = Fl(11), // Will overwrite terrain of a superior priority.\n\n    E_IGNORE_FOV = Fl(12),\n\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n\n    E_EVACUATE_CREATURES = Fl(15), // Creatures in the effect area get moved outside of it\n    E_EVACUATE_ITEMS = Fl(16), // Creatures in the effect area get moved outside of it\n\n    E_BUILD_IN_WALLS = Fl(17),\n    E_MUST_TOUCH_WALLS = Fl(18),\n    E_NO_TOUCH_WALLS = Fl(19),\n\n    E_CLEAR_GROUND = Fl(21), // clear all existing tiles\n    E_CLEAR_SURFACE = Fl(22),\n    E_CLEAR_LIQUID = Fl(23),\n    E_CLEAR_GAS = Fl(24),\n\n    E_CLEAR_TILE = Fl(25), // Clear this tile\n\n    E_CLEAR_CELL = E_CLEAR_GROUND |\n        E_CLEAR_SURFACE |\n        E_CLEAR_LIQUID |\n        E_CLEAR_GAS,\n\n    E_ONLY_IF_EMPTY = E_BLOCKED_BY_ITEMS | E_BLOCKED_BY_ACTORS,\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n\n    // These should be effect types\n    // E_ACTIVATE_DORMANT_MONSTER = Fl(27), // Dormant monsters on this tile will appear -- e.g. when a statue bursts to reveal a monster.\n    // E_AGGRAVATES_MONSTERS = Fl(28), // Will act as though an aggravate monster scroll of effectRadius radius had been read at that point.\n    // E_RESURRECT_ALLY = Fl(29), // Will bring back to life your most recently deceased ally.\n}\n\nexport interface SpreadInfo {\n    grow: number;\n    decrement: number;\n    matchTile: string;\n    features: FeatureFn[];\n    flags: number;\n}\n\nexport interface SpreadConfig\n    extends Partial<Omit<SpreadInfo, 'flags' | 'features'>> {\n    features?: FeatureConfig;\n    flags?: GWU.flag.FlagBase;\n}\n\nexport interface SpreadFn extends FeatureFn {\n    config: SpreadInfo;\n}\n\nexport type SpreadArgs = [number, number, FeatureConfig, SpreadConfig?];\n\nexport function spread(config: SpreadArgs | SpreadConfig): SpreadFn;\nexport function spread(\n    grow: number,\n    decrement: number,\n    action: FeatureConfig,\n    opts?: SpreadConfig\n): SpreadFn;\nexport function spread(...args: any[]): SpreadFn {\n    let config = {} as SpreadInfo;\n    if (!args.length) {\n        throw new Error('Must have config to create spread.');\n    }\n    if (args.length === 1) {\n        if (typeof args[0] === 'string') {\n            args = args[0].split(':').map((t) => t.trim());\n        } else if (Array.isArray(args[0])) {\n            args = args[0];\n        } else {\n            Object.assign(config, args[0]);\n            args = [config];\n        }\n    }\n    if (args.length >= 3) {\n        Object.assign(config, args[3] || {});\n        config.grow = Number.parseInt(args[0]);\n        config.decrement = Number.parseInt(args[1]);\n        config.features = args[2];\n    } else if (args.length === 2) {\n        throw new Error('Must have actions to run for spread.');\n    }\n\n    if (typeof config.grow !== 'number')\n        config.grow = Number.parseInt(config.grow || 0);\n    if (typeof config.decrement !== 'number')\n        config.decrement = Number.parseInt(config.decrement || 100);\n    config.flags = GWU.flag.from(Flags, config.flags || 0);\n    config.matchTile = config.matchTile || '';\n\n    if (\n        typeof config.features === 'string' &&\n        // @ts-ignore\n        config.features.indexOf(':') < 0\n    ) {\n        if (tileId(config.features) >= 0) {\n            // @ts-ignore\n            config.features = 'TILE:' + config.features;\n        }\n    }\n\n    const action = makeArray(config.features);\n    if (!action) throw new Error('Failed to make action for spread.');\n    config.features = action;\n\n    const fn = spreadFeature.bind(undefined, config) as SpreadFn;\n    fn.config = config;\n    return fn;\n}\n\ninstallType('spread', spread);\n\nexport function spreadFeature(\n    cfg: SpreadInfo,\n    site: Site,\n    x: number,\n    y: number\n): boolean {\n    const abortIfBlocking = !!(cfg.flags & Flags.E_ABORT_IF_BLOCKS_MAP);\n\n    const map = site;\n    let didSomething = false;\n\n    const spawnMap = GWU.grid.alloc(map.width, map.height);\n\n    if (!computeSpawnMap(cfg, spawnMap, site, x, y)) {\n        GWU.grid.free(spawnMap);\n        return false;\n    }\n\n    if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return false;\n    }\n\n    if (cfg.flags & Flags.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n\n    if (cfg.flags & Flags.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n\n    if (cfg.flags & Flags.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(map, spawnMap, cfg.flags)) {\n            didSomething = true;\n        }\n    }\n\n    spawnMap.update((v) => {\n        if (!v) return 0;\n        return 1;\n    });\n\n    cfg.features.forEach((fn, i) => {\n        spawnMap.forEach((v, x, y) => {\n            if (v !== i + 1) return;\n\n            if (fn(site, x, y)) {\n                didSomething = true;\n                spawnMap.increment(x, y);\n            }\n        });\n    });\n\n    if (didSomething) {\n        didSomething = true;\n    }\n    GWU.grid.free(spawnMap);\n    return didSomething;\n}\n\nexport function mapDisruptedBy(\n    map: Site,\n    blockingGrid: GWU.grid.NumGrid,\n    blockingToMapX = 0,\n    blockingToMapY = 0\n) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.isStairs(i, j)) {\n                disrupts = true;\n            }\n        } else if (!map.blocksMove(i, j)) {\n            walkableGrid.set(i, j, 1);\n        }\n    });\n\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid.get(i, j) == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                } else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n\n// Spread\n\nfunction cellIsOk(\n    effect: SpreadInfo,\n    map: Site,\n    x: number,\n    y: number,\n    isStart: boolean\n) {\n    if (!map.hasXY(x, y)) return false;\n    if (map.isProtected(x, y)) return false;\n\n    if (map.blocksEffects(x, y) && !effect.matchTile && !isStart) {\n        return false;\n    }\n\n    if (effect.flags & Flags.E_BUILD_IN_WALLS) {\n        if (!map.isWall(x, y)) return false;\n    } else if (effect.flags & Flags.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(\n            x,\n            y,\n            (i, j) => {\n                if (map.isWall(i, j)) {\n                    ok = true;\n                }\n            },\n            true\n        );\n        if (!ok) return false;\n    } else if (effect.flags & Flags.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.isWall(x, y)) return false; // or on wall\n        GWU.xy.eachNeighbor(\n            x,\n            y,\n            (i, j) => {\n                if (map.isWall(i, j)) {\n                    ok = false;\n                }\n            },\n            true\n        );\n        if (!ok) return false;\n    }\n\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !map.hasTile(x, y, effect.matchTile)) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function computeSpawnMap(\n    effect: SpreadInfo,\n    spawnMap: GWU.grid.NumGrid,\n    site: Site,\n    x: number,\n    y: number\n) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n\n    const map = site;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n\n    spawnMap.fill(0);\n\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n\n    spawnMap.set(x, y, 1);\n    t = 1; // incremented before anything else happens\n    let count = 1;\n\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap.get(i, j) == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (\n                                spawnMap.hasXY(x2, y2) &&\n                                !spawnMap.get(x2, y2) &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)\n                            ) {\n                                spawnMap.set(x2, y2, t);\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n\n    return count > 0;\n}\n\nexport function clearCells(map: Site, spawnMap: GWU.grid.NumGrid, _flags = 0) {\n    let didSomething = false;\n    // const clearAll = (flags & Flags.E_CLEAR_CELL) === Flags.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v) return;\n\n        // if (clearAll) {\n        map.clearTile(i, j);\n        // } else {\n        //     if (flags & Flags.E_CLEAR_GAS) {\n        //         cell.clearDepth(Flags.Depth.GAS);\n        //     }\n        //     if (flags & Flags.E_CLEAR_LIQUID) {\n        //         cell.clearDepth(Flags.Depth.LIQUID);\n        //     }\n        //     if (flags & Flags.E_CLEAR_SURFACE) {\n        //         cell.clearDepth(Flags.Depth.SURFACE);\n        //     }\n        //     if (flags & Flags.E_CLEAR_GROUND) {\n        //         cell.clearDepth(Flags.Depth.GROUND);\n        //     }\n        // }\n        didSomething = true;\n    });\n    return didSomething;\n}\n\nexport function evacuateCreatures(map: Site, blockingMap: GWU.grid.NumGrid) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap.get(a.x, a.y)) return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y)) return false;\n            if (blockingMap.get(x, y)) return false;\n            return !map.forbidsActor(x, y, a);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            a.y = loc[0];\n            a.y = loc[1];\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n\nexport function evacuateItems(map: Site, blockingMap: GWU.grid.NumGrid) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap.get(i.x, i.y)) return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y)) return false;\n            if (blockingMap.get(x, y)) return false;\n            return !map.forbidsItem(x, y, i);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            i.x = loc[0];\n            i.y = loc[1];\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport { ItemInstance } from './item';\nimport * as FEATURE from '../feature';\nimport { Site } from '../site';\n\nexport type HordeId = string;\n\nexport interface ActorInstance {\n    id: string;\n    make: Record<string, any>;\n    x: number;\n    y: number;\n    machine: number;\n    leader?: ActorInstance; // number??\n    item?: ItemInstance;\n}\n\nexport interface MemberConfig {\n    count?: GWU.range.RangeBase;\n    make?: Record<string, any>;\n}\n\nexport interface HordeConfig {\n    id?: string;\n    leader: HordeId;\n    make?: Record<string, any>;\n    members?: Record<HordeId, GWU.range.RangeBase | MemberConfig>;\n\n    tags?: GWU.tags.TagBase;\n    frequency?: GWU.frequency.FrequencyConfig;\n\n    // flags?: GWU.flag.FlagBase;\n    requiredTile?: string; // ID\n    feature?: string; // ID\n    blueprint?: string; // ID\n}\n\nexport interface MemberInfo {\n    count: GWU.range.Range;\n    make: Record<string, any>;\n}\n\nexport interface HordeInfo {\n    id?: string;\n    leader: HordeId;\n    make: Record<string, any>;\n    members: Record<HordeId, MemberInfo>;\n\n    tags: string[];\n    frequency: GWU.frequency.FrequencyFn;\n\n    flags: number;\n    requiredTile: string | null;\n    feature: FEATURE.FeatureFn | null;\n    blueprint: string | null;\n}\n\nexport const hordes: HordeInfo[] = [];\n\nexport function installHorde(config: HordeConfig): HordeInfo {\n    const info = {} as HordeInfo;\n    info.id = config.id || config.leader;\n    info.leader = config.leader;\n    info.make = config.make || {};\n    info.members = {};\n    if (config.members) {\n        Object.entries(config.members).forEach(([key, value]) => {\n            let member = {} as MemberInfo;\n            if (\n                typeof value === 'object' &&\n                ('count' in value || 'make' in value)\n            ) {\n                member.count = GWU.range.make(value.count || 1);\n                member.make = value.make || {};\n            } else {\n                // @ts-ignore\n                member.count = GWU.range.make(value);\n            }\n            info.members[key] = member;\n        });\n    }\n\n    info.tags = [];\n    if (config.tags) {\n        if (typeof config.tags === 'string') {\n            config.tags = config.tags.split(/[:|,]/g).map((t) => t.trim());\n        }\n        info.tags = config.tags;\n    }\n\n    info.frequency = GWU.frequency.make(config.frequency);\n    info.flags = 0;\n\n    info.requiredTile = config.requiredTile || null;\n    info.feature = config.feature ? FEATURE.make(config.feature) : null;\n    info.blueprint = config.blueprint || null;\n\n    hordes.push(info);\n\n    return info;\n}\n\nexport function pickHorde(\n    depth: number,\n    rules: string | { id: string } | { tags: string | string[] },\n    rng?: GWU.rng.Random\n): HordeInfo | null {\n    rng = rng || GWU.random;\n    let tagMatch: GWU.tags.TagMatchFn;\n    if (typeof rules === 'string') {\n        tagMatch = GWU.tags.makeMatch(rules);\n    } else if ('id' in rules) {\n        return hordes.find((h) => h.id === rules.id) || null;\n    } else {\n        tagMatch = GWU.tags.makeMatch(rules);\n    }\n\n    const choices = hordes.filter((horde) => tagMatch(horde.tags));\n    if (choices.length == 0) return null;\n\n    const freq = choices.map((info) => info.frequency(depth));\n    const choice = rng.weighted(freq);\n    return choices[choice] || null;\n}\n\nexport interface HordeFlagsType {\n    horde: number;\n}\n\nexport interface SpawnOptions {\n    canSpawn: GWU.xy.XYMatchFunc;\n    rng: GWU.rng.Random;\n    machine: number;\n}\n\nexport function spawnHorde(\n    info: HordeInfo,\n    map: Site,\n    x = -1,\n    y = -1,\n    opts: Partial<SpawnOptions> = {}\n): ActorInstance | null {\n    // Leader info\n    opts.canSpawn = opts.canSpawn || GWU.TRUE;\n    opts.rng = opts.rng || map.rng;\n    opts.machine = opts.machine || 0;\n\n    const leader = _spawnLeader(info, map, x, y, opts as SpawnOptions);\n    if (!leader) return null;\n\n    _spawnMembers(info, leader, map, opts as SpawnOptions);\n    return leader;\n}\n\nfunction _spawnLeader(\n    info: HordeInfo,\n    map: Site,\n    x: number,\n    y: number,\n    opts: SpawnOptions\n): ActorInstance | null {\n    const leader: ActorInstance = {\n        id: info.leader,\n        make: info.make,\n        x,\n        y,\n        machine: opts.machine || 0,\n    };\n\n    if (x >= 0 && y >= 0) {\n        if (!map.canSpawnActor(x, y, leader)) return null;\n    } else {\n        [x, y] = _pickLeaderLoc(leader, map, opts) || [-1, -1];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n    }\n\n    // pre-placement stuff?  machine? effect?\n\n    if (!_addLeader(leader, map, x, y, opts)) {\n        return null;\n    }\n\n    return leader;\n}\n\nfunction _addLeader(\n    leader: ActorInstance,\n    map: Site,\n    x: number,\n    y: number,\n    _opts: SpawnOptions\n): number {\n    return map.addActor(x, y, leader);\n}\n\nfunction _addMember(\n    member: ActorInstance,\n    map: Site,\n    x: number,\n    y: number,\n    leader: ActorInstance,\n    _opts: SpawnOptions\n): number {\n    member.leader = leader;\n    return map.addActor(x, y, member);\n}\n\nfunction _spawnMembers(\n    horde: HordeInfo,\n    leader: ActorInstance,\n    map: Site,\n    opts: SpawnOptions\n): number {\n    const entries = Object.entries(horde.members);\n\n    if (entries.length == 0) return 0;\n\n    let count = 0;\n    entries.forEach(([kindId, config]) => {\n        const count = config.count.value(opts.rng);\n        for (let i = 0; i < count; ++i) {\n            _spawnMember(kindId, config, map, leader, opts);\n        }\n    });\n\n    return count;\n}\n\nfunction _spawnMember(\n    id: string,\n    member: MemberInfo,\n    map: Site,\n    leader: ActorInstance,\n    opts: SpawnOptions\n): ActorInstance | null {\n    const instance = {\n        id,\n        make: member.make,\n        x: -1,\n        y: -1,\n        machine: leader.machine,\n    };\n\n    const [x, y] = _pickMemberLoc(instance, map, leader, opts) || [-1, -1];\n    if (x < 0 || y < 0) {\n        return null;\n    }\n\n    // pre-placement stuff?  machine? effect?\n\n    if (!_addMember(instance, map, x, y, leader, opts)) {\n        return null;\n    }\n\n    return instance;\n}\n\nfunction _pickLeaderLoc(\n    leader: ActorInstance,\n    map: Site,\n    opts: SpawnOptions\n): GWU.xy.Loc | null {\n    let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n        if (!map.hasXY(x, y)) return false;\n\n        if (map.hasActor(x, y)) return false; // Brogue kills existing actors, but lets do this instead\n\n        if (!opts.canSpawn(x, y)) return false;\n        if (!map.canSpawnActor(x, y, leader)) return false;\n        // const cell = map.cell(x, y);\n\n        // if (leader.avoidsCell(cell)) return false;\n\n        // if (Map.isHallway(map, x, y)) {\n        //     return false;\n        // }\n        return true;\n    });\n    return loc;\n}\n\nfunction _pickMemberLoc(\n    actor: ActorInstance,\n    map: Site,\n    leader: ActorInstance,\n    opts: SpawnOptions\n): GWU.xy.Loc | null {\n    let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n        if (!map.hasXY(x, y)) return false;\n        if (map.hasActor(x, y)) return false;\n        // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n\n        if (!map.canSpawnActor(x, y, actor)) return false;\n        if (!opts.canSpawn(x, y)) return false;\n        return true;\n    });\n    return loc;\n}\n","import * as GWU from 'gw-utils';\n\nexport type ItemId = string;\n\nexport interface ItemInstance {\n    id: string;\n    make?: Record<string, any>;\n    key?: { x: number; y: number; disposable?: boolean };\n    x: number; // -1 means not on map (carried)\n    y: number; // -1 means not on map\n}\n\nexport interface ItemConfig {\n    id: ItemId;\n    make?: Record<string, any>;\n\n    tags?: GWU.tags.TagBase;\n    frequency?: GWU.frequency.FrequencyConfig;\n\n    // flags?: GWU.flag.FlagBase;\n    requiredTile?: string;\n    feature?: string;\n    blueprint?: string;\n}\n\nexport interface ItemMatchOptions {\n    tags: string | string[];\n    forbidTags: string | string[];\n    rng?: GWU.rng.Random;\n}\n\nexport interface ItemInfo {\n    id: ItemId;\n    make: Record<string, any>;\n\n    tags: string[];\n    frequency: GWU.frequency.FrequencyFn;\n\n    flags: number;\n    requiredTile: string | null;\n    feature: string | null;\n    blueprint: string | null;\n}\n\nexport const items: ItemInfo[] = [];\n\nexport function installItem(config: ItemConfig): ItemInfo;\nexport function installItem(id: string, cfg: Omit<ItemConfig, 'id'>): ItemInfo;\nexport function installItem(\n    config: ItemConfig | string,\n    cfg?: Omit<ItemConfig, 'id'>\n): ItemInfo {\n    const info = {} as ItemInfo;\n    if (typeof config === 'string') {\n        info.id = config;\n        if (!cfg) throw new Error('Need a configuration.');\n        config = cfg as ItemConfig;\n    } else {\n        info.id = config.id;\n    }\n\n    info.make = config.make || {};\n\n    info.tags = [];\n    if (config.tags) {\n        if (typeof config.tags === 'string') {\n            config.tags = config.tags.split(/[:|,]/g).map((t) => t.trim());\n        }\n        info.tags = config.tags;\n    }\n\n    info.frequency = GWU.frequency.make(config.frequency || 100);\n    info.flags = 0;\n\n    info.requiredTile = config.requiredTile || null;\n    info.feature = config.feature || null;\n    info.blueprint = config.blueprint || null;\n\n    items.push(info);\n\n    return info;\n}\n\nexport function pickItem(\n    depth: number,\n    tagRules: string | { tags: string } | { id: string },\n    rng?: GWU.rng.Random\n): ItemInfo | null {\n    rng = rng || GWU.random;\n    if (typeof tagRules !== 'string' && 'id' in tagRules) {\n        // @ts-ignore\n        return items.find((i) => i.id === tagRules.id) || null;\n    }\n    tagRules = typeof tagRules === 'string' ? tagRules : tagRules.tags;\n    const tagMatch = GWU.tags.makeMatch(tagRules);\n    const choices = items.filter((item) => tagMatch(item.tags));\n    if (choices.length == 0) return null;\n\n    const freq = choices.map((info) => info.frequency(depth));\n    const choice = rng.weighted(freq);\n    return choices[choice] || null;\n}\n\nexport function makeItem(info: ItemInfo): ItemInstance {\n    return {\n        id: info.id,\n        make: info.make,\n        x: -1,\n        y: -1,\n    };\n}\n\nexport function getItemInfo(id: string): ItemInfo | undefined {\n    return items.find((i) => i.id === id);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\nimport * as DIG from './site';\n\nconst DIRS = GWU.xy.DIRS;\n\nexport function loadSite(\n    site: DIG.Site,\n    cells: string[],\n    tiles: Record<string, string>\n) {\n    const w = site.width;\n    const h = site.height;\n\n    cells.forEach((line, j) => {\n        if (j >= h) return;\n        for (let i = 0; i < w && i < line.length; ++i) {\n            const ch = line[i];\n            const tile = tiles[ch] || 'FLOOR';\n\n            site.setTile(i, j, tile);\n        }\n    });\n}\n\n// export function attachRoom(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GWU.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n\n//                 attachDoor(map, room, opts, x, y, oppDir);\n\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n\n//     return false;\n// }\n\n// export function attachDoor(\n//     map: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n\n//     if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n\n// export function roomFitsAt(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(\n    site: DIG.Site,\n    x: number,\n    y: number\n): number {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n\n    solutionDir = GWU.xy.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (\n            site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)\n        ) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GWU.xy.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GWU.xy.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\n\nexport function chooseRandomDoorSites(site: DIG.Site): GWU.xy.Loc[] {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n\n    const DOORS: GWU.xy.Loc[][] = [[], [], [], []];\n\n    // const grid = GWU.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n\n    const h = site.height;\n    const w = site.width;\n\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GWU.xy.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GWU.xy.DIRS[dir][0];\n                    newY = j + GWU.xy.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (\n                        k = 0;\n                        k < 10 && site.hasXY(newX, newY) && !doorSiteFailed;\n                        k++\n                    ) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GWU.xy.DIRS[dir][0];\n                        newY += GWU.xy.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n\n    let doorSites: GWU.xy.Loc[] = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = site.rng.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n\n    // GWU.grid.free(grid);\n    return doorSites;\n}\n\n// export function forceRoomAtMapLoc(\n//     map: GWU.grid.NumGrid,\n//     xy: GWU.xy.Loc,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n\n//     const site = new SITE.GridSite(map);\n\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n\n//         if (roomGrid[x][y]) continue;\n\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GWU.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n\n//     return false;\n// }\n\n// export function attachRoomAtMapDoor(\n//     map: GWU.grid.NumGrid,\n//     mapDoors: GWU.xy.Loc[],\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorIndexes = site.rng.sequence(mapDoors.length);\n\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n\n//     return false;\n// }\n\n// function attachRoomAtXY(\n//     map: GWU.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = site.rng.sequence(4);\n\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GWU.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n//             //     return [x0, y0] as GWU.xy.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n\nexport function fillCostGrid(source: DIG.Site, costGrid: GWU.grid.NumGrid) {\n    costGrid.update((_v, x, y) =>\n        source.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION\n    );\n}\n\nexport interface DisruptOptions {\n    offsetX: number; // blockingGridOffsetX\n    offsetY: number; // blockingGridOffsetY\n    machine: number;\n    updateWalkable: (grid: GWU.grid.NumGrid) => boolean; // true = ok to proceed, false = disrupts\n}\n\nexport function siteDisruptedByXY(\n    site: DIG.Site,\n    x: number,\n    y: number,\n    options: Partial<DisruptOptions> = {}\n) {\n    options.offsetX ??= 0;\n    options.offsetY ??= 0;\n    options.machine ??= 0;\n\n    if (\n        GWU.xy.arcCount(x, y, (i, j) => {\n            return site.isPassable(i, j);\n        }) <= 1\n    )\n        return false;\n\n    const blockingGrid = GWU.grid.alloc(site.width, site.height);\n    blockingGrid.set(x, y, 1);\n    const result = siteDisruptedBy(site, blockingGrid, options);\n    GWU.grid.free(blockingGrid);\n    return result;\n}\n\nexport function siteDisruptedBy(\n    site: DIG.Site,\n    blockingGrid: GWU.grid.NumGrid,\n    options: Partial<DisruptOptions> = {}\n) {\n    options.offsetX ??= 0;\n    options.offsetY ??= 0;\n    options.machine ??= 0;\n\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = false;\n\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const blockingX = i + options.offsetX!;\n        const blockingY = j + options.offsetY!;\n        if (blockingGrid.get(blockingX, blockingY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        } else if (\n            site.isPassable(i, j) &&\n            (site.getMachine(i, j) == 0 ||\n                site.getMachine(i, j) == options.machine)\n        ) {\n            walkableGrid.set(i, j, 1);\n        }\n    });\n\n    if (options.updateWalkable) {\n        if (!options.updateWalkable(walkableGrid)) {\n            return true;\n        }\n    }\n\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid.get(i, j) == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                } else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n\nexport function siteDisruptedSize(\n    site: DIG.Site,\n    blockingGrid: GWU.grid.NumGrid,\n    blockingToMapX = 0,\n    blockingToMapY = 0\n) {\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        } else if (site.isPassable(i, j)) {\n            walkableGrid.set(i, j, 1);\n        }\n    });\n\n    if (disrupts) return disrupts;\n\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid.get(i, j) == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                } else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n\nexport function computeDistanceMap(\n    site: DIG.Site,\n    distanceMap: GWU.path.DijkstraMap,\n    originX: number,\n    originY: number,\n    _maxDistance: number\n) {\n    distanceMap.reset(site.width, site.height);\n    distanceMap.setGoal(originX, originY);\n    distanceMap.calculate((x, y) => {\n        if (!site.hasXY(x, y)) return GWU.path.OBSTRUCTION;\n        if (site.isPassable(x, y)) return GWU.path.OK;\n        if (site.blocksDiagonal(x, y)) return GWU.path.OBSTRUCTION;\n        return GWU.path.BLOCKED;\n    }, false);\n}\n\nexport function clearInteriorFlag(site: DIG.Site, machine: number) {\n    for (let i = 0; i < site.width; i++) {\n        for (let j = 0; j < site.height; j++) {\n            if (site.getMachine(i, j) == machine && !site.needsMachine(i, j)) {\n                site.setMachine(i, j, 0);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\n\nexport interface AnalysisBase {\n    readonly height: number;\n    readonly width: number;\n\n    hasXY: GWU.xy.XYMatchFunc;\n\n    blocksPathing: GWU.xy.XYMatchFunc;\n    blocksMove: GWU.xy.XYMatchFunc;\n    blocksDiagonal: GWU.xy.XYMatchFunc;\n    isSecretDoor: GWU.xy.XYMatchFunc;\n}\n\nexport interface LoopSite extends AnalysisBase {\n    setInLoop: GWU.xy.XYFunc;\n    clearInLoop: GWU.xy.XYFunc;\n    isInLoop: GWU.xy.XYMatchFunc;\n}\n\nexport interface ChokeSite extends AnalysisBase {\n    clearChokepoint: GWU.xy.XYFunc;\n    setChokepoint: GWU.xy.XYFunc;\n    isChokepoint: GWU.xy.XYMatchFunc;\n    setChokeCount(x: number, y: number, count: number): void;\n    getChokeCount(x: number, y: number): number;\n\n    setGateSite: GWU.xy.XYFunc;\n    clearGateSite: GWU.xy.XYFunc;\n    isGateSite: GWU.xy.XYMatchFunc;\n\n    isAreaMachine: GWU.xy.XYMatchFunc;\n    isInLoop: GWU.xy.XYMatchFunc;\n}\n\nexport type AnalysisSite = LoopSite & ChokeSite;\n\nexport function analyze(map: AnalysisSite, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\n\nexport function updateChokepoints(map: ChokeSite, updateCounts: boolean) {\n    const blockMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            if (map.blocksDiagonal(i, j)) {\n                blockMap.set(i, j, 2);\n            } else if (\n                (map.blocksPathing(i, j) || map.blocksMove(i, j)) &&\n                !map.isSecretDoor(i, j)\n            ) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                blockMap.set(i, j, 1);\n            } else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                blockMap.set(i, j, 0);\n            }\n        }\n    }\n\n    let passableArcCount;\n\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < blockMap.width - 1; i++) {\n        for (let j = 1; j < blockMap.height - 1; j++) {\n            map.clearChokepoint(i, j);\n            if (!blockMap.get(i, j)) {\n                if (!map.isInLoop(i, j)) {\n                    passableArcCount = 0;\n                    for (let dir = 0; dir < 8; dir++) {\n                        const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                        const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                        const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                        const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                        if (\n                            (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                                blockMap.get(newX, newY)! > 0) !=\n                            (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                                blockMap.get(oldX, oldY)! > 0)\n                        ) {\n                            if (++passableArcCount > 2) {\n                                if (\n                                    (blockMap.get(i - 1, j) &&\n                                        blockMap.get(i + 1, j)) ||\n                                    (blockMap.get(i, j - 1) &&\n                                        blockMap.get(i, j + 1))\n                                ) {\n                                    map.setChokepoint(i, j);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                const left = i - 1;\n                const right = i + 1;\n                const up = j - 1;\n                const down = j + 1;\n\n                if (blockMap.get(i, up) && blockMap.get(i, down)) {\n                    if (!blockMap.get(left, j) && !blockMap.get(right, j)) {\n                        if (\n                            !blockMap.get(left, up) ||\n                            !blockMap.get(left, down) ||\n                            !blockMap.get(right, up) ||\n                            !blockMap.get(right, down)\n                        ) {\n                            map.setGateSite(i, j);\n                        }\n                    }\n                } else if (blockMap.get(left, j) && blockMap.get(right, j)) {\n                    if (!blockMap.get(i, up) && !blockMap.get(i, down)) {\n                        if (\n                            !blockMap.get(left, up) ||\n                            !blockMap.get(left, down) ||\n                            !blockMap.get(right, up) ||\n                            !blockMap.get(right, down)\n                        ) {\n                            map.setGateSite(i, j);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.setChokeCount(i, j, 30000);\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n\n        // Scan through and find a chokepoint next to an open point.\n\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                if (!blockMap.get(i, j) && map.isChokepoint(i, j)) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (\n                            map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            !blockMap.get(newX, newY) &&\n                            !map.isChokepoint(newX, newY)\n                        ) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            blockMap.set(i, j, 1);\n                            let cellCount = floodFillCount(\n                                map,\n                                grid,\n                                blockMap,\n                                newX,\n                                newY\n                            );\n                            blockMap.set(i, j, 0);\n\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (\n                                            grid.get(i2, j2) &&\n                                            cellCount <\n                                                map.getChokeCount(i2, j2)\n                                        ) {\n                                            map.setChokeCount(\n                                                i2,\n                                                j2,\n                                                cellCount\n                                            );\n                                            // map.clearGateSite(i2, j2);\n                                        }\n                                    }\n                                }\n\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < map.getChokeCount(i, j)) {\n                                    map.setChokeCount(i, j, cellCount);\n                                    // map.setGateSite(i, j);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    GWU.grid.free(blockMap);\n    GWU.grid.free(grid);\n}\n\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(\n    map: ChokeSite,\n    results: GWU.grid.NumGrid,\n    blockMap: GWU.grid.NumGrid,\n    startX: number,\n    startY: number\n) {\n    function getCount(x: number, y: number): number {\n        let count = 1;\n\n        if (map.isAreaMachine(x, y)) {\n            // huh?\n            count = 10000;\n        }\n        return count;\n    }\n\n    let count = 0;\n    const todo: GWU.xy.Loc[] = [[startX, startY]];\n    const free: GWU.xy.Loc[] = [];\n\n    while (todo.length) {\n        const item = todo.pop()!;\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results.get(x, y)) continue;\n\n        results.set(x, y, 1);\n        count += getCount(x, y);\n\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n\n            if (\n                map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                !blockMap.get(newX, newY) &&\n                !results.get(newX, newY)\n            ) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n\n    return Math.min(count, 10000);\n}\n\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n\nexport function updateLoopiness(map: LoopSite) {\n    resetLoopiness(map);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\n\nexport function resetLoopiness(map: LoopSite) {\n    GWU.xy.forRect(map.width, map.height, (x, y) => {\n        if (\n            (map.blocksPathing(x, y) || map.blocksMove(x, y)) &&\n            !map.isSecretDoor(x, y)\n        ) {\n            map.clearInLoop(x, y);\n            // cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n            // passMap[i][j] = false;\n        } else {\n            map.setInLoop(x, y);\n            // cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n            // passMap[i][j] = true;\n        }\n    });\n}\n\nexport function checkLoopiness(map: LoopSite) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v) return;\n            // const cell = map.cell(x, y);\n\n            todo.set(x, y, 0);\n\n            if (!map.isInLoop(x, y)) {\n                return;\n            }\n\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n\n                if (!map.hasXY(newX, newY)) continue;\n\n                // const cell = map.cell(newX, newY);\n                if (!map.isInLoop(newX, newY)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY)) continue;\n\n                // const newCell = map.cell(newX, newY);\n                if (map.isInLoop(newX, newY)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                } else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                map.clearInLoop(x, y);\n                // cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && map.isInLoop(newX, newY)) {\n                        todo.set(newX, newY, 1);\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\n\nexport function fillInnerLoopGrid(map: LoopSite, grid: GWU.grid.NumGrid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            // const cell = map.cell(x, y);\n            if (map.isInLoop(x, y)) {\n                grid.set(x, y, 1);\n            } else if (x > 0 && y > 0) {\n                // const up = map.cell(x, y - 1);\n                // const left = map.cell(x - 1, y);\n                if (\n                    map.isInLoop(x, y - 1) &&\n                    map.isInLoop(x - 1, y)\n                    // up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    // left.flags.cell & Flags.Cell.IS_IN_LOOP\n                ) {\n                    grid.set(x, y, 1);\n                }\n            }\n        }\n    }\n}\n\nexport function cleanLoopiness(map: LoopSite) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            // const cell = map.cell(i, j);\n            if (map.isInLoop(i, j)) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n\n                    if (\n                        map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid.get(newX, newY) &&\n                        !map.isInLoop(newX, newY)\n                    ) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid.set(i, j, 1);\n                    map.clearInLoop(i, j);\n                    // map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport * as Utils from './utils';\n\nimport { TileFactory, tileFactory, TileInfo } from './tile';\nimport * as ITEM from './item';\nimport * as HORDE from './horde';\nimport * as ANALYZE from './analyze';\n\nexport interface SetTileOptions {\n    superpriority?: boolean;\n    blockedByOtherLayers?: boolean;\n    blockedByActors?: boolean;\n    blockedByItems?: boolean;\n    volume?: number;\n    machine?: number;\n}\n\nexport const Flags = GWU.flag.make([\n    'CHOKEPOINT',\n    'GATE_SITE',\n    'IN_LOOP',\n    'IN_MACHINE',\n    'IN_AREA_MACHINE',\n    'IMPREGNABLE',\n]);\n\nexport interface SiteOptions {\n    rng?: GWU.rng.Random;\n    tiles?: TileFactory;\n}\n\nexport class Site implements ANALYZE.AnalysisSite {\n    _tiles: GWU.grid.NumGrid;\n    _doors: GWU.grid.NumGrid;\n    _flags: GWU.grid.NumGrid;\n    _machine: GWU.grid.NumGrid;\n    _chokeCounts: GWU.grid.NumGrid;\n\n    rng: GWU.rng.Random = GWU.rng.random;\n    tileFactory: TileFactory;\n\n    items: ITEM.ItemInstance[] = [];\n    actors: HORDE.ActorInstance[] = [];\n\n    depth: number;\n    machineCount: number;\n\n    constructor(width: number, height: number, opts: SiteOptions = {}) {\n        this.depth = 0;\n        this.machineCount = 0;\n        this.tileFactory = opts.tiles || tileFactory;\n\n        this._tiles = GWU.grid.alloc(width, height);\n        this._doors = GWU.grid.alloc(width, height);\n        this._flags = GWU.grid.alloc(width, height);\n        this._machine = GWU.grid.alloc(width, height);\n        this._chokeCounts = GWU.grid.alloc(width, height);\n\n        if (opts.rng) {\n            this.rng = opts.rng;\n        }\n    }\n\n    free() {\n        GWU.grid.free(this._tiles);\n        GWU.grid.free(this._doors);\n        GWU.grid.free(this._flags);\n        GWU.grid.free(this._machine);\n        GWU.grid.free(this._chokeCounts);\n    }\n    clear() {\n        this._tiles.fill(0);\n        this._doors.fill(0);\n        this._flags.fill(0);\n        this._machine.fill(0);\n        this._chokeCounts.fill(0);\n        // this.depth = 0;\n        this.machineCount = 0;\n    }\n    dump(fmt?: GWU.grid.GridFormat<number>) {\n        if (fmt) {\n            return this._tiles.dump(fmt);\n        }\n\n        this._tiles.dump((c) => this.tileFactory.getTile(c)!.ch || '?');\n    }\n    // drawInto(buffer: GWU.canvas.Buffer): void {\n    //     buffer.blackOut();\n    //     this.tiles.forEach((t, x, y) => {\n    //         const tile = GWM.tile.get(t);\n    //         buffer.drawSprite(x, y, tile.sprite);\n    //     });\n    // }\n\n    copy(other: Site) {\n        this.depth = other.depth;\n        this.machineCount = other.machineCount;\n\n        this._tiles.copy(other._tiles);\n        this._doors.copy(other._doors);\n        this._machine.copy(other._machine);\n        this._flags.copy(other._flags);\n        this._chokeCounts.copy(other._chokeCounts);\n\n        this.rng = other.rng;\n\n        this.items = other.items.slice();\n        this.actors = other.actors.slice();\n    }\n\n    copyTiles(other: Site, offsetX = 0, offsetY = 0) {\n        GWU.xy.forRect(this.width, this.height, (x, y) => {\n            const otherX = x - offsetX;\n            const otherY = y - offsetY;\n\n            const v = other._tiles.get(otherX, otherY);\n            if (!v) return;\n            this._tiles.set(x, y, v);\n        });\n    }\n\n    setSeed(seed: number) {\n        this.rng.seed(seed);\n    }\n\n    get width() {\n        return this._tiles.width;\n    }\n    get height() {\n        return this._tiles.height;\n    }\n\n    hasXY(x: number, y: number) {\n        return this._tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x: number, y: number) {\n        return this._tiles.isBoundaryXY(x, y);\n    }\n\n    isPassable(x: number, y: number) {\n        return (\n            this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y)\n        );\n    }\n\n    isNothing(x: number, y: number) {\n        return this.hasTile(x, y, 'NOTHING');\n    }\n\n    isDiggable(x: number, y: number) {\n        return this.hasTile(x, y, 'NOTHING') || this.hasTile(x, y, 'WALL');\n    }\n\n    isProtected(_x: number, _y: number): boolean {\n        return false;\n    }\n\n    isFloor(x: number, y: number) {\n        return this.hasTile(x, y, 'FLOOR');\n    }\n\n    isDoor(x: number, y: number) {\n        return this.hasTile(x, y, 'DOOR');\n    }\n\n    isSecretDoor(x: number, y: number) {\n        return this.hasTile(x, y, 'SECRET_DOOR');\n    }\n\n    isBridge(x: number, y: number) {\n        return this.hasTile(x, y, 'BRIDGE');\n    }\n\n    isWall(x: number, y: number): boolean {\n        return this.blocksMove(x, y) && this.blocksVision(x, y);\n    }\n\n    blocksMove(x: number, y: number): boolean {\n        return (\n            this.tileFactory.getTile(this._tiles.get(x, y)!)!.blocksMove ||\n            false\n        );\n    }\n\n    blocksDiagonal(x: number, y: number) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n\n    blocksPathing(x: number, y: number) {\n        return (\n            this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y)\n        );\n    }\n\n    blocksVision(x: number, y: number) {\n        return (\n            this.tileFactory.getTile(this._tiles.get(x, y)!)!.blocksVision ||\n            false\n        );\n    }\n\n    blocksItems(x: number, y: number) {\n        return (\n            this.blocksPathing(x, y) ||\n            this.isChokepoint(x, y) ||\n            this.isInLoop(x, y) ||\n            this.isInMachine(x, y)\n        );\n        // site.hasCellFlag(\n        //     x,\n        //     y,\n        //     GWM.flags.Cell.IS_CHOKEPOINT |\n        //         GWM.flags.Cell.IS_IN_LOOP |\n        //         GWM.flags.Cell.IS_IN_MACHINE\n        // );\n    }\n\n    blocksEffects(x: number, y: number) {\n        return this.isWall(x, y);\n    }\n\n    isStairs(x: number, y: number) {\n        return (\n            this.hasTile(x, y, 'UP_STAIRS') || this.hasTile(x, y, 'DOWN_STAIRS')\n        );\n    }\n\n    isDeep(x: number, y: number) {\n        return this.hasTile(x, y, 'DEEP');\n    }\n\n    isShallow(x: number, y: number) {\n        return this.hasTile(x, y, 'SHALLOW');\n    }\n\n    isAnyLiquid(x: number, y: number) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n\n    isSet(x: number, y: number) {\n        return (this._tiles.get(x, y) || 0) > 0;\n    }\n\n    tileBlocksMove(tile: string): boolean {\n        return this.tileFactory.blocksMove(tile);\n    }\n\n    setTile(\n        x: number,\n        y: number,\n        tile: string | number,\n        _opts: SetTileOptions = {}\n    ) {\n        // if (tile instanceof GWM.tile.Tile) {\n        //     tile = tile.index;\n        // }\n        if (!this._tiles.hasXY(x, y)) return false;\n\n        if (typeof tile === 'string') {\n            tile = this.tileFactory.tileId(tile);\n        }\n\n        // priority checks...\n\n        this._tiles.set(x, y, tile);\n        return true;\n    }\n    clearTile(x: number, y: number) {\n        if (this.hasXY(x, y)) {\n            this._tiles.set(x, y, 0);\n        }\n    }\n    getTile(x: number, y: number): TileInfo {\n        const id = this._tiles.get(x, y) || 0;\n        return this.tileFactory.getTile(id)!;\n    }\n\n    makeImpregnable(x: number, y: number): void {\n        this._flags._data[x][y] |= Flags.IMPREGNABLE;\n        // site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n    }\n\n    isImpregnable(x: number, y: number): boolean {\n        return !!(this._flags.get(x, y)! & Flags.IMPREGNABLE);\n    }\n\n    hasTile(x: number, y: number, tile: string | number): boolean {\n        if (typeof tile === 'string') {\n            tile = this.tileFactory.tileId(tile);\n        }\n        return this.hasXY(x, y) && this._tiles.get(x, y) == tile;\n    }\n\n    getChokeCount(x: number, y: number): number {\n        return this._chokeCounts.get(x, y) || 0;\n    }\n    setChokeCount(x: number, y: number, count: number): void {\n        this._chokeCounts.set(x, y, count);\n    }\n\n    getFlags(x: number, y: number): number {\n        return this._flags.get(x, y) || 0;\n    }\n\n    setChokepoint(x: number, y: number): void {\n        this._flags._data[x][y] |= Flags.CHOKEPOINT;\n    }\n    isChokepoint(x: number, y: number): boolean {\n        return !!(this._flags.get(x, y)! & Flags.CHOKEPOINT);\n    }\n    clearChokepoint(x: number, y: number): void {\n        this._flags._data[x][y] &= ~Flags.CHOKEPOINT;\n    }\n\n    setGateSite(x: number, y: number): void {\n        this._flags._data[x][y] |= Flags.GATE_SITE;\n    }\n    isGateSite(x: number, y: number): boolean {\n        return !!(this._flags.get(x, y)! & Flags.GATE_SITE);\n    }\n\n    clearGateSite(x: number, y: number): void {\n        this._flags._data[x][y] &= ~Flags.GATE_SITE;\n    }\n\n    setInLoop(x: number, y: number): void {\n        this._flags._data[x][y] |= Flags.IN_LOOP;\n    }\n    isInLoop(x: number, y: number): boolean {\n        return !!(this._flags.get(x, y)! & Flags.IN_LOOP);\n    }\n    clearInLoop(x: number, y: number): void {\n        this._flags._data[x][y] &= ~Flags.IN_LOOP;\n    }\n\n    analyze(updateChokeCounts = true): void {\n        ANALYZE.analyze(this, updateChokeCounts);\n    }\n\n    snapshot(): Site {\n        const other = new Site(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    restore(snapshot: Site) {\n        this.copy(snapshot);\n    }\n\n    nextMachineId(): number {\n        this.machineCount += 1;\n        return this.machineCount;\n    }\n    setMachine(x: number, y: number, id: number, isRoom?: boolean): void {\n        this._machine.set(x, y, id);\n        const flag = isRoom ? Flags.IN_MACHINE : Flags.IN_AREA_MACHINE;\n        this._flags._data[x][y] |= flag;\n    }\n    isAreaMachine(x: number, y: number): boolean {\n        return !!(this._machine.get(x, y)! & Flags.IN_AREA_MACHINE);\n    }\n    isInMachine(x: number, y: number): boolean {\n        return this._machine.get(x, y)! > 0;\n    }\n    getMachine(x: number, y: number): number {\n        return this._machine.get(x, y) || 0;\n    }\n\n    needsMachine(_x: number, _y: number): boolean {\n        // site.hasCellFlag(\n        //     i,\n        //     j,\n        //     GWM.flags.Cell.IS_WIRED | GWM.flags.Cell.IS_CIRCUIT_BREAKER\n        // );\n        return false;\n    }\n\n    updateDoorDirs(): void {\n        this._doors.update((_v, x, y) => {\n            return Utils.directionOfDoorSite(this, x, y);\n        });\n    }\n    getDoorDir(x: number, y: number): number {\n        return this._doors.get(x, y) || 0;\n    }\n\n    // tileBlocksMove(tile: number): boolean {\n    //     return (\n    //         tile === WALL ||\n    //         tile === DEEP ||\n    //         tile === IMPREGNABLE ||\n    //         tile === DIG.NOTHING\n    //     );\n    // }\n\n    isOccupied(x: number, y: number): boolean {\n        return this.hasActor(x, y) || this.hasItem(x, y);\n    }\n\n    canSpawnActor(x: number, y: number, _actor: HORDE.ActorInstance): boolean {\n        // const cell = map.cell(x, y);\n        // if (actor.avoidsCell(cell)) return false;\n\n        // if (Map.isHallway(map, x, y)) {\n        //     return false;\n        // }\n        return this.isFloor(x, y);\n    }\n\n    eachActor(cb: (a: HORDE.ActorInstance) => void): void {\n        this.actors.forEach(cb);\n    }\n    addActor(x: number, y: number, a: HORDE.ActorInstance): number {\n        a.x = x;\n        a.y = y;\n        this.actors.push(a);\n        return this.actors.length;\n    }\n    getActor(i: number): HORDE.ActorInstance {\n        return this.actors[i];\n    }\n    // removeActor(a: HORDE.ActorInstance): void {\n    //     GWU.arrayDelete(this.actors, a);\n    // }\n    forbidsActor(x: number, y: number, _a: HORDE.ActorInstance): boolean {\n        return !this.isFloor(x, y);\n    }\n    hasActor(x: number, y: number): boolean {\n        return this.actors.some((a) => a.x === x && a.y === y);\n    }\n\n    eachItem(cb: (i: ITEM.ItemInstance) => void): void {\n        this.items.forEach(cb);\n    }\n    addItem(x: number, y: number, i: ITEM.ItemInstance): number {\n        i.x = x;\n        i.y = y;\n        this.items.push(i);\n        return this.items.length;\n    }\n    getItem(i: number): ITEM.ItemInstance {\n        return this.items[i];\n    }\n    // removeItem(i: ITEM.ItemInstance): void {\n    //     GWU.arrayDelete(this.items, i);\n    // }\n    forbidsItem(x: number, y: number, _i: ITEM.ItemInstance): boolean {\n        return !this.isFloor(x, y);\n    }\n    hasItem(x: number, y: number): boolean {\n        return this.items.some((i) => i.x === x && i.y === y);\n    }\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport { Site } from '../site';\nimport { Room } from '../../types';\nimport { BuildData } from '../../build/data';\nimport { BuildStep } from '../../build/buildStep';\nimport * as ITEM from '../item';\n\nexport interface Logger {\n    onDigFirstRoom(site: Site): void;\n    onRoomCandidate(room: Room, roomSite: Site): void;\n    onRoomFailed(site: Site, room: Room, roomSite: Site, error: string): void;\n    onRoomSuccess(site: Site, room: Room): void;\n\n    onLoopsAdded(site: Site): void;\n    onLakesAdded(site: Site): void;\n    onBridgesAdded(site: Site): void;\n    onStairsAdded(site: Site): void;\n\n    //\n\n    onBuildError(error: string): void;\n\n    onBlueprintPick(data: BuildData, flags: number, depth: number): void;\n\n    onBlueprintCandidates(data: BuildData): void;\n\n    onBlueprintStart(\n        data: BuildData,\n        adoptedItem: ITEM.ItemInstance | null\n    ): void;\n\n    onBlueprintInterior(data: BuildData): void;\n\n    onBlueprintFail(data: BuildData, error: string): void;\n\n    onBlueprintSuccess(data: BuildData): void;\n\n    onStepStart(\n        data: BuildData,\n        step: BuildStep,\n        item: ITEM.ItemInstance | null\n    ): void;\n\n    onStepCandidates(\n        data: BuildData,\n        step: BuildStep,\n        candidates: GWU.grid.NumGrid,\n        wantCount: number\n    ): void;\n\n    onStepInstanceSuccess(\n        data: BuildData,\n        step: BuildStep,\n        x: number,\n        y: number\n    ): void;\n\n    onStepInstanceFail(\n        data: BuildData,\n        step: BuildStep,\n        x: number,\n        y: number,\n        error: string\n    ): void;\n\n    onStepSuccess(data: BuildData, step: BuildStep): void;\n\n    onStepFail(data: BuildData, step: BuildStep, error: string): void;\n}\n\nexport class NullLogger implements Logger {\n    onDigFirstRoom(): void {}\n    onRoomCandidate(): void {}\n    onRoomFailed(): void {}\n    onRoomSuccess(): void {}\n    onLoopsAdded(): void {}\n    onLakesAdded(): void {}\n    onBridgesAdded(): void {}\n    onStairsAdded(): void {}\n\n    onBuildError(): void {}\n    onBlueprintPick(): void {}\n    onBlueprintCandidates(): void {}\n    onBlueprintStart(): void {}\n    onBlueprintInterior(): void {}\n    onBlueprintFail(): void {}\n    onBlueprintSuccess(): void {}\n    onStepStart(): void {}\n    onStepCandidates(): void {}\n    onStepInstanceSuccess(): void {}\n    onStepInstanceFail(): void {}\n    onStepSuccess(): void {}\n    onStepFail(): void {}\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport { BuildData } from './data';\nimport { Blueprint } from './blueprint';\nimport * as FEATURE from '../feature';\n// import * as ITEM from '../item';\n\nexport interface HordeStepOptions {\n    id?: string;\n    tags?: string;\n    feature?: FEATURE.FeatureConfig;\n    make?: Record<string, any>;\n}\n\nexport interface ItemStepOptions {\n    id?: string;\n    tags?: string;\n    make?: Record<string, any>;\n    feature?: FEATURE.FeatureConfig;\n}\n\nexport interface StepOptions {\n    tile: string;\n    flags: GWU.flag.FlagBase;\n    pad: number;\n    count: GWU.range.RangeBase;\n    item: string | ItemStepOptions;\n    horde: string | boolean | HordeStepOptions;\n    feature: FEATURE.FeatureConfig;\n}\n\nexport interface HordeStepInfo extends HordeStepOptions {\n    tags: string;\n    feature?: FEATURE.FeatureFn;\n}\n\nexport interface ItemStepInfo extends ItemStepOptions {\n    tags: string;\n    feature?: FEATURE.FeatureFn;\n}\n\nconst Fl = GWU.flag.fl;\n\nexport enum StepFlags {\n    BS_OUTSOURCE_ITEM_TO_MACHINE = Fl(1), // item must be adopted by another machine\n    BS_BUILD_VESTIBULE = Fl(2), // call this at the origin of a door room to create a new door guard machine there\n    BS_ADOPT_ITEM = Fl(3), // this feature will take the adopted item (be it from another machine or a previous feature)\n    BS_BUILD_AT_ORIGIN = Fl(4), // generate this feature at the room entrance\n\n    BS_PERMIT_BLOCKING = Fl(5), // permit the feature to block the map's passability (e.g. to add a locked door)\n    BS_TREAT_AS_BLOCKING = Fl(6), // treat this terrain as though it blocks, for purposes of deciding whether it can be placed there\n\n    BS_NEAR_ORIGIN = Fl(7), // feature must spawn in the rough quarter of tiles closest to the origin\n    BS_FAR_FROM_ORIGIN = Fl(8), // feature must spawn in the rough quarter of tiles farthest from the origin\n    BS_IN_VIEW_OF_ORIGIN = Fl(9), // this feature must be in view of the origin\n    BS_IN_PASSABLE_VIEW_OF_ORIGIN = Fl(10), // this feature must be in view of the origin, where \"view\" is blocked by pathing blockers\n\n    BS_HORDE_TAKES_ITEM = Fl(11), // the item associated with this feature (including if adopted) will be in possession of the horde leader that's generated\n    BS_HORDE_SLEEPING = Fl(12), // the monsters should be asleep when generated\n    BS_HORDE_FLEEING = Fl(13), // the monsters should be permanently fleeing when generated\n    BS_HORDES_DORMANT = Fl(14), // monsters are dormant, and appear when a dungeon feature with DFF_ACTIVATE_DORMANT_MONSTER spawns on their tile\n\n    BS_ITEM_IS_KEY = Fl(15),\n    BS_ITEM_IDENTIFIED = Fl(16),\n    BS_ITEM_PLAYER_AVOIDS = Fl(17),\n\n    BS_EVERYWHERE = Fl(18), // generate the feature on every tile of the machine (e.g. carpeting)\n    BS_ALTERNATIVE = Fl(19), // build only one feature that has this flag per machine; the rest are skipped\n    BS_ALTERNATIVE_2 = Fl(20), // same as BS_ALTERNATIVE, but provides for a second set of alternatives of which only one will be chosen\n\n    BS_BUILD_IN_WALLS = Fl(21), // build in an impassable tile that is adjacent to the interior\n    BS_BUILD_ANYWHERE_ON_LEVEL = Fl(22), // build anywhere on the level that is not inside the machine\n    BS_REPEAT_UNTIL_NO_PROGRESS = Fl(23), // keep trying to build this feature set until no changes are made\n    BS_IMPREGNABLE = Fl(24), // this feature's location will be immune to tunneling\n\n    BS_NO_BLOCK_ORIGIN = Fl(25), // Treat as blocking, but do not block the path to the origin\n\n    // TODO - BS_ALLOW_IN_HALLWAY instead?\n    BS_NOT_IN_HALLWAY = Fl(27), // the feature location must have a passableArcCount of <= 1\n\n    BS_ALLOW_BOUNDARY = Fl(28), // allow build it in the outermost walls of the level\n\n    BS_SKELETON_KEY = Fl(29), // if a key is generated or adopted by this feature, it will open all locks in this machine.\n    BS_KEY_DISPOSABLE = Fl(30), // if a key is generated or adopted, it will self-destruct after being used at this current location.\n}\n\nexport class BuildStep {\n    tile: string | null = null;\n    flags: number = 0;\n    pad: number = 0;\n    count: GWU.range.Range;\n    item: ItemStepInfo | null = null;\n    horde: HordeStepInfo | null = null;\n    feature: FEATURE.FeatureFn | null = null;\n    chance = 0;\n    index = -1;\n    // next: null = null;\n    // id = 'n/a';\n\n    constructor(cfg: Partial<StepOptions> = {}) {\n        this.tile = cfg.tile || null;\n        if (cfg.flags) {\n            this.flags = GWU.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GWU.range.make(cfg.count || 1);\n        if (typeof cfg.item === 'string') {\n            this.item = { tags: cfg.item };\n        } else if (cfg.item) {\n            // @ts-ignore\n            this.item = Object.assign({ tags: '' }, cfg.item);\n            if (this.item!.feature) {\n                this.item!.feature = FEATURE.make(this.item!.feature);\n            }\n        } else {\n            this.item = null;\n        }\n        if (cfg.horde) {\n            if (cfg.horde === true) {\n                this.horde = { tags: '' };\n            } else if (typeof cfg.horde === 'string') {\n                this.horde = { tags: cfg.horde };\n            } else {\n                // @ts-ignore\n                this.horde = Object.assign({ tags: '' }, cfg.horde);\n                if (this.horde!.feature) {\n                    this.horde!.feature = FEATURE.make(this.horde!.feature);\n                }\n            }\n        } else {\n            this.horde = null;\n        }\n\n        if (cfg.feature) {\n            this.feature = FEATURE.make(cfg.feature);\n        } else {\n            this.feature = null;\n        }\n\n        if (this.item && this.flags & StepFlags.BS_ADOPT_ITEM) {\n            throw new Error(\n                'Cannot have blueprint step with item and BS_ADOPT_ITEM.'\n            );\n        }\n\n        if (this.buildAtOrigin && this.count.hi > 1) {\n            throw new Error(\n                'Cannot have count > 1 for step with BS_BUILD_AT_ORIGIN.'\n            );\n        }\n        if (this.buildAtOrigin && this.repeatUntilNoProgress) {\n            throw new Error(\n                'Cannot have BS_BUILD_AT_ORIGIN and BS_REPEAT_UNTIL_NO_PROGRESS together in a build step.'\n            );\n        }\n        if (this.hordeTakesItem && !this.horde) {\n            throw new Error(\n                'Cannot have BS_HORDE_TAKES_ITEM without a horde configured.'\n            );\n        }\n    }\n\n    get allowBoundary(): boolean {\n        return !!(this.flags & StepFlags.BS_ALLOW_BOUNDARY);\n    }\n\n    get notInHallway(): boolean {\n        return !!(this.flags & StepFlags.BS_NOT_IN_HALLWAY);\n    }\n\n    get buildInWalls(): boolean {\n        return !!(this.flags & StepFlags.BS_BUILD_IN_WALLS);\n    }\n\n    get buildAnywhere(): boolean {\n        return !!(this.flags & StepFlags.BS_BUILD_ANYWHERE_ON_LEVEL);\n    }\n\n    get repeatUntilNoProgress(): boolean {\n        return !!(this.flags & StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS);\n    }\n\n    get permitBlocking(): boolean {\n        return !!(this.flags & StepFlags.BS_PERMIT_BLOCKING);\n    }\n\n    get treatAsBlocking(): boolean {\n        return !!(\n            this.flags &\n            (StepFlags.BS_TREAT_AS_BLOCKING | StepFlags.BS_NO_BLOCK_ORIGIN)\n        );\n    }\n\n    get noBlockOrigin(): boolean {\n        return !!(this.flags & StepFlags.BS_NO_BLOCK_ORIGIN);\n    }\n\n    get adoptItem(): boolean {\n        return !!(this.flags & StepFlags.BS_ADOPT_ITEM);\n    }\n\n    get itemIsKey(): boolean {\n        return !!(this.flags & StepFlags.BS_ITEM_IS_KEY);\n    }\n\n    get keyIsDisposable(): boolean {\n        return !!(this.flags & StepFlags.BS_KEY_DISPOSABLE);\n    }\n\n    get outsourceItem(): boolean {\n        return !!(this.flags & StepFlags.BS_OUTSOURCE_ITEM_TO_MACHINE);\n    }\n\n    get impregnable(): boolean {\n        return !!(this.flags & StepFlags.BS_IMPREGNABLE);\n    }\n\n    get buildVestibule(): boolean {\n        return !!(this.flags & StepFlags.BS_BUILD_VESTIBULE);\n    }\n\n    get hordeTakesItem(): boolean {\n        return !!(this.flags & StepFlags.BS_HORDE_TAKES_ITEM);\n    }\n\n    get generateEverywhere(): boolean {\n        return !!(\n            this.flags &\n            StepFlags.BS_EVERYWHERE &\n            ~StepFlags.BS_BUILD_AT_ORIGIN\n        );\n    }\n\n    get buildAtOrigin(): boolean {\n        return !!(this.flags & StepFlags.BS_BUILD_AT_ORIGIN);\n    }\n\n    get buildsInstances(): boolean {\n        return !!(\n            this.feature ||\n            this.tile ||\n            this.item ||\n            this.horde ||\n            this.adoptItem\n        );\n    }\n\n    // makeItem(data: BuildData): ITEM.ItemInfo | null {\n    //     if (!this.item) return null;\n    //     return ITEM.pick(data.depth, this.item);\n    // }\n\n    // cellIsCandidate(\n    //     builder: BuildData,\n    //     blueprint: Blueprint,\n    //     x: number,\n    //     y: number,\n    //     distanceBound: [number, number]\n    // ) {\n    //     return cellIsCandidate(builder, blueprint, this, x, y, distanceBound);\n    // }\n\n    // distanceBound(builder: BuildData): [number, number] {\n    //     return calcDistanceBound(builder, this);\n    // }\n\n    // updateViewMap(builder: BuildData): void {\n    //     updateViewMap(builder, this);\n    // }\n\n    // build(\n    //     builder: BuildData,\n    //     blueprint: Blueprint,\n    //     adoptedItem: GWM.item.Item | null\n    // ): boolean {\n    //     return buildStep(builder, blueprint, this, adoptedItem);\n    // }\n\n    markCandidates(\n        data: BuildData,\n        candidates: GWU.grid.NumGrid,\n        distanceBound: [number, number] = [0, 10000]\n    ): number {\n        updateViewMap(data, this);\n        const blueprint = data.blueprint;\n        let count = 0;\n        candidates.update((_v, i, j) => {\n            const candidateType = cellIsCandidate(\n                data,\n                blueprint,\n                this,\n                i,\n                j,\n                distanceBound\n            );\n            if (candidateType === CandidateType.OK) {\n                count++;\n            }\n            return candidateType;\n        });\n        return count;\n    }\n\n    makePersonalSpace(\n        _data: BuildData,\n        x: number,\n        y: number,\n        candidates: GWU.grid.NumGrid\n    ) {\n        let count = 0;\n\n        if (this.pad < 1) return 0; // do not mark occupied\n        // or...\n        // if (this.buildEverywhere) return 0;  // do not mark occupied\n\n        for (let i = x - this.pad; i <= x + this.pad; i++) {\n            for (let j = y - this.pad; j <= y + this.pad; j++) {\n                if (candidates.hasXY(i, j)) {\n                    if (candidates.get(i, j) == 1) {\n                        candidates.set(i, j, 0);\n                        ++count;\n                    }\n                    // builder.occupied[i][j] = 1;\n                }\n            }\n        }\n        return count;\n    }\n\n    toString() {\n        let parts = [];\n        if (this.tile) {\n            parts.push('tile: ' + this.tile);\n        }\n        if (this.feature) {\n            parts.push('effect: ' + JSON.stringify(this.feature));\n        }\n        if (this.item) {\n            parts.push('item: ' + JSON.stringify(this.item));\n        }\n        if (this.horde) {\n            parts.push('horde: ' + JSON.stringify(this.horde));\n        }\n        if (this.pad > 1) {\n            parts.push('pad: ' + this.pad);\n        }\n        if (this.count.lo > 1 || this.count.hi > 1) {\n            parts.push('count: ' + this.count.toString());\n        }\n        if (this.chance) {\n            parts.push('chance: ' + this.chance);\n        }\n        if (this.flags) {\n            parts.push('flags: ' + GWU.flag.toString(StepFlags, this.flags));\n        }\n        return '{ ' + parts.join(', ') + ' }';\n    }\n}\n\nexport function updateViewMap(builder: BuildData, buildStep: BuildStep): void {\n    if (\n        buildStep.flags &\n        (StepFlags.BS_IN_VIEW_OF_ORIGIN |\n            StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN)\n    ) {\n        const site = builder.site;\n        if (buildStep.flags & StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN) {\n            const fov = new GWU.fov.FOV({\n                isBlocked: (x, y) => {\n                    return site.blocksPathing(x, y) || site.blocksVision(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap.set(x, y, 1);\n            });\n        } else {\n            const fov = new GWU.fov.FOV({\n                isBlocked: (x, y) => {\n                    return site.blocksVision(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap.set(x, y, 1);\n            });\n        }\n        builder.viewMap.set(builder.originX, builder.originY, 1);\n    }\n}\n\nexport function calcDistanceBound(\n    builder: BuildData,\n    buildStep: BuildStep\n): [number, number] {\n    const distanceBound: [number, number] = [0, 10000];\n    if (buildStep.flags & StepFlags.BS_NEAR_ORIGIN) {\n        distanceBound[1] = builder.distance25;\n    }\n    if (buildStep.flags & StepFlags.BS_FAR_FROM_ORIGIN) {\n        distanceBound[0] = builder.distance75;\n    }\n    return distanceBound;\n}\n\nexport enum CandidateType {\n    NOT_CANDIDATE = 0,\n    OK = 1,\n    IN_HALLWAY,\n    ON_BOUNDARY,\n    MUST_BE_ORIGIN,\n    NOT_ORIGIN,\n    OCCUPIED,\n    NOT_IN_VIEW,\n    TOO_FAR,\n    TOO_CLOSE,\n    INVALID_WALL,\n    BLOCKED,\n    FAILED,\n}\n\nexport function cellIsCandidate(\n    builder: BuildData,\n    blueprint: Blueprint,\n    buildStep: BuildStep,\n    x: number,\n    y: number,\n    distanceBound: [number, number]\n): CandidateType {\n    const site = builder.site;\n\n    // No building in the hallway if it's prohibited.\n    // This check comes before the origin check, so an area machine will fail altogether\n    // if its origin is in a hallway and the feature that must be built there does not permit as much.\n    if (\n        buildStep.notInHallway &&\n        GWU.xy.arcCount(\n            x,\n            y,\n            (i, j) => site.hasXY(i, j) && site.isPassable(i, j)\n        ) > 1\n    ) {\n        return CandidateType.IN_HALLWAY;\n    }\n\n    // if (buildStep.noBlockOrigin) {\n    //     let ok = true;\n    //     GWU.xy.eachNeighbor(\n    //         x,\n    //         y,\n    //         (nx, ny) => {\n    //             if (nx === builder.originX && ny === builder.originY) {\n    //                 ok = false;\n    //             }\n    //         },\n    //         true\n    //     );\n    //     if (!ok) return false;\n    // }\n\n    // No building along the perimeter of the level if it's prohibited.\n    if (\n        (x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1) &&\n        !buildStep.allowBoundary\n    ) {\n        return CandidateType.ON_BOUNDARY;\n    }\n\n    // The origin is a candidate if the feature is flagged to be built at the origin.\n    // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n    if (buildStep.buildAtOrigin) {\n        if (x == builder.originX && y == builder.originY)\n            return CandidateType.OK;\n        return CandidateType.MUST_BE_ORIGIN;\n    } else if (\n        blueprint.isRoom &&\n        x == builder.originX &&\n        y == builder.originY\n    ) {\n        return CandidateType.NOT_ORIGIN;\n    }\n\n    // No building in another feature's personal space!\n    if (builder.occupied.get(x, y)) {\n        return CandidateType.OCCUPIED;\n    }\n\n    // Must be in the viewmap if the appropriate flag is set.\n    if (\n        buildStep.flags &\n            (StepFlags.BS_IN_VIEW_OF_ORIGIN |\n                StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n        !builder.viewMap.get(x, y)\n    ) {\n        return CandidateType.NOT_IN_VIEW;\n    }\n\n    // Do a distance check if the feature requests it.\n    let distance = 10000;\n    if (site.isWall(x, y)) {\n        // Distance is calculated for walls too.\n        GWU.xy.eachNeighbor(\n            x,\n            y,\n            (i, j) => {\n                if (!builder.distanceMap.hasXY(i, j)) return;\n                if (\n                    !site.blocksPathing(i, j) &&\n                    distance > builder.distanceMap.getDistance(i, j) + 1\n                ) {\n                    distance = builder.distanceMap.getDistance(i, j) + 1;\n                }\n            },\n            true\n        );\n    } else {\n        distance = builder.distanceMap.getDistance(x, y);\n    }\n\n    if (distance > distanceBound[1]) return CandidateType.TOO_FAR; // distance exceeds max\n    if (distance < distanceBound[0]) return CandidateType.TOO_CLOSE;\n\n    if (buildStep.buildInWalls) {\n        // If we're supposed to build in a wall...\n        const cellMachine = site.getMachine(x, y);\n        if (\n            !builder.interior.get(x, y) &&\n            (!cellMachine || cellMachine == builder.machineNumber) &&\n            site.isWall(x, y)\n        ) {\n            let ok = false;\n            let failed = false;\n            // ...and this location is a wall that's not already machined...\n            GWU.xy.eachNeighbor(\n                x,\n                y,\n                (newX, newY) => {\n                    if (failed) return;\n                    if (!site.hasXY(newX, newY)) return;\n                    if (\n                        !builder.interior.get(newX, newY) &&\n                        !buildStep.buildAnywhere\n                    ) {\n                        return;\n                    }\n                    // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                    const neighborMachine = site.getMachine(newX, newY);\n                    if (\n                        !site.blocksPathing(newX, newY) &&\n                        (!neighborMachine ||\n                            neighborMachine == builder.machineNumber) &&\n                        !(newX == builder.originX && newY == builder.originY)\n                    ) {\n                        if (\n                            buildStep.notInHallway &&\n                            GWU.xy.arcCount(\n                                newX,\n                                newY,\n                                (i, j) =>\n                                    site.hasXY(i, j) && site.isPassable(i, j)\n                            ) > 1\n                        ) {\n                            // return CandidateType.IN_HALLWAY;\n                            failed = true;\n                            ok = false;\n                        } else {\n                            ok = true;\n                        }\n                    }\n                },\n                true\n            );\n            return ok ? CandidateType.OK : CandidateType.INVALID_WALL;\n        }\n        return CandidateType.NOT_CANDIDATE;\n    } else if (site.isWall(x, y)) {\n        // Can't build in a wall unless instructed to do so.\n        return CandidateType.INVALID_WALL;\n    } else if (buildStep.buildAnywhere) {\n        if (buildStep.item && site.blocksItems(x, y)) {\n            return CandidateType.BLOCKED;\n        } else {\n            return CandidateType.OK;\n        }\n    } else if (builder.interior.get(x, y)) {\n        return CandidateType.OK;\n    }\n    return CandidateType.FAILED;\n}\n\n// export function buildStep(\n//     builder: BuildData,\n//     blueprint: Blueprint,\n//     buildStep: BuildStep,\n//     adoptedItem: GWM.item.Item | null\n// ): boolean {\n//     let wantCount = 0;\n//     let builtCount = 0;\n\n//     const site = builder.site;\n\n//     const candidates = GWU.grid.alloc(site.width, site.height);\n\n//     // Figure out the distance bounds.\n//     const distanceBound = calcDistanceBound(builder, buildStep);\n//     buildStep.updateViewMap(builder);\n\n//     // If the StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n\n//     // Make a master map of candidate locations for this feature.\n//     let qualifyingTileCount = markCandidates(\n//         candidates,\n//         builder,\n//         blueprint,\n//         buildStep,\n//         distanceBound\n//     );\n\n//     if (!buildStep.generateEverywhere) {\n//         wantCount = buildStep.count.value();\n//     }\n\n//     if (!qualifyingTileCount || qualifyingTileCount < buildStep.count.lo) {\n//         console.log(\n//             ' - Only %s qualifying tiles - want at least %s.',\n//             qualifyingTileCount,\n//             buildStep.count.lo\n//         );\n//         GWU.grid.free(candidates);\n//         return false;\n//     }\n\n//     let x = 0,\n//         y = 0;\n\n//     let success = true;\n//     let didSomething = false;\n\n//     do {\n//         success = true;\n//         // Find a location for the feature.\n//         if (buildStep.buildAtOrigin) {\n//             // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n//             x = builder.originX;\n//             y = builder.originY;\n//         } else {\n//             // Pick our candidate location randomly, and also strike it from\n//             // the candidates map so that subsequent instances of this same feature can't choose it.\n//             [x, y] = site.rng.matchingLoc(\n//                 candidates.width,\n//                 candidates.height,\n//                 (x, y) => candidates[x][y] > 0\n//             );\n//         }\n//         // Don't waste time trying the same place again whether or not this attempt succeeds.\n//         candidates[x][y] = 0;\n//         qualifyingTileCount--;\n\n//         // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n//         if (buildStep.effect) {\n//             success = site.fireEffect(buildStep.effect, x, y);\n//             didSomething = success;\n//         }\n\n//         // Now try to place the terrain tile, if any.\n//         if (success && buildStep.tile !== -1) {\n//             const tile = GWM.tile.get(buildStep.tile);\n//             if (\n//                 !(buildStep.flags & StepFlags.BS_PERMIT_BLOCKING) &&\n//                 (tile.blocksMove() ||\n//                     buildStep.flags & StepFlags.BS_TREAT_AS_BLOCKING)\n//             ) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y, {\n//                     machine: site.machineCount,\n//                 });\n//             }\n//             if (success) {\n//                 success = site.setTile(x, y, tile);\n//                 didSomething = didSomething || success;\n//             }\n//         }\n\n//         // Generate an actor, if necessary\n\n//         // Generate an item, if necessary\n//         if (success && buildStep.item) {\n//             const item = site.makeRandomItem(buildStep.item);\n//             if (!item) {\n//                 success = false;\n//             }\n\n//             if (buildStep.flags & StepFlags.BS_ITEM_IS_KEY) {\n//                 item.key = GWM.entity.makeKeyInfo(\n//                     x,\n//                     y,\n//                     !!(buildStep.flags & StepFlags.BS_KEY_DISPOSABLE)\n//                 );\n//             }\n\n//             if (buildStep.flags & StepFlags.BS_OUTSOURCE_ITEM_TO_MACHINE) {\n//                 success = builder.buildRandom(\n//                     Flags.BP_ADOPT_ITEM,\n//                     -1,\n//                     -1,\n//                     item\n//                 );\n//                 if (success) {\n//                     didSomething = true;\n//                 }\n//             } else {\n//                 success = site.addItem(x, y, item);\n//                 didSomething = didSomething || success;\n//             }\n//         } else if (success && buildStep.flags & StepFlags.BS_ADOPT_ITEM) {\n//             // adopt item if necessary\n//             if (!adoptedItem) {\n//                 GWU.grid.free(candidates);\n//                 throw new Error(\n//                     'Failed to build blueprint because there is no adopted item.'\n//                 );\n//             }\n\n//             if (buildStep.flags & StepFlags.BS_TREAT_AS_BLOCKING) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y);\n//             }\n\n//             if (success) {\n//                 success = site.addItem(x, y, adoptedItem);\n//                 if (success) {\n//                     didSomething = true;\n//                 } else {\n//                     console.log('- failed to add item', x, y);\n//                 }\n//             } else {\n//                 // console.log('- blocks map', x, y);\n//             }\n//         }\n\n//         if (success && didSomething) {\n//             // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n//             qualifyingTileCount -= makePersonalSpace(\n//                 builder,\n//                 x,\n//                 y,\n//                 candidates,\n//                 buildStep.pad\n//             );\n//             builtCount++; // we've placed an instance\n\n//             // Mark the feature location as part of the machine, in case it is not already inside of it.\n//             if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n//                 site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n//             }\n\n//             // Mark the feature location as impregnable if requested.\n//             if (buildStep.flags & StepFlags.BS_IMPREGNABLE) {\n//                 site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n//             }\n//         }\n\n//         // Finished with this instance!\n//     } while (\n//         qualifyingTileCount > 0 &&\n//         (buildStep.generateEverywhere ||\n//             builtCount < wantCount ||\n//             buildStep.flags & StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS)\n//     );\n\n//     if (success && buildStep.flags & StepFlags.BS_BUILD_VESTIBULE) {\n//         // Generate a door guard machine.\n//         // Try to create a sub-machine that qualifies.\n\n//         success = builder.buildRandom(\n//             Flags.BP_VESTIBULE,\n//             builder.originX,\n//             builder.originY\n//         );\n\n//         if (!success) {\n//             // console.log(\n//             //     `Depth ${builder.depth}: Failed to place blueprint ${blueprint.id} because it requires a vestibule and we couldn't place one.`\n//             // );\n//             // failure! abort!\n//             GWU.grid.free(candidates);\n//             return false;\n//         }\n//         ++builtCount;\n//     }\n\n//     //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n//     //DEBUG logBuffer(candidates);\n\n//     success = builtCount > 0;\n\n//     GWU.grid.free(candidates);\n//     return success;\n// }\n","import * as GWU from 'gw-utils';\nimport { Room } from '../../types';\nimport { Site } from '../site';\nimport { Logger } from './logger';\nimport { BuildData } from '../../build/data';\nimport { BuildStep, StepFlags } from '../../build/buildStep';\n\nexport class ConsoleLogger implements Logger {\n    onDigFirstRoom(site: Site) {\n        console.group('dig first room');\n        site.dump();\n        console.groupEnd();\n    }\n\n    onRoomCandidate(room: Room, roomSite: Site): void {\n        console.group('room candidate: ' + room.toString());\n        roomSite.dump();\n        console.groupEnd();\n    }\n\n    onRoomFailed(\n        _site: Site,\n        _room: Room,\n        _roomSite: Site,\n        error: string\n    ): void {\n        console.log('Room Failed - ', error);\n    }\n\n    onRoomSuccess(site: Site, room: Room): void {\n        console.group('Added Room - ' + room.toString());\n        site.dump();\n        console.groupEnd();\n    }\n\n    onLoopsAdded(_site: Site): void {\n        console.log('loops added');\n    }\n    onLakesAdded(_site: Site): void {\n        console.log('lakes added');\n    }\n    onBridgesAdded(_site: Site): void {\n        console.log('bridges added');\n    }\n    onStairsAdded(_site: Site): void {\n        console.log('stairs added');\n    }\n\n    //\n\n    onBuildError(error: string) {\n        console.log(`onBuildError - error: ${error}`);\n    }\n\n    onBlueprintPick(data: BuildData, flags: number, depth: number) {\n        console.log(\n            `onBlueprintPick - ${\n                data.blueprint.id\n            }, depth = ${depth}, matchingFlags = ${GWU.flag.toString(\n                StepFlags,\n                flags\n            )}`\n        );\n    }\n\n    onBlueprintCandidates(data: BuildData) {\n        const label = `onBlueprintCandidates - ${data.blueprint.id}`;\n        console.group(label);\n        data.candidates.dump();\n        console.groupEnd();\n    }\n\n    onBlueprintStart(data: BuildData) {\n        console.group(\n            `onBlueprintStart - ${data.blueprint.id} @ ${data.originX},${\n                data.originY\n            } : stepCount: ${\n                data.blueprint.steps.length\n            }, size: [${data.blueprint.size.toString()}], flags: ${GWU.flag.toString(\n                StepFlags,\n                data.blueprint.flags\n            )}`\n        );\n    }\n\n    onBlueprintInterior(data: BuildData) {\n        console.group(`onBlueprintInterior - ${data.blueprint.id}`);\n        data.interior.dump();\n        console.groupEnd();\n    }\n\n    onBlueprintFail(data: BuildData, error: string) {\n        console.log(\n            `onBlueprintFail - ${data.blueprint.id} @ ${data.originX},${data.originY} : error: ${error}`\n        );\n        console.groupEnd();\n    }\n\n    onBlueprintSuccess(data: BuildData) {\n        console.log(\n            `onBlueprintSuccess - ${data.blueprint.id} @ ${data.originX},${data.originY}`\n        );\n        console.groupEnd();\n    }\n\n    onStepStart(data: BuildData, step: BuildStep) {\n        console.group(\n            `onStepStart - ${data.blueprint.id}[${\n                data.blueprint.steps.indexOf(step) + 1\n            }/${data.blueprint.steps.length}] @ ${data.originX},${\n                data.originY\n            } : count: [${step.count.toString()}], flags: ${GWU.flag.toString(\n                StepFlags,\n                step.flags\n            )}`\n        );\n        console.log(step.toString());\n    }\n\n    onStepCandidates(\n        data: BuildData,\n        step: BuildStep,\n        candidates: GWU.grid.NumGrid,\n        wantCount: number\n    ) {\n        const haveCount = candidates.count((v) => v == 1);\n        console.log(\n            `onStepCandidates - ${data.blueprint.id}[${\n                data.blueprint.steps.indexOf(step) + 1\n            }/${data.blueprint.steps.length}] @ ${data.originX},${\n                data.originY\n            } : wantCount: ${wantCount}, have: ${haveCount}`\n        );\n        candidates.dump();\n        if (haveCount == 0) {\n            console.log('No candidates - check interior');\n            data.interior.dump();\n        }\n    }\n\n    onStepInstanceSuccess(\n        _data: BuildData,\n        _step: BuildStep,\n        x: number,\n        y: number\n    ) {\n        console.log(`onStepInstance @ ${x},${y}`);\n    }\n\n    onStepInstanceFail(\n        _data: BuildData,\n        _step: BuildStep,\n        x: number,\n        y: number,\n        error: string\n    ) {\n        console.log(`onStepInstanceFail @ ${x},${y} - error: ${error}`);\n    }\n\n    onStepSuccess(data: BuildData, step: BuildStep) {\n        console.log(\n            `onStepSuccess - ${data.blueprint.id}[${\n                data.blueprint.steps.indexOf(step) + 1\n            }/${data.blueprint.steps.length}] @ ${data.originX},${\n                data.originY\n            } : count: [${step.count.toString()}], flags: ${GWU.flag.toString(\n                StepFlags,\n                step.flags\n            )}`\n        );\n        console.groupEnd();\n    }\n\n    onStepFail(data: BuildData, step: BuildStep, error: string) {\n        console.log(\n            `onStepFail - ${data.blueprint.id}[${\n                data.blueprint.steps.indexOf(step) + 1\n            }/${data.blueprint.steps.length}] @ ${data.originX},${\n                data.originY\n            } : error : ${error}`\n        );\n        console.groupEnd();\n    }\n}\n","import * as GWU from 'gw-utils';\n\nexport type TileId = string;\n\nexport interface RoomConfig {\n    // fn?: RoomFn;\n    // door?: boolean | number;\n    // doorChance?: number;\n    tile?: TileId;\n    [x: string]: any;\n}\n\n// export type RoomFn = (\n//     config: RoomConfig,\n//     grid: GWU.grid.NumGrid\n// ) => Room | RoomConfig | null;\n\n// export interface RoomData extends RoomConfig {\n//     fn: RoomFn;\n//     id: string;\n// }\n\n// export type HallFn = (\n//     opts: HallConfig,\n//     grid: GWU.grid.NumGrid,\n//     room: Room\n// ) => Hall | any | null;\n// export interface HallConfig {\n//     fn?: HallFn;\n//     chance?: number;\n//     length?: GWU.range.RangeBase | [GWU.range.RangeBase, GWU.range.RangeBase];\n//     width?: GWU.range.RangeBase;\n//     tile?: number;\n//     [x: string]: any;\n// }\n\n// export interface HallData extends HallConfig {\n//     fn: HallFn;\n//     id: string;\n// }\n\n// export interface DigConfig {\n//     room: string | any;\n//     hall?: string | HallConfig | boolean;\n//     tries?: number;\n//     locs?: GWU.xy.Loc[];\n//     loc?: GWU.xy.Loc;\n//     door?: number | boolean;\n// }\n\nexport type DigFn = (x: number, y: number, tile: number) => any;\n\nexport class Hall extends GWU.xy.Bounds {\n    public doors: GWU.xy.Loc[] = [];\n\n    constructor(x: number, y: number, width: number, height: number) {\n        super(x, y, width, height);\n    }\n\n    translate(dx: number, dy: number) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d) return;\n                if (d[0] < 0 || d[1] < 0) return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\n\nexport function makeHall(\n    loc: GWU.xy.Loc,\n    dirIndex: number,\n    hallLength: number,\n    hallWidth = 1\n) {\n    const dir = GWU.xy.DIRS[dirIndex];\n    const x = Math.min(loc[0], loc[0] + dir[0] * (hallLength - 1));\n    const y = Math.min(loc[1], loc[1] + dir[1] * (hallLength - 1));\n    const width = Math.abs(dir[0] * hallLength) || hallWidth;\n    const height = Math.abs(dir[1] * hallLength) || hallWidth;\n    return new Hall(x, y, width, height);\n}\n\nexport class Room extends GWU.xy.Bounds {\n    public doors: GWU.xy.Loc[] = [];\n    public hall: Hall | null = null;\n\n    constructor(x: number, y: number, width: number, height: number) {\n        super(x, y, width, height);\n    }\n\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n\n    translate(dx: number, dy: number) {\n        this.x += dx;\n        this.y += dy;\n\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d) return;\n                if (d[0] < 0 || d[1] < 0) return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GWU.xy.Loc[] | null;\n//     door: number;\n// }\n","import * as GWU from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\n\nexport function checkConfig(\n    config: TYPES.RoomConfig,\n    expected: TYPES.RoomConfig = {}\n) {\n    config = config || {};\n    expected = expected || {};\n\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect as TYPES.TileId;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error(\n                    'Missing required config for room digger: ' + key\n                );\n            }\n        } else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        } else if (Array.isArray(expect)) {\n            have = have || expect;\n        } else {\n            // just set the value\n            have = have || expect;\n        }\n\n        const range = GWU.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n\n    return config;\n}\n\nexport abstract class RoomDigger {\n    public options: TYPES.RoomConfig = {};\n    public doors: GWU.xy.Loc[] = [];\n\n    constructor(config: TYPES.RoomConfig, expected: TYPES.RoomConfig = {}) {\n        this._setOptions(config, expected);\n    }\n\n    _setOptions(config: TYPES.RoomConfig, expected: TYPES.RoomConfig = {}) {\n        this.options = checkConfig(config, expected);\n    }\n\n    create(site: SITE.Site): TYPES.Room {\n        const result = this.carve(site);\n        if (result) {\n            if (\n                !result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)\n            ) {\n                result.doors = SITE.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n\n    abstract carve(site: SITE.Site): TYPES.Room;\n}\n\nexport var rooms: Record<string, RoomDigger> = {};\n\nexport class ChoiceRoom extends RoomDigger {\n    // @ts-ignore\n    public randomRoom: (rng: GWU.rng.Random) => string;\n\n    constructor(config: TYPES.RoomConfig = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n\n    _setOptions(config: TYPES.RoomConfig, expected: TYPES.RoomConfig = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = (rng) => rng.item(choices);\n        } else if (typeof choices == 'object') {\n            this.randomRoom = (rng) =>\n                rng.weighted(choices as GWU.rng.WeightedObject);\n        } else {\n            throw new Error(\n                'Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }'\n            );\n        }\n    }\n\n    carve(site: SITE.Site) {\n        let id = this.randomRoom(site.rng);\n        const room = rooms[id];\n        if (!room) {\n            GWU.ERROR('Missing room digger choice: ' + id);\n        }\n\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\n\nexport function choiceRoom(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\n\nexport class Cavern extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n\n    carve(site: SITE.Site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const blobGrid = GWU.grid.alloc(site.width, site.height, 0);\n\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n\n        const blob = new GWU.blob.Blob({\n            rng: site.rng,\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) =>\n            blobGrid.set(x, y, 1)\n        );\n\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v) site.setTile(x + dx, y + dy, tile);\n        });\n        GWU.grid.free(blobGrid);\n\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\n\nexport function cavern(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n\n    carve(site: SITE.Site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        const room = new TYPES.Room(\n            Math.min(roomX, roomX2),\n            Math.min(roomY, roomY2),\n            Math.max(roomWidth, roomWidth2),\n            Math.max(roomHeight, roomHeight2)\n        );\n\n        room.doors[GWU.xy.DOWN] = [Math.floor(site.width / 2), site.height - 2];\n        return room;\n    }\n}\n\nexport function brogueEntrance(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\n\nexport class Cross extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n\n    carve(site: SITE.Site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const roomWidth = width;\n        const roomWidth2 = Math.max(\n            3,\n            Math.floor((width * site.rng.range(25, 75)) / 100)\n        ); // [4,20]\n        const roomHeight = Math.max(\n            3,\n            Math.floor((height * site.rng.range(25, 75)) / 100)\n        ); // [2,5]\n        const roomHeight2 = height;\n\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 =\n            roomX + site.rng.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY =\n            roomY2 +\n            site.rng.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        return new TYPES.Room(\n            roomX,\n            roomY2,\n            Math.max(roomWidth, roomWidth2),\n            Math.max(roomHeight, roomHeight2)\n        );\n    }\n}\n\nexport function cross(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\n\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n\n    carve(site: SITE.Site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        let minorWidth = Math.max(\n            3,\n            Math.floor((width * site.rng.range(25, 50)) / 100)\n        ); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(\n            3,\n            Math.floor((height * site.rng.range(25, 50)) / 100)\n        ); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GWU.xy.forRect(x, y, width, minorHeight, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x2, y2, minorWidth, height, (x, y) =>\n            site.setTile(x, y, tile)\n        );\n        return new TYPES.Room(\n            Math.min(x, x2),\n            Math.min(y, y2),\n            Math.max(width, minorWidth),\n            Math.max(height, minorHeight)\n        );\n    }\n}\n\nexport function symmetricalCross(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\n\nexport class Rectangular extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n\n    carve(site: SITE.Site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\n\nexport function rectangular(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\n\nexport class Circular extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n\n    carve(site: SITE.Site) {\n        const radius = this.options.radius.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n\n        return new TYPES.Room(\n            x - radius,\n            y - radius,\n            radius * 2 + 1,\n            radius * 2 + 1\n        );\n    }\n}\n\nexport function circular(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\n\nexport class BrogueDonut extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n\n    carve(site: SITE.Site) {\n        const radius = this.options.radius.value(site.rng);\n        const ringMinWidth = this.options.ringMinWidth.value(site.rng);\n        const holeMinSize = this.options.holeMinSize.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n\n        if (\n            radius > ringMinWidth + holeMinSize &&\n            site.rng.chance(this.options.holeChance.value(site.rng))\n        ) {\n            GWU.xy.forCircle(\n                x,\n                y,\n                site.rng.range(holeMinSize, radius - holeMinSize),\n                (x, y) => site.clearTile(x, y)\n            );\n        }\n\n        return new TYPES.Room(\n            x - radius,\n            y - radius,\n            radius * 2 + 1,\n            radius * 2 + 1\n        );\n    }\n}\n\nexport function brogueDonut(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\n\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config: Partial<TYPES.RoomConfig> = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n\n    carve(site: SITE.Site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value(site.rng);\n\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n\n        GWU.xy.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n\n        for (i = 0; i < chunkCount; ) {\n            x = site.rng.range(minX, maxX);\n            y = site.rng.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX) continue;\n                if (x + 2 > maxX) continue;\n                if (y - 2 < minY) continue;\n                if (y + 2 > maxY) continue;\n\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n\n                GWU.xy.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\n\nexport function chunkyRoom(config: TYPES.RoomConfig, site: SITE.Site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\n\nexport function install(id: string, room: RoomDigger) {\n    rooms[id] = room;\n    return room;\n}\n\ninstall('DEFAULT', new Rectangular());\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\n\nconst DIRS = GWU.xy.DIRS;\n\nexport function isDoorLoc(site: SITE.Site, loc: GWU.xy.Loc, dir: GWU.xy.Loc) {\n    if (!site.hasXY(loc[0], loc[1])) return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1])) return false; // must be a wall/diggable space\n\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1])) return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1])) return false; // must have floor in opposite direction\n\n    return true;\n}\n\nexport type WidthBase = number | string | number[] | { [key: number]: number };\n\nexport function pickWidth(width: WidthBase, rng?: GWU.rng.Random): number {\n    return GWU.utils.clamp(_pickWidth(width, rng), 1, 3);\n}\n\nfunction _pickWidth(width: WidthBase, rng?: GWU.rng.Random): number {\n    if (!width) return 1;\n    if (typeof width === 'number') return width;\n\n    rng = rng ?? GWU.rng.random;\n\n    if (Array.isArray(width)) {\n        width = rng.weighted(width) + 1;\n    } else if (typeof width === 'string') {\n        width = GWU.range.make(width).value(rng);\n    } else if (width instanceof GWU.range.Range) {\n        width = width.value(rng);\n    } else {\n        const weights = width as GWU.types.WeightedObject;\n        width = Number.parseInt(rng.weighted(weights) as string);\n    }\n    return width;\n}\n\nexport function pickLength(\n    dir: number,\n    lengths: [GWU.range.Range, GWU.range.Range],\n    rng?: GWU.rng.Random\n): number {\n    if (dir == GWU.xy.UP || dir == GWU.xy.DOWN) {\n        return lengths[1].value(rng);\n    } else {\n        return lengths[0].value(rng);\n    }\n}\n\nexport function pickHallDirection(\n    site: SITE.Site,\n    doors: GWU.xy.Loc[],\n    lengths: [GWU.range.Range, GWU.range.Range]\n): number {\n    // Pick a direction.\n    let dir: number = GWU.xy.NO_DIRECTION;\n    if (dir == GWU.xy.NO_DIRECTION) {\n        const dirs = site.rng.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GWU.xy.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\n\nexport function pickHallExits(\n    site: SITE.Site,\n    x: number,\n    y: number,\n    dir: number,\n    obliqueChance: number\n) {\n    let newX: number, newY: number;\n    const allowObliqueHallwayExit = site.rng.chance(obliqueChance);\n    const hallDoors: GWU.xy.Loc[] = [\n        // [-1, -1],\n        // [-1, -1],\n        // [-1, -1],\n        // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n\n        if (\n            (dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)\n        ) {\n            // do nothing\n        } else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\n\n// export function digWide(\n//     opts: TYPES.HallConfig,\n//     grid: GWU.grid.NumGrid,\n//     room: TYPES.Room\n// ): TYPES.Hall | TYPES.HallConfig | null {\n//     opts = opts || {};\n//     if (!opts.width) {\n//         opts.width = 2;\n//     }\n//     if (!grid) {\n//         return opts;\n//     }\n\n//     const dir = pickHallDirection(grid, room, opts);\n//     if (dir === GWU.xy.NO_DIRECTION) return null;\n\n//     const length = pickLength(dir, opts.lengths);\n//     const width = pickWidth(opts) || 2;\n\n//     const door = room.doors[dir];\n//     const tile = opts.tile || SITE.FLOOR;\n//     const hallDoors: GWU.xy.Loc[] = [];\n\n//     let x0: number, y0: number;\n//     let hall;\n//     if (dir === GWU.utils.UP) {\n//         x0 = GWU.clamp(door[0], room.x, room.x + room.width - width);\n//         y0 = door[1] - length + 1;\n\n//         for (let x = x0; x < x0 + width; ++x) {\n//             for (let y = y0; y < y0 + length; ++y) {\n//                 grid[x][y] = tile;\n//             }\n//         }\n\n//         hallDoors[dir] = [x0, y0 - 1];\n//         hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n//     } else if (dir === GWU.utils.DOWN) {\n//         x0 = GWU.clamp(door[0], room.x, room.x + room.width - width);\n//         y0 = door[1] + length - 1;\n\n//         for (let x = x0; x < x0 + width; ++x) {\n//             for (let y = y0; y > y0 - length; --y) {\n//                 grid[x][y] = tile;\n//             }\n//         }\n\n//         hallDoors[dir] = [x0, y0 + 1];\n//         hall = new TYPES.Hall([x0, door[1]], dir, length, 2);\n//     } else if (dir === GWU.utils.LEFT) {\n//         x0 = door[0] - length + 1;\n//         y0 = GWU.clamp(door[1], room.y, room.y + room.height - width);\n\n//         for (let x = x0; x < x0 + length; ++x) {\n//             for (let y = y0; y < y0 + width; ++y) {\n//                 grid[x][y] = tile;\n//             }\n//         }\n\n//         hallDoors[dir] = [x0 - 1, y0];\n//         hall = new TYPES.Hall([door[0], y0], dir, length, 2);\n//     } else {\n//         //if (dir === GWU.utils.RIGHT) {\n//         x0 = door[0] + length - 1;\n//         y0 = GWU.clamp(door[1], room.y, room.y + room.height - width);\n\n//         for (let x = x0; x > x0 - length; --x) {\n//             for (let y = y0; y < y0 + width; ++y) {\n//                 grid[x][y] = tile;\n//             }\n//         }\n\n//         hallDoors[dir] = [x0 + 1, y0];\n//         hall = new TYPES.Hall([door[0], y0], dir, length, width);\n//     }\n\n//     hall.doors = hallDoors;\n//     hall.width = width;\n//     return hall;\n// }\n\n// export function dig(\n//     opts: TYPES.HallConfig,\n//     grid: GWU.grid.NumGrid,\n//     room: TYPES.Room\n// ): TYPES.Hall | TYPES.HallConfig | null {\n//     opts = opts || {};\n//     opts.width = 1;\n//     if (!grid) {\n//         return opts;\n//     }\n\n//     const dir = pickHallDirection(grid, room, opts);\n//     if (dir === GWU.xy.NO_DIRECTION) return null;\n\n//     const length = pickLength(dir, opts.length);\n\n//     const door = room.doors[dir];\n//     const DIR = DIRS[dir];\n\n//     let x = door[0];\n//     let y = door[1];\n\n//     const tile = opts.tile || SITE.FLOOR;\n//     for (let i = 0; i < length; i++) {\n//         grid[x][y] = tile;\n//         x += DIR[0];\n//         y += DIR[1];\n//     }\n\n//     x -= DIR[0];\n//     y -= DIR[1];\n\n//     const hall = new TYPES.Hall(door, dir, length);\n//     hall.doors = pickHallExits(grid, x, y, dir, opts);\n//     return hall;\n// }\n\nexport interface HallOptions {\n    width: number | string;\n    length: number | string | number[] | string[];\n    tile: TYPES.TileId;\n    obliqueChance: number;\n    chance: number;\n}\n\nexport interface HallConfig {\n    width: WidthBase;\n    length: [GWU.range.Range, GWU.range.Range];\n    tile: string;\n    obliqueChance: number;\n    chance: number;\n}\n\nexport class HallDigger {\n    public config: HallConfig = {\n        width: 1,\n        length: [GWU.range.make('2-15'), GWU.range.make('2-9')],\n        tile: 'FLOOR',\n        obliqueChance: 15,\n        chance: 100,\n    };\n\n    constructor(options: Partial<HallOptions> = {}) {\n        this._setOptions(options);\n    }\n\n    _setOptions(options: Partial<HallOptions> = {}) {\n        if (options.width) {\n            this.config.width = options.width;\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GWU.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n\n    create(site: SITE.Site, doors: GWU.xy.Loc[] = []): TYPES.Hall | null {\n        doors = doors || SITE.chooseRandomDoorSites(site);\n\n        if (!site.rng.chance(this.config.chance)) return null;\n\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GWU.xy.NO_DIRECTION) return null;\n        if (!doors[dir]) return null;\n\n        const width = pickWidth(this.config.width, site.rng);\n        const length = pickLength(dir, this.config.length, site.rng);\n        const doorLoc = doors[dir];\n\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        } else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n\n    _digLine(\n        site: SITE.Site,\n        door: GWU.xy.Loc,\n        dir: GWU.xy.Loc,\n        length: number\n    ) {\n        let x = door[0];\n        let y = door[1];\n\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n\n        x -= dir[0];\n        y -= dir[1];\n\n        return [x, y];\n    }\n\n    dig(site: SITE.Site, dir: number, door: GWU.xy.Loc, length: number) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = TYPES.makeHall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n\n    digWide(\n        site: SITE.Site,\n        dir: number,\n        door: GWU.xy.Loc,\n        length: number,\n        width: number\n    ) {\n        const DIR = GWU.xy.DIRS[dir];\n\n        const lower: GWU.xy.Loc = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher: GWU.xy.Loc = [door[0] + DIR[1], door[1] + DIR[0]];\n\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n\n        const hall = TYPES.makeHall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        // hall.width = width;\n        return hall;\n    }\n}\n\nexport function dig(\n    config: Partial<HallOptions>,\n    site: SITE.Site,\n    doors: GWU.xy.Loc[]\n) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\n\nexport var halls: Record<string, HallDigger> = {};\n\nexport function install(id: string, hall: HallDigger) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\n\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\n\nimport * as TYPES from './types';\n\nexport interface LakeOpts {\n    height: number;\n    width: number;\n    minSize: number;\n    tries: number;\n    count: number;\n    canDisrupt: boolean;\n    wreathTile: TYPES.TileId;\n    wreathChance: number;\n    wreathSize: number;\n    tile: TYPES.TileId;\n}\n\nexport class Lakes {\n    options: LakeOpts = {\n        height: 15,\n        width: 30,\n        minSize: 5,\n        tries: 20,\n        count: 1,\n        canDisrupt: false,\n        wreathTile: 'SHALLOW',\n        wreathChance: 50,\n        wreathSize: 1,\n        tile: 'DEEP',\n    };\n\n    constructor(options: Partial<LakeOpts> = {}) {\n        GWU.object.assignObject(this.options, options);\n    }\n\n    create(site: SITE.Site): number {\n        let i, j, k;\n        let x: number, y: number;\n        let lakeMaxHeight,\n            lakeMaxWidth,\n            lakeMinSize,\n            tries,\n            maxCount,\n            canDisrupt;\n        let count = 0;\n\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = site.rng.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || 'SHALLOW';\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || 'DEEP';\n\n        const lakeGrid = GWU.grid.alloc(site.width, site.height, 0);\n\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n\n            const width =\n                Math.round(\n                    ((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                        maxCount\n                ) + lakeMinSize;\n            const height =\n                Math.round(\n                    ((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                        maxCount\n                ) + lakeMinSize;\n\n            const blob = new GWU.blob.Blob({\n                rng: site.rng,\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                // birthParameters: 'ffffftttt',\n                // survivalParameters: 'ffffttttt',\n            });\n\n            lakeGrid.fill(0);\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) =>\n                lakeGrid.set(x, y, 1)\n            );\n\n            // console.log('LAKE ATTEMPT');\n            // lakeGrid.dump();\n\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = site.rng.range(\n                    1 - bounds.x,\n                    lakeGrid.width - bounds.width - bounds.x - 2\n                );\n                y = site.rng.range(\n                    1 - bounds.y,\n                    lakeGrid.height - bounds.height - bounds.y - 2\n                );\n\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid.get(i + bounds.x, j + bounds.y)) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n\n                                if (hasWreath) {\n                                    // if (site.hasTile(sx, sy, wreathTile)) {\n                                    //     site.clearTile(sx, sy, wreathTile);\n                                    // }\n                                    GWU.xy.forCircle(\n                                        sx,\n                                        sy,\n                                        wreathSize,\n                                        (i2, j2) => {\n                                            if (\n                                                site.isPassable(i2, j2) &&\n                                                !lakeGrid.get(i2 - x, j2 - y)\n                                                // SITE.isFloor(map, i, j) ||\n                                                // SITE.isDoor(map, i, j)\n                                            ) {\n                                                site.setTile(\n                                                    i2,\n                                                    j2,\n                                                    wreathTile\n                                                );\n                                            }\n                                        }\n                                    );\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n\n            if (success) {\n                ++count;\n                attempts = 0;\n            } else {\n                ++attempts;\n            }\n        }\n        GWU.grid.free(lakeGrid);\n        return count;\n    }\n\n    isDisruptedBy(\n        site: SITE.Site,\n        lakeGrid: GWU.grid.NumGrid,\n        lakeToMapX = 0,\n        lakeToMapY = 0\n    ) {\n        const walkableGrid = GWU.grid.alloc(site.width, site.height);\n        let disrupts = false;\n\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            } else if (site.isPassable(i, j)) {\n                walkableGrid.set(i, j, 1);\n            }\n        });\n\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid.get(i, j) == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    } else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\n\nexport interface BridgeOpts {\n    minDistance: number;\n    maxLength: number;\n}\n\nexport class Bridges {\n    public options: BridgeOpts = {\n        minDistance: 20,\n        maxLength: 5,\n    };\n\n    constructor(options: Partial<BridgeOpts> = {}) {\n        GWU.object.assignObject(this.options, options);\n    }\n\n    create(site: SITE.Site): number {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n\n        const pathGrid = new GWU.path.DijkstraMap();\n        // const costGrid = GWU.grid.alloc(site.width, site.height);\n\n        const dirCoords: [number, number][] = [\n            [1, 0],\n            [0, 1],\n        ];\n\n        const seq = site.rng.sequence(site.width * site.height);\n\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n\n            if (\n                // map.hasXY(x, y) &&\n                // map.get(x, y) &&\n                site.isPassable(x, y) &&\n                (site.isBridge(x, y) || !site.isAnyLiquid(x, y))\n            ) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n\n                    // if (!map.hasXY(newX, newY)) continue;\n\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (\n                        site.isAnyLiquid(newX, newY) &&\n                        !site.isBridge(newX, newY)\n                    ) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (\n                                site.isBridge(newX, newY) ||\n                                !site.isAnyLiquid(newX, newY)\n                            ) {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (\n                        // map.get(newX, newY) &&\n                        site.isPassable(newX, newY) &&\n                        j < maxLength\n                    ) {\n                        SITE.computeDistanceMap(\n                            site,\n                            pathGrid,\n                            newX,\n                            newY,\n                            999\n                        );\n\n                        if (\n                            pathGrid.getDistance(x, y) > minDistance &&\n                            pathGrid.getDistance(x, y) < GWU.path.BLOCKED\n                        ) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n\n                            while (x !== newX || y !== newY) {\n                                if (\n                                    this.isBridgeCandidate(\n                                        site,\n                                        x,\n                                        y,\n                                        bridgeDir\n                                    )\n                                ) {\n                                    site.setTile(x, y, 'BRIDGE'); // map[x][y] = SITE.BRIDGE;\n                                    // costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                } else {\n                                    site.setTile(x, y, 'FLOOR'); // map[x][y] = SITE.FLOOR;\n                                    // costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // GWU.grid.free(costGrid);\n        return count;\n    }\n\n    isBridgeCandidate(\n        site: SITE.Site,\n        x: number,\n        y: number,\n        _bridgeDir: [number, number]\n    ) {\n        if (site.isBridge(x, y)) return true;\n        if (!site.isAnyLiquid(x, y)) return false;\n        // if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0])) return false;\n        // if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0])) return false;\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport * as TYPES from './types';\nimport * as SITE from './site';\n\nexport interface StairOpts {\n    up: boolean | GWU.xy.Loc;\n    down: boolean | GWU.xy.Loc;\n    minDistance: number;\n\n    start: boolean | string | GWU.xy.Loc;\n\n    upTile: TYPES.TileId;\n    downTile: TYPES.TileId;\n    wall: TYPES.TileId;\n}\n\nexport class Stairs {\n    public options: StairOpts = {\n        up: true,\n        down: true,\n        minDistance: 10,\n        start: false,\n        upTile: 'UP_STAIRS',\n        downTile: 'DOWN_STAIRS',\n        wall: 'IMPREGNABLE',\n    };\n\n    constructor(options: Partial<StairOpts> = {}) {\n        GWU.object.assignObject(this.options, options);\n    }\n\n    create(site: SITE.Site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance =\n            this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n\n        const locations: Record<string, GWU.xy.Loc> = {};\n        let upLoc: GWU.xy.Loc | null = null;\n        let downLoc: GWU.xy.Loc | null = null;\n\n        const isValidLoc = this.isStairXY.bind(this, site);\n\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = site.rng.matchingLoc(\n                    site.width,\n                    site.height,\n                    isValidLoc\n                );\n            } else {\n                start = site.rng.matchingLocNear(\n                    GWU.xy.x(start),\n                    GWU.xy.y(start),\n                    isValidLoc\n                );\n            }\n            locations.start = start;\n        }\n\n        if (\n            Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)\n        ) {\n            const up = this.options.up;\n            upLoc = site.rng.matchingLocNear(\n                GWU.xy.x(up),\n                GWU.xy.y(up),\n                isValidLoc\n            );\n            const down = this.options.down;\n            downLoc = site.rng.matchingLocNear(\n                GWU.xy.x(down),\n                GWU.xy.y(down),\n                isValidLoc\n            );\n        } else if (\n            Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)\n        ) {\n            const up = this.options.up;\n            upLoc = site.rng.matchingLocNear(\n                GWU.xy.x(up),\n                GWU.xy.y(up),\n                isValidLoc\n            );\n            if (needDown) {\n                downLoc = site.rng.matchingLoc(\n                    site.width,\n                    site.height,\n                    (x, y) => {\n                        if (\n                            // @ts-ignore\n                            GWU.xy.distanceBetween(x, y, upLoc![0], upLoc![1]) <\n                            minDistance\n                        )\n                            return false;\n                        return isValidLoc(x, y);\n                    }\n                );\n            }\n        } else if (\n            Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)\n        ) {\n            const down = this.options.down;\n            downLoc = site.rng.matchingLocNear(\n                GWU.xy.x(down),\n                GWU.xy.y(down),\n                isValidLoc\n            );\n            if (needUp) {\n                upLoc = site.rng.matchingLoc(\n                    site.width,\n                    site.height,\n                    (x, y) => {\n                        if (\n                            GWU.xy.distanceBetween(\n                                x,\n                                y,\n                                downLoc![0],\n                                downLoc![1]\n                            ) < minDistance\n                        )\n                            return false;\n                        return isValidLoc(x, y);\n                    }\n                );\n            }\n        } else if (needUp) {\n            upLoc = site.rng.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = site.rng.matchingLoc(\n                    site.width,\n                    site.height,\n                    (x, y) => {\n                        if (\n                            // @ts-ignore\n                            GWU.xy.distanceBetween(x, y, upLoc![0], upLoc![1]) <\n                            minDistance\n                        )\n                            return false;\n                        return isValidLoc(x, y);\n                    }\n                );\n            }\n        } else if (needDown) {\n            downLoc = site.rng.matchingLoc(site.width, site.height, isValidLoc);\n        }\n\n        if (upLoc) {\n            locations.up = upLoc.slice() as GWU.xy.Loc;\n            this.setupStairs(\n                site,\n                upLoc[0],\n                upLoc[1],\n                this.options.upTile,\n                this.options.wall\n            );\n            if (this.options.start === 'up') {\n                locations.start = locations.up;\n            } else {\n                locations.end = locations.up;\n            }\n        }\n        if (downLoc) {\n            locations.down = downLoc.slice() as GWU.xy.Loc;\n            this.setupStairs(\n                site,\n                downLoc[0],\n                downLoc[1],\n                this.options.downTile,\n                this.options.wall\n            );\n            if (this.options.start === 'down') {\n                locations.start = locations.down;\n            } else {\n                locations.end = locations.down;\n            }\n        }\n\n        return upLoc || downLoc ? locations : null;\n    }\n\n    hasXY(site: SITE.Site, x: number, y: number) {\n        if (x < 0 || y < 0) return false;\n        if (x >= site.width || y >= site.height) return false;\n        return true;\n    }\n\n    isStairXY(site: SITE.Site, x: number, y: number) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y)) return false;\n\n        for (let i = 0; i < 4; ++i) {\n            const dir = GWU.xy.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1])) return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1])) return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            } else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n\n    setupStairs(\n        site: SITE.Site,\n        x: number,\n        y: number,\n        tile: TYPES.TileId,\n        wallTile: TYPES.TileId\n    ) {\n        const indexes = site.rng.sequence(4);\n\n        let dir: GWU.xy.Loc | null = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GWU.xy.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1])) break;\n            }\n\n            dir = null;\n        }\n\n        if (!dir) GWU.ERROR('No stair direction found!');\n\n        site.setTile(x, y, tile);\n\n        const dirIndex = GWU.xy.CLOCK_DIRS.findIndex(\n            // @ts-ignore\n            (d) => d[0] == dir[0] && d[1] == dir[1]\n        );\n\n        for (let i = 0; i < GWU.xy.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex) continue;\n            const d = GWU.xy.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wallTile);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\n\nexport interface LoopOptions {\n    minDistance: number;\n    maxLength: number;\n    doorChance: number;\n}\n\nexport interface LoopConfig {\n    minDistance: number;\n    maxLength: number;\n    doorChance: number;\n}\n\nexport class LoopDigger {\n    public options: LoopConfig = {\n        minDistance: 100,\n        maxLength: 1,\n        doorChance: 50,\n    };\n\n    constructor(options: Partial<LoopOptions> = {}) {\n        GWU.object.assignObject(this.options, options);\n    }\n\n    create(site: SITE.Site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n\n        const minDistance = Math.min(\n            this.options.minDistance,\n            Math.floor(Math.max(site.width, site.height) / 2)\n        );\n        const maxLength = this.options.maxLength;\n\n        const pathGrid = new GWU.path.DijkstraMap();\n        // const costGrid = GWU.grid.alloc(site.width, site.height);\n\n        const dirCoords: [number, number][] = [\n            [1, 0],\n            [0, 1],\n        ];\n\n        // SITE.fillCostGrid(site, costGrid);\n\n        function isValidTunnelStart(\n            x: number,\n            y: number,\n            dir: [number, number]\n        ) {\n            if (!site.hasXY(x, y)) return false;\n            if (!site.hasXY(x + dir[1], y + dir[0])) return false;\n            if (!site.hasXY(x - dir[1], y - dir[0])) return false;\n            if (site.isSet(x, y)) return false;\n            if (site.isSet(x + dir[1], y + dir[0])) return false;\n            if (site.isSet(x - dir[1], y - dir[0])) return false;\n            return true;\n        }\n\n        function isValidTunnelEnd(x: number, y: number, dir: [number, number]) {\n            if (!site.hasXY(x, y)) return false;\n            if (!site.hasXY(x + dir[1], y + dir[0])) return false;\n            if (!site.hasXY(x - dir[1], y - dir[0])) return false;\n            if (site.isSet(x, y)) return true;\n            if (site.isSet(x + dir[1], y + dir[0])) return true;\n            if (site.isSet(x - dir[1], y - dir[0])) return true;\n            return false;\n        }\n\n        let count = 0;\n        const seq = site.rng.sequence(site.width * site.height);\n\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir)) continue;\n                    j = maxLength;\n\n                    // check up/left\n                    if (\n                        site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])\n                    ) {\n                        // just can't build directly into a door\n                        if (\n                            !site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])\n                        ) {\n                            continue;\n                        }\n                    } else if (\n                        site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])\n                    ) {\n                        if (\n                            !site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])\n                        ) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v) as [number, number];\n                    } else {\n                        continue; // not valid start for tunnel\n                    }\n\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n\n                    if (j < maxLength) {\n                        SITE.computeDistanceMap(\n                            site,\n                            pathGrid,\n                            startX,\n                            startY,\n                            888\n                        );\n\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (\n                            pathGrid.getDistance(endX, endY) > minDistance &&\n                            pathGrid.getDistance(endX, endY) < GWU.path.BLOCKED\n                        ) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, 'FLOOR');\n                                    // costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            const tile = site.rng.chance(\n                                this.options.doorChance\n                            )\n                                ? 'DOOR'\n                                : 'FLOOR';\n                            site.setTile(x, y, tile); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // pathGrid.free();\n        // GWU.grid.free(costGrid);\n\n        return count;\n    }\n}\n\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site: SITE.Site, opts: Partial<LoopOptions> = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport * as TYPES from './types';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\n\nimport * as LOGGER from './site/log/logger';\nimport { ConsoleLogger } from './site/log/consoleLogger';\n\nexport interface DoorOpts {\n    chance: number;\n    tile: string;\n}\n\nexport interface RoomOptions {\n    count: number;\n    fails: number;\n    first: string | string[] | Record<string, number> | ROOM.RoomDigger;\n    digger: string | string[] | Record<string, number> | ROOM.RoomDigger;\n}\n\nexport interface DiggerOptions {\n    halls?: Partial<HALL.HallOptions> | boolean;\n    loops?: Partial<LOOP.LoopOptions> | boolean;\n    lakes?: Partial<LAKE.LakeOpts> | boolean | number;\n    bridges?: Partial<BRIDGE.BridgeOpts> | boolean | number;\n    stairs?: Partial<STAIRS.StairOpts> | boolean;\n    doors?: Partial<DoorOpts> | boolean;\n\n    rooms?: number | Partial<RoomOptions>;\n\n    startLoc?: GWU.xy.Loc;\n    endLoc?: GWU.xy.Loc;\n    goesUp?: boolean;\n\n    seed?: number;\n    boundary?: boolean;\n\n    log?: LOGGER.Logger | boolean;\n}\n\nexport class Digger {\n    site!: SITE.Site;\n\n    seed = 0;\n    rooms: Partial<RoomOptions> = { fails: 20 };\n    doors: Partial<DoorOpts> = { chance: 15 };\n    halls: Partial<HALL.HallOptions> = { chance: 15 };\n    loops: Partial<LOOP.LoopOptions> | null = {};\n    lakes: Partial<LAKE.LakeOpts> | null = {};\n    bridges: Partial<BRIDGE.BridgeOpts> | null = {};\n    stairs: Partial<STAIRS.StairOpts> | null = {};\n    boundary: boolean = true;\n\n    // startLoc: GWU.xy.Loc = [-1, -1];\n    // endLoc: GWU.xy.Loc = [-1, -1];\n\n    locations: Record<string, GWU.xy.Loc> = {};\n    _locs: Record<string, GWU.xy.Loc> = {};\n    goesUp = false;\n\n    seq!: number[];\n    log: LOGGER.Logger;\n    tiles: SITE.TileFactory;\n\n    constructor(options: DiggerOptions = {}, tiles?: SITE.TileFactory) {\n        this.seed = options.seed || 0;\n        this.tiles = tiles || SITE.tileFactory;\n\n        if (typeof options.rooms === 'number') {\n            options.rooms = { count: options.rooms };\n        }\n        GWU.object.setOptions(this.rooms, options.rooms);\n\n        this.goesUp = options.goesUp || false;\n        if (options.startLoc) {\n            this._locs.start = options.startLoc;\n        }\n        if (options.endLoc) {\n            this._locs.end = options.endLoc;\n        }\n\n        // Doors\n        if (options.doors === false) {\n            options.doors = { chance: 0 };\n        } else if (options.doors === true) {\n            options.doors = { chance: 100 };\n        }\n        GWU.object.setOptions(this.doors, options.doors);\n\n        // Halls\n        if (options.halls === false) {\n            options.halls = { chance: 0 };\n        } else if (options.halls === true) {\n            options.halls = {};\n        }\n        GWU.object.setOptions(this.halls, options.halls);\n\n        // Loops\n        if (options.loops === false) {\n            this.loops = null;\n        } else {\n            if (options.loops === true) options.loops = {};\n            else if (typeof options.loops === 'number') {\n                options.loops = { maxLength: options.loops };\n            }\n            options.loops = options.loops || {};\n            options.loops.doorChance =\n                options.loops.doorChance ?? options.doors?.chance;\n            // @ts-ignore\n            GWU.object.setOptions(this.loops, options.loops);\n        }\n\n        // Lakes\n        if (options.lakes === false) {\n            this.lakes = null;\n        } else {\n            if (options.lakes === true) options.lakes = {};\n            else if (typeof options.lakes === 'number') {\n                options.lakes = { count: options.lakes };\n            }\n            options.lakes = options.lakes || {};\n            // @ts-ignore\n            GWU.object.setOptions(this.lakes, options.lakes);\n        }\n\n        // Bridges\n        if (options.bridges === false) {\n            this.bridges = null;\n        } else {\n            if (typeof options.bridges === 'number') {\n                options.bridges = { maxLength: options.bridges };\n            }\n            if (options.bridges === true) options.bridges = {};\n            // @ts-ignore\n            GWU.object.setOptions(this.bridges, options.bridges);\n        }\n\n        // Stairs\n        if (options.stairs === false) {\n            this.stairs = null;\n        } else {\n            if (typeof options.stairs !== 'object') options.stairs = {};\n            // @ts-ignore\n            GWU.object.setOptions(this.stairs, options.stairs);\n            this.stairs!.start = this.goesUp ? 'down' : 'up';\n        }\n\n        // this.startLoc = options.startLoc || [-1, -1];\n        // this.endLoc = options.endLoc || [-1, -1];\n\n        if (options.log === true) {\n            this.log = new ConsoleLogger();\n        } else if (options.log) {\n            this.log = options.log;\n        } else {\n            this.log = new LOGGER.NullLogger();\n        }\n    }\n\n    _makeRoomSite(width: number, height: number) {\n        const site = new SITE.Site(width, height);\n        site.rng = this.site.rng;\n        return site;\n    }\n\n    _createSite(width: number, height: number): void {\n        this.site = new SITE.Site(width, height);\n    }\n\n    create(width: number, height: number, cb: TYPES.DigFn): boolean;\n    create(map: GWU.grid.NumGrid): boolean;\n    create(map: SITE.Site): boolean;\n    create(...args: any[]): boolean {\n        let needsFree = true;\n        if (args.length == 1) {\n            const dest = args[0];\n            if (dest instanceof SITE.Site) {\n                this.site = dest;\n                needsFree = false;\n            } else {\n                this._createSite(dest.width, dest.height);\n            }\n        } else {\n            this._createSite(args[0], args[1]);\n        }\n\n        const result = this._create(this.site);\n\n        const cb = args[2] || null;\n        if (cb) {\n            GWU.xy.forRect(this.site.width, this.site.height, (x, y) => {\n                const t = this.site._tiles.get(x, y);\n                if (t) cb(x, y, t);\n            });\n        } else if (args.length == 1 && needsFree) {\n            const dest = args[0];\n            dest.copy(this.site._tiles);\n        }\n\n        needsFree && this.site.free();\n        return result;\n    }\n\n    _create(site: SITE.Site): boolean {\n        this.start(site);\n\n        this.addRooms(site);\n\n        if (this.loops) {\n            this.addLoops(site, this.loops);\n            this.log.onLoopsAdded(site);\n        }\n        if (this.lakes) {\n            this.addLakes(site, this.lakes);\n            this.log.onLakesAdded(site);\n        }\n        if (this.bridges) {\n            this.addBridges(site, this.bridges);\n            this.log.onBridgesAdded(site);\n        }\n        if (this.stairs) {\n            this.addStairs(site, this.stairs);\n            this.log.onStairsAdded(site);\n        }\n\n        this.finish(site);\n\n        return true;\n    }\n\n    start(site: SITE.Site) {\n        this.site = site;\n\n        const seed = this.seed || GWU.rng.random.number();\n        site.setSeed(seed);\n\n        site.clear();\n        this.seq = site.rng.sequence(site.width * site.height);\n\n        this.locations = Object.assign({}, this._locs);\n\n        if (!this.locations.start || this.locations.start[0] < 0) {\n            const stair = this.goesUp ? 'down' : 'up';\n            if (this.stairs && Array.isArray(this.stairs[stair])) {\n                this.locations.start = this.stairs[stair] as GWU.xy.Loc;\n            } else {\n                this.locations.start = [\n                    Math.floor(site.width / 2),\n                    site.height - 2,\n                ];\n                if (this.stairs && this.stairs[stair]) {\n                    this.stairs[stair] = this.locations.start;\n                }\n            }\n        }\n\n        if (!this.locations.end || this.locations.end[0] < 0) {\n            const stair = this.goesUp ? 'up' : 'down';\n            if (this.stairs && Array.isArray(this.stairs[stair])) {\n                this.locations.end = this.stairs[stair] as GWU.xy.Loc;\n            }\n        }\n\n        // if (this.startLoc[0] < 0 && this.startLoc[0] < 0) {\n        //     this.startLoc[0] = Math.floor(site.width / 2);\n        //     this.startLoc[1] = site.height - 2;\n        // }\n    }\n\n    getDigger(\n        id: string | string[] | Record<string, number> | ROOM.RoomDigger\n    ) {\n        if (!id) throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger) return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n\n    addRooms(site: SITE.Site) {\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site)) break;\n        }\n        if (!tries) throw new Error('Failed to place first room!');\n        site.updateDoorDirs();\n\n        this.log.onDigFirstRoom(site);\n\n        // site.dump();\n        // console.log('- rng.number', site.rng.number());\n\n        let fails = 0;\n        let count = 1;\n        const maxFails = this.rooms.fails || 20;\n        while (fails < maxFails) {\n            if (this.addRoom(site)) {\n                fails = 0;\n                site.updateDoorDirs();\n                site.rng.shuffle(this.seq);\n\n                // site.dump();\n                // console.log('- rng.number', site.rng.number());\n\n                if (this.rooms.count && ++count >= this.rooms.count) {\n                    break; // we are done\n                }\n            } else {\n                ++fails;\n            }\n        }\n    }\n\n    addFirstRoom(site: SITE.Site): TYPES.Room | null {\n        const roomSite = this._makeRoomSite(site.width, site.height);\n\n        let digger: ROOM.RoomDigger = this.getDigger(\n            this.rooms.first || this.rooms.digger || 'DEFAULT'\n        );\n        let room: TYPES.Room | null = digger.create(roomSite);\n\n        if (\n            room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.locations.start)\n        ) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n\n    addRoom(site: SITE.Site): TYPES.Room | null {\n        const roomSite = this._makeRoomSite(site.width, site.height);\n        let digger: ROOM.RoomDigger = this.getDigger(\n            this.rooms.digger || 'DEFAULT'\n        );\n\n        let room: TYPES.Room | null = digger.create(roomSite);\n\n        // attach hall?\n        if (room && this.halls.chance) {\n            let hall: TYPES.Hall | null = HALL.dig(\n                this.halls,\n                roomSite,\n                room.doors\n            );\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n\n        // console.log('potential room');\n        // roomSite.dump();\n\n        if (room) {\n            this.log.onRoomCandidate(room, roomSite);\n\n            if (this._attachRoom(site, roomSite, room)) {\n                this.log.onRoomSuccess(site, room);\n            } else {\n                this.log.onRoomFailed(site, room, roomSite, 'Did not fit.');\n                room = null;\n            }\n        }\n\n        roomSite.free();\n        return room;\n    }\n\n    _attachRoom(\n        site: SITE.Site,\n        roomSite: SITE.Site,\n        room: TYPES.Room\n    ): boolean {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        let i = 0;\n        const len = this.seq.length;\n\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (i = 0; i < len; i++) {\n            const x = Math.floor(this.seq[i] / site.height);\n            const y = this.seq[i] % site.height;\n\n            const dir = site.getDoorDir(x, y);\n            if (dir != GWU.xy.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door) continue;\n\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n\n                if (\n                    door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, room, offsetX, offsetY)\n                ) {\n                    // TYPES.Room fits here.\n                    site.copyTiles(roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    _attachRoomAtLoc(\n        site: SITE.Site,\n        roomSite: SITE.Site,\n        room: TYPES.Room,\n        attachLoc: GWU.xy.Loc\n    ): boolean {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = site.rng.sequence(4);\n\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1) continue;\n\n            const offX = x - door[0];\n            const offY = y - door[1];\n\n            if (this._roomFitsAt(site, roomSite, room, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n\n                // TYPES.Room fits here.\n                site.copyTiles(roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n                //     return [x0, y0] as GWU.xy.Loc;\n                // });\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _roomFitsAt(\n        map: SITE.Site,\n        roomGrid: SITE.Site,\n        room: TYPES.Room,\n        roomToSiteX: number,\n        roomToSiteY: number\n    ) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n\n        const hall = room.hall || room;\n        const left = Math.min(room.left, hall.left);\n        const top = Math.min(room.top, hall.top);\n        const right = Math.max(room.right, hall.right);\n        const bottom = Math.max(room.bottom, hall.bottom);\n\n        for (xRoom = left; xRoom <= right; xRoom++) {\n            for (yRoom = top; yRoom <= bottom; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    if (\n                        !map.hasXY(xSite, ySite) ||\n                        map.isBoundaryXY(xSite, ySite)\n                    ) {\n                        return false;\n                    }\n\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n\n    _attachDoor(\n        site: SITE.Site,\n        room: TYPES.Room,\n        x: number,\n        y: number,\n        dir: number\n    ) {\n        const opts = this.doors;\n        let isDoor = false;\n\n        if (opts.chance && site.rng.chance(opts.chance)) {\n            isDoor = true;\n        }\n\n        const tile = isDoor ? opts.tile || 'DOOR' : 'FLOOR';\n        site.setTile(x, y, tile); // Door site.\n\n        // most cases...\n        if (!room.hall || room.hall.width == 1 || room.hall.height == 1) {\n            return;\n        }\n\n        if (dir === GWU.xy.UP || dir === GWU.xy.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n\n                if (site.isNothing(x - k, y)) {\n                    if (site.isSet(x - k, y - 1) && site.isSet(x - k, y + 1)) {\n                        site.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (site.isNothing(x + k, y)) {\n                    if (site.isSet(x + k, y - 1) && site.isSet(x + k, y + 1)) {\n                        site.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        } else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n\n                if (site.isNothing(x, y - k)) {\n                    if (site.isSet(x - 1, y - k) && site.isSet(x + 1, y - k)) {\n                        site.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (site.isNothing(x, y + k)) {\n                    if (site.isSet(x - 1, y + k) && site.isSet(x + 1, y + k)) {\n                        site.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n\n    addLoops(site: SITE.Site, opts: Partial<LOOP.LoopOptions>) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n\n    addLakes(site: SITE.Site, opts: Partial<LAKE.LakeOpts>) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n\n    addBridges(site: SITE.Site, opts: Partial<BRIDGE.BridgeOpts>) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n\n    addStairs(site: SITE.Site, opts: Partial<STAIRS.StairOpts>) {\n        const digger = new STAIRS.Stairs(opts);\n        const locs = digger.create(site);\n        if (locs) Object.assign(this.locations, locs);\n        return !!locs;\n    }\n\n    finish(site: SITE.Site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n\n    _removeDiagonalOpenings(site: SITE.Site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < site.width - 1; i++) {\n                for (j = 0; j < site.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (\n                            !site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)\n                        ) {\n                            if (site.rng.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            } else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, 'FLOOR'); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n\n    _finishDoors(site: SITE.Site) {\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isBoundaryXY(x, y)) return;\n\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                // if (\n                //     // TODO - isPassable\n                //     (site.isPassable(x + 1, y) || site.isPassable(x - 1, y)) &&\n                //     (site.isPassable(x, y + 1) || site.isPassable(x, y - 1))\n                // ) {\n                //     // If there's passable terrain to the left or right, and there's passable terrain\n                //     // above or below, then the door is orphaned and must be removed.\n                //     site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                // } else\n                if (\n                    (site.isWall(x + 1, y) ? 1 : 0) +\n                        (site.isWall(x - 1, y) ? 1 : 0) +\n                        (site.isWall(x, y + 1) ? 1 : 0) +\n                        (site.isWall(x, y - 1) ? 1 : 0) !=\n                    2\n                ) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, 'FLOOR', { superpriority: true }); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n\n    _finishWalls(site: SITE.Site) {\n        const boundaryTile = this.boundary ? 'IMPREGNABLE' : 'WALL';\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                } else {\n                    site.setTile(x, y, 'WALL');\n                }\n            }\n        });\n    }\n}\n\n// export function digMap(map: GWM.map.Map, options: Partial<DiggerOptions> = {}) {\n//     const digger = new Digger(options);\n//     return digger.create(map);\n// }\n","import * as GWU from 'gw-utils';\nimport * as SITE from '../site';\nimport { Blueprint } from './blueprint';\n\nexport class BuildData {\n    site: SITE.Site;\n    blueprint: Blueprint;\n    interior: GWU.grid.NumGrid;\n    occupied: GWU.grid.NumGrid;\n    candidates: GWU.grid.NumGrid;\n    viewMap: GWU.grid.NumGrid;\n    distanceMap: GWU.path.DijkstraMap;\n    originX: number = -1;\n    originY: number = -1;\n    distance25: number = -1;\n    distance75: number = -1;\n    machineNumber: number;\n    // depth = 0;\n    // seed = 0;\n\n    constructor(site: SITE.Site, blueprint: Blueprint, machine = 0) {\n        this.site = site;\n        this.blueprint = blueprint;\n        this.interior = GWU.grid.alloc(site.width, site.height);\n        this.occupied = GWU.grid.alloc(site.width, site.height);\n        this.viewMap = GWU.grid.alloc(site.width, site.height);\n        this.distanceMap = new GWU.path.DijkstraMap(site.width, site.height);\n        this.candidates = GWU.grid.alloc(site.width, site.height);\n        this.machineNumber = machine;\n    }\n\n    free() {\n        GWU.grid.free(this.interior);\n        GWU.grid.free(this.occupied);\n        GWU.grid.free(this.viewMap);\n        GWU.grid.free(this.candidates);\n    }\n\n    get rng(): GWU.rng.Random {\n        return this.site.rng;\n    }\n\n    reset(originX: number, originY: number) {\n        this.interior.fill(0);\n        this.occupied.fill(0);\n        this.viewMap.fill(0);\n        this.distanceMap.reset(this.site.width, this.site.height);\n        // this.candidates.fill(0);\n\n        this.originX = originX;\n        this.originY = originY;\n        this.distance25 = 0;\n        this.distance75 = 0;\n\n        // if (this.seed) {\n        //     this.site.setSeed(this.seed);\n        // }\n    }\n\n    calcDistances(maxDistance: number) {\n        SITE.computeDistanceMap(\n            this.site,\n            this.distanceMap,\n            this.originX,\n            this.originY,\n            maxDistance\n        );\n\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n\n        this.interior.forEach((v, x, y) => {\n            if (!v) return;\n            const dist = Math.round(this.distanceMap.getDistance(x, y));\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            } else {\n                distance25 -= distances[i];\n            }\n        }\n\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            } else {\n                distance75 -= distances[i];\n            }\n        }\n\n        this.distance25 = distance25;\n        this.distance75 = distance75;\n    }\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport * as SITE from '../site';\nimport * as STEP from './buildStep';\nimport { BuildData } from './data';\n\nconst Fl = GWU.flag.fl;\n\nexport enum Flags {\n    BP_ROOM = Fl(0), // spawns in a dead-end room that is dominated by a chokepoint of the given size (as opposed to a random place of the given size)\n    BP_VESTIBULE = Fl(1), // spawns in a doorway (location must be given) and expands outward, to guard the room\n    BP_REWARD = Fl(2), // metered reward machines\n    BP_ADOPT_ITEM = Fl(3), // the machine must adopt an item (e.g. a door key)\n\n    BP_PURGE_PATHING_BLOCKERS = Fl(4), // clean out traps and other T_PATHING_BLOCKERs\n    BP_PURGE_INTERIOR = Fl(5), // clean out all of the terrain in the interior before generating the machine\n    BP_PURGE_LIQUIDS = Fl(6), // clean out all of the liquids in the interior before generating the machine\n\n    BP_SURROUND_WITH_WALLS = Fl(7), // fill in any impassable gaps in the perimeter (e.g. water, lava, brimstone, traps) with wall\n    BP_IMPREGNABLE = Fl(8), // impassable perimeter and interior tiles are locked; tunneling bolts will bounce off harmlessly\n\n    BP_OPEN_INTERIOR = Fl(9), // clear out walls in the interior, widen the interior until convex or bumps into surrounding areas\n    BP_MAXIMIZE_INTERIOR = Fl(10), // same as BP_OPEN_INTERIOR but expands the room as far as it can go, potentially surrounding the whole level.\n    BP_REDESIGN_INTERIOR = Fl(11), // nuke and pave -- delete all terrain in the interior and build entirely new rooms within the bounds\n\n    BP_TREAT_AS_BLOCKING = Fl(12), // abort the machine if, were it filled with wall tiles, it would disrupt the level connectivity\n    BP_REQUIRE_BLOCKING = Fl(13), // abort the machine unless, were it filled with wall tiles, it would disrupt the level connectivity\n\n    BP_NO_INTERIOR_FLAG = Fl(14), // don't flag the area as being part of a machine\n    BP_NOT_IN_HALLWAY = Fl(15), // Do not allow building in hallways (for !ROOM, !VESTIBULE)\n}\n\nexport interface BlueprintOptions {\n    id: string;\n    tags: string | string[];\n    frequency: GWU.frequency.FrequencyConfig;\n    size: string | number[] | number;\n    flags: GWU.flag.FlagBase;\n    steps: Partial<STEP.StepOptions>[];\n}\n\nexport class Blueprint {\n    public tags: string[] = [];\n    public frequency: GWU.frequency.FrequencyFn;\n    public size: GWU.range.Range;\n    public flags: number = 0;\n    public steps: STEP.BuildStep[] = [];\n    public id: string = 'n/a';\n\n    constructor(opts: Partial<BlueprintOptions> = {}) {\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GWU.frequency.make(opts.frequency || 100);\n\n        if (opts.size) {\n            this.size = GWU.range.make(opts.size);\n            if (this.size.lo <= 0) this.size.lo = 1;\n            if (this.size.hi < this.size.lo) this.size.hi = this.size.lo;\n        } else {\n            this.size = GWU.range.make([1, 1]); // Anything bigger makes weird things happen\n        }\n        if (opts.flags) {\n            this.flags = GWU.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n            this.steps.forEach((s, i) => (s.index = i));\n        }\n        if (opts.id) {\n            this.id = opts.id;\n        }\n\n        if (this.flags & Flags.BP_ADOPT_ITEM) {\n            if (\n                !this.steps.some((step) => {\n                    if (step.adoptItem) return true;\n                    if (step.hordeTakesItem && !step.item) return true;\n                    return false;\n                })\n            ) {\n                throw new Error(\n                    'Blueprint calls for BP_ADOPT_ITEM, but has no adoptive step.'\n                );\n            }\n        }\n    }\n\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n\n    get notInHallway() {\n        return !!(this.flags & Flags.BP_NOT_IN_HALLWAY);\n    }\n\n    qualifies(requiredFlags: number, tags?: string | string[]) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want))) return false;\n        }\n\n        if (\n            // Must have the required flags:\n            ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    pickComponents(rng: GWU.rng.Random) {\n        const alternativeFlags = [\n            STEP.StepFlags.BS_ALTERNATIVE,\n            STEP.StepFlags.BS_ALTERNATIVE_2,\n        ];\n\n        const keepFeature = new Array(this.steps.length).fill(true);\n\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = rng.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        } else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n\n    fillInterior(builder: BuildData): number {\n        const interior = builder.interior;\n        const site = builder.site;\n\n        interior.fill(0);\n\n        // Find a location and map out the machine interior.\n        if (this.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n\n            // Now map out the interior into interior[][].\n            // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n            // same or lower choke value, ignoring any tiles that are already part of a machine.\n            // If we get false from this, try again. If we've tried too many times already, abort.\n            return addTileToInteriorAndIterate(\n                builder,\n                builder.originX,\n                builder.originY\n            );\n        } else if (this.isVestiblue) {\n            return computeVestibuleInterior(builder, this);\n            // success\n        } else {\n            // Find a location and map out the interior for a non-room machine.\n            // The strategy here is simply to pick a random location on the map,\n            // expand it along a pathing map by one space in all directions until the size reaches\n            // the chosen size, and then make sure the resulting space qualifies.\n            // If not, try again. If we've tried too many times already, abort.\n\n            let distanceMap = builder.distanceMap;\n\n            SITE.computeDistanceMap(\n                site,\n                distanceMap,\n                builder.originX,\n                builder.originY,\n                this.size.hi\n            );\n\n            const seq = site.rng.sequence(site.width * site.height);\n            let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n            let goalSize = this.size.value(); // Keeps track of the goal size.\n\n            for (let k = 0; k < 1000 && qualifyingTileCount < goalSize; k++) {\n                for (\n                    let n = 0;\n                    n < seq.length && qualifyingTileCount < goalSize;\n                    n++\n                ) {\n                    const i = Math.floor(seq[n] / site.height);\n                    const j = seq[n] % site.height;\n\n                    if (Math.round(distanceMap.getDistance(i, j)) == k) {\n                        interior.set(i, j, 1);\n                        qualifyingTileCount++;\n\n                        const machine = site.getMachine(i, j);\n                        if (\n                            site.isOccupied(i, j) ||\n                            (machine > 0 && machine !== builder.machineNumber) // in different machine\n                        ) {\n                            // Abort if we've entered another machine or engulfed another machine's item or monster.\n                            return 0;\n                        }\n                    }\n                }\n            }\n            // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n            // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n            return qualifyingTileCount;\n        }\n    }\n\n    //  function redesignInterior( interior, originX, originY, theDungeonProfileIndex) {\n    //     let i, j, n, newX, newY;\n    //     let dir;\n    //     let orphanList = [];\n    //     let orphanCount = 0;\n\n    //     let grid, pathingGrid, costGrid;\n    //     grid = allocGrid();\n\n    //     for (i=0; i<DCOLS; i++) {\n    //         for (j=0; j<DROWS; j++) {\n    //             if (interior.get(i,j)) {\n    //                 if (i == originX && j == originY) {\n    //                     grid[i][j] = 1; // All rooms must grow from this space.\n    //                 } else {\n    //                     grid[i][j] = 0; // Other interior squares are fair game for placing rooms.\n    //                 }\n    //             } else if (cellIsPassableOrDoor(i, j)) {\n    //                 grid[i][j] = 1; // Treat existing level as already built (though shielded by a film of -1s).\n    //                 for (dir = 0; dir < 4; dir++) {\n    //                     newX = i + nbDirs[dir][0];\n    //                     newY = j + nbDirs[dir][1];\n    //                     if (coordinatesAreInMap(newX, newY)\n    //                         && interior[newX][newY]\n    //                         && (newX != originX || newY != originY)) {\n\n    //                         orphanList[orphanCount] = [newX, newY];\n    //                         orphanCount++;\n    //                         grid[i][j] = -1; // Treat the orphaned door as off limits.\n\n    //                         break;\n    //                     }\n    //                 }\n    //             } else {\n    //                 grid[i][j] = -1; // Exterior spaces are off limits.\n    //             }\n    //         }\n    //     }\n    //     await attachRooms(grid, dungeonProfileCatalog[theDungeonProfileIndex], 40, 40);\n\n    //     // Connect to preexisting rooms that were orphaned (mostly preexisting machine rooms).\n    //     if (orphanCount > 0) {\n    //         pathingGrid = allocGrid();\n    //         costGrid = allocGrid();\n    //         for (n = 0; n < orphanCount; n++) {\n\n    //             if (D_INSPECT_MACHINES) {\n    //                 dumpLevelToScreen();\n    //                 copyGrid(pathingGrid, grid);\n    //                 findReplaceGrid(pathingGrid, -1, -1, 0);\n    //                 hiliteGrid(pathingGrid, /* Color. */green, 50);\n    //                 plotCharWithColor('X', mapToWindowX(orphanList[n][0]), mapToWindowY(orphanList[n][1]), /* Color. */black, /* Color. */orange);\n    //                 await temporaryMessage(\"Orphan detected:\", true);\n    //             }\n\n    //             for (i=0; i<DCOLS; i++) {\n    //                 for (j=0; j<DROWS; j++) {\n    //                     if (interior.get(i,j)) {\n    //                         if (grid[i][j] > 0) {\n    //                             pathingGrid[i][j] = 0;\n    //                             costGrid[i][j] = 1;\n    //                         } else {\n    //                             pathingGrid[i][j] = 30000;\n    //                             costGrid[i][j] = 1;\n    //                         }\n    //                     } else {\n    //                         pathingGrid[i][j] = 30000;\n    //                         costGrid[i][j] = PDS_OBSTRUCTION;\n    //                     }\n    //                 }\n    //             }\n    //             dijkstraScan(pathingGrid, costGrid, false);\n\n    //             i = orphanList[n][0];\n    //             j = orphanList[n][1];\n    //             while (pathingGrid[i][j] > 0) {\n    //                 for (dir = 0; dir < 4; dir++) {\n    //                     newX = i + nbDirs[dir][0];\n    //                     newY = j + nbDirs[dir][1];\n\n    //                     if (coordinatesAreInMap(newX, newY)\n    //                         && pathingGrid[newX][newY] < pathingGrid[i][j]) {\n\n    //                         grid[i][j] = 1;\n    //                         i = newX;\n    //                         j = newY;\n    //                         break;\n    //                     }\n    //                 }\n    //                 brogueAssert(dir < 4);\n    //                 if (D_INSPECT_MACHINES) {\n    //                     dumpLevelToScreen();\n    //                     displayGrid(pathingGrid);\n    //                     plotCharWithColor('X', mapToWindowX(i), mapToWindowY(j), /* Color. */black, /* Color. */orange);\n    //                     await temporaryMessage(\"Orphan connecting:\", true);\n    //                 }\n    //             }\n    //         }\n    //         freeGrid(pathingGrid);\n    //         freeGrid(costGrid);\n    //     }\n\n    //     await addLoops(grid, 10);\n    //     for(i=0; i<DCOLS; i++) {\n    //         for(j=0; j<DROWS; j++) {\n    //             if (interior.get(i,j)) {\n    //                 if (grid[i][j] >= 0) {\n    //                     pmap[i][j].layers[SURFACE] = pmap[i][j].layers[GAS] = NOTHING;\n    //                 }\n    //                 if (grid[i][j] == 0) {\n    //                     pmap[i][j].layers[DUNGEON] = GRANITE;\n    //                     interior.get(i,j) = false;\n    //                 }\n    //                 if (grid[i][j] >= 1) {\n    //                     pmap[i][j].layers[DUNGEON] = FLOOR;\n    //                 }\n    //             }\n    //         }\n    //     }\n    //     freeGrid(grid);\n    // }\n}\n\nexport function markCandidates(buildData: BuildData): number {\n    const site = buildData.site;\n    const candidates = buildData.candidates;\n    const blueprint = buildData.blueprint;\n    candidates.fill(0);\n\n    // Find a location and map out the machine interior.\n    if (blueprint.isRoom) {\n        // If it's a room machine, count up the gates of appropriate\n        // choke size and remember where they are. The origin of the room will be the gate location.\n\n        candidates.update((_v, x, y) => {\n            return site.isGateSite(x, y) &&\n                blueprint.size.contains(site.getChokeCount(x, y))\n                ? 1\n                : 0;\n        });\n    } else if (blueprint.isVestiblue) {\n        //  Door machines must have locations passed in. We can't pick one ourselves.\n        throw new Error(\n            'ERROR: Attempted to build a vestiblue without a location being provided.'\n        );\n    } else {\n        candidates.update((_v, x, y) => {\n            if (!site.isPassable(x, y)) return 0;\n            if (blueprint.notInHallway) {\n                const count = GWU.xy.arcCount(x, y, (i, j) =>\n                    site.isPassable(i, j)\n                );\n                return count <= 1 ? 1 : 0;\n            }\n            return 1;\n        });\n    }\n    return candidates.count((v) => v == 1);\n}\n\nexport function pickCandidateLoc(buildData: BuildData): GWU.xy.Loc | null {\n    const site = buildData.site;\n    const candidates = buildData.candidates;\n\n    const randSite = site.rng.matchingLoc(\n        site.width,\n        site.height,\n        (x, y) => candidates.get(x, y)! == 1\n    );\n\n    if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n        // If no suitable sites, abort.\n        return null;\n    }\n    return randSite;\n}\n\n// // Assume site has been analyzed (aka GateSites and ChokeCounts set)\n// export function computeInterior(\n//     builder: BuildData,\n//     blueprint: Blueprint\n// ): boolean {\n//     let failsafe = blueprint.isRoom ? 10 : 20;\n//     let tryAgain;\n//     const interior = builder.interior;\n//     const site = builder.site;\n\n//     do {\n//         tryAgain = false;\n//         if (--failsafe <= 0) {\n//             // console.log(\n//             //     `Failed to build blueprint ${blueprint.id}; failed repeatedly to find a suitable blueprint location.`\n//             // );\n//             return false;\n//         }\n\n//         let count = fillInterior(builder, blueprint);\n\n//         // Now make sure the interior map satisfies the machine's qualifications.\n//         if (!count) {\n//             console.debug('- no interior');\n//             tryAgain = true;\n//         } else if (!blueprint.size.contains(count)) {\n//             console.debug('- too small');\n//             tryAgain = true;\n//         } else if (\n//             blueprint.treatAsBlocking &&\n//             SITE.siteDisruptedBy(site, interior, { machine: site.machineCount })\n//         ) {\n//             console.debug('- blocks');\n//             tryAgain = true;\n//         } else if (\n//             blueprint.requireBlocking &&\n//             SITE.siteDisruptedSize(site, interior) < 100\n//         ) {\n//             console.debug('- does not block');\n//             tryAgain = true;\n//         }\n\n//         // Now loop if necessary.\n//     } while (tryAgain);\n\n//     // console.log(tryAgain, failsafe);\n\n//     return true;\n// }\n\nexport function computeVestibuleInterior(\n    builder: BuildData,\n    blueprint: Blueprint\n): number {\n    let success = true;\n\n    const site = builder.site;\n    const interior = builder.interior;\n    interior.fill(0);\n\n    if (blueprint.size.hi == 1) {\n        interior.set(builder.originX, builder.originY, 1);\n        return 1;\n    }\n\n    // If this is a wall - it is really an error (maybe manually trying a build location?)\n    const doorChokeCount = site.getChokeCount(builder.originX, builder.originY);\n    if (doorChokeCount > 10000) {\n        return 0;\n    }\n\n    const vestibuleLoc = [-1, -1];\n    let vestibuleChokeCount = doorChokeCount;\n    GWU.xy.eachNeighbor(\n        builder.originX,\n        builder.originY,\n        (x, y) => {\n            const count = site.getChokeCount(x, y);\n            if (count == doorChokeCount) return;\n            if (count > 10000) return;\n            if (count < 0) return;\n            vestibuleLoc[0] = x;\n            vestibuleLoc[1] = y;\n            vestibuleChokeCount = count;\n        },\n        true\n    );\n\n    const roomSize = vestibuleChokeCount - doorChokeCount;\n    if (blueprint.size.contains(roomSize)) {\n        // The room entirely fits within the vestibule desired size\n        const count = interior.floodFill(\n            vestibuleLoc[0],\n            vestibuleLoc[1],\n            (_v, i, j) => {\n                if (site.isOccupied(i, j)) {\n                    success = false;\n                }\n                return site.getChokeCount(i, j) === vestibuleChokeCount;\n            },\n            1\n        );\n        if (success && blueprint.size.contains(count)) return roomSize;\n    }\n\n    let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n    const wantSize = blueprint.size.value(site.rng); // Keeps track of the goal size.\n\n    const distMap = builder.distanceMap;\n    SITE.computeDistanceMap(\n        site,\n        distMap,\n        builder.originX,\n        builder.originY,\n        blueprint.size.hi\n    );\n\n    const cells = site.rng.sequence(site.width * site.height);\n    success = true;\n    for (let k = 0; k < 1000 && qualifyingTileCount < wantSize; k++) {\n        for (\n            let i = 0;\n            i < cells.length && qualifyingTileCount < wantSize;\n            ++i\n        ) {\n            const x = Math.floor(cells[i] / site.height);\n            const y = cells[i] % site.height;\n\n            const dist = Math.round(distMap.getDistance(x, y));\n\n            if (dist != k) continue;\n            if (site.isOccupied(x, y)) {\n                success = false;\n                qualifyingTileCount = wantSize;\n            }\n            if (site.getChokeCount(x, y) <= doorChokeCount) continue;\n\n            interior.set(x, y, 1);\n            qualifyingTileCount += 1;\n        }\n    }\n\n    return qualifyingTileCount;\n}\n\n// Assumes (startX, startY) is in the machine.\n// Returns true if everything went well, and false if we ran into a machine component\n// that was already there, as we don't want to build a machine around it.\nfunction addTileToInteriorAndIterate(\n    builder: BuildData,\n    startX: number,\n    startY: number\n): number {\n    let goodSoFar = true;\n    const interior = builder.interior;\n    const site = builder.site;\n\n    let count = 1;\n    interior.set(startX, startY, 1);\n    const startChokeCount = site.getChokeCount(startX, startY);\n\n    for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n        const newX = startX + GWU.xy.DIRS[dir][0];\n        const newY = startY + GWU.xy.DIRS[dir][1];\n        if (!site.hasXY(newX, newY)) continue;\n        if (interior.get(newX, newY)) continue; // already done\n\n        if (\n            site.isOccupied(newX, newY) ||\n            (site.getMachine(newX, newY) && !site.isGateSite(newX, newY))\n        ) {\n            // Abort if there's an item in the room.\n            // Items haven't been populated yet, so the only way this could happen is if another machine\n            // previously placed an item here.\n            // Also abort if we're touching another machine at any point other than a gate tile.\n            return 0;\n        }\n        if (\n            site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n            !site.getMachine(newX, newY)\n        ) {\n            let additional = addTileToInteriorAndIterate(builder, newX, newY);\n            if (additional <= 0) return 0;\n            count += additional;\n        }\n    }\n    return count;\n}\n\nexport function maximizeInterior(\n    data: BuildData,\n    minimumInteriorNeighbors = 1\n) {\n    const interior = data.interior;\n    const site = data.site;\n    let interiorNeighborCount = 0;\n    // let openNeighborCount = 0;\n\n    let madeChange = true;\n    let interiorCount = 0;\n    let maxInteriorCount = data.blueprint.size.hi;\n    let gen = 0;\n\n    while (madeChange && interiorCount < maxInteriorCount) {\n        madeChange = false;\n        interiorCount = 0;\n        ++gen;\n        interior.forEach((i, x, y) => {\n            if (!i) return;\n            ++interiorCount;\n\n            if (i != gen) return;\n\n            GWU.xy.eachNeighbor(\n                x,\n                y,\n                (i, j) => {\n                    if (!interior.hasXY(i, j) || interior.get(i, j)) return;\n                    if (interior.isBoundaryXY(i, j)) return;\n\n                    interiorNeighborCount = 0;\n                    let ok = true;\n                    GWU.xy.eachNeighbor(\n                        i,\n                        j,\n                        (x2, y2) => {\n                            if (interior.get(x2, y2)) {\n                                ++interiorNeighborCount;\n                            } else if (!site.isWall(x2, y2)) {\n                                ok = false; // non-interior and not wall\n                            } else if (site.getMachine(x2, y2)) {\n                                ok = false; // in another machine\n                            }\n                        },\n                        false // 8 dirs\n                    );\n\n                    if (!ok || interiorNeighborCount < minimumInteriorNeighbors)\n                        return;\n\n                    interior.set(i, j, gen + 1);\n                    ++interiorCount;\n                    if (site.blocksPathing(i, j)) {\n                        site.setTile(i, j, 'FLOOR');\n                    }\n                    madeChange = true;\n                },\n                true // 4 dirs\n            );\n        });\n    }\n    interior.update((v) => (v > 0 ? 1 : 0));\n}\n\nexport function prepareInterior(builder: BuildData) {\n    const interior = builder.interior;\n    const site = builder.site;\n    const blueprint = builder.blueprint;\n\n    // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n    if (blueprint.maximizeInterior) {\n        maximizeInterior(builder, 1);\n    } else if (blueprint.openInterior) {\n        maximizeInterior(builder, 4);\n    }\n\n    // If requested, cleanse the interior -- no interesting terrain allowed.\n    if (blueprint.purgeInterior) {\n        interior.forEach((v, x, y) => {\n            if (v) site.setTile(x, y, 'FLOOR');\n        });\n    } else {\n        if (blueprint.purgeBlockers) {\n            // If requested, purge pathing blockers -- no traps allowed.\n            interior.forEach((v, x, y) => {\n                if (!v) return;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, 'FLOOR');\n                }\n            });\n        }\n\n        // If requested, purge the liquid layer in the interior -- no liquids allowed.\n        if (blueprint.purgeLiquids) {\n            interior.forEach((v, x, y) => {\n                if (v && site.isAnyLiquid(x, y)) {\n                    site.setTile(x, y, 'FLOOR');\n                }\n            });\n        }\n    }\n\n    // Surround with walls if requested.\n    if (blueprint.surroundWithWalls) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.isGateSite(x, y)) return;\n            GWU.xy.eachNeighbor(\n                x,\n                y,\n                (i, j) => {\n                    if (!interior.hasXY(i, j)) return; // Not valid x,y\n                    if (interior.get(i, j)) return; // is part of machine\n                    if (site.isWall(i, j)) return; // is already a wall (of some sort)\n\n                    if (site.isGateSite(i, j)) return; // is a door site\n                    if (site.getMachine(i, j)) return; // is part of a machine\n\n                    if (site.blocksPathing(i, j)) return; // is a blocker for the player (water?)\n                    site.setTile(i, j, 'WALL');\n                },\n                false // all 8 directions\n            );\n        });\n    }\n\n    // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n    // Then zero out any portion of the interior that is still wall.\n    // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n    //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n    // }\n\n    // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n    if (blueprint.makeImpregnable) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.isGateSite(x, y)) return;\n            site.makeImpregnable(x, y);\n            GWU.xy.eachNeighbor(\n                x,\n                y,\n                (i, j) => {\n                    if (!interior.hasXY(i, j)) return;\n                    if (interior.get(i, j)) return;\n                    if (site.isGateSite(i, j)) return;\n                    site.makeImpregnable(i, j);\n                },\n                false\n            );\n        });\n    }\n\n    // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n    const machineNumber = builder.machineNumber;\n    interior.forEach((v, x, y) => {\n        if (!v) return;\n\n        if (!blueprint.noInteriorFlag) {\n            site.setMachine(x, y, machineNumber, blueprint.isRoom);\n        }\n\n        // secret doors mess up machines\n        // TODO - is this still true?\n        if (site.isSecretDoor(x, y)) {\n            site.setTile(x, y, 'DOOR');\n        }\n    });\n}\n\n// export function expandMachineInterior(\n//     builder: BuildData,\n//     minimumInteriorNeighbors = 1\n// ) {\n//     let madeChange;\n//     const interior = builder.interior;\n//     const site = builder.site;\n\n//     do {\n//         madeChange = false;\n//         interior.forEach((_v, x, y) => {\n//             // if (v && site.isDoor(x, y)) {\n//             //     site.setTile(x, y, SITE.FLOOR); // clean out the doors...\n//             //     return;\n//             // }\n//             if (site.hasCellFlag(x, y, GWM.flags.Cell.IS_IN_MACHINE)) return;\n//             if (!site.blocksPathing(x, y)) return;\n\n//             let nbcount = 0;\n//             GWU.xy.eachNeighbor(\n//                 x,\n//                 y,\n//                 (i, j) => {\n//                     if (!interior.hasXY(i, j)) return; // Not in map\n//                     if (interior.isBoundaryXY(i, j)) return; // Not on boundary\n\n//                     if (interior.get(i,j) && !site.blocksPathing(i, j)) {\n//                         ++nbcount; // in machine and open tile\n//                     }\n//                 },\n//                 false\n//             );\n\n//             if (nbcount < minimumInteriorNeighbors) return;\n\n//             nbcount = 0;\n//             GWU.xy.eachNeighbor(\n//                 x,\n//                 y,\n//                 (i, j) => {\n//                     if (!interior.hasXY(i, j)) return; // not on map\n//                     if (interior.get(i,j)) return; // already part of machine\n//                     if (\n//                         !site.isWall(i, j) ||\n//                         site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)\n//                     ) {\n//                         ++nbcount; // tile is not a wall or is in a machine\n//                     }\n//                 },\n//                 false\n//             );\n\n//             if (nbcount) return;\n\n//             // Eliminate this obstruction; welcome its location into the machine.\n//             madeChange = true;\n//             interior[x][y] = 1;\n//             if (site.blocksPathing(x, y)) {\n//                 site.setTile(x, y, SITE.FLOOR);\n//             }\n//             GWU.xy.eachNeighbor(x, y, (i, j) => {\n//                 if (!interior.hasXY(i, j)) return;\n//                 if (site.isSet(i, j)) return;\n//                 site.setTile(i, j, SITE.WALL);\n//             });\n//         });\n//     } while (madeChange);\n// }\n\n///////////////////////////\n// INSTALL\n\nexport const blueprints: Record<string, Blueprint> = {};\n\nexport function install(\n    id: string,\n    blueprint: Blueprint | Partial<BlueprintOptions>\n) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\n\nexport function random(\n    requiredFlags: number,\n    depth: number,\n    rng?: GWU.rng.Random\n): Blueprint {\n    const matches = Object.values(blueprints).filter(\n        (b) => b.qualifies(requiredFlags) && b.frequency(depth)\n    );\n    rng = rng || GWU.rng.random;\n    return rng.item(matches);\n}\n\nexport function get(id: string | Blueprint): Blueprint {\n    if (id instanceof Blueprint) return id;\n    return blueprints[id];\n}\n\nexport function make(config: Partial<BlueprintOptions>): Blueprint {\n    // if (!config.id) throw new Error('id is required to make Blueprint.');\n    return new Blueprint(config);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\n\nimport * as SITE from '../site';\nimport * as BLUE from './blueprint';\nimport * as STEP from './buildStep';\nimport * as ITEM from '../site/item';\nimport * as HORDE from '../site/horde';\n\nimport { BuildData } from './data';\nimport { NullLogger, Logger } from '../site/log/logger';\nimport { ConsoleLogger } from '../site/log/consoleLogger';\nimport { DisruptOptions, Site } from '../site';\n\nexport type BlueType = BLUE.Blueprint | string;\n\nexport interface BuilderOptions {\n    blueprints: BlueType[] | { [key: string]: BlueType };\n    log: Logger | boolean;\n    seed: number;\n}\n\nexport interface BuildInfo {\n    x: number;\n    y: number;\n}\n\nexport type BuildResult = BuildInfo | null;\n\nexport class Builder {\n    blueprints: BLUE.Blueprint[] | null = null;\n    log: Logger;\n    seed: number;\n\n    constructor(options: Partial<BuilderOptions> = {}) {\n        if (options.blueprints) {\n            if (!Array.isArray(options.blueprints)) {\n                options.blueprints = Object.values(options.blueprints);\n            }\n            this.blueprints = options.blueprints.map((v) => BLUE.get(v));\n        }\n        if (options.log === true) {\n            this.log = new ConsoleLogger();\n        } else {\n            this.log = options.log || new NullLogger();\n        }\n        if (options.seed) {\n            this.seed = options.seed;\n        } else {\n            this.seed = 0;\n        }\n    }\n\n    _pickRandom(\n        requiredFlags: number,\n        depth: number,\n        rng?: GWU.rng.Random\n    ): BLUE.Blueprint | null {\n        rng = rng || GWU.rng.random;\n        const blueprints = this.blueprints || Object.values(BLUE.blueprints);\n        const weights = blueprints.map((b) => {\n            if (!b.qualifies(requiredFlags)) return 0;\n            return b.frequency(depth);\n        });\n\n        const index = rng.weighted(weights) as number;\n        return blueprints[index] || null;\n    }\n\n    buildRandom(\n        site: Site,\n        requiredMachineFlags = BLUE.Flags.BP_ROOM,\n        x = -1,\n        y = -1,\n        adoptedItem: ITEM.ItemInstance | null = null\n    ): BuildResult {\n        const depth = site.depth;\n\n        let tries = 0;\n        while (tries < 10) {\n            const blueprint = this._pickRandom(\n                requiredMachineFlags,\n                depth,\n                site.rng\n            );\n            if (!blueprint) {\n                this.log.onBuildError(\n                    `Failed to find matching blueprint: requiredMachineFlags : ${GWU.flag.toString(\n                        BLUE.Flags,\n                        requiredMachineFlags\n                    )}, depth: ${depth}`\n                );\n                return null;\n            }\n\n            const data = new BuildData(site, blueprint);\n            site.analyze();\n\n            this.log.onBlueprintPick(data, requiredMachineFlags, depth);\n\n            if (this._buildAt(data, x, y, adoptedItem)) {\n                return { x, y };\n            }\n            ++tries;\n        }\n\n        // console.log(\n        //     'Failed to build random blueprint matching flags: ' +\n        //         GWU.flag.toString(BLUE.Flags, requiredMachineFlags) +\n        //         ' tried : ' +\n        //         tries.join(', ')\n        // );\n        return null;\n    }\n\n    build(\n        site: Site,\n        blueprint: BLUE.Blueprint | string,\n        x = -1,\n        y = -1,\n        adoptedItem: ITEM.ItemInstance | null = null\n    ): BuildResult {\n        if (typeof blueprint === 'string') {\n            const id = blueprint;\n            blueprint = BLUE.blueprints[id];\n            if (!blueprint) throw new Error('Failed to find blueprint - ' + id);\n        }\n\n        if (this.seed) {\n            site.rng.seed(this.seed);\n        }\n\n        const data = new BuildData(site, blueprint);\n        site.analyze();\n\n        return this._buildAt(data, x, y, adoptedItem);\n    }\n\n    _buildAt(\n        data: BuildData,\n        x = -1,\n        y = -1,\n        adoptedItem: ITEM.ItemInstance | null = null\n    ): BuildResult {\n        if (x >= 0 && y >= 0) {\n            return this._build(data, x, y, adoptedItem);\n        }\n\n        let count = this._markCandidates(data);\n        if (!count) {\n            return null;\n        }\n\n        let tries = 20; // TODO - Make property of Blueprint\n        while (count-- && tries--) {\n            const loc = BLUE.pickCandidateLoc(data) || false;\n            if (loc) {\n                if (this._build(data, loc[0], loc[1], adoptedItem)) {\n                    return { x: loc[0], y: loc[1] };\n                }\n            }\n        }\n\n        this.log.onBlueprintFail(\n            data,\n            'No suitable locations found to build blueprint.'\n        );\n        return null;\n    }\n\n    //////////////////////////////////////////\n    // Returns true if the machine got built; false if it was aborted.\n    // If empty array spawnedItems or spawnedMonsters is given, will pass those back for deletion if necessary.\n    _build(\n        data: BuildData,\n        originX: number,\n        originY: number,\n        adoptedItem: ITEM.ItemInstance | null = null\n    ): BuildResult {\n        data.reset(originX, originY);\n        this.log.onBlueprintStart(data, adoptedItem);\n\n        if (!this._computeInterior(data)) {\n            return null;\n        }\n\n        // This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.\n        const snapshot = data.site.snapshot();\n        data.machineNumber = data.site.nextMachineId(); // Reserve this machine number, starting with 1.\n\n        // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.\n        BLUE.prepareInterior(data);\n\n        // Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)\n        // and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.\n        data.calcDistances(data.blueprint.size.hi);\n\n        // Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.\n        // Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.\n\n        const components = data.blueprint.pickComponents(data.site.rng);\n\n        // Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.\n\n        // Now tick through the features and build them.\n        for (let index = 0; index < components.length; index++) {\n            const component = components[index];\n            // console.log('BUILD COMPONENT', component);\n\n            if (!this._buildStep(data, component, adoptedItem)) {\n                // failure! abort!\n                // Restore the map to how it was before we touched it.\n                this.log.onBlueprintFail(\n                    data,\n                    `Failed to build step ${component.index + 1}/${\n                        data.blueprint.steps.length\n                    }.`\n                );\n                data.site.restore(snapshot);\n                snapshot.free();\n                // abortItemsAndMonsters(spawnedItems, spawnedMonsters);\n                return null;\n            }\n        }\n\n        // Clear out the interior flag for all non-wired cells, if requested.\n        if (data.blueprint.noInteriorFlag) {\n            SITE.clearInteriorFlag(data.site, data.machineNumber);\n        }\n\n        // if (torchBearer && torch) {\n        // \tif (torchBearer->carriedItem) {\n        // \t\tdeleteItem(torchBearer->carriedItem);\n        // \t}\n        // \tremoveItemFromChain(torch, floorItems);\n        // \ttorchBearer->carriedItem = torch;\n        // }\n\n        this.log.onBlueprintSuccess(data);\n\n        snapshot.free();\n\n        // console.log('Built a machine from blueprint:', originX, originY);\n        return { x: originX, y: originY };\n    }\n\n    _markCandidates(data: BuildData): number {\n        const count = BLUE.markCandidates(data);\n\n        if (count <= 0) {\n            this.log.onBlueprintFail(\n                data,\n                'No suitable candidate locations found.'\n            );\n            return 0;\n        }\n\n        this.log.onBlueprintCandidates(data);\n\n        return count;\n    }\n\n    _computeInterior(data: BuildData): boolean {\n        let fail = null;\n        let count = data.blueprint.fillInterior(data);\n\n        // Now make sure the interior map satisfies the machine's qualifications.\n        if (!count) {\n            fail = 'Interior error.';\n        } else if (!data.blueprint.size.contains(count)) {\n            fail = `Interior wrong size - have: ${count}, want: ${data.blueprint.size.toString()}`;\n        } else if (\n            data.blueprint.treatAsBlocking &&\n            SITE.siteDisruptedBy(data.site, data.interior, {\n                machine: data.site.machineCount,\n            })\n        ) {\n            fail = 'Interior blocks map.';\n        } else if (\n            data.blueprint.requireBlocking &&\n            SITE.siteDisruptedSize(data.site, data.interior) < 100\n        ) {\n            fail = 'Interior does not block enough cells.';\n        }\n\n        if (!fail) {\n            this.log.onBlueprintInterior(data);\n\n            return true;\n        }\n\n        this.log.onBlueprintFail(data, fail);\n        return false;\n    }\n\n    _buildStep(\n        data: BuildData,\n        buildStep: STEP.BuildStep,\n        adoptedItem: ITEM.ItemInstance | null\n    ) {\n        let wantCount = 0;\n        let builtCount = 0;\n\n        const site = data.site;\n\n        this.log.onStepStart(data, buildStep, adoptedItem);\n\n        // console.log(\n        //     'buildComponent',\n        //     blueprint.id,\n        //     blueprint.steps.indexOf(buildStep)\n        // );\n\n        // Figure out the distance bounds.\n        const distanceBound = STEP.calcDistanceBound(data, buildStep);\n\n        // If the StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n\n        // Make a master map of candidate locations for this feature.\n        let qualifyingTileCount = 0;\n\n        if (buildStep.buildVestibule) {\n            // Generate a door guard machine.\n            // Try to create a sub-machine that qualifies.\n\n            let success = this.buildRandom(\n                data.site,\n                BLUE.Flags.BP_VESTIBULE,\n                data.originX,\n                data.originY\n            );\n\n            if (!success) {\n                this.log.onStepFail(\n                    data,\n                    buildStep,\n                    'Failed to build vestibule'\n                );\n                return false;\n            }\n        }\n\n        // If we are just building a vestibule, then we can exit here...\n        if (!buildStep.buildsInstances) {\n            this.log.onStepSuccess(data, buildStep);\n            return true;\n        }\n\n        const candidates = GWU.grid.alloc(site.width, site.height);\n\n        let didSomething = false;\n\n        do {\n            didSomething = false;\n\n            if (buildStep.buildAtOrigin) {\n                candidates.set(data.originX, data.originY, 1);\n                qualifyingTileCount = 1;\n                wantCount = 1;\n            } else {\n                qualifyingTileCount = buildStep.markCandidates(\n                    data,\n                    candidates,\n                    distanceBound\n                );\n\n                if (\n                    buildStep.generateEverywhere ||\n                    buildStep.repeatUntilNoProgress\n                ) {\n                    wantCount = qualifyingTileCount;\n                } else {\n                    wantCount = buildStep.count.value(site.rng);\n                }\n\n                this.log.onStepCandidates(\n                    data,\n                    buildStep,\n                    candidates,\n                    wantCount\n                );\n\n                // get rid of all error/invalid codes\n                candidates.update((v) => (v == 1 ? 1 : 0));\n\n                if (\n                    !qualifyingTileCount ||\n                    qualifyingTileCount < buildStep.count.lo\n                ) {\n                    this.log.onStepFail(\n                        data,\n                        buildStep,\n                        `Only ${qualifyingTileCount} qualifying tiles - want ${buildStep.count.toString()}.`\n                    );\n                    return false;\n                }\n            }\n\n            let x = 0,\n                y = 0;\n\n            while (qualifyingTileCount > 0 && builtCount < wantCount) {\n                // Find a location for the feature.\n                if (buildStep.buildAtOrigin) {\n                    // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                    x = data.originX;\n                    y = data.originY;\n                } else {\n                    // Pick our candidate location randomly, and also strike it from\n                    // the candidates map so that subsequent instances of this same feature can't choose it.\n                    [x, y] = data.rng.matchingLoc(\n                        candidates.width,\n                        candidates.height,\n                        (x, y) => candidates.get(x, y) == 1\n                    );\n                }\n                // Don't waste time trying the same place again whether or not this attempt succeeds.\n                candidates.set(x, y, 0);\n                qualifyingTileCount--;\n\n                const snapshot = data.site.snapshot();\n\n                if (\n                    this._buildStepInstance(data, buildStep, x, y, adoptedItem)\n                ) {\n                    // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n                    qualifyingTileCount -= buildStep.makePersonalSpace(\n                        data,\n                        x,\n                        y,\n                        candidates\n                    );\n                    builtCount++; // we've placed an instance\n                    didSomething = true;\n                    snapshot.free(); // This snapshot is useless b/c we made changes...\n                } else {\n                    data.site.restore(snapshot); // need to undo any changes...\n                    snapshot.free();\n                }\n\n                // Finished with this instance!\n            }\n        } while (didSomething && buildStep.repeatUntilNoProgress);\n\n        GWU.grid.free(candidates);\n\n        if (\n            !buildStep.count.contains(builtCount) &&\n            !buildStep.generateEverywhere &&\n            !buildStep.repeatUntilNoProgress\n        ) {\n            this.log.onStepFail(\n                data,\n                buildStep,\n                `Failed to build enough instances - want: ${buildStep.count.toString()}, built: ${builtCount}`\n            );\n            return false;\n        }\n\n        this.log.onStepSuccess(data, buildStep);\n\n        return true;\n    }\n\n    _buildStepInstance(\n        data: BuildData,\n        buildStep: STEP.BuildStep,\n        x: number,\n        y: number,\n        adoptedItem: ITEM.ItemInstance | null = null\n    ): boolean {\n        let success = true;\n        let didSomething = true;\n\n        const site = data.site;\n\n        if (success && buildStep.treatAsBlocking) {\n            // Yes, check for blocking.\n            const options: Partial<DisruptOptions> = {\n                machine: site.machineCount,\n            };\n            if (buildStep.noBlockOrigin) {\n                options.updateWalkable = (g) => {\n                    g.set(data.originX, data.originY, 1);\n                    return true;\n                };\n            }\n            if (SITE.siteDisruptedByXY(site, x, y, options)) {\n                this.log.onStepInstanceFail(\n                    data,\n                    buildStep,\n                    x,\n                    y,\n                    'instance blocks map'\n                );\n                success = false;\n            }\n        }\n\n        // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n        if (success && buildStep.feature) {\n            success = buildStep.feature(site, x, y);\n            didSomething = success;\n            if (!success) {\n                this.log.onStepInstanceFail(\n                    data,\n                    buildStep,\n                    x,\n                    y,\n                    'Failed to build effect - ' +\n                        JSON.stringify(buildStep.feature)\n                );\n            }\n        }\n\n        // Now try to place the terrain tile, if any.\n        if (success && buildStep.tile) {\n            if (\n                !buildStep.permitBlocking &&\n                site.tileBlocksMove(buildStep.tile) &&\n                !buildStep.treatAsBlocking // already did treatAsBlocking\n            ) {\n                if (\n                    SITE.siteDisruptedByXY(site, x, y, {\n                        machine: site.machineCount,\n                    })\n                ) {\n                    this.log.onStepInstanceFail(\n                        data,\n                        buildStep,\n                        x,\n                        y,\n                        'tile blocks site'\n                    );\n                    success = false;\n                }\n            }\n\n            if (success) {\n                success = site.setTile(x, y, buildStep.tile);\n                didSomething = didSomething || success;\n                if (!success) {\n                    this.log.onStepInstanceFail(\n                        data,\n                        buildStep,\n                        x,\n                        y,\n                        'failed to set tile - ' + buildStep.tile\n                    );\n                }\n            }\n        }\n\n        let torch: ITEM.ItemInstance | null = adoptedItem;\n\n        // Generate an item, if necessary\n        if (success && buildStep.item) {\n            const itemInfo = ITEM.pickItem(data.site.depth, buildStep.item);\n\n            if (!itemInfo) {\n                success = false;\n                this.log.onStepInstanceFail(\n                    data,\n                    buildStep,\n                    x,\n                    y,\n                    'Failed to make random item - ' +\n                        JSON.stringify(buildStep.item)\n                );\n            } else {\n                const item = ITEM.makeItem(itemInfo);\n                if (buildStep.itemIsKey) {\n                    item.key = {\n                        x,\n                        y,\n                        disposable: !!buildStep.keyIsDisposable,\n                    };\n                }\n\n                if (buildStep.outsourceItem) {\n                    const result = this.buildRandom(\n                        data.site,\n                        BLUE.Flags.BP_ADOPT_ITEM,\n                        -1,\n                        -1,\n                        item\n                    );\n                    if (result) {\n                        didSomething = true;\n                    } else {\n                        this.log.onStepInstanceFail(\n                            data,\n                            buildStep,\n                            x,\n                            y,\n                            'Failed to build machine to adopt item - ' + item.id\n                        );\n                        success = false;\n                    }\n                } else if (buildStep.hordeTakesItem) {\n                    torch = item;\n                } else {\n                    success = site.addItem(x, y, item) > 0;\n                    didSomething = didSomething || success;\n                    if (!success) {\n                        this.log.onStepInstanceFail(\n                            data,\n                            buildStep,\n                            x,\n                            y,\n                            'Failed to add item to site - ' + item.id\n                        );\n                    }\n                }\n            }\n        } else if (success && buildStep.adoptItem) {\n            // adopt item if necessary\n            if (!adoptedItem) {\n                throw new Error(\n                    'Failed to build blueprint because there is no adopted item.'\n                );\n            }\n\n            if (success) {\n                success = site.addItem(x, y, adoptedItem) > 0;\n                if (success) {\n                    didSomething = true;\n                } else {\n                    this.log.onStepInstanceFail(\n                        data,\n                        buildStep,\n                        x,\n                        y,\n                        'Failed to add adopted item to site - ' + adoptedItem.id\n                    );\n                }\n            }\n        }\n\n        let torchBearer: HORDE.ActorInstance | null = null;\n\n        if (success && buildStep.horde) {\n            let horde = HORDE.pickHorde(\n                data.site.depth,\n                buildStep.horde,\n                site.rng\n            );\n            // if (buildStep.horde.random) {\n            //     horde = GWM.horde.random({ rng: site.rng });\n            // } else if (buildStep.horde.id) {\n            //     horde = GWM.horde.from(buildStep.horde.id);\n            // } else {\n            //     buildStep.horde.rng = site.rng;\n            //     horde = GWM.horde.random(buildStep.horde);\n            // }\n            if (!horde) {\n                success = false;\n                this.log.onStepInstanceFail(\n                    data,\n                    buildStep,\n                    x,\n                    y,\n                    'Failed to pick horde - ' + JSON.stringify(buildStep.horde)\n                );\n            } else {\n                if (horde.blueprint) {\n                    const blueprint = BLUE.get(horde.blueprint);\n                    const newData = new BuildData(\n                        data.site,\n                        blueprint,\n                        data.machineNumber\n                    );\n                    const result = this._build(newData, x, y, null);\n                    newData.free();\n                    if (!result) {\n                        return false;\n                    }\n                }\n\n                const leader = HORDE.spawnHorde(horde, site, x, y, {\n                    machine: site.machineCount,\n                });\n                if (!leader) {\n                    success = false;\n                    this.log.onStepInstanceFail(\n                        data,\n                        buildStep,\n                        x,\n                        y,\n                        'Failed to build horde - ' + horde\n                    );\n                } else {\n                    // What to do now?\n                    didSomething = true;\n\n                    // leader adopts item...\n                    if (torch && buildStep.hordeTakesItem) {\n                        torchBearer = leader;\n                        torchBearer.item = torch;\n                        torch.x = -1;\n                        torch.y = -1;\n                    }\n\n                    if (horde.feature) {\n                        horde.feature(site, x, y);\n                    }\n\n                    if (buildStep.horde.feature) {\n                        buildStep.horde.feature(site, x, y);\n                    }\n                }\n            }\n        }\n\n        if (success && didSomething) {\n            // Mark the feature location as part of the machine, in case it is not already inside of it.\n            if (!data.blueprint.noInteriorFlag) {\n                site.setMachine(\n                    x,\n                    y,\n                    data.machineNumber,\n                    data.blueprint.isRoom\n                );\n            }\n\n            // Mark the feature location as impregnable if requested.\n            if (buildStep.impregnable) {\n                site.makeImpregnable(x, y);\n            }\n\n            this.log.onStepInstanceSuccess(data, buildStep, x, y);\n        } else if (didSomething) {\n            // roll back any changes?\n        }\n\n        return success && didSomething;\n    }\n}\n\n////////////////////////////////////////////////////\n// TODO - Change this!!!\n// const blue = BLUE.get(id | blue);\n// const result =  blue.buildAt(map, x, y);\n//\nexport function build(\n    blueprint: BlueType,\n    site: Site,\n    x: number,\n    y: number,\n    opts?: Partial<BuilderOptions>\n): BuildResult {\n    const builder = new Builder(opts);\n\n    return builder.build(site, blueprint, x, y);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\nimport * as LEVEL from './digger';\n\nimport * as TYPES from './types';\nimport * as ROOM from './room';\n// import * as HALL from './hall';\n// import * as LOOP from './loop';\n// import * as LAKE from './lake';\n// import * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nimport * as DIG from './digger';\nimport { RoomOptions } from '.';\n\nexport interface DungeonOptions extends DIG.DiggerOptions {\n    // seed?: number;\n    levels: number;\n    goesUp?: boolean;\n\n    width: number;\n    height: number;\n\n    entrance?: string | string[] | Record<string, number> | ROOM.RoomDigger;\n\n    startLoc?: GWU.xy.Loc;\n    startTile?: TYPES.TileId;\n    stairDistance?: number;\n\n    endLoc?: GWU.xy.Loc;\n    endTile?: TYPES.TileId;\n\n    // rooms?: {\n    //     count?: number;\n    //     digger?: string | ROOM.RoomDigger;\n    //     entrance?: string | ROOM.RoomDigger;\n    //     first?: string | ROOM.RoomDigger;\n    // };\n\n    // halls?: Partial<HALL.HallOptions>;\n    // loops?: Partial<LOOP.LoopOptions>;\n    // lakes?: Partial<LAKE.LakeOpts>;\n    // bridges?: Partial<BRIDGE.BridgeOpts>;\n    // stairs?: Partial<STAIRS.StairOpts>;\n\n    // boundary?: boolean;\n}\n\nexport type LocPair = [GWU.xy.Loc, GWU.xy.Loc];\n\nexport class Dungeon {\n    // @ts-ignore\n    config: DungeonOptions = {\n        levels: 1,\n        width: 80,\n        height: 34,\n        rooms: { fails: 20 },\n        // rooms: { count: 20, digger: 'DEFAULT' },\n        // halls: {},\n        // loops: {},\n        // lakes: {},\n        // bridges: {},\n        // stairs: {},\n\n        boundary: true,\n    };\n    seeds: number[] = [];\n    stairLocs: LocPair[] = [];\n\n    constructor(options: DungeonOptions) {\n        GWU.object.setOptions(this.config, options);\n\n        if (this.config.seed) {\n            GWU.rng.random.seed(this.config.seed);\n        }\n\n        if (typeof this.config.stairs === 'boolean' || !this.config.stairs) {\n            this.config.stairs = {};\n        }\n        if (!this.config.rooms) {\n            this.config.rooms = {};\n        } else if (typeof this.config.rooms === 'number') {\n            this.config.rooms = { count: this.config.rooms };\n        }\n\n        this._initSeeds();\n        this._initStairLocs();\n    }\n\n    get length() {\n        return this.config.levels;\n    }\n\n    _initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GWU.rng.random.number(2 ** 32);\n        }\n    }\n\n    _initStairLocs() {\n        let startLoc: GWU.xy.Loc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n\n        const minDistance =\n            this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n\n        let needUpdate = false;\n        for (let i = 0; i < this.config.levels; ++i) {\n            let endLoc: GWU.xy.Loc;\n\n            if (\n                this.stairLocs[i] &&\n                this.stairLocs[i][1] &&\n                this.stairLocs[i][1][0] > 0\n            ) {\n                endLoc = this.stairLocs[i][1];\n                needUpdate =\n                    GWU.xy.distanceBetween(\n                        startLoc[0],\n                        startLoc[1],\n                        endLoc[0],\n                        endLoc[1]\n                    ) < minDistance;\n            } else {\n                endLoc = GWU.rng.random.matchingLoc(\n                    this.config.width,\n                    this.config.height,\n                    (x, y) => {\n                        return (\n                            GWU.xy.distanceBetween(\n                                startLoc[0],\n                                startLoc[1],\n                                x,\n                                y\n                            ) > minDistance\n                        );\n                    }\n                );\n            }\n\n            this.stairLocs[i] = [\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ];\n            startLoc = endLoc;\n        }\n\n        if (needUpdate) {\n            // loop does not go all the way to level 0\n            for (let i = this.config.levels - 1; i > 0; --i) {\n                let [startLoc, endLoc] = this.stairLocs[i];\n\n                if (\n                    GWU.xy.distanceBetween(\n                        startLoc[0],\n                        startLoc[1],\n                        endLoc[0],\n                        endLoc[1]\n                    ) > minDistance\n                ) {\n                    break;\n                }\n\n                startLoc = GWU.rng.random.matchingLoc(\n                    this.config.width,\n                    this.config.height,\n                    (x, y) => {\n                        return (\n                            GWU.xy.distanceBetween(endLoc[0], endLoc[1], x, y) >\n                            minDistance\n                        );\n                    }\n                );\n\n                this.stairLocs[i][0] = startLoc;\n                this.stairLocs[i - 1][1] = startLoc;\n            }\n        }\n    }\n\n    getLevel(id: number, cb: TYPES.DigFn) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n\n        const stairOpts = Object.assign(\n            {},\n            this.config.stairs as Partial<STAIRS.StairOpts>\n        );\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        } else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n\n        const rooms = Object.assign(\n            {},\n            this.config.rooms as Partial<RoomOptions>\n        );\n        if (id === 0 && this.config.entrance) {\n            rooms.first = this.config.entrance;\n        }\n\n        let width = this.config.width,\n            height = this.config.height;\n        // if (cb instanceof GWM.map.Map) {\n        //     width = cb.width;\n        //     height = cb.height;\n        // }\n\n        const levelOpts = {\n            seed: this.seeds[id],\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n\n            rooms: rooms,\n\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n\n            goesUp: this.config.goesUp,\n            width,\n            height,\n        };\n\n        return this._makeLevel(id, levelOpts, cb);\n\n        // TODO - Update startLoc, endLoc\n    }\n\n    _makeLevel(id: number, opts: LEVEL.DiggerOptions, cb: TYPES.DigFn) {\n        const digger = new LEVEL.Digger(opts);\n        let result = false;\n        // if (cb instanceof GWM.map.Map) {\n        //     result = digger.create(cb);\n        // } else {\n        result = digger.create(this.config.width, this.config.height, cb);\n        // }\n\n        this.stairLocs[id] = [digger.locations.start, digger.locations.end];\n\n        // if (cb instanceof GWM.map.Map) {\n        //     const locs = this.stairLocs[id];\n        //     if (this.config.goesUp) {\n        //         cb.locations.down = cb.locations.start = locs[0];\n        //         cb.locations.up = cb.locations.end = locs[1];\n        //     } else {\n        //         cb.locations.down = cb.locations.start = locs[1];\n        //         cb.locations.up = cb.locations.end = locs[0];\n        //     }\n        // }\n        return result;\n    }\n}\n"],"names":["TileFactory","[object Object]","withDefaults","factory","this","tileIds","install","priority","ch","index","blocksMove","blocksVision","door","secretDoor","stairs","liquid","impregnable","plugin","plugins","push","name","id","undefined","allTiles","getTile","info","opts","base","length","tags","extends","root","Object","assign","Error","GWU","object","assignOmitting","make","text","replace","search","Number","parseInt","tile","substring","delta","blocksPathing","apply","config","forEach","p","createTile","tileFactory","tileId","features","types","installType","fn","feature","Array","isArray","featureFeature","bind","site","x","y","feat","FALSE","parts","split","shift","toLowerCase","handler","steps","map","filter","a","entries","key","every","step","makeArray","cfg","c","s","src","includes","superpriority","blockedByActors","blockedByItems","tileAction","machine","setTile","chance","endsWith","parseFloat","chanceAction","rng","Fl","flag","fl","Flags","spread","args","t","trim","grow","decrement","flags","from","matchTile","indexOf","action","spreadFeature","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","didSomething","spawnMap","grid","alloc","width","height","computeSpawnMap","mapDisruptedBy","free","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","update","v","i","increment","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","xy","forRect","j","lakeX","lakeY","get","isStairs","set","first","floodFill","cellIsOk","effect","isStart","hasXY","isProtected","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","hasTile","dir","x2","y2","madeChange","startProb","probDec","fill","count","DIRS","_flags","clearTile","blockingMap","eachActor","loc","matchingLocNear","forbidsActor","eachItem","forbidsItem","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","hordes","pickHorde","depth","rules","tagMatch","random","makeMatch","find","h","choices","horde","freq","frequency","weighted","spawnHorde","canSpawn","TRUE","leader","canSpawnActor","matchingLoc","hasActor","_pickLeaderLoc","_opts","addActor","_addLeader","_spawnLeader","members","kindId","value","_spawnMember","_spawnMembers","member","instance","actor","_pickMemberLoc","_addMember","items","pickItem","tagRules","item","makeItem","directionOfDoorSite","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","isFloor","chooseRandomDoorSites","k","doorSiteFailed","DOORS","w","isDiggable","isSet","doorSites","siteDisruptedByXY","options","offsetX","offsetY","arcCount","isPassable","result","siteDisruptedBy","blockingX","blockingY","getMachine","updateWalkable","siteDisruptedSize","nextId","minSize","disrupted","Math","min","computeDistanceMap","distanceMap","originX","originY","_maxDistance","reset","setGoal","calculate","path","OK","blocksDiagonal","OBSTRUCTION","BLOCKED","clearInteriorFlag","needsMachine","setMachine","analyze","updateChokeCounts","updateLoopiness","updateChokepoints","updateCounts","blockMap","isSecretDoor","passableArcCount","clearChokepoint","isInLoop","oldX","CLOCK_DIRS","oldY","setChokepoint","left","right","up","down","setGateSite","setChokeCount","isChokepoint","cellCount","floodFillCount","i2","j2","getChokeCount","results","startX","startY","getCount","isAreaMachine","todo","pop","resetLoopiness","checkLoopiness","cleanLoopiness","setInLoop","clearInLoop","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","designationSurvives","Site","machineCount","tiles","_tiles","_doors","_machine","_chokeCounts","fmt","dump","other","copy","slice","actors","otherX","otherY","seed","isBoundaryXY","isDoor","isBridge","isShallow","_x","_y","isNothing","isDeep","isInMachine","_data","IMPREGNABLE","CHOKEPOINT","GATE_SITE","IN_LOOP","ANALYZE.analyze","snapshot","isRoom","IN_MACHINE","IN_AREA_MACHINE","_v","Utils.directionOfDoorSite","hasItem","_actor","cb","_a","some","_i","NullLogger","StepFlags","CandidateType","BuildStep","pad","range","FEATURE.make","BS_ADOPT_ITEM","buildAtOrigin","hi","repeatUntilNoProgress","hordeTakesItem","allowBoundary","BS_ALLOW_BOUNDARY","notInHallway","BS_NOT_IN_HALLWAY","buildInWalls","BS_BUILD_IN_WALLS","buildAnywhere","BS_BUILD_ANYWHERE_ON_LEVEL","BS_REPEAT_UNTIL_NO_PROGRESS","permitBlocking","BS_PERMIT_BLOCKING","treatAsBlocking","BS_TREAT_AS_BLOCKING","BS_NO_BLOCK_ORIGIN","noBlockOrigin","adoptItem","itemIsKey","BS_ITEM_IS_KEY","keyIsDisposable","BS_KEY_DISPOSABLE","outsourceItem","BS_OUTSOURCE_ITEM_TO_MACHINE","BS_IMPREGNABLE","buildVestibule","BS_BUILD_VESTIBULE","BS_HORDE_TAKES_ITEM","generateEverywhere","BS_EVERYWHERE","BS_BUILD_AT_ORIGIN","buildsInstances","data","candidates","distanceBound","updateViewMap","blueprint","candidateType","cellIsCandidate","JSON","stringify","lo","toString","join","builder","buildStep","BS_IN_VIEW_OF_ORIGIN","BS_IN_PASSABLE_VIEW_OF_ORIGIN","fov","FOV","isBlocked","viewMap","calcDistanceBound","BS_NEAR_ORIGIN","distance25","BS_FAR_FROM_ORIGIN","distance75","IN_HALLWAY","ON_BOUNDARY","MUST_BE_ORIGIN","NOT_ORIGIN","occupied","OCCUPIED","NOT_IN_VIEW","distance","getDistance","TOO_FAR","TOO_CLOSE","cellMachine","interior","machineNumber","failed","neighborMachine","INVALID_WALL","NOT_CANDIDATE","blocksItems","FAILED","ConsoleLogger","console","group","groupEnd","room","roomSite","_site","_room","_roomSite","error","log","label","size","wantCount","haveCount","_step","requiredTile","cells","line","source","costGrid","Hall","Bounds","super","dx","dy","doors","d","makeHall","dirIndex","hallLength","hallWidth","abs","Room","cx","floor","cy","hall","translate","checkConfig","expected","expect","have","RoomDigger","_setOptions","carve","SITE.chooseRandomDoorSites","rooms","ChoiceRoom","randomRoom","ERROR","create","Cavern","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","DOWN","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","top","bottom","isDoorLoc","pickWidth","utils","clamp","Range","weights","_pickWidth","pickLength","lengths","UP","pickHallDirection","dirs","sequence","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.makeHall","lower","higher","actual","halls","Lakes","tries","canDisrupt","wreathTile","wreathChance","wreathSize","assignObject","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","DijkstraMap","dirCoords","seq","isAnyLiquid","bridgeDir","SITE.computeDistanceMap","isBridgeCandidate","_bridgeDir","Stairs","start","upTile","downTile","wall","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","distanceBetween","setupStairs","end","wallTile","indexes","x0","y0","findIndex","r","LoopDigger","doorChance","endX","endY","isValidTunnelStart","isValidTunnelEnd","Digger","fails","SITE.tileFactory","setOptions","goesUp","startLoc","_locs","endLoc","loops","lakes","bridges","LOGGER.NullLogger","SITE.Site","needsFree","dest","_createSite","_create","addRooms","addLoops","onLoopsAdded","addLakes","onLakesAdded","addBridges","onBridgesAdded","addStairs","onStairsAdded","finish","number","setSeed","clear","stair","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","addFirstRoom","updateDoorDirs","onDigFirstRoom","maxFails","addRoom","shuffle","_makeRoomSite","getDigger","_attachRoomAtLoc","HALL.dig","onRoomCandidate","_attachRoom","onRoomSuccess","onRoomFailed","len","getDoorDir","oppDir","_roomFitsAt","copyTiles","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","locs","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","boundaryTile","boundary","BuildData","maxDistance","qualifyingTileCount","distances","dist","Blueprint","STEP.BuildStep","BP_ADOPT_ITEM","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","BP_NO_INTERIOR_FLAG","BP_NOT_IN_HALLWAY","requiredFlags","want","alternativeFlags","STEP.StepFlags","BS_ALTERNATIVE","BS_ALTERNATIVE_2","keepFeature","totalFreq","randIndex","_f","addTileToInteriorAndIterate","computeVestibuleInterior","goalSize","n","isOccupied","markCandidates","buildData","isGateSite","contains","pickCandidateLoc","randSite","doorChokeCount","vestibuleLoc","vestibuleChokeCount","roomSize","wantSize","distMap","startChokeCount","additional","minimumInteriorNeighbors","interiorNeighborCount","interiorCount","maxInteriorCount","gen","prepareInterior","blueprints","Builder","values","BLUE.get","BLUE.blueprints","b","qualifies","requiredMachineFlags","BLUE.Flags","adoptedItem","_pickRandom","onBuildError","onBlueprintPick","_buildAt","_build","_markCandidates","BLUE.pickCandidateLoc","onBlueprintFail","onBlueprintStart","_computeInterior","nextMachineId","BLUE.prepareInterior","calcDistances","components","pickComponents","component","_buildStep","restore","SITE.clearInteriorFlag","onBlueprintSuccess","BLUE.markCandidates","onBlueprintCandidates","fail","fillInterior","SITE.siteDisruptedBy","SITE.siteDisruptedSize","onBlueprintInterior","builtCount","onStepStart","STEP.calcDistanceBound","buildRandom","onStepFail","onStepSuccess","onStepCandidates","_buildStepInstance","makePersonalSpace","g","SITE.siteDisruptedByXY","onStepInstanceFail","tileBlocksMove","torch","itemInfo","ITEM.pickItem","ITEM.makeItem","disposable","addItem","torchBearer","HORDE.pickHorde","newData","HORDE.spawnHorde","onStepInstanceSuccess","build","matches","levels","_initSeeds","_initStairLocs","seeds","stairDistance","needUpdate","stairLocs","stairOpts","startTile","endTile","entrance","levelOpts","_makeLevel","LEVEL.Digger"],"mappings":"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"}
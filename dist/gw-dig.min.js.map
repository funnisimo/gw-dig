{"version":3,"file":"gw-dig.min.js","sources":["../js/digger.js","../js/dig.js","../js/gw.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, doors) {\n        this.width = 1;\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.x2 = this.x + length * d[0];\n        this.y2 = this.y + length * d[1];\n        this.dir = dir;\n        this.length = length;\n        this.doors = doors;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var diggers = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    diggers[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    if (!config.width || !config.height)\n        GW.utils.ERROR('All diggers require config to include width and height.');\n    Object.entries(opts).forEach(([key, expect]) => {\n        const have = config[key];\n        if (expect === true) {\n            // needs to be a number > 0\n            if (typeof have !== 'number') {\n                GW.utils.ERROR('Invalid configuration for digger: ' +\n                    key +\n                    ' expected number received ' +\n                    typeof have);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            const have = config[key];\n            if (typeof have !== 'number') {\n                config[key] = expect; // provide default\n            }\n        }\n        else if (Array.isArray(expect)) {\n            // needs to be an array with this size, these are the defaults\n            if (typeof have === 'number') {\n                config[key] = new Array(expect.length).fill(have);\n            }\n            else if (!Array.isArray(have)) {\n                GW.utils.WARN('Received unexpected config for digger : ' +\n                    key +\n                    ' expected array, received ' +\n                    typeof have +\n                    ', using defaults.');\n                config[key] = expect.slice();\n            }\n            else if (expect.length > have.length) {\n                for (let i = have.length; i < expect.length; ++i) {\n                    have[i] = expect[i];\n                }\n            }\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n        }\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * config.width); // 6\n    const maxWidth = config.width;\n    const minHeight = Math.floor(0.5 * config.height); // 4\n    const maxHeight = config.height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, CONST.FLOOR);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = config.choices;\n    }\n    else if (typeof config.choices == 'object') {\n        choices = Object.keys(config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    for (let choice of choices) {\n        if (!diggers[choice]) {\n            GW.utils.ERROR('Missing digger choice: ' + choice);\n        }\n    }\n    if (!grid)\n        return config;\n    let id;\n    if (Array.isArray(config.choices)) {\n        id = GW.random.item(config.choices);\n    }\n    else {\n        id = GW.random.weighted(config.choices);\n    }\n    const digger = diggers[id];\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entranceRoom(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.floor(0.4 * config.width); // 8\n    const roomHeight = config.height;\n    const roomWidth2 = config.width;\n    const roomHeight2 = Math.floor(0.5 * config.height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function crossRoom(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.max(2, Math.floor((config.width * GW.random.range(15, 60)) / 100)); // [3,12]\n    const roomWidth2 = Math.max(2, Math.floor((config.width * GW.random.range(20, 100)) / 100)); // [4,20]\n    const roomHeight = Math.max(2, Math.floor((config.height * GW.random.range(50, 100)) / 100)); // [3,7]\n    const roomHeight2 = Math.max(2, Math.floor((config.height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomX = GW.random.range(Math.max(0, Math.floor(grid.width / 2) - (roomWidth - 1)), Math.min(grid.width, Math.floor(grid.width / 2)));\n    const roomX2 = roomX +\n        Math.floor(roomWidth / 2) +\n        GW.random.range(0, 2) +\n        GW.random.range(0, 2) -\n        3 -\n        Math.floor(roomWidth2 / 2);\n    const roomY = Math.floor(grid.height / 2 - roomHeight);\n    const roomY2 = Math.floor(grid.height / 2 -\n        roomHeight2 -\n        (GW.random.range(0, 2) + GW.random.range(0, 1)));\n    grid.fill(0);\n    grid.fillRect(roomX - 5, roomY + 5, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2 - 5, roomY2 + 5, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2) - 5, Math.min(roomY, roomY2) - 5, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCrossRoom(config, grid) {\n    config = checkConfig(config, { width: 8, height: 5 });\n    if (!grid)\n        return config;\n    let majorWidth = Math.floor((config.width * GW.random.range(50, 100)) / 100); // [4,8]\n    let majorHeight = Math.floor((config.height * GW.random.range(75, 100)) / 100); // [4,5]\n    let minorWidth = Math.max(2, Math.floor((config.width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (majorHeight % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(2, Math.floor((config.height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    if (majorWidth % 2 == 0 && minorHeight > 2) {\n        minorHeight -= 1;\n    }\n    grid.fill(0);\n    const x = Math.floor((grid.width - majorWidth) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, majorWidth, minorHeight, CONST.FLOOR);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - majorHeight) / 2);\n    grid.fillRect(x2, y2, minorWidth, majorHeight, CONST.FLOOR);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(majorWidth, minorWidth), Math.max(majorHeight, minorHeight));\n}\nexport function rectangularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 4, minPct: 50 });\n    if (!grid)\n        return config;\n    const width = Math.floor((config.width * GW.random.range(config.minPct, 100)) / 100); // [3,6]\n    const height = Math.floor((config.height * GW.random.range(config.minPct, 100)) / 100); // [2,4]\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, CONST.FLOOR);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 6 });\n    if (!grid)\n        return config;\n    const radius = Math.floor(((Math.min(config.width, config.height) - 1) *\n        GW.random.range(75, 100)) /\n        200); // [3,4]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, CONST.FLOOR);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        width: 10,\n        height: 10,\n        altChance: 5,\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = Math.floor((Math.min(config.width, config.height) * GW.random.range(75, 100)) / 100); // [5,10]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, CONST.FLOOR);\n    if (radius > config.ringMinWidth + config.holeMinSize &&\n        GW.random.chance(config.holeChance)) {\n        grid.fillCircle(x, y, GW.random.range(config.holeMinSize, radius - config.holeMinSize), 0);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, { count: 8 });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = Math.floor((config.count * GW.random.range(25, 100)) / 100); // [2,8]\n    minX = Math.floor(grid.width / 2) - Math.floor(config.width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(config.width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(config.height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(config.height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, CONST.FLOOR);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, CONST.FLOOR);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    return new Room(config.id, minX, minY, maxX - minX + 1, maxY - minY + 1);\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nexport * from './digger';\nimport { diggers as DIGGERS, Hall } from './digger';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = config.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(config, roomGrid);\n        const attachHall = GW.random.chance(hallChance);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = attachHallway(roomGrid, room, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, config);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, config);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts = {}) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                // doorSites[oppDir][0] = -1;\n                // doorSites[oppDir][1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts = {}) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const x = mapDoors[index][0];\n        const y = mapDoors[index][1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts = {}) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        if (doorSites[oppDir][0] != -1 &&\n            roomFitsAt(map, roomGrid, x - doorSites[oppDir][0], y - doorSites[oppDir][1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - doorSites[oppDir][0];\n            const offY = y - doorSites[oppDir][1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function attachHallway(grid, room, opts) {\n    let i, x, y, newX, newY;\n    let dir, dir2;\n    opts = opts || {};\n    const tile = opts.tile || CONST.FLOOR;\n    const horizontalLength = GW.utils.firstOpt('horizontalHallLength', opts, [\n        9,\n        15,\n    ]);\n    const verticalLength = GW.utils.firstOpt('verticalHallLength', opts, [\n        2,\n        9,\n    ]);\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const doors = room.doors;\n    // Pick a direction.\n    dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const dx = doors[dir][0] + Math.floor(DIRS[dir][0] * horizontalLength[1]);\n            const dy = doors[dir][1] + Math.floor(DIRS[dir][1] * verticalLength[1]);\n            if (doors[dir][0] != -1 &&\n                doors[dir][1] != -1 &&\n                grid.hasXY(dx, dy)) {\n                break; // That's our direction!\n            }\n        }\n        if (i == 4) {\n            return null; // No valid direction for hallways.\n        }\n    }\n    let maxLength = 0;\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        maxLength = GW.random.range(verticalLength[0], verticalLength[1]);\n    }\n    else {\n        maxLength = GW.random.range(horizontalLength[0], horizontalLength[1]);\n    }\n    x = doors[dir][0];\n    y = doors[dir][1];\n    const attachLoc = [x - DIRS[dir][0], y - DIRS[dir][1]];\n    let length = 0;\n    for (length = 0; length < maxLength; length++) {\n        if (grid.hasXY(x, y)) {\n            grid[x][y] = tile;\n        }\n        else {\n            break;\n        }\n        x += DIRS[dir][0];\n        y += DIRS[dir][1];\n    }\n    if (length < 2) {\n        return null;\n    }\n    x = GW.utils.clamp(x - DIRS[dir][0], 0, grid.width - 1);\n    y = GW.utils.clamp(y - DIRS[dir][1], 0, grid.height - 1); // Now (x, y) points at the last interior cell of the hallway.\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n    ];\n    for (dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            hallDoors[dir2][0] = -1;\n            hallDoors[dir2][1] = -1;\n        }\n        else {\n            hallDoors[dir2][0] = newX;\n            hallDoors[dir2][1] = newY;\n        }\n    }\n    return new Hall(attachLoc, dir, length, hallDoors);\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n"],"names":["Hall","[object Object]","loc","dir","length","doors","this","width","x","y","d","GW.utils","DIRS","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","diggers","checkConfig","config","opts","ERROR","Object","entries","key","expect","have","Array","isArray","fill","i","WARN","slice","SEQ","attachRoom","map","roomGrid","room","doorSites","get","GW.grid","directionOfDoorSite","NO_DIRECTION","oppDir","offsetX","offsetY","roomFitsAt","offsetZip","_d","_s","j","tile","door","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","hasXY","isBoundaryXY","attachRoomAtMapDoor","mapDoors","doorIndexes","GW.random","sequence","index","attachRoomAtXY","dirs","offX","offY","chooseRandomDoorSites","sourceGrid","k","newX","newY","doorSiteFailed","grid","alloc","copy","randomMatchingLoc","free","attachHallway","dir2","horizontalLength","firstOpt","verticalLength","obliqueChance","maxLength","UP","DOWN","range","attachLoc","clamp","allowObliqueHallwayExit","chance","hallDoors","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","diggerId","id","DIGGERS","locs","count","assign","hallChance","hallway","result","tries","fn","attachHall","xy","destX","destY","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","choices","keys","choice","item","weighted","digConfig","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","min","max","majorWidth","majorHeight","minorWidth","minorHeight","minPct","radius","fillCircle","altChance","ringMinWidth","holeMinSize","holeChance","minX","maxX","minY","maxY","chunkCount"],"mappings":"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"}
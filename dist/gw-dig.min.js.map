{"version":3,"file":"gw-dig.min.js","sources":["../js/site/utils.js","../js/site/digSite.js","../js/site/buildSite.js","../js/types.js","../js/room.js","../js/hall.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/loop.js","../js/level.js","../js/blueprint/buildStep.js","../js/blueprint/blueprint.js","../js/blueprint/builder.js","../js/dungeon.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\n// import * as TYPES from './types';\nconst DIRS = GWU.xy.DIRS;\n// export function attachRoom(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GWU.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GWU.xy.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GWU.xy.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GWU.xy.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GWU.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GWU.xy.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GWU.xy.DIRS[dir][0];\n                    newY = j + GWU.xy.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GWU.xy.DIRS[dir][0];\n                        newY += GWU.xy.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GWU.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GWU.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GWU.grid.NumGrid,\n//     xy: GWU.xy.Loc,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GWU.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GWU.grid.NumGrid,\n//     mapDoors: GWU.xy.Loc[],\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorIndexes = GWU.random.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GWU.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = GWU.random.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GWU.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n//             //     return [x0, y0] as GWU.xy.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function copySite(dest, source, offsetX = 0, offsetY = 0) {\n    GWU.xy.forRect(dest.width, dest.height, (x, y) => {\n        const otherX = x - offsetX;\n        const otherY = y - offsetY;\n        const v = source.getTileIndex(otherX, otherY);\n        if (!v)\n            return;\n        dest.setTile(x, y, v);\n    });\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n}\nexport function siteDisruptedByXY(site, x, y, options = {}) {\n    var _a, _b, _c;\n    (_a = options.offsetX) !== null && _a !== void 0 ? _a : (options.offsetX = 0);\n    (_b = options.offsetY) !== null && _b !== void 0 ? _b : (options.offsetY = 0);\n    (_c = options.machine) !== null && _c !== void 0 ? _c : (options.machine = 0);\n    if (GWU.xy.arcCount(x, y, (i, j) => {\n        return site.isPassable(i, j);\n    }) <= 1)\n        return false;\n    const blockingGrid = GWU.grid.alloc(site.width, site.height);\n    blockingGrid[x][y] = 1;\n    const result = siteDisruptedBy(site, blockingGrid, options);\n    GWU.grid.free(blockingGrid);\n    return result;\n}\nexport function siteDisruptedBy(site, blockingGrid, options = {}) {\n    var _a, _b, _c;\n    (_a = options.offsetX) !== null && _a !== void 0 ? _a : (options.offsetX = 0);\n    (_b = options.offsetY) !== null && _b !== void 0 ? _b : (options.offsetY = 0);\n    (_c = options.machine) !== null && _c !== void 0 ? _c : (options.machine = 0);\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + options.offsetX;\n        const lakeY = j + options.offsetY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (site.isPassable(i, j) &&\n            (site.getMachine(i, j) == 0 ||\n                site.getMachine(i, j) == options.machine)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function siteDisruptedSize(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (disrupts)\n        return disrupts;\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                }\n                else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function computeDistanceMap(site, distanceMap, originX, originY, maxDistance) {\n    const costGrid = GWU.grid.alloc(site.width, site.height);\n    fillCostGrid(site, costGrid);\n    GWU.path.calculateDistances(distanceMap, originX, originY, costGrid, false, maxDistance + 1 // max distance is the same as max size of this blueprint\n    );\n    GWU.grid.free(costGrid);\n}\nexport function clearInteriorFlag(site, machine) {\n    for (let i = 0; i < site.width; i++) {\n        for (let j = 0; j < site.height; j++) {\n            if (site.getMachine(i, j) == machine &&\n                !site.hasCellFlag(i, j, GWM.flags.Cell.IS_WIRED | GWM.flags.Cell.IS_CIRCUIT_BREAKER)) {\n                site.setMachine(i, j, 0);\n            }\n        }\n    }\n}\n","var _a, _b;\nimport * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Utils from './utils';\nexport const NOTHING = GWM.tile.get('NULL').index;\nexport const FLOOR = GWM.tile.get('FLOOR').index;\nexport const DOOR = GWM.tile.get('DOOR').index;\nexport const SECRET_DOOR = (_b = (_a = GWM.tile.get('DOOR_SECRET')) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;\nexport const WALL = GWM.tile.get('WALL').index;\nexport const DEEP = GWM.tile.get('LAKE').index;\nexport const SHALLOW = GWM.tile.get('SHALLOW').index;\nexport const BRIDGE = GWM.tile.get('BRIDGE').index;\nexport const UP_STAIRS = GWM.tile.get('UP_STAIRS').index;\nexport const DOWN_STAIRS = GWM.tile.get('DOWN_STAIRS').index;\nexport const IMPREGNABLE = GWM.tile.get('IMPREGNABLE').index;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport class GridSite {\n    constructor(width, height) {\n        this.seed = 0;\n        this.tiles = GWU.grid.alloc(width, height);\n        this.doors = GWU.grid.alloc(width, height);\n    }\n    free() {\n        GWU.grid.free(this.tiles);\n        GWU.grid.free(this.doors);\n    }\n    clear() {\n        this.tiles.fill(0);\n        this.doors.fill(0);\n    }\n    get width() {\n        return this.tiles.width;\n    }\n    get height() {\n        return this.tiles.height;\n    }\n    hasXY(x, y) {\n        return this.tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.tiles.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === DOOR;\n    }\n    isSecretDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === SECRET_DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    blocksMove(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y) || this.isDeep(x, y);\n    }\n    blocksDiagonal(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksPathing(x, y) {\n        return (this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y));\n    }\n    blocksVision(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksItems(x, y) {\n        return this.blocksPathing(x, y) || this.blocksPathing(x, y);\n    }\n    blocksEffects(x, y) {\n        return this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.tiles.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.tiles.get(x, y) === SHALLOW;\n    }\n    isAnyLiquid(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.tiles.get(x, y) || 0) > 0;\n    }\n    getTileIndex(x, y) {\n        return this.tiles.get(x, y) || 0;\n    }\n    setTile(x, y, tile) {\n        if (tile instanceof GWM.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GWM.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        if (!this.tiles.hasXY(x, y))\n            return false;\n        this.tiles[x][y] = tile;\n        return true;\n    }\n    hasTile(x, y, tile) {\n        if (tile instanceof GWM.tile.Tile) {\n            tile = tile.index;\n        }\n        if (typeof tile === 'string') {\n            const obj = GWM.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        return this.tiles.hasXY(x, y) && this.tiles[x][y] == tile;\n    }\n    getMachine(_x, _y) {\n        return 0;\n    }\n    updateDoorDirs() {\n        this.doors.update((_v, x, y) => {\n            return Utils.directionOfDoorSite(this, x, y);\n        });\n    }\n    getDoorDir(x, y) {\n        return this.doors[x][y];\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Utils from './utils';\nconst Flags = GWM.flags.Cell;\nexport class MapSite {\n    constructor(map) {\n        this.machineCount = 0;\n        this.needsAnalysis = true;\n        this.map = map;\n        this.doors = GWU.grid.alloc(map.width, map.height);\n    }\n    get seed() {\n        return this.map.seed;\n    }\n    set seed(v) {\n        this.map.seed = v;\n    }\n    get width() {\n        return this.map.width;\n    }\n    get height() {\n        return this.map.height;\n    }\n    hasXY(x, y) {\n        return this.map.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.map.isBoundaryXY(x, y);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.map.cellInfo(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.needsAnalysis = true;\n        this.map.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.needsAnalysis = true;\n        this.map.cell(x, y).clearCellFlag(flag);\n    }\n    hasTile(x, y, tile) {\n        return this.map.cellInfo(x, y).hasTile(tile);\n    }\n    setTile(x, y, tile, opts) {\n        this.needsAnalysis = true;\n        return this.map.setTile(x, y, tile, opts);\n    }\n    getTileIndex(x, y) {\n        if (!this.hasXY(x, y))\n            return 0;\n        const cell = this.map.cell(x, y);\n        const tile = cell.highestPriorityTile();\n        return tile.index;\n    }\n    clear() {\n        this.needsAnalysis = true;\n        this.map.cells.forEach((c) => c.clear());\n    }\n    hasItem(x, y) {\n        return this.map.cellInfo(x, y).hasItem();\n    }\n    makeRandomItem(tags) {\n        return GWM.item.makeRandom(tags);\n    }\n    addItem(x, y, item) {\n        this.needsAnalysis = true;\n        return this.map.forceItem(x, y, item);\n    }\n    hasActor(x, y) {\n        return this.map.hasActor(x, y);\n    }\n    blocksMove(x, y) {\n        return this.map.cellInfo(x, y).blocksMove();\n    }\n    blocksVision(x, y) {\n        return this.map.cellInfo(x, y).blocksVision();\n    }\n    blocksDiagonal(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_DIAGONAL);\n    }\n    blocksPathing(x, y) {\n        const info = this.map.cellInfo(x, y);\n        return (info.hasEntityFlag(GWM.flags.Entity.L_BLOCKS_MOVE) ||\n            info.hasTileFlag(GWM.tile.flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksItems(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_ITEMS);\n    }\n    blocksEffects(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isWall(x, y) {\n        return this.map.cellInfo(x, y).isWall();\n    }\n    isStairs(x, y) {\n        return this.map.cellInfo(x, y).isStairs();\n    }\n    isSet(x, y) {\n        return this.hasXY(x, y) && !this.map.cell(x, y).isEmpty();\n    }\n    isDiggable(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.isEmpty())\n            return true;\n        if (cell.isWall())\n            return true;\n        return false;\n    }\n    isNothing(x, y) {\n        return this.hasXY(x, y) && this.map.cell(x, y).isEmpty();\n    }\n    isFloor(x, y) {\n        return this.isPassable(x, y);\n    }\n    isBridge(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_BRIDGE);\n    }\n    isDoor(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_IS_DOOR);\n    }\n    isSecretDoor(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasEntityFlag(GWM.flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    isDeep(x, y) {\n        return this.map\n            .cellInfo(x, y)\n            .hasTileFlag(GWM.tile.flags.Tile.T_DEEP_WATER);\n    }\n    isShallow(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        return (!!cell.depthTile(GWM.flags.Depth.LIQUID) &&\n            !cell.hasTileFlag(GWM.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    isAnyLiquid(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.map.cell(x, y);\n        return (cell.hasDepthTile(GWM.flags.Depth.LIQUID) ||\n            cell.hasTileFlag(GWM.tile.flags.Tile.T_IS_DEEP_LIQUID));\n    }\n    isOccupied(x, y) {\n        return this.hasItem(x, y) || this.hasActor(x, y);\n    }\n    isPassable(x, y) {\n        const info = this.map.cellInfo(x, y);\n        return !(info.blocksMove() || info.blocksPathing());\n    }\n    // tileBlocksMove(tile: number): boolean {\n    //     return GWM.tile.get(tile).blocksMove();\n    // }\n    backup() {\n        const site = new MapSite(this.map.clone());\n        site.machineCount = this.machineCount;\n        site.needsAnalysis = this.needsAnalysis;\n        return site;\n    }\n    restore(backup) {\n        this.map.copy(backup.map);\n        this.machineCount = backup.machineCount;\n        this.needsAnalysis = backup.needsAnalysis;\n    }\n    free() {\n        GWU.grid.free(this.doors);\n    }\n    getChokeCount(x, y) {\n        return this.map.cell(x, y).chokeCount;\n    }\n    setChokeCount(x, y, count) {\n        this.map.cell(x, y).chokeCount = count;\n    }\n    analyze() {\n        if (this.needsAnalysis) {\n            GWM.map.analyze(this.map);\n        }\n        this.needsAnalysis = false;\n    }\n    fireEffect(effect, x, y) {\n        this.needsAnalysis = true;\n        return GWM.effect.fireSync(effect, this.map, x, y);\n    }\n    nextMachineId() {\n        return ++this.machineCount;\n    }\n    getMachine(x, y) {\n        return this.map.cell(x, y).machineId;\n    }\n    setMachine(x, y, id, isRoom = true) {\n        this.needsAnalysis = true;\n        this.map.cell(x, y).machineId = id;\n        if (id == 0) {\n            this.map.clearCellFlag(x, y, Flags.IS_IN_MACHINE);\n        }\n        else {\n            this.map.setCellFlag(x, y, isRoom ? Flags.IS_IN_ROOM_MACHINE : Flags.IS_IN_AREA_MACHINE);\n        }\n    }\n    updateDoorDirs() {\n        this.doors.update((_v, x, y) => {\n            return Utils.directionOfDoorSite(this, x, y);\n        });\n    }\n    getDoorDir(x, y) {\n        return this.doors[x][y];\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Hall extends GWU.xy.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport function makeHall(loc, dirIndex, hallLength, hallWidth = 1) {\n    const dir = GWU.xy.DIRS[dirIndex];\n    const x = Math.min(loc[0], loc[0] + dir[0] * (hallLength - 1));\n    const y = Math.min(loc[1], loc[1] + dir[1] * (hallLength - 1));\n    const width = Math.abs(dir[0] * hallLength) || hallWidth;\n    const height = Math.abs(dir[1] * hallLength) || hallWidth;\n    return new Hall(x, y, width, height);\n}\nexport class Room extends GWU.xy.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GWU.xy.Loc[] | null;\n//     door: number;\n// }\n","import * as GWU from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GWU.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = SITE.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GWU.random.item.bind(GWU.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GWU.random.weighted.bind(GWU.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GWU.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GWU.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GWU.blob.Blob({\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GWU.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GWU.xy.DOWN] = [Math.floor(site.width / 2), site.height - 2];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GWU.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX +\n            GWU.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GWU.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GWU.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GWU.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GWU.xy.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GWU.random.chance(this.options.holeChance.value())) {\n            GWU.xy.forCircle(x, y, GWU.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GWU.xy.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GWU.random.range(minX, maxX);\n            y = GWU.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GWU.xy.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GWU.xy.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GWU.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GWU.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GWU.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GWU.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GWU.xy.UP || dir == GWU.xy.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GWU.xy.NO_DIRECTION;\n    if (dir == GWU.xy.NO_DIRECTION) {\n        const dirs = GWU.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GWU.xy.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GWU.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GWU.range.make(1),\n            length: [GWU.range.make('2-15'), GWU.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GWU.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GWU.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || SITE.chooseRandomDoorSites(site);\n        if (!GWU.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GWU.xy.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = TYPES.makeHall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GWU.xy.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = TYPES.makeHall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        // hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: SITE.SHALLOW,\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = GWU.random.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GWU.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GWU.blob.Blob({\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GWU.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GWU.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    GWU.xy.forCircle(sx, sy, wreathSize, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GWU.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n        const seq = GWU.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyLiquid(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyLiquid(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyLiquid(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GWU.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyLiquid(x, y))\n            return false;\n        if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc = null;\n        let downLoc = null;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GWU.random.matchingLocNear(GWU.xy.x(start), GWU.xy.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GWU.random.matchingLocNear(GWU.xy.x(up), GWU.xy.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GWU.random.matchingLocNear(GWU.xy.x(down), GWU.xy.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GWU.random.matchingLocNear(GWU.xy.x(up), GWU.xy.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GWU.random.matchingLocNear(GWU.xy.x(down), GWU.xy.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (GWU.xy.distanceBetween(x, y, downLoc[0], downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GWU.random.matchingLoc(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GWU.xy.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GWU.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GWU.xy.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GWU.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GWU.xy.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GWU.xy.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GWU.xy.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n            doorChance: 50,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        SITE.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        const seq = GWU.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, SITE.FLOOR);\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            const tile = GWU.random.chance(this.options.doorChance)\n                                ? SITE.DOOR\n                                : SITE.FLOOR;\n                            site.setTile(x, y, tile); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nexport class Level {\n    constructor(options = {}) {\n        var _a, _b;\n        this.seed = 0;\n        this.rooms = {};\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        this.startLoc = [-1, -1];\n        this.endLoc = [-1, -1];\n        this.seed = options.seed || GWU.random.number();\n        GWU.object.setOptions(this.rooms, options.rooms);\n        // Doors\n        if (options.doors === false) {\n            options.doors = { chance: 0 };\n        }\n        else if (options.doors === true) {\n            options.doors = { chance: 100 };\n        }\n        GWU.object.setOptions(this.doors, options.doors);\n        // Halls\n        if (options.halls === false) {\n            options.halls = { chance: 0 };\n        }\n        else if (options.halls === true) {\n            options.halls = {};\n        }\n        GWU.object.setOptions(this.halls, options.halls);\n        // Loops\n        if (options.loops === false) {\n            this.loops = null;\n        }\n        else {\n            if (options.loops === true)\n                options.loops = {};\n            options.loops = options.loops || {};\n            options.loops.doorChance =\n                (_a = options.loops.doorChance) !== null && _a !== void 0 ? _a : (_b = options.doors) === null || _b === void 0 ? void 0 : _b.chance;\n            GWU.object.setOptions(this.loops, options.loops);\n        }\n        // Lakes\n        if (options.lakes === false) {\n            this.lakes = null;\n        }\n        else {\n            if (options.lakes === true)\n                options.lakes = {};\n            GWU.object.setOptions(this.lakes, options.lakes);\n        }\n        // Bridges\n        if (options.bridges === false) {\n            this.bridges = null;\n        }\n        else {\n            if (options.bridges === true)\n                options.bridges = {};\n            GWU.object.setOptions(this.bridges, options.bridges);\n        }\n        // Stairs\n        if (options.stairs === false) {\n            this.stairs = null;\n        }\n        else {\n            if (options.stairs === true)\n                options.stairs = {};\n            GWU.object.setOptions(this.stairs, options.stairs);\n        }\n        this.startLoc = options.startLoc || [-1, -1];\n        this.endLoc = options.endLoc || [-1, -1];\n    }\n    _makeSite(width, height) {\n        return new SITE.GridSite(width, height);\n    }\n    create(...args) {\n        if (args.length == 1 && args[0] instanceof GWM.map.Map) {\n            const map = args[0];\n            this.site = new SITE.MapSite(map);\n        }\n        if (args.length > 1) {\n            const width = args[0];\n            const height = args[1];\n            this.site = new SITE.GridSite(width, height);\n        }\n        const result = this._create(this.site);\n        if (args.length > 1) {\n            const width = args[0];\n            const height = args[1];\n            const cb = args[2];\n            GWU.xy.forRect(width, height, (x, y) => {\n                const t = this.site.getTileIndex(x, y);\n                if (t)\n                    cb(x, y, t);\n            });\n        }\n        this.site.free();\n        return result;\n    }\n    _create(site) {\n        if (this.startLoc[0] < 0 && this.startLoc[0] < 0) {\n            this.startLoc[0] = Math.floor(site.width / 2);\n            this.startLoc[1] = site.height - 2;\n        }\n        this.start(site);\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        site.updateDoorDirs();\n        let fails = 0;\n        while (fails < 20) {\n            if (this.addRoom(site)) {\n                fails = 0;\n                site.updateDoorDirs();\n                GWU.random.shuffle(this.seq);\n            }\n            else {\n                ++fails;\n            }\n        }\n        if (this.loops)\n            this.addLoops(site, this.loops);\n        if (this.lakes)\n            this.addLakes(site, this.lakes);\n        if (this.bridges)\n            this.addBridges(site, this.bridges);\n        if (this.stairs)\n            this.addStairs(site, this.stairs);\n        this.finish(site);\n        return true;\n    }\n    start(site) {\n        if (this.seed) {\n            GWU.random.seed(this.seed);\n            site.seed = this.seed;\n        }\n        site.clear();\n        this.seq = GWU.random.sequence(site.width * site.height);\n    }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addFirstRoom(site) {\n        const roomSite = this._makeSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.startLoc)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this._makeSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        if (room && !this._attachRoom(site, roomSite, room)) {\n            room = null;\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        let i = 0;\n        const len = this.seq.length;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (i = 0; i < len; i++) {\n            const x = Math.floor(this.seq[i] / site.height);\n            const y = this.seq[i] % site.height;\n            const dir = site.getDoorDir(x, y);\n            if (dir != GWU.xy.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, room, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    SITE.copySite(site, roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = GWU.random.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, room, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                SITE.copySite(site, roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n                //     return [x0, y0] as GWU.xy.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, room, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        const hall = room.hall || room;\n        const left = Math.min(room.left, hall.left);\n        const top = Math.min(room.top, hall.top);\n        const right = Math.max(room.right, hall.right);\n        const bottom = Math.max(room.bottom, hall.bottom);\n        for (xRoom = left; xRoom <= right; xRoom++) {\n            for (yRoom = top; yRoom <= bottom; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    if (!map.hasXY(xSite, ySite) ||\n                        map.isBoundaryXY(xSite, ySite)) {\n                        return false;\n                    }\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(map, room, x, y, dir) {\n        const opts = this.doors;\n        let isDoor = false;\n        if (opts.chance && GWU.random.chance(opts.chance)) {\n            isDoor = true;\n        }\n        const tile = isDoor ? opts.tile || SITE.DOOR : SITE.FLOOR;\n        map.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || room.hall.width == 1 || room.hall.height == 1) {\n            return;\n        }\n        if (dir === GWU.xy.UP || dir === GWU.xy.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x - k, y)) {\n                    if (map.isSet(x - k, y - 1) && map.isSet(x - k, y + 1)) {\n                        map.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x + k, y)) {\n                    if (map.isSet(x + k, y - 1) && map.isSet(x + k, y + 1)) {\n                        map.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x, y - k)) {\n                    if (map.isSet(x - 1, y - k) && map.isSet(x + 1, y - k)) {\n                        map.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x, y + k)) {\n                    if (map.isSet(x - 1, y + k) && map.isSet(x + 1, y + k)) {\n                        map.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        return digger.create(site);\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < site.width - 1; i++) {\n                for (j = 0; j < site.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (!site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)) {\n                            if (GWU.random.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, SITE.FLOOR); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                if (\n                // TODO - isPassable\n                (site.isFloor(x + 1, y) || site.isFloor(x - 1, y)) &&\n                    (site.isFloor(x, y + 1) || site.isFloor(x, y - 1))) {\n                    // If there's passable terrain to the left or right, and there's passable terrain\n                    // above or below, then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                }\n                else if ((site.blocksPathing(x + 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x - 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x, y + 1) ? 1 : 0) +\n                    (site.blocksPathing(x, y - 1) ? 1 : 0) >=\n                    3) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? SITE.IMPREGNABLE : SITE.WALL;\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, SITE.WALL);\n                }\n            }\n        });\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nconst Fl = GWU.flag.fl;\nexport var StepFlags;\n(function (StepFlags) {\n    StepFlags[StepFlags[\"BF_OUTSOURCE_ITEM_TO_MACHINE\"] = Fl(1)] = \"BF_OUTSOURCE_ITEM_TO_MACHINE\";\n    StepFlags[StepFlags[\"BF_BUILD_VESTIBULE\"] = Fl(2)] = \"BF_BUILD_VESTIBULE\";\n    StepFlags[StepFlags[\"BF_ADOPT_ITEM\"] = Fl(3)] = \"BF_ADOPT_ITEM\";\n    StepFlags[StepFlags[\"BF_BUILD_AT_ORIGIN\"] = Fl(4)] = \"BF_BUILD_AT_ORIGIN\";\n    StepFlags[StepFlags[\"BF_PERMIT_BLOCKING\"] = Fl(5)] = \"BF_PERMIT_BLOCKING\";\n    StepFlags[StepFlags[\"BF_TREAT_AS_BLOCKING\"] = Fl(6)] = \"BF_TREAT_AS_BLOCKING\";\n    StepFlags[StepFlags[\"BF_NEAR_ORIGIN\"] = Fl(7)] = \"BF_NEAR_ORIGIN\";\n    StepFlags[StepFlags[\"BF_FAR_FROM_ORIGIN\"] = Fl(8)] = \"BF_FAR_FROM_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_VIEW_OF_ORIGIN\"] = Fl(9)] = \"BF_IN_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_PASSABLE_VIEW_OF_ORIGIN\"] = Fl(10)] = \"BF_IN_PASSABLE_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_MONSTER_TAKE_ITEM\"] = Fl(11)] = \"BF_MONSTER_TAKE_ITEM\";\n    StepFlags[StepFlags[\"BF_MONSTER_SLEEPING\"] = Fl(12)] = \"BF_MONSTER_SLEEPING\";\n    StepFlags[StepFlags[\"BF_MONSTER_FLEEING\"] = Fl(13)] = \"BF_MONSTER_FLEEING\";\n    StepFlags[StepFlags[\"BF_MONSTERS_DORMANT\"] = Fl(14)] = \"BF_MONSTERS_DORMANT\";\n    StepFlags[StepFlags[\"BF_ITEM_IS_KEY\"] = Fl(15)] = \"BF_ITEM_IS_KEY\";\n    StepFlags[StepFlags[\"BF_ITEM_IDENTIFIED\"] = Fl(16)] = \"BF_ITEM_IDENTIFIED\";\n    StepFlags[StepFlags[\"BF_ITEM_PLAYER_AVOIDS\"] = Fl(17)] = \"BF_ITEM_PLAYER_AVOIDS\";\n    StepFlags[StepFlags[\"BF_EVERYWHERE\"] = Fl(18)] = \"BF_EVERYWHERE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE\"] = Fl(19)] = \"BF_ALTERNATIVE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE_2\"] = Fl(20)] = \"BF_ALTERNATIVE_2\";\n    StepFlags[StepFlags[\"BF_BUILD_IN_WALLS\"] = Fl(21)] = \"BF_BUILD_IN_WALLS\";\n    StepFlags[StepFlags[\"BF_BUILD_ANYWHERE_ON_LEVEL\"] = Fl(22)] = \"BF_BUILD_ANYWHERE_ON_LEVEL\";\n    StepFlags[StepFlags[\"BF_REPEAT_UNTIL_NO_PROGRESS\"] = Fl(23)] = \"BF_REPEAT_UNTIL_NO_PROGRESS\";\n    StepFlags[StepFlags[\"BF_IMPREGNABLE\"] = Fl(24)] = \"BF_IMPREGNABLE\";\n    // TODO - BF_ALLOW_IN_HALLWAY instead?\n    StepFlags[StepFlags[\"BF_NOT_IN_HALLWAY\"] = Fl(27)] = \"BF_NOT_IN_HALLWAY\";\n    // TODO - BF_ALLOW_BOUNDARY instead\n    StepFlags[StepFlags[\"BF_NOT_ON_LEVEL_PERIMETER\"] = Fl(28)] = \"BF_NOT_ON_LEVEL_PERIMETER\";\n    StepFlags[StepFlags[\"BF_SKELETON_KEY\"] = Fl(29)] = \"BF_SKELETON_KEY\";\n    StepFlags[StepFlags[\"BF_KEY_DISPOSABLE\"] = Fl(30)] = \"BF_KEY_DISPOSABLE\";\n})(StepFlags || (StepFlags = {}));\nexport class BuildStep {\n    constructor(cfg = {}) {\n        var _a;\n        this.tile = -1;\n        this.flags = 0;\n        this.pad = 0;\n        this.item = null;\n        this.horde = null;\n        this.effect = null;\n        this.chance = 0;\n        this.id = 'n/a';\n        this.tile = (_a = cfg.tile) !== null && _a !== void 0 ? _a : -1;\n        if (cfg.flags) {\n            this.flags = GWU.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GWU.range.make(cfg.count || 1);\n        this.item = cfg.item || null;\n        this.horde = cfg.horde || null;\n        if (cfg.effect) {\n            this.effect = GWM.effect.from(cfg.effect);\n        }\n        if (this.item && this.flags & StepFlags.BF_ADOPT_ITEM) {\n            throw new Error('Cannot have blueprint step with item and BF_ADOPT_ITEM.');\n        }\n    }\n    get repeatUntilNoProgress() {\n        return !!(this.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS);\n    }\n    get permitBlocking() {\n        return !!(this.flags & StepFlags.BF_PERMIT_BLOCKING);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & StepFlags.BF_TREAT_AS_BLOCKING);\n    }\n    get adoptItem() {\n        return !!(this.flags & StepFlags.BF_ADOPT_ITEM);\n    }\n    get itemIsKey() {\n        return !!(this.flags & StepFlags.BF_ITEM_IS_KEY);\n    }\n    get keyIsDisposable() {\n        return !!(this.flags & StepFlags.BF_KEY_DISPOSABLE);\n    }\n    get outsourceItem() {\n        return !!(this.flags & StepFlags.BF_OUTSOURCE_ITEM_TO_MACHINE);\n    }\n    get impregnable() {\n        return !!(this.flags & StepFlags.BF_IMPREGNABLE);\n    }\n    get buildVestibule() {\n        return !!(this.flags & StepFlags.BF_BUILD_VESTIBULE);\n    }\n    get generateEverywhere() {\n        return !!(this.flags &\n            StepFlags.BF_EVERYWHERE &\n            ~StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n    get buildAtOrigin() {\n        return !!(this.flags & StepFlags.BF_BUILD_AT_ORIGIN);\n    }\n}\nexport function updateViewMap(builder, buildStep) {\n    if (buildStep.flags &\n        (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n            StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN)) {\n        const site = builder.site;\n        if (buildStep.flags & StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) {\n            const fov = new GWU.fov.FOV({\n                isBlocked: (x, y) => {\n                    return site.blocksPathing(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap[x][y] = 1;\n            });\n        }\n        else {\n            const fov = new GWU.fov.FOV({\n                // TileFlags.T_OBSTRUCTS_PASSABILITY |\n                //     TileFlags.T_OBSTRUCTS_VISION,\n                isBlocked: (x, y) => {\n                    return site.blocksPathing(x, y) || site.blocksVision(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap[x][y] = 1;\n            });\n        }\n        builder.viewMap[builder.originX][builder.originY] = 1;\n    }\n}\nexport function calcDistanceBound(builder, buildStep) {\n    const distanceBound = [0, 10000];\n    if (buildStep.flags & StepFlags.BF_NEAR_ORIGIN) {\n        distanceBound[1] = builder.distance25;\n    }\n    if (buildStep.flags & StepFlags.BF_FAR_FROM_ORIGIN) {\n        distanceBound[0] = builder.distance75;\n    }\n    return distanceBound;\n}\nexport function markCandidates(candidates, builder, blueprint, buildStep, distanceBound) {\n    let count = 0;\n    candidates.update((_v, i, j) => {\n        if (cellIsCandidate(builder, blueprint, buildStep, i, j, distanceBound)) {\n            count++;\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    });\n    return count;\n}\nexport function cellIsCandidate(builder, blueprint, buildStep, x, y, distanceBound) {\n    const site = builder.site;\n    // No building in the hallway if it's prohibited.\n    // This check comes before the origin check, so an area machine will fail altogether\n    // if its origin is in a hallway and the feature that must be built there does not permit as much.\n    if (buildStep.flags & StepFlags.BF_NOT_IN_HALLWAY &&\n        GWU.xy.arcCount(x, y, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n        return false;\n    }\n    // No building along the perimeter of the level if it's prohibited.\n    if (buildStep.flags & StepFlags.BF_NOT_ON_LEVEL_PERIMETER &&\n        (x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1)) {\n        return false;\n    }\n    // The origin is a candidate if the feature is flagged to be built at the origin.\n    // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n    if (buildStep.flags & StepFlags.BF_BUILD_AT_ORIGIN) {\n        return x == builder.originX && y == builder.originY ? true : false;\n    }\n    else if (blueprint.isRoom &&\n        x == builder.originX &&\n        y == builder.originY) {\n        return false;\n    }\n    // No building in another feature's personal space!\n    if (builder.occupied[x][y]) {\n        return false;\n    }\n    // Must be in the viewmap if the appropriate flag is set.\n    if (buildStep.flags &\n        (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n            StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n        !builder.viewMap[x][y]) {\n        return false;\n    }\n    // Do a distance check if the feature requests it.\n    let distance = 10000;\n    if (site.isWall(x, y)) {\n        // Distance is calculated for walls too.\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (!builder.distanceMap.hasXY(i, j))\n                return;\n            if (!site.blocksPathing(i, j) &&\n                distance > builder.distanceMap[i][j] + 1) {\n                distance = builder.distanceMap[i][j] + 1;\n            }\n        }, true);\n    }\n    else {\n        distance = builder.distanceMap[x][y];\n    }\n    if (distance > distanceBound[1] || // distance exceeds max\n        distance < distanceBound[0]) {\n        // distance falls short of min\n        return false;\n    }\n    if (buildStep.flags & StepFlags.BF_BUILD_IN_WALLS) {\n        // If we're supposed to build in a wall...\n        const cellMachine = site.getMachine(x, y);\n        if (!builder.interior[x][y] &&\n            (!cellMachine || cellMachine == builder.machineNumber) &&\n            site.isWall(x, y)) {\n            let ok = false;\n            // ...and this location is a wall that's not already machined...\n            GWU.xy.eachNeighbor(x, y, (newX, newY) => {\n                if (site.hasXY(newX, newY) && // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                    ((builder.interior[newX][newY] &&\n                        !(newX == builder.originX && newY == builder.originY)) ||\n                        (buildStep.flags &\n                            StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL &&\n                            !site.blocksPathing(newX, newY) &&\n                            !site.getMachine(newX, newY)))) {\n                    ok = true;\n                }\n            });\n            return ok;\n        }\n        return false;\n    }\n    else if (site.isWall(x, y)) {\n        // Can't build in a wall unless instructed to do so.\n        return false;\n    }\n    else if (buildStep.flags & StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL) {\n        if ((buildStep.item && site.blocksItems(x, y)) ||\n            site.hasCellFlag(x, y, GWM.flags.Cell.IS_CHOKEPOINT |\n                GWM.flags.Cell.IS_IN_LOOP |\n                GWM.flags.Cell.IS_IN_MACHINE)) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else if (builder.interior[x][y]) {\n        return true;\n    }\n    return false;\n}\nexport function makePersonalSpace(builder, x, y, candidates, personalSpace) {\n    let count = 0;\n    for (let i = x - personalSpace + 1; i <= x + personalSpace - 1; i++) {\n        for (let j = y - personalSpace + 1; j <= y + personalSpace - 1; j++) {\n            if (builder.site.hasXY(i, j)) {\n                if (candidates[i][j]) {\n                    candidates[i][j] = 0;\n                    ++count;\n                }\n                builder.occupied[i][j] = 1;\n            }\n        }\n    }\n    return count;\n}\n// export function buildStep(\n//     builder: BuildData,\n//     blueprint: Blueprint,\n//     buildStep: BuildStep,\n//     adoptedItem: GWM.item.Item | null\n// ): boolean {\n//     let wantCount = 0;\n//     let builtCount = 0;\n//     const site = builder.site;\n//     const candidates = GWU.grid.alloc(site.width, site.height);\n//     // Figure out the distance bounds.\n//     const distanceBound = calcDistanceBound(builder, buildStep);\n//     buildStep.updateViewMap(builder);\n//     // If the StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n//     // Make a master map of candidate locations for this feature.\n//     let qualifyingTileCount = markCandidates(\n//         candidates,\n//         builder,\n//         blueprint,\n//         buildStep,\n//         distanceBound\n//     );\n//     if (!buildStep.generateEverywhere) {\n//         wantCount = buildStep.count.value();\n//     }\n//     if (!qualifyingTileCount || qualifyingTileCount < buildStep.count.lo) {\n//         console.log(\n//             ' - Only %s qualifying tiles - want at least %s.',\n//             qualifyingTileCount,\n//             buildStep.count.lo\n//         );\n//         GWU.grid.free(candidates);\n//         return false;\n//     }\n//     let x = 0,\n//         y = 0;\n//     let success = true;\n//     let didSomething = false;\n//     do {\n//         success = true;\n//         // Find a location for the feature.\n//         if (buildStep.buildAtOrigin) {\n//             // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n//             x = builder.originX;\n//             y = builder.originY;\n//         } else {\n//             // Pick our candidate location randomly, and also strike it from\n//             // the candidates map so that subsequent instances of this same feature can't choose it.\n//             [x, y] = GWU.random.matchingLoc(\n//                 candidates.width,\n//                 candidates.height,\n//                 (x, y) => candidates[x][y] > 0\n//             );\n//         }\n//         // Don't waste time trying the same place again whether or not this attempt succeeds.\n//         candidates[x][y] = 0;\n//         qualifyingTileCount--;\n//         // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n//         if (buildStep.effect) {\n//             success = site.fireEffect(buildStep.effect, x, y);\n//             didSomething = success;\n//         }\n//         // Now try to place the terrain tile, if any.\n//         if (success && buildStep.tile !== -1) {\n//             const tile = GWM.tile.get(buildStep.tile);\n//             if (\n//                 !(buildStep.flags & StepFlags.BF_PERMIT_BLOCKING) &&\n//                 (tile.blocksMove() ||\n//                     buildStep.flags & StepFlags.BF_TREAT_AS_BLOCKING)\n//             ) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y, {\n//                     machine: site.machineCount,\n//                 });\n//             }\n//             if (success) {\n//                 success = site.setTile(x, y, tile);\n//                 didSomething = didSomething || success;\n//             }\n//         }\n//         // Generate an actor, if necessary\n//         // Generate an item, if necessary\n//         if (success && buildStep.item) {\n//             const item = site.makeRandomItem(buildStep.item);\n//             if (!item) {\n//                 success = false;\n//             }\n//             if (buildStep.flags & StepFlags.BF_ITEM_IS_KEY) {\n//                 item.key = GWM.entity.makeKeyInfo(\n//                     x,\n//                     y,\n//                     !!(buildStep.flags & StepFlags.BF_KEY_DISPOSABLE)\n//                 );\n//             }\n//             if (buildStep.flags & StepFlags.BF_OUTSOURCE_ITEM_TO_MACHINE) {\n//                 success = builder.buildRandom(\n//                     Flags.BP_ADOPT_ITEM,\n//                     -1,\n//                     -1,\n//                     item\n//                 );\n//                 if (success) {\n//                     didSomething = true;\n//                 }\n//             } else {\n//                 success = site.addItem(x, y, item);\n//                 didSomething = didSomething || success;\n//             }\n//         } else if (success && buildStep.flags & StepFlags.BF_ADOPT_ITEM) {\n//             // adopt item if necessary\n//             if (!adoptedItem) {\n//                 GWU.grid.free(candidates);\n//                 throw new Error(\n//                     'Failed to build blueprint because there is no adopted item.'\n//                 );\n//             }\n//             if (buildStep.flags & StepFlags.BF_TREAT_AS_BLOCKING) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y);\n//             }\n//             if (success) {\n//                 success = site.addItem(x, y, adoptedItem);\n//                 if (success) {\n//                     didSomething = true;\n//                 } else {\n//                     console.log('- failed to add item', x, y);\n//                 }\n//             } else {\n//                 // console.log('- blocks map', x, y);\n//             }\n//         }\n//         if (success && didSomething) {\n//             // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n//             qualifyingTileCount -= makePersonalSpace(\n//                 builder,\n//                 x,\n//                 y,\n//                 candidates,\n//                 buildStep.pad\n//             );\n//             builtCount++; // we've placed an instance\n//             // Mark the feature location as part of the machine, in case it is not already inside of it.\n//             if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n//                 site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n//             }\n//             // Mark the feature location as impregnable if requested.\n//             if (buildStep.flags & StepFlags.BF_IMPREGNABLE) {\n//                 site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n//             }\n//         }\n//         // Finished with this instance!\n//     } while (\n//         qualifyingTileCount > 0 &&\n//         (buildStep.generateEverywhere ||\n//             builtCount < wantCount ||\n//             buildStep.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS)\n//     );\n//     if (success && buildStep.flags & StepFlags.BF_BUILD_VESTIBULE) {\n//         // Generate a door guard machine.\n//         // Try to create a sub-machine that qualifies.\n//         success = builder.buildRandom(\n//             Flags.BP_VESTIBULE,\n//             builder.originX,\n//             builder.originY\n//         );\n//         if (!success) {\n//             // console.log(\n//             //     `Depth ${builder.depth}: Failed to place blueprint ${blueprint.id} because it requires a vestibule and we couldn't place one.`\n//             // );\n//             // failure! abort!\n//             GWU.grid.free(candidates);\n//             return false;\n//         }\n//         ++builtCount;\n//     }\n//     //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n//     //DEBUG logBuffer(candidates);\n//     success = builtCount > 0;\n//     GWU.grid.free(candidates);\n//     return success;\n// }\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport * as STEP from './buildStep';\nconst Fl = GWU.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(0)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(2)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(3)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(4)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(5)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(6)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(7)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(8)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(9)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(10)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(11)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(12)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(13)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(14)] = \"BP_NO_INTERIOR_FLAG\";\n    Flags[Flags[\"BP_NOT_IN_HALLWAY\"] = Fl(15)] = \"BP_NOT_IN_HALLWAY\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.flags = 0;\n        this.steps = [];\n        this.id = 'n/a';\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GWU.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            this.size = GWU.range.make(opts.size);\n            if (this.size.lo > this.size.hi)\n                throw new Error('Blueprint size must be small to large.');\n        }\n        else {\n            this.size = GWU.range.make([1, 1]); // Anything bigger makes weird things happen\n        }\n        if (opts.flags) {\n            this.flags = GWU.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n        }\n        if (this.flags & Flags.BP_ADOPT_ITEM) {\n            if (!this.steps.some((s) => s.flags & STEP.StepFlags.BF_ADOPT_ITEM)) {\n                throw new Error('Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.');\n            }\n        }\n    }\n    getChance(level, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return 0;\n        }\n        return this.frequency(level);\n    }\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n    qualifies(requiredFlags, depth) {\n        if (this.frequency(depth) <= 0 ||\n            // Must have the required flags:\n            ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags) {\n            return false;\n        }\n        return true;\n    }\n    pickLocation(site) {\n        return pickLocation(site, this);\n    }\n    pickComponents() {\n        const alternativeFlags = [\n            STEP.StepFlags.BF_ALTERNATIVE,\n            STEP.StepFlags.BF_ALTERNATIVE_2,\n        ];\n        const keepFeature = new Array(this.steps.length).fill(true);\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = GWU.random.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n}\nexport function pickLocation(site, blueprint) {\n    // Find a location and map out the machine interior.\n    if (blueprint.isRoom) {\n        // If it's a room machine, count up the gates of appropriate\n        // choke size and remember where they are. The origin of the room will be the gate location.\n        const randSite = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n            return (site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE) &&\n                blueprint.size.contains(site.getChokeCount(x, y)));\n        });\n        if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n            // If no suitable sites, abort.\n            console.log('Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint.');\n            return false;\n        }\n        return randSite;\n    }\n    else if (blueprint.isVestiblue) {\n        //  Door machines must have locations passed in. We can't pick one ourselves.\n        console.log('ERROR: Attempted to build a vestiblue without a location being provided.');\n        return false;\n    }\n    // Pick a random origin location.\n    const pos = GWU.random.matchingLoc(site.width, site.height, (x, y) => {\n        if (!site.isPassable(x, y))\n            return false;\n        if (blueprint.flags & Flags.BP_NOT_IN_HALLWAY) {\n            const count = GWU.xy.arcCount(x, y, (i, j) => site.isPassable(i, j));\n            return count <= 1;\n        }\n        return true;\n    });\n    if (!pos || pos[0] < 0 || pos[1] < 0)\n        return false;\n    return pos;\n}\n// Assume site has been analyzed (aka GateSites and ChokeCounts set)\nexport function computeInterior(builder, blueprint) {\n    let failsafe = blueprint.isRoom ? 10 : 20;\n    let tryAgain;\n    const interior = builder.interior;\n    const site = builder.site;\n    do {\n        tryAgain = false;\n        if (--failsafe <= 0) {\n            // console.log(\n            //     `Failed to build blueprint ${blueprint.id}; failed repeatedly to find a suitable blueprint location.`\n            // );\n            return false;\n        }\n        interior.fill(0);\n        // Find a location and map out the machine interior.\n        if (blueprint.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n            // Now map out the interior into interior[][].\n            // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n            // same or lower choke value, ignoring any tiles that are already part of a machine.\n            // If we get false from this, try again. If we've tried too many times already, abort.\n            tryAgain = !addTileToInteriorAndIterate(builder, builder.originX, builder.originY);\n        }\n        else if (blueprint.isVestiblue) {\n            if (!computeVestibuleInterior(builder, blueprint)) {\n                // TODO - tryagain = true?\n                console.log(`ERROR: Attempted to build vestibule ${blueprint.id}: not enough room.`);\n                return false;\n            }\n            // success\n        }\n        else {\n            // Find a location and map out the interior for a non-room machine.\n            // The strategy here is simply to pick a random location on the map,\n            // expand it along a pathing map by one space in all directions until the size reaches\n            // the chosen size, and then make sure the resulting space qualifies.\n            // If not, try again. If we've tried too many times already, abort.\n            let distanceMap = GWU.grid.alloc(interior.width, interior.height);\n            SITE.computeDistanceMap(site, distanceMap, builder.originX, builder.originY, blueprint.size.hi);\n            const seq = GWU.random.sequence(site.width * site.height);\n            let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n            let goalSize = blueprint.size.value(); // Keeps track of the goal size.\n            for (let k = 0; k < 1000 && qualifyingTileCount < goalSize; k++) {\n                for (let n = 0; n < seq.length && qualifyingTileCount < goalSize; n++) {\n                    const i = Math.floor(seq[n] / site.height);\n                    const j = seq[n] % site.height;\n                    if (distanceMap[i][j] == k) {\n                        interior[i][j] = 1;\n                        qualifyingTileCount++;\n                        if (site.isOccupied(i, j) ||\n                            site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)) {\n                            // Abort if we've entered another machine or engulfed another machine's item or monster.\n                            tryAgain = true;\n                            qualifyingTileCount = goalSize; // This is a hack to drop out of these three for-loops.\n                        }\n                    }\n                }\n            }\n            // Now make sure the interior map satisfies the machine's qualifications.\n            if (qualifyingTileCount < goalSize) {\n                tryAgain = true;\n                console.debug('- too small');\n            }\n            else if (blueprint.treatAsBlocking &&\n                SITE.siteDisruptedBy(site, interior, {\n                    machine: site.machineCount,\n                })) {\n                console.debug(' - disconnected');\n                tryAgain = true;\n            }\n            else if (blueprint.requireBlocking &&\n                SITE.siteDisruptedSize(site, interior) < 100) {\n                console.debug(' - not disconnected enough');\n                tryAgain = true; // BP_REQUIRE_BLOCKING needs some work to make sure the disconnect is interesting.\n            }\n            // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n            // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n            GWU.grid.free(distanceMap);\n        }\n        // Now loop if necessary.\n    } while (tryAgain);\n    // console.log(tryAgain, failsafe);\n    return true;\n}\nexport function computeVestibuleInterior(builder, blueprint) {\n    let success = true;\n    const site = builder.site;\n    const interior = builder.interior;\n    interior.fill(0);\n    // console.log('DISTANCE MAP', originX, originY);\n    // RUT.Grid.dump(distMap);\n    const doorChokeCount = site.getChokeCount(builder.originX, builder.originY);\n    const vestibuleLoc = [-1, -1];\n    let vestibuleChokeCount = doorChokeCount;\n    GWU.xy.eachNeighbor(builder.originX, builder.originY, (x, y) => {\n        const count = site.getChokeCount(x, y);\n        if (count == doorChokeCount)\n            return;\n        if (count > 10000)\n            return;\n        if (count < 0)\n            return;\n        vestibuleLoc[0] = x;\n        vestibuleLoc[1] = y;\n        vestibuleChokeCount = count;\n    }, true);\n    const roomSize = vestibuleChokeCount - doorChokeCount;\n    if (blueprint.size.contains(roomSize)) {\n        // The room entirely fits within the vestibule desired size\n        const count = interior.floodFill(vestibuleLoc[0], vestibuleLoc[1], (_v, i, j) => {\n            if (site.isOccupied(i, j)) {\n                success = false;\n            }\n            return site.getChokeCount(i, j) === vestibuleChokeCount;\n        }, 1);\n        if (success && blueprint.size.contains(count))\n            return true;\n    }\n    let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n    const wantSize = blueprint.size.value(); // Keeps track of the goal size.\n    const distMap = GWU.grid.alloc(site.width, site.height);\n    SITE.computeDistanceMap(site, distMap, builder.originX, builder.originY, blueprint.size.hi);\n    const cells = GWU.random.sequence(site.width * site.height);\n    success = true;\n    for (let k = 0; k < 1000 && qualifyingTileCount < wantSize; k++) {\n        for (let i = 0; i < cells.length && qualifyingTileCount < wantSize; ++i) {\n            const x = Math.floor(cells[i] / site.height);\n            const y = cells[i] % site.height;\n            const dist = distMap[x][y];\n            if (dist != k)\n                continue;\n            if (site.isOccupied(x, y)) {\n                success = false;\n                qualifyingTileCount = wantSize;\n            }\n            if (site.getChokeCount(x, y) <= doorChokeCount)\n                continue;\n            interior[x][y] = 1;\n            qualifyingTileCount += 1;\n        }\n    }\n    // Now make sure the interior map satisfies the machine's qualifications.\n    if (blueprint.treatAsBlocking &&\n        SITE.siteDisruptedBy(site, interior, { machine: site.machineCount })) {\n        success = false;\n        console.debug('- blocks');\n    }\n    else if (blueprint.requireBlocking &&\n        SITE.siteDisruptedSize(site, interior) < 100) {\n        success = false;\n        console.debug('- does not block');\n    }\n    GWU.grid.free(distMap);\n    return success;\n}\n// Assumes (startX, startY) is in the machine.\n// Returns true if everything went well, and false if we ran into a machine component\n// that was already there, as we don't want to build a machine around it.\nfunction addTileToInteriorAndIterate(builder, startX, startY) {\n    let goodSoFar = true;\n    const interior = builder.interior;\n    const site = builder.site;\n    interior[startX][startY] = 1;\n    const startChokeCount = site.getChokeCount(startX, startY);\n    for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n        const newX = startX + GWU.xy.DIRS[dir][0];\n        const newY = startY + GWU.xy.DIRS[dir][1];\n        if (!site.hasXY(newX, newY))\n            continue;\n        if (interior[newX][newY])\n            continue; // already done\n        if (site.isOccupied(newX, newY) ||\n            (site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_IN_MACHINE) &&\n                !site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_GATE_SITE))) {\n            // Abort if there's an item in the room.\n            // Items haven't been populated yet, so the only way this could happen is if another machine\n            // previously placed an item here.\n            // Also abort if we're touching another machine at any point other than a gate tile.\n            return false;\n        }\n        if (site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n            !site.hasCellFlag(newX, newY, GWM.flags.Cell.IS_IN_MACHINE)) {\n            goodSoFar = addTileToInteriorAndIterate(builder, newX, newY);\n        }\n    }\n    return goodSoFar;\n}\nexport function prepareInterior(builder, blueprint) {\n    const interior = builder.interior;\n    const site = builder.site;\n    // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n    if (blueprint.maximizeInterior) {\n        expandMachineInterior(builder, 1);\n    }\n    else if (blueprint.openInterior) {\n        expandMachineInterior(builder, 4);\n    }\n    // If requested, cleanse the interior -- no interesting terrain allowed.\n    if (blueprint.purgeInterior) {\n        interior.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x, y, SITE.FLOOR);\n        });\n    }\n    // If requested, purge pathing blockers -- no traps allowed.\n    if (blueprint.purgeBlockers) {\n        interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            if (site.blocksPathing(x, y)) {\n                site.setTile(x, y, SITE.FLOOR);\n            }\n        });\n    }\n    // If requested, purge the liquid layer in the interior -- no liquids allowed.\n    if (blueprint.purgeLiquids) {\n        interior.forEach((v, x, y) => {\n            if (v && site.isAnyLiquid(x, y)) {\n                site.setTile(x, y, SITE.FLOOR);\n            }\n        });\n    }\n    // Surround with walls if requested.\n    if (blueprint.surroundWithWalls) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE))\n                return;\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return; // Not valid x,y\n                if (interior[i][j])\n                    return; // is part of machine\n                if (site.isWall(i, j))\n                    return; // is already a wall (of some sort)\n                if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_GATE_SITE))\n                    return; // is a door site\n                if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE))\n                    return; // is part of a machine\n                if (!site.blocksPathing(i, j))\n                    return; // is not a blocker for the player (water?)\n                site.setTile(i, j, SITE.WALL);\n            }, false);\n        });\n    }\n    // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n    // Then zero out any portion of the interior that is still wall.\n    // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n    //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n    // }\n    // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n    if (blueprint.makeImpregnable) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.hasCellFlag(x, y, GWM.flags.Cell.IS_GATE_SITE))\n                return;\n            site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return;\n                if (interior[i][j])\n                    return;\n                if (site.hasCellFlag(i, j, GWM.flags.Cell.IS_GATE_SITE))\n                    return;\n                site.setCellFlag(i, j, GWM.flags.Cell.IMPREGNABLE);\n            }, false);\n        });\n    }\n    // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n    const machineNumber = builder.machineNumber;\n    interior.forEach((v, x, y) => {\n        if (!v)\n            return;\n        if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n            site.setMachine(x, y, machineNumber, blueprint.isRoom);\n        }\n        // secret doors mess up machines\n        // TODO - is this still true?\n        if (site.isSecretDoor(x, y)) {\n            site.setTile(x, y, SITE.DOOR);\n        }\n    });\n}\nexport function expandMachineInterior(builder, minimumInteriorNeighbors = 1) {\n    let madeChange;\n    const interior = builder.interior;\n    const site = builder.site;\n    do {\n        madeChange = false;\n        interior.forEach((_v, x, y) => {\n            // if (v && site.isDoor(x, y)) {\n            //     site.setTile(x, y, SITE.FLOOR); // clean out the doors...\n            //     return;\n            // }\n            if (site.hasCellFlag(x, y, GWM.flags.Cell.IS_IN_MACHINE))\n                return;\n            if (!site.blocksPathing(x, y))\n                return;\n            let nbcount = 0;\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return; // Not in map\n                if (interior[i][j] && !site.blocksPathing(i, j)) {\n                    ++nbcount; // in machine and open tile\n                }\n            }, false);\n            if (nbcount < minimumInteriorNeighbors)\n                return;\n            nbcount = 0;\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return; // not on map\n                if (interior[i][j])\n                    return; // already part of machine\n                if (!site.isWall(i, j) ||\n                    site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)) {\n                    ++nbcount; // tile is not a wall or is in a machine\n                }\n            }, false);\n            if (nbcount)\n                return;\n            // Eliminate this obstruction; welcome its location into the machine.\n            madeChange = true;\n            interior[x][y] = 1;\n            if (site.blocksPathing(x, y)) {\n                site.setTile(x, y, SITE.FLOOR);\n            }\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return;\n                if (site.isSet(i, j))\n                    return;\n                site.setTile(i, j, SITE.WALL);\n            });\n        });\n    } while (madeChange);\n}\n///////////////////////////\n// INSTALL\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\nexport function random(requiredFlags, depth) {\n    const matches = Object.values(blueprints).filter((b) => b.qualifies(requiredFlags, depth));\n    return GWU.random.item(matches);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport * as BLUE from './blueprint';\nimport * as STEP from './buildStep';\n// export interface BuildData {\n//     site: SITE.BuildSite;\n//     spawnedItems: any[];\n//     spawnedHordes: any[];\n//     interior: GWU.grid.NumGrid;\n//     occupied: GWU.grid.NumGrid;\n//     viewMap: GWU.grid.NumGrid;\n//     distanceMap: GWU.grid.NumGrid;\n//     originX: number;\n//     originY: number;\n//     distance25: number;\n//     distance75: number;\n//     machineNumber: number;\n// }\nexport class BuildData {\n    constructor(map, depth) {\n        this.map = map;\n        this.spawnedItems = [];\n        this.spawnedHordes = [];\n        this.originX = -1;\n        this.originY = -1;\n        this.distance25 = -1;\n        this.distance75 = -1;\n        this.machineNumber = 0;\n        this.depth = 0;\n        this.site = new SITE.MapSite(map);\n        this.interior = GWU.grid.alloc(map.width, map.height);\n        this.occupied = GWU.grid.alloc(map.width, map.height);\n        this.viewMap = GWU.grid.alloc(map.width, map.height);\n        this.distanceMap = GWU.grid.alloc(map.width, map.height);\n        this.depth = depth;\n    }\n    free() {\n        GWU.grid.free(this.interior);\n        GWU.grid.free(this.occupied);\n        GWU.grid.free(this.viewMap);\n        GWU.grid.free(this.distanceMap);\n    }\n    reset(originX, originY) {\n        this.interior.fill(0);\n        this.occupied.fill(0);\n        this.viewMap.fill(0);\n        this.distanceMap.fill(0);\n        this.originX = originX;\n        this.originY = originY;\n    }\n    calcDistances(maxSize) {\n        this.distanceMap.fill(0);\n        SITE.computeDistanceMap(this.site, this.distanceMap, this.originX, this.originY, maxSize);\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n        this.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const dist = this.distanceMap[x][y];\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            }\n            else {\n                distance25 -= distances[i];\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            }\n            else {\n                distance75 -= distances[i];\n            }\n        }\n        this.distance25 = distance25;\n        this.distance75 = distance75;\n    }\n}\nexport class Builder {\n    constructor(map, depth) {\n        this.data = new BuildData(map, depth);\n    }\n    async buildRandom(requiredMachineFlags = BLUE.Flags.BP_ROOM, x = -1, y = -1, adoptedItem = null) {\n        this.data.site.analyze();\n        let tries = [];\n        while (tries.length < 10) {\n            const blueprint = BLUE.random(requiredMachineFlags, this.data.depth);\n            if (!blueprint) {\n                return false;\n            }\n            tries.push(blueprint.id);\n            if (await this._buildAt(blueprint, x, y, adoptedItem)) {\n                return true;\n            }\n        }\n        // console.log(\n        //     'Failed to build random blueprint matching flags: ' +\n        //         GWU.flag.toString(BLUE.Flags, requiredMachineFlags) +\n        //         ' tried : ' +\n        //         tries.join(', ')\n        // );\n        return false;\n    }\n    async build(blueprint, x = -1, y = -1, adoptedItem = null) {\n        if (typeof blueprint === 'string') {\n            const id = blueprint;\n            blueprint = BLUE.blueprints[id];\n            if (!blueprint)\n                throw new Error('Failed to find blueprint - ' + id);\n        }\n        this.data.site.analyze();\n        return this._buildAt(blueprint, x, y, adoptedItem);\n    }\n    async _buildAt(blueprint, x = -1, y = -1, adoptedItem = null) {\n        if (x >= 0 && y >= 0) {\n            return await this._build(blueprint, x, y, adoptedItem);\n        }\n        let tries = 10;\n        while (tries--) {\n            const loc = await this.pickLocation(blueprint);\n            if (!loc) {\n                continue;\n            }\n            if (await this._build(blueprint, loc[0], loc[1], adoptedItem)) {\n                return true;\n            }\n        }\n        // console.log('Failed to build blueprint - ' + blueprint.id);\n        return false;\n    }\n    //////////////////////////////////////////\n    // Returns true if the machine got built; false if it was aborted.\n    // If empty array spawnedItems or spawnedMonsters is given, will pass those back for deletion if necessary.\n    async _build(blueprint, originX, originY, adoptedItem = null) {\n        const data = this.data;\n        data.reset(originX, originY);\n        if (!(await this.computeInterior(blueprint))) {\n            return false;\n        }\n        // This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.\n        const levelBackup = data.site.backup();\n        data.machineNumber = data.site.nextMachineId(); // Reserve this machine number, starting with 1.\n        // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.\n        BLUE.prepareInterior(data, blueprint);\n        // Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)\n        // and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.\n        this.data.calcDistances(blueprint.size.hi);\n        // Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.\n        // Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.\n        const components = blueprint.pickComponents();\n        // Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.\n        // Now tick through the features and build them.\n        for (let index = 0; index < components.length; index++) {\n            const component = components[index];\n            // console.log('BUILD COMPONENT', component);\n            if (!(await this.buildComponent(blueprint, component, adoptedItem))) {\n                // failure! abort!\n                // Restore the map to how it was before we touched it.\n                data.site.restore(levelBackup);\n                // abortItemsAndMonsters(spawnedItems, spawnedMonsters);\n                return false;\n            }\n        }\n        // Clear out the interior flag for all non-wired cells, if requested.\n        if (blueprint.noInteriorFlag) {\n            SITE.clearInteriorFlag(data.site, this.data.machineNumber);\n        }\n        // if (torchBearer && torch) {\n        // \tif (torchBearer->carriedItem) {\n        // \t\tdeleteItem(torchBearer->carriedItem);\n        // \t}\n        // \tremoveItemFromChain(torch, floorItems);\n        // \ttorchBearer->carriedItem = torch;\n        // }\n        // console.log('Built a machine from blueprint:', originX, originY);\n        return true;\n    }\n    async pickLocation(blueprint) {\n        return BLUE.pickLocation(this.data.site, blueprint);\n    }\n    async computeInterior(blueprint) {\n        return BLUE.computeInterior(this.data, blueprint);\n    }\n    async buildComponent(blueprint, buildStep, adoptedItem) {\n        let wantCount = 0;\n        let builtCount = 0;\n        const builder = this.data;\n        const site = builder.site;\n        const candidates = GWU.grid.alloc(site.width, site.height);\n        // console.log(\n        //     'buildComponent',\n        //     blueprint.id,\n        //     blueprint.steps.indexOf(buildStep)\n        // );\n        // Figure out the distance bounds.\n        const distanceBound = STEP.calcDistanceBound(builder, buildStep);\n        STEP.updateViewMap(builder, buildStep);\n        // If the StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n        // Make a master map of candidate locations for this feature.\n        let qualifyingTileCount = STEP.markCandidates(candidates, builder, blueprint, buildStep, distanceBound);\n        if (!buildStep.generateEverywhere) {\n            wantCount = buildStep.count.value();\n        }\n        if (!qualifyingTileCount || qualifyingTileCount < buildStep.count.lo) {\n            // console.log(\n            //     `Blueprint ${blueprint.id}, step ${blueprint.steps.indexOf(\n            //         buildStep\n            //     )} - Only ${qualifyingTileCount} qualifying tiles - want ${buildStep.count.toString()}.`\n            // );\n            return false;\n        }\n        let x = 0, y = 0;\n        let success = true;\n        let didSomething = false;\n        do {\n            success = true;\n            // Find a location for the feature.\n            if (buildStep.buildAtOrigin) {\n                // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                x = builder.originX;\n                y = builder.originY;\n            }\n            else {\n                // Pick our candidate location randomly, and also strike it from\n                // the candidates map so that subsequent instances of this same feature can't choose it.\n                [x, y] = GWU.random.matchingLoc(candidates.width, candidates.height, (x, y) => candidates[x][y] > 0);\n            }\n            // Don't waste time trying the same place again whether or not this attempt succeeds.\n            candidates[x][y] = 0;\n            qualifyingTileCount--;\n            // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n            if (buildStep.effect) {\n                success = site.fireEffect(buildStep.effect, x, y);\n                didSomething = success;\n            }\n            // Now try to place the terrain tile, if any.\n            if (success && buildStep.tile !== -1) {\n                const tile = GWM.tile.get(buildStep.tile);\n                if (!buildStep.permitBlocking &&\n                    (tile.blocksMove() || buildStep.treatAsBlocking)) {\n                    // Yes, check for blocking.\n                    success = !SITE.siteDisruptedByXY(site, x, y, {\n                        machine: site.machineCount,\n                    });\n                }\n                if (success) {\n                    success = site.setTile(x, y, tile);\n                    didSomething = didSomething || success;\n                }\n            }\n            // Generate an actor, if necessary\n            // Generate an item, if necessary\n            if (success && buildStep.item) {\n                const item = site.makeRandomItem(buildStep.item);\n                if (!item) {\n                    success = false;\n                }\n                if (buildStep.itemIsKey) {\n                    item.key = GWM.entity.makeKeyInfo(x, y, !!buildStep.keyIsDisposable);\n                }\n                if (buildStep.outsourceItem) {\n                    success = await this.buildRandom(BLUE.Flags.BP_ADOPT_ITEM, -1, -1, item);\n                    if (success) {\n                        didSomething = true;\n                    }\n                }\n                else {\n                    success = site.addItem(x, y, item);\n                    didSomething = didSomething || success;\n                }\n            }\n            else if (success && buildStep.adoptItem) {\n                // adopt item if necessary\n                if (!adoptedItem) {\n                    throw new Error('Failed to build blueprint because there is no adopted item.');\n                }\n                if (buildStep.treatAsBlocking) {\n                    // Yes, check for blocking.\n                    success = !SITE.siteDisruptedByXY(site, x, y);\n                }\n                if (success) {\n                    success = site.addItem(x, y, adoptedItem);\n                    if (success) {\n                        didSomething = true;\n                    }\n                    else {\n                        console.log('- failed to add item', x, y);\n                    }\n                }\n                else {\n                    // console.log('- blocks map', x, y);\n                }\n            }\n            if (success && didSomething) {\n                // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n                qualifyingTileCount -= STEP.makePersonalSpace(builder, x, y, candidates, buildStep.pad);\n                builtCount++; // we've placed an instance\n                // Mark the feature location as part of the machine, in case it is not already inside of it.\n                if (!blueprint.noInteriorFlag) {\n                    site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n                }\n                // Mark the feature location as impregnable if requested.\n                if (buildStep.impregnable) {\n                    site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n                }\n            }\n            // Finished with this instance!\n        } while (qualifyingTileCount > 0 &&\n            (buildStep.generateEverywhere ||\n                builtCount < wantCount ||\n                buildStep.repeatUntilNoProgress));\n        if (success && buildStep.buildVestibule) {\n            // Generate a door guard machine.\n            // Try to create a sub-machine that qualifies.\n            success = await this.buildRandom(BLUE.Flags.BP_VESTIBULE, builder.originX, builder.originY);\n            if (!success) {\n                // console.log(\n                //     `Depth ${builder.depth}: Failed to place blueprint ${blueprint.id} because it requires a vestibule and we couldn't place one.`\n                // );\n                // failure! abort!\n                return false;\n            }\n            ++builtCount;\n        }\n        //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n        //DEBUG logBuffer(candidates);\n        success = builtCount > 0;\n        GWU.grid.free(candidates);\n        return success;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as LEVEL from './level';\nexport class Dungeon {\n    constructor(options = {}) {\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { count: 20, digger: 'DEFAULT' },\n            halls: {},\n            loops: {},\n            lakes: {},\n            bridges: {},\n            stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GWU.object.setOptions(this.config, options);\n        if (this.config.seed) {\n            GWU.random.seed(this.config.seed);\n        }\n        this.initSeeds();\n        this.initStairLocs();\n    }\n    get levels() {\n        return this.config.levels;\n    }\n    initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GWU.random.number(2 ** 32);\n        }\n    }\n    initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        for (let i = 0; i < this.config.levels; ++i) {\n            const endLoc = GWU.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                return (GWU.xy.distanceBetween(startLoc[0], startLoc[1], x, y) >\n                    minDistance);\n            });\n            this.stairLocs.push([\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ]);\n            startLoc = endLoc;\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        GWU.random.seed(this.seeds[id]);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && rooms.entrance) {\n            rooms.first = rooms.entrance;\n        }\n        const levelOpts = {\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            width: this.config.width,\n            height: this.config.height,\n        };\n        return this.makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    makeLevel(id, opts, cb) {\n        const level = new LEVEL.Level(opts);\n        const result = level.create(this.config.width, this.config.height, cb);\n        if (!GWU.xy.equalsXY(level.endLoc, opts.endLoc) ||\n            !GWU.xy.equalsXY(level.startLoc, opts.startLoc)) {\n            this.stairLocs[id] = [level.startLoc, level.endLoc];\n        }\n        return result;\n    }\n}\n"],"names":["DIRS","GWU","xy","directionOfDoorSite","site","x","y","dir","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","hasXY","isFloor","chooseRandomDoorSites","i","j","k","doorSiteFailed","DOORS","h","height","w","width","isDiggable","isSet","push","doorSites","loc","random","item","copySite","dest","source","offsetX","offsetY","forRect","otherX","otherY","v","getTileIndex","setTile","fillCostGrid","costGrid","update","_v","isPassable","path","OBSTRUCTION","siteDisruptedByXY","options","_a","_b","_c","machine","arcCount","blockingGrid","grid","alloc","result","siteDisruptedBy","free","walkableGrid","disrupts","lakeX","lakeY","get","isStairs","getMachine","first","floodFill","siteDisruptedSize","blockingToMapX","blockingToMapY","nextId","minSize","disrupted","Math","min","computeDistanceMap","distanceMap","originX","originY","maxDistance","calculateDistances","clearInteriorFlag","hasCellFlag","GWM","flags","Cell","IS_WIRED","IS_CIRCUIT_BREAKER","setMachine","NOTHING","tile","index","FLOOR","DOOR","SECRET_DOOR","WALL","DEEP","SHALLOW","BRIDGE","UP_STAIRS","DOWN_STAIRS","IMPREGNABLE","TILEMAP","[object Object]","GridSite","this","seed","tiles","doors","fill","isBoundaryXY","isDoor","isBridge","isShallow","isNothing","isWall","isDeep","blocksPathing","Tile","obj","Error","_x","_y","Utils.directionOfDoorSite","Flags","MapSite","map","machineCount","needsAnalysis","flag","cellInfo","cell","setCellFlag","clearCellFlag","hasTile","opts","highestPriorityTile","cells","forEach","c","clear","hasItem","tags","makeRandom","forceItem","hasActor","blocksMove","blocksVision","hasEntityFlag","Entity","L_BLOCKS_DIAGONAL","info","L_BLOCKS_MOVE","hasTileFlag","T_PATHING_BLOCKER","L_BLOCKS_ITEMS","L_BLOCKS_EFFECTS","isEmpty","T_BRIDGE","T_IS_DOOR","L_SECRETLY_PASSABLE","T_DEEP_WATER","depthTile","Depth","LIQUID","T_IS_DEEP_LIQUID","hasDepthTile","clone","backup","copy","chokeCount","count","analyze","effect","fireSync","machineId","id","isRoom","IS_IN_MACHINE","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","Hall","Bounds","super","dx","dy","d","makeHall","dirIndex","hallLength","hallWidth","abs","Room","hall","cx","floor","cy","translate","checkConfig","config","expected","Object","entries","key","expect","have","undefined","Array","isArray","range","make","RoomDigger","_setOptions","carve","length","every","SITE.chooseRandomDoorSites","rooms","ChoiceRoom","choices","randomRoom","bind","weighted","room","utils","ERROR","create","Cavern","value","SITE.FLOOR","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","DOWN","Cross","SymmetricalCross","minorWidth","minorHeight","x2","y2","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","chance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickLength","lengths","UP","pickHallDirection","dirs","sequence","hi","door","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.makeHall","lower","higher","actual","startX","startY","halls","clamp","Number","parseInt","_pickWidth","Lakes","tries","canDisrupt","wreathTile","SITE.SHALLOW","wreathChance","wreathSize","SITE.DEEP","assign","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","dirCoords","seq","isAnyLiquid","bridgeDir","NO_PATH","isBridgeCandidate","SITE.BRIDGE","Stairs","up","down","start","upTile","SITE.UP_STAIRS","downTile","SITE.DOWN_STAIRS","wall","SITE.IMPREGNABLE","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingLoc","matchingLocNear","distanceBetween","slice","setupStairs","indexes","x0","y0","CLOCK_DIRS","findIndex","r","LoopDigger","doorChance","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.DOOR","Level","loops","lakes","bridges","stairs","boundary","startLoc","endLoc","number","object","setOptions","SITE.GridSite","args","Map","SITE.MapSite","_create","cb","t","addFirstRoom","updateDoorDirs","fails","addRoom","shuffle","addLoops","addLakes","addBridges","addStairs","finish","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","roomSite","_makeSite","getDigger","_attachRoomAtLoc","HALL.dig","_attachRoom","len","getDoorDir","oppDir","_roomFitsAt","SITE.copySite","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","didSomething","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","blocksDiagonal","boundaryTile","SITE.WALL","Fl","fl","StepFlags","BuildStep","cfg","pad","horde","from","BF_ADOPT_ITEM","repeatUntilNoProgress","BF_REPEAT_UNTIL_NO_PROGRESS","permitBlocking","BF_PERMIT_BLOCKING","treatAsBlocking","BF_TREAT_AS_BLOCKING","adoptItem","itemIsKey","BF_ITEM_IS_KEY","keyIsDisposable","BF_KEY_DISPOSABLE","outsourceItem","BF_OUTSOURCE_ITEM_TO_MACHINE","impregnable","BF_IMPREGNABLE","buildVestibule","BF_BUILD_VESTIBULE","generateEverywhere","BF_EVERYWHERE","BF_BUILD_AT_ORIGIN","buildAtOrigin","updateViewMap","builder","buildStep","BF_IN_VIEW_OF_ORIGIN","BF_IN_PASSABLE_VIEW_OF_ORIGIN","fov","FOV","isBlocked","calculate","viewMap","calcDistanceBound","distanceBound","BF_NEAR_ORIGIN","distance25","BF_FAR_FROM_ORIGIN","distance75","markCandidates","candidates","blueprint","cellIsCandidate","BF_NOT_IN_HALLWAY","BF_NOT_ON_LEVEL_PERIMETER","occupied","distance","eachNeighbor","BF_BUILD_IN_WALLS","cellMachine","interior","machineNumber","ok","BF_BUILD_ANYWHERE_ON_LEVEL","blocksItems","IS_CHOKEPOINT","IS_IN_LOOP","makePersonalSpace","personalSpace","Blueprint","steps","split","trim","frequency","size","lo","STEP.BuildStep","BP_ADOPT_ITEM","some","s","STEP.StepFlags","level","want","includes","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","BP_NO_INTERIOR_FLAG","requiredFlags","depth","pickLocation","alternativeFlags","BF_ALTERNATIVE","BF_ALTERNATIVE_2","keepFeature","totalFreq","randIndex","filter","_f","randSite","IS_GATE_SITE","contains","getChokeCount","console","log","pos","BP_NOT_IN_HALLWAY","computeVestibuleInterior","doorChokeCount","vestibuleLoc","vestibuleChokeCount","roomSize","isOccupied","qualifyingTileCount","wantSize","distMap","SITE.computeDistanceMap","SITE.siteDisruptedBy","debug","SITE.siteDisruptedSize","addTileToInteriorAndIterate","goodSoFar","startChokeCount","expandMachineInterior","minimumInteriorNeighbors","madeChange","nbcount","blueprints","matches","values","b","qualifies","BuildData","spawnedItems","spawnedHordes","maxSize","distances","dist","data","requiredMachineFlags","BLUE.Flags","adoptedItem","BLUE.random","_buildAt","BLUE.blueprints","_build","reset","computeInterior","levelBackup","nextMachineId","isSecretDoor","BLUE.prepareInterior","calcDistances","components","pickComponents","component","buildComponent","restore","SITE.clearInteriorFlag","BLUE.pickLocation","tryAgain","failsafe","goalSize","n","BLUE.computeInterior","wantCount","builtCount","STEP.calcDistanceBound","STEP.updateViewMap","STEP.markCandidates","fireEffect","SITE.siteDisruptedByXY","makeRandomItem","entity","makeKeyInfo","buildRandom","addItem","STEP.makePersonalSpace","levels","seeds","stairLocs","initSeeds","initStairLocs","stairDistance","stairOpts","goesUp","startTile","endTile","entrance","levelOpts","makeLevel","LEVEL.Level","equalsXY"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/site/tile.js","../js/feature/feature.js","../js/feature/tile.js","../js/feature/chance.js","../js/feature/spread.js","../js/site/horde.js","../js/site/item.js","../js/site/utils.js","../js/site/analyze.js","../js/site/site.js","../js/site/log/logger.js","../js/build/buildStep.js","../js/site/log/consoleLogger.js","../js/types.js","../js/room.js","../js/hall.js","../js/lake.js","../js/bridge.js","../js/stairs.js","../js/loop.js","../js/digger.js","../js/build/data.js","../js/build/blueprint.js","../js/build/builder.js","../js/dungeon.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nconst tiles = {};\nconst all = [];\nexport function installTile(id, opts = {}) {\n    const base = { id, index: all.length, priority: 0, tags: [] };\n    if (opts.extends) {\n        const root = getTile(opts.extends);\n        if (!root)\n            throw new Error('Cannot extend tile: ' + opts.extends);\n        Object.assign(base, root);\n    }\n    const info = GWU.object.assignOmitting('priority, extends', base, opts);\n    info.id = id;\n    info.index = all.length;\n    if (opts.tags) {\n        info.tags = GWU.tags.make(opts.tags);\n    }\n    if (typeof opts.priority === 'string') {\n        let text = opts.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            info.priority = info.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = getTile(text);\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                info.priority = tile.priority;\n            }\n            else {\n                info.priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = getTile(id);\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            info.priority = tile.priority + delta;\n        }\n    }\n    else if (opts.priority !== undefined) {\n        info.priority = opts.priority;\n    }\n    if (info.blocksPathing === undefined) {\n        if (info.blocksMove) {\n            info.blocksPathing = true;\n        }\n    }\n    if (tiles[id]) {\n        info.index = tiles[id];\n        all[info.index] = info;\n    }\n    else {\n        all.push(info);\n        tiles[id] = info.index;\n    }\n    return info;\n}\nexport function getTile(name) {\n    if (typeof name === 'string') {\n        name = tiles[name];\n    }\n    return all[name];\n}\nexport function tileId(name) {\n    var _a;\n    if (typeof name === 'number')\n        return name;\n    return (_a = tiles[name]) !== null && _a !== void 0 ? _a : -1;\n}\nexport function blocksMove(name) {\n    const info = getTile(name);\n    return info.blocksMove || false;\n}\ntiles['NOTHING'] = tiles['NULL'] = installTile('NONE', {\n    priority: 0,\n    ch: '',\n}).index;\ninstallTile('FLOOR', { priority: 10, ch: '.' });\ninstallTile('WALL', {\n    blocksMove: true,\n    blocksVision: true,\n    priority: 50,\n    ch: '#',\n});\ninstallTile('DOOR', {\n    blocksVision: true,\n    door: true,\n    priority: 60,\n    ch: '+',\n});\ninstallTile('SECRET_DOOR', {\n    blocksMove: true,\n    secretDoor: true,\n    priority: 70,\n    ch: '%',\n});\ninstallTile('UP_STAIRS', {\n    stairs: true,\n    priority: 80,\n    ch: '>',\n});\ninstallTile('DOWN_STAIRS', {\n    stairs: true,\n    priority: 80,\n    ch: '<',\n});\ntiles['DEEP'] = installTile('LAKE', {\n    priority: 40,\n    liquid: true,\n    ch: '~',\n}).index;\ninstallTile('SHALLOW', { priority: 30, ch: '`' });\ninstallTile('BRIDGE', { priority: 45, ch: '=' }); // layers help here\ninstallTile('IMPREGNABLE', { priority: 200, ch: '%', impregnable: true });\n","import * as GWU from 'gw-utils';\nexport const features = {};\nexport function install(name, fn) {\n    if (typeof fn !== 'function') {\n        fn = make(fn);\n    }\n    features[name] = fn;\n}\nexport const types = {};\nexport function installType(name, fn) {\n    types[name] = fn;\n}\n// FEATURE TYPE\nexport function feature(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureFeature.bind(undefined, id);\n}\nexport function featureFeature(id, site, x, y) {\n    const feat = features[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat(site, x, y);\n}\ninstallType('feature', feature);\ninstallType('effect', feature);\ninstallType('id', feature);\nexport function make(id, config) {\n    if (!id)\n        return GWU.FALSE;\n    if (typeof id === 'string') {\n        if (!id.length)\n            throw new Error('Cannot create effect from empty string.');\n        if (!config) {\n            const parts = id.split(':');\n            id = parts.shift().toLowerCase();\n            config = parts;\n        }\n        // string with no parameters is interpreted as id of registered feature\n        if (config.length === 0) {\n            config = id;\n            id = 'feature';\n        }\n        const handler = types[id];\n        if (!handler)\n            throw new Error('Failed to find effect - ' + id);\n        return handler(config || {});\n    }\n    let steps;\n    if (Array.isArray(id)) {\n        steps = id\n            .map((config) => make(config))\n            .filter((a) => a !== null);\n    }\n    else if (typeof id === 'function') {\n        return id;\n    }\n    else {\n        steps = Object.entries(id)\n            .map(([key, config]) => make(key, config))\n            .filter((a) => a !== null);\n    }\n    if (steps.length === 1) {\n        return steps[0];\n    }\n    return (site, x, y) => {\n        return steps.every((step) => step(site, x, y));\n    };\n}\nexport function makeArray(cfg) {\n    if (!cfg)\n        return [];\n    if (Array.isArray(cfg)) {\n        return cfg\n            .map((c) => make(c))\n            .filter((fn) => fn !== null);\n    }\n    if (typeof cfg === 'string') {\n        if (!cfg.length)\n            throw new Error('Cannot create effect from empty string.');\n        const parts = cfg.split(':');\n        cfg = parts.shift().toLowerCase();\n        const handler = types[cfg];\n        if (!handler)\n            return [];\n        return [handler(parts)];\n    }\n    else if (typeof cfg === 'function') {\n        return [cfg];\n    }\n    const steps = Object.entries(cfg).map(([key, config]) => make(key, config));\n    return steps.filter((s) => s !== null);\n}\n","import { installType } from './feature';\nexport function tile(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    // if (opts.id.includes('+')) {\n    //     opts.protected = true;\n    // }\n    opts.id = opts.id.replace(/[!~+]*/g, '');\n    return tileAction.bind(undefined, opts);\n}\nexport function tileAction(cfg, site, x, y) {\n    cfg.machine = 0; // >???<\n    if (site.setTile(x, y, cfg.id, cfg)) {\n        return true;\n    }\n    return false;\n}\ninstallType('tile', tile);\n","import { installType } from './feature';\n//////////////////////////////////////////////\n// chance\nexport function chance(opts) {\n    if (Array.isArray(opts)) {\n        opts = opts[0];\n    }\n    if (typeof opts === 'object') {\n        opts = opts.chance;\n    }\n    if (typeof opts === 'string') {\n        if (opts.endsWith('%')) {\n            opts = Number.parseFloat(opts) * 100;\n        }\n        else {\n            opts = Number.parseInt(opts || '10000');\n        }\n    }\n    if (typeof opts !== 'number') {\n        throw new Error('Chance effect config must be number or string that can be a number.');\n    }\n    return chanceAction.bind(undefined, opts);\n}\nexport function chanceAction(cfg, site) {\n    return site.rng.chance(cfg, 10000);\n}\ninstallType('chance', chance);\n","import * as GWU from 'gw-utils';\nimport { tileId } from '../site';\nimport { installType, makeArray } from './feature';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Flags;\n(function (Flags) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    // E_NEXT_ALWAYS = Fl(0), // Always fire the next effect, even if no tiles changed.\n    // E_NEXT_EVERYWHERE = Fl(1), // next effect spawns in every cell that this effect spawns in, instead of only the origin\n    // E_FIRED = Fl(2), // has already been fired once\n    // E_NO_MARK_FIRED = Fl(3), // Do not mark this cell as having fired an effect (so can log messages multiple times)\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    // E_PROTECTED = Fl(4),\n    // E_NO_REDRAW_CELL = Fl(),\n    Flags[Flags[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Flags[Flags[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Flags[Flags[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Flags[Flags[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Flags[Flags[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Flags[Flags[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Flags[Flags[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Flags[Flags[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Flags[Flags[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Flags[Flags[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Flags[Flags[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Flags[Flags[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Flags[Flags[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Flags[Flags[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Flags[Flags[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Flags[Flags[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Flags[Flags[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Flags[Flags[\"E_CLEAR_CELL\"] = Flags.E_CLEAR_GROUND |\n        Flags.E_CLEAR_SURFACE |\n        Flags.E_CLEAR_LIQUID |\n        Flags.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Flags[Flags[\"E_ONLY_IF_EMPTY\"] = Flags.E_BLOCKED_BY_ITEMS | Flags.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    // E_ACTIVATE_DORMANT_MONSTER = Fl(27), // Dormant monsters on this tile will appear -- e.g. when a statue bursts to reveal a monster.\n    // E_AGGRAVATES_MONSTERS = Fl(28), // Will act as though an aggravate monster scroll of effectRadius radius had been read at that point.\n    // E_RESURRECT_ALLY = Fl(29), // Will bring back to life your most recently deceased ally.\n})(Flags || (Flags = {}));\nexport function spread(...args) {\n    let config = {};\n    if (!args.length) {\n        throw new Error('Must have config to create spread.');\n    }\n    if (args.length === 1) {\n        if (typeof args[0] === 'string') {\n            args = args[0].split(':').map((t) => t.trim());\n        }\n        else if (Array.isArray(args[0])) {\n            args = args[0];\n        }\n        else {\n            Object.assign(config, args[0]);\n            args = [config];\n        }\n    }\n    if (args.length >= 3) {\n        Object.assign(config, args[3] || {});\n        config.grow = Number.parseInt(args[0]);\n        config.decrement = Number.parseInt(args[1]);\n        config.features = args[2];\n    }\n    else if (args.length === 2) {\n        throw new Error('Must have actions to run for spread.');\n    }\n    if (typeof config.grow !== 'number')\n        config.grow = Number.parseInt(config.grow || 0);\n    if (typeof config.decrement !== 'number')\n        config.decrement = Number.parseInt(config.decrement || 100);\n    config.flags = GWU.flag.from(Flags, config.flags || 0);\n    config.matchTile = config.matchTile || '';\n    if (typeof config.features === 'string' &&\n        // @ts-ignore\n        config.features.indexOf(':') < 0) {\n        if (tileId(config.features) >= 0) {\n            // @ts-ignore\n            config.features = 'TILE:' + config.features;\n        }\n    }\n    const action = makeArray(config.features);\n    if (!action)\n        throw new Error('Failed to make action for spread.');\n    config.features = action;\n    const fn = spreadFeature.bind(undefined, config);\n    fn.config = config;\n    return fn;\n}\ninstallType('spread', spread);\nexport function spreadFeature(cfg, site, x, y) {\n    const abortIfBlocking = !!(cfg.flags & Flags.E_ABORT_IF_BLOCKS_MAP);\n    const map = site;\n    let didSomething = false;\n    const spawnMap = GWU.grid.alloc(map.width, map.height);\n    if (!computeSpawnMap(cfg, spawnMap, site, x, y)) {\n        GWU.grid.free(spawnMap);\n        return false;\n    }\n    if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return false;\n    }\n    if (cfg.flags & Flags.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n    if (cfg.flags & Flags.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(map, spawnMap)) {\n            didSomething = true;\n        }\n    }\n    if (cfg.flags & Flags.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(map, spawnMap, cfg.flags)) {\n            didSomething = true;\n        }\n    }\n    spawnMap.update((v) => {\n        if (!v)\n            return 0;\n        return 1;\n    });\n    cfg.features.forEach((fn, i) => {\n        spawnMap.forEach((v, x, y) => {\n            if (v !== i + 1)\n                return;\n            if (fn(site, x, y)) {\n                didSomething = true;\n                spawnMap[x][y] += 1;\n            }\n        });\n    });\n    if (didSomething) {\n        didSomething = true;\n    }\n    GWU.grid.free(spawnMap);\n    return didSomething;\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (!map.blocksMove(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    if (map.isProtected(x, y))\n        return false;\n    if (map.blocksEffects(x, y) && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.E_BUILD_IN_WALLS) {\n        if (!map.isWall(x, y))\n            return false;\n    }\n    else if (effect.flags & Flags.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.isWall(i, j)) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.isWall(x, y))\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.isWall(i, j)) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !map.hasTile(x, y, effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, spawnMap, site, x, y) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = site;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, _flags = 0) {\n    let didSomething = false;\n    // const clearAll = (flags & Flags.E_CLEAR_CELL) === Flags.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        // if (clearAll) {\n        map.clearTile(i, j);\n        // } else {\n        //     if (flags & Flags.E_CLEAR_GAS) {\n        //         cell.clearDepth(Flags.Depth.GAS);\n        //     }\n        //     if (flags & Flags.E_CLEAR_LIQUID) {\n        //         cell.clearDepth(Flags.Depth.LIQUID);\n        //     }\n        //     if (flags & Flags.E_CLEAR_SURFACE) {\n        //         cell.clearDepth(Flags.Depth.SURFACE);\n        //     }\n        //     if (flags & Flags.E_CLEAR_GROUND) {\n        //         cell.clearDepth(Flags.Depth.GROUND);\n        //     }\n        // }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            return !map.forbidsActor(x, y, a);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            a.y = loc[0];\n            a.y = loc[1];\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            return !map.forbidsItem(x, y, i);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            i.x = loc[0];\n            i.y = loc[1];\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as FEATURE from '../feature';\nexport const hordes = [];\nexport function installHorde(config) {\n    const info = {};\n    info.id = config.id || config.leader;\n    info.leader = config.leader;\n    info.make = config.make || {};\n    info.members = {};\n    if (config.members) {\n        Object.entries(config.members).forEach(([key, value]) => {\n            let member = {};\n            if (typeof value === 'object' &&\n                ('count' in value || 'make' in value)) {\n                member.count = GWU.range.make(value.count || 1);\n                member.make = value.make || {};\n            }\n            else {\n                // @ts-ignore\n                member.count = GWU.range.make(value);\n            }\n            info.members[key] = member;\n        });\n    }\n    info.tags = [];\n    if (config.tags) {\n        if (typeof config.tags === 'string') {\n            config.tags = config.tags.split(/[:|,]/g).map((t) => t.trim());\n        }\n        info.tags = config.tags;\n    }\n    info.frequency = GWU.frequency.make(config.frequency);\n    info.flags = 0;\n    info.requiredTile = config.requiredTile || null;\n    info.feature = config.feature ? FEATURE.make(config.feature) : null;\n    info.blueprint = config.blueprint || null;\n    hordes.push(info);\n    return info;\n}\nexport function pickHorde(depth, rules, rng) {\n    rng = rng || GWU.random;\n    let tagMatch;\n    if (typeof rules === 'string') {\n        tagMatch = GWU.tags.makeMatch(rules);\n    }\n    else if ('id' in rules) {\n        return hordes.find((h) => h.id === rules.id) || null;\n    }\n    else {\n        tagMatch = GWU.tags.makeMatch(rules);\n    }\n    const choices = hordes.filter((horde) => tagMatch(horde.tags));\n    if (choices.length == 0)\n        return null;\n    const freq = choices.map((info) => info.frequency(depth));\n    const choice = rng.weighted(freq);\n    return choices[choice] || null;\n}\nexport function spawnHorde(info, map, x = -1, y = -1, opts = {}) {\n    // Leader info\n    opts.canSpawn = opts.canSpawn || GWU.TRUE;\n    opts.rng = opts.rng || map.rng;\n    opts.machine = opts.machine || 0;\n    const leader = _spawnLeader(info, map, x, y, opts);\n    if (!leader)\n        return null;\n    _spawnMembers(info, leader, map, opts);\n    return leader;\n}\nfunction _spawnLeader(info, map, x, y, opts) {\n    const leader = {\n        id: info.leader,\n        make: info.make,\n        x,\n        y,\n        machine: opts.machine || 0,\n    };\n    if (x >= 0 && y >= 0) {\n        if (!map.canSpawnActor(x, y, leader))\n            return null;\n    }\n    else {\n        [x, y] = _pickLeaderLoc(leader, map, opts) || [-1, -1];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n    }\n    // pre-placement stuff?  machine? effect?\n    if (!_addLeader(leader, map, x, y, opts)) {\n        return null;\n    }\n    return leader;\n}\nfunction _addLeader(leader, map, x, y, _opts) {\n    return map.addActor(x, y, leader);\n}\nfunction _addMember(member, map, x, y, leader, _opts) {\n    member.leader = leader;\n    return map.addActor(x, y, member);\n}\nfunction _spawnMembers(horde, leader, map, opts) {\n    const entries = Object.entries(horde.members);\n    if (entries.length == 0)\n        return 0;\n    let count = 0;\n    entries.forEach(([kindId, config]) => {\n        const count = config.count.value(opts.rng);\n        for (let i = 0; i < count; ++i) {\n            _spawnMember(kindId, config, map, leader, opts);\n        }\n    });\n    return count;\n}\nfunction _spawnMember(id, member, map, leader, opts) {\n    const instance = {\n        id,\n        make: member.make,\n        x: -1,\n        y: -1,\n        machine: leader.machine,\n    };\n    const [x, y] = _pickMemberLoc(instance, map, leader, opts) || [-1, -1];\n    if (x < 0 || y < 0) {\n        return null;\n    }\n    // pre-placement stuff?  machine? effect?\n    if (!_addMember(instance, map, x, y, leader, opts)) {\n        return null;\n    }\n    return instance;\n}\nfunction _pickLeaderLoc(leader, map, opts) {\n    let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (map.hasActor(x, y))\n            return false; // Brogue kills existing actors, but lets do this instead\n        if (!opts.canSpawn(x, y))\n            return false;\n        if (!map.canSpawnActor(x, y, leader))\n            return false;\n        // const cell = map.cell(x, y);\n        // if (leader.avoidsCell(cell)) return false;\n        // if (Map.isHallway(map, x, y)) {\n        //     return false;\n        // }\n        return true;\n    });\n    return loc;\n}\nfunction _pickMemberLoc(actor, map, leader, opts) {\n    let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (map.hasActor(x, y))\n            return false;\n        // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n        if (!map.canSpawnActor(x, y, actor))\n            return false;\n        if (!opts.canSpawn(x, y))\n            return false;\n        return true;\n    });\n    return loc;\n}\n","import * as GWU from 'gw-utils';\nexport const items = [];\nexport function installItem(config, cfg) {\n    const info = {};\n    if (typeof config === 'string') {\n        info.id = config;\n        if (!cfg)\n            throw new Error('Need a configuration.');\n        config = cfg;\n    }\n    else {\n        info.id = config.id;\n    }\n    info.make = config.make || {};\n    info.tags = [];\n    if (config.tags) {\n        if (typeof config.tags === 'string') {\n            config.tags = config.tags.split(/[:|,]/g).map((t) => t.trim());\n        }\n        info.tags = config.tags;\n    }\n    info.frequency = GWU.frequency.make(config.frequency || 100);\n    info.flags = 0;\n    info.requiredTile = config.requiredTile || null;\n    info.feature = config.feature || null;\n    info.blueprint = config.blueprint || null;\n    items.push(info);\n    return info;\n}\nexport function pickItem(depth, tagRules, rng) {\n    rng = rng || GWU.random;\n    if (typeof tagRules !== 'string' && 'id' in tagRules) {\n        // @ts-ignore\n        return items.find((i) => i.id === tagRules.id) || null;\n    }\n    tagRules = typeof tagRules === 'string' ? tagRules : tagRules.tags;\n    const tagMatch = GWU.tags.makeMatch(tagRules);\n    const choices = items.filter((item) => tagMatch(item.tags));\n    if (choices.length == 0)\n        return null;\n    const freq = choices.map((info) => info.frequency(depth));\n    const choice = rng.weighted(freq);\n    return choices[choice] || null;\n}\nexport function makeItem(info) {\n    return {\n        id: info.id,\n        make: info.make,\n        x: -1,\n        y: -1,\n    };\n}\nexport function getItemInfo(id) {\n    return items.find((i) => i.id === id);\n}\n","import * as GWU from 'gw-utils';\nconst DIRS = GWU.xy.DIRS;\nexport function loadSite(site, cells, tiles) {\n    const w = site.width;\n    const h = site.height;\n    cells.forEach((line, j) => {\n        if (j >= h)\n            return;\n        for (let i = 0; i < w && i < line.length; ++i) {\n            const ch = line[i];\n            const tile = tiles[ch] || 'FLOOR';\n            site.setTile(i, j, tile);\n        }\n    });\n}\n// export function attachRoom(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GWU.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GWU.utils.UP || dir === GWU.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GWU.grid.NumGrid,\n//     roomGrid: GWU.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GWU.xy.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GWU.xy.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GWU.xy.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GWU.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GWU.xy.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GWU.xy.DIRS[dir][0];\n                    newY = j + GWU.xy.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GWU.xy.DIRS[dir][0];\n                        newY += GWU.xy.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = site.rng.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GWU.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GWU.grid.NumGrid,\n//     xy: GWU.xy.Loc,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GWU.xy.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GWU.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GWU.grid.NumGrid,\n//     mapDoors: GWU.xy.Loc[],\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorIndexes = site.rng.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GWU.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GWU.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GWU.xy.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = site.rng.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GWU.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n//             //     return [x0, y0] as GWU.xy.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n}\nexport function siteDisruptedByXY(site, x, y, options = {}) {\n    var _a, _b, _c;\n    (_a = options.offsetX) !== null && _a !== void 0 ? _a : (options.offsetX = 0);\n    (_b = options.offsetY) !== null && _b !== void 0 ? _b : (options.offsetY = 0);\n    (_c = options.machine) !== null && _c !== void 0 ? _c : (options.machine = 0);\n    if (GWU.xy.arcCount(x, y, (i, j) => {\n        return site.isPassable(i, j);\n    }) <= 1)\n        return false;\n    const blockingGrid = GWU.grid.alloc(site.width, site.height);\n    blockingGrid[x][y] = 1;\n    const result = siteDisruptedBy(site, blockingGrid, options);\n    GWU.grid.free(blockingGrid);\n    return result;\n}\nexport function siteDisruptedBy(site, blockingGrid, options = {}) {\n    var _a, _b, _c;\n    (_a = options.offsetX) !== null && _a !== void 0 ? _a : (options.offsetX = 0);\n    (_b = options.offsetY) !== null && _b !== void 0 ? _b : (options.offsetY = 0);\n    (_c = options.machine) !== null && _c !== void 0 ? _c : (options.machine = 0);\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const blockingX = i + options.offsetX;\n        const blockingY = j + options.offsetY;\n        if (blockingGrid.get(blockingX, blockingY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (site.isPassable(i, j) &&\n            (site.getMachine(i, j) == 0 ||\n                site.getMachine(i, j) == options.machine)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (options.updateWalkable) {\n        if (!options.updateWalkable(walkableGrid)) {\n            return true;\n        }\n    }\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function siteDisruptedSize(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (disrupts)\n        return disrupts;\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                }\n                else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function computeDistanceMap(site, distanceMap, originX, originY, maxDistance) {\n    const costGrid = GWU.grid.alloc(site.width, site.height);\n    fillCostGrid(site, costGrid);\n    GWU.path.calculateDistances(distanceMap, originX, originY, costGrid, false, maxDistance + 1 // max distance is the same as max size of this blueprint\n    );\n    GWU.grid.free(costGrid);\n}\nexport function clearInteriorFlag(site, machine) {\n    for (let i = 0; i < site.width; i++) {\n        for (let j = 0; j < site.height; j++) {\n            if (site.getMachine(i, j) == machine && !site.needsMachine(i, j)) {\n                site.setMachine(i, j, 0);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            if ((map.blocksPathing(i, j) || map.blocksMove(i, j)) &&\n                !map.isSecretDoor(i, j)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.clearChokepoint(i, j);\n            if (passMap[i][j] && !map.isInLoop(i, j)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.setChokepoint(i, j);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.setChokeCount(i, j, 30000);\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                if (passMap[i][j] && map.isChokepoint(i, j)) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !map.isChokepoint(newX, newY)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.getChokeCount(i2, j2)) {\n                                            map.setChokeCount(i2, j2, cellCount);\n                                            map.clearGateSite(i2, j2);\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < map.getChokeCount(i, j)) {\n                                    map.setChokeCount(i, j, cellCount);\n                                    map.setGateSite(i, j);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.isAreaMachine(x, y)) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    resetLoopiness(map);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(map) {\n    GWU.xy.forRect(map.width, map.height, (x, y) => {\n        if ((map.blocksPathing(x, y) || map.blocksMove(x, y)) &&\n            !map.isSecretDoor(x, y)) {\n            map.clearInLoop(x, y);\n            // cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n            // passMap[i][j] = false;\n        }\n        else {\n            map.setInLoop(x, y);\n            // cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n            // passMap[i][j] = true;\n        }\n    });\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            // const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!map.isInLoop(x, y)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                // const cell = map.cell(newX, newY);\n                if (!map.isInLoop(newX, newY)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                // const newCell = map.cell(newX, newY);\n                if (map.isInLoop(newX, newY)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                map.clearInLoop(x, y);\n                // cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && map.isInLoop(newX, newY)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            // const cell = map.cell(x, y);\n            if (map.isInLoop(x, y)) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                // const up = map.cell(x, y - 1);\n                // const left = map.cell(x - 1, y);\n                if (map.isInLoop(x, y - 1) &&\n                    map.isInLoop(x - 1, y)\n                // up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                // left.flags.cell & Flags.Cell.IS_IN_LOOP\n                ) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            // const cell = map.cell(i, j);\n            if (map.isInLoop(i, j)) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !map.isInLoop(newX, newY)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.clearInLoop(i, j);\n                    // map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport * as Utils from './utils';\nimport * as TILE from './tile';\nimport * as ANALYZE from './analyze';\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"CHOKEPOINT\"] = GWU.flag.fl(0)] = \"CHOKEPOINT\";\n    Flags[Flags[\"GATE_SITE\"] = GWU.flag.fl(1)] = \"GATE_SITE\";\n    Flags[Flags[\"IN_LOOP\"] = GWU.flag.fl(2)] = \"IN_LOOP\";\n    Flags[Flags[\"IN_MACHINE\"] = GWU.flag.fl(3)] = \"IN_MACHINE\";\n    Flags[Flags[\"IN_AREA_MACHINE\"] = GWU.flag.fl(4)] = \"IN_AREA_MACHINE\";\n    Flags[Flags[\"IMPREGNABLE\"] = GWU.flag.fl(5)] = \"IMPREGNABLE\";\n})(Flags || (Flags = {}));\nexport class Site {\n    constructor(width, height, opts = {}) {\n        this.rng = GWU.rng.random;\n        this.items = [];\n        this.actors = [];\n        this.depth = 0;\n        this.machineCount = 0;\n        this._tiles = GWU.grid.alloc(width, height);\n        this._doors = GWU.grid.alloc(width, height);\n        this._flags = GWU.grid.alloc(width, height);\n        this._machine = GWU.grid.alloc(width, height);\n        this._chokeCounts = GWU.grid.alloc(width, height);\n        if (opts.rng) {\n            this.rng = opts.rng;\n        }\n    }\n    free() {\n        GWU.grid.free(this._tiles);\n        GWU.grid.free(this._doors);\n        GWU.grid.free(this._flags);\n        GWU.grid.free(this._machine);\n        GWU.grid.free(this._chokeCounts);\n    }\n    clear() {\n        this._tiles.fill(0);\n        this._doors.fill(0);\n        this._flags.fill(0);\n        this._machine.fill(0);\n        this._chokeCounts.fill(0);\n        // this.depth = 0;\n        this.machineCount = 0;\n    }\n    dump(fmt) {\n        if (fmt) {\n            return this._tiles.dump(fmt);\n        }\n        this._tiles.dump((c) => TILE.getTile(c).ch || '?');\n    }\n    // drawInto(buffer: GWU.canvas.Buffer): void {\n    //     buffer.blackOut();\n    //     this.tiles.forEach((t, x, y) => {\n    //         const tile = GWM.tile.get(t);\n    //         buffer.drawSprite(x, y, tile.sprite);\n    //     });\n    // }\n    copy(other) {\n        this.depth = other.depth;\n        this.machineCount = other.machineCount;\n        this._tiles.copy(other._tiles);\n        this._doors.copy(other._doors);\n        this._machine.copy(other._machine);\n        this._flags.copy(other._flags);\n        this._chokeCounts.copy(other._chokeCounts);\n        this.rng = other.rng;\n        this.items = other.items.slice();\n        this.actors = other.actors.slice();\n    }\n    copyTiles(other, offsetX = 0, offsetY = 0) {\n        GWU.xy.forRect(this.width, this.height, (x, y) => {\n            const otherX = x - offsetX;\n            const otherY = y - offsetY;\n            const v = other._tiles.get(otherX, otherY);\n            if (!v)\n                return;\n            this._tiles[x][y] = v;\n        });\n    }\n    setSeed(seed) {\n        this.rng.seed(seed);\n    }\n    get width() {\n        return this._tiles.width;\n    }\n    get height() {\n        return this._tiles.height;\n    }\n    hasXY(x, y) {\n        return this._tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this._tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        return this.hasTile(x, y, 'NOTHING');\n    }\n    isDiggable(x, y) {\n        return this.hasTile(x, y, 'NOTHING') || this.hasTile(x, y, 'WALL');\n    }\n    isProtected(_x, _y) {\n        return false;\n    }\n    isFloor(x, y) {\n        return this.hasTile(x, y, 'FLOOR');\n    }\n    isDoor(x, y) {\n        return this.hasTile(x, y, 'DOOR');\n    }\n    isSecretDoor(x, y) {\n        return this.hasTile(x, y, 'SECRET_DOOR');\n    }\n    isBridge(x, y) {\n        return this.hasTile(x, y, 'BRIDGE');\n    }\n    isWall(x, y) {\n        return this.hasTile(x, y, 'WALL') || this.hasTile(x, y, 'IMPREGNABLE');\n    }\n    blocksMove(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y) || this.isDeep(x, y);\n    }\n    blocksDiagonal(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksPathing(x, y) {\n        return (this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y));\n    }\n    blocksVision(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksItems(x, y) {\n        return this.blocksPathing(x, y) || this.blocksPathing(x, y);\n        // site.hasCellFlag(\n        //     x,\n        //     y,\n        //     GWM.flags.Cell.IS_CHOKEPOINT |\n        //         GWM.flags.Cell.IS_IN_LOOP |\n        //         GWM.flags.Cell.IS_IN_MACHINE\n        // );\n    }\n    blocksEffects(x, y) {\n        return this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        return (this.hasTile(x, y, 'UP_STAIRS') || this.hasTile(x, y, 'DOWN_STAIRS'));\n    }\n    isDeep(x, y) {\n        return this.hasTile(x, y, 'DEEP');\n    }\n    isShallow(x, y) {\n        return this.hasTile(x, y, 'SHALLOW');\n    }\n    isAnyLiquid(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this._tiles.get(x, y) || 0) > 0;\n    }\n    tileBlocksMove(tile) {\n        return TILE.getTile(tile).blocksMove || false;\n    }\n    setTile(x, y, tile, _opts = {}) {\n        // if (tile instanceof GWM.tile.Tile) {\n        //     tile = tile.index;\n        // }\n        // if (typeof tile === 'string') {\n        const id = TILE.tileId(tile);\n        // }\n        if (!this._tiles.hasXY(x, y))\n            return false;\n        this._tiles[x][y] = id;\n        return true;\n    }\n    clearTile(x, y) {\n        if (this.hasXY(x, y)) {\n            this._tiles[x][y] = 0;\n        }\n    }\n    makeImpregnable(x, y) {\n        this._flags[x][y] |= Flags.IMPREGNABLE;\n        // site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n    }\n    isImpregnable(x, y) {\n        return !!(this._flags[x][y] & Flags.IMPREGNABLE);\n    }\n    hasTile(x, y, tile) {\n        // if (tile instanceof GWM.tile.Tile) {\n        //     tile = tile.index;\n        // }\n        // if (typeof tile === 'string') {\n        const id = TILE.tileId(tile);\n        // }\n        return this._tiles.hasXY(x, y) && this._tiles[x][y] == id;\n    }\n    getChokeCount(x, y) {\n        return this._chokeCounts[x][y];\n    }\n    setChokeCount(x, y, count) {\n        this._chokeCounts[x][y] = count;\n    }\n    setChokepoint(x, y) {\n        this._flags[x][y] |= Flags.CHOKEPOINT;\n    }\n    isChokepoint(x, y) {\n        return !!(this._flags[x][y] & Flags.CHOKEPOINT);\n    }\n    clearChokepoint(x, y) {\n        this._flags[x][y] &= ~Flags.CHOKEPOINT;\n    }\n    setGateSite(x, y) {\n        this._flags[x][y] |= Flags.GATE_SITE;\n    }\n    isGateSite(x, y) {\n        return !!(this._flags[x][y] & Flags.GATE_SITE);\n    }\n    clearGateSite(x, y) {\n        this._flags[x][y] &= ~Flags.GATE_SITE;\n    }\n    setInLoop(x, y) {\n        this._flags[x][y] |= Flags.IN_LOOP;\n    }\n    isInLoop(x, y) {\n        return !!(this._flags[x][y] & Flags.IN_LOOP);\n    }\n    clearInLoop(x, y) {\n        this._flags[x][y] &= ~Flags.IN_LOOP;\n    }\n    analyze(updateChokeCounts = true) {\n        ANALYZE.analyze(this, updateChokeCounts);\n    }\n    snapshot() {\n        const other = new Site(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    restore(snapshot) {\n        this.copy(snapshot);\n    }\n    nextMachineId() {\n        this.machineCount += 1;\n        return this.machineCount;\n    }\n    setMachine(x, y, id, isRoom) {\n        this._machine[x][y] = id;\n        const flag = isRoom ? Flags.IN_MACHINE : Flags.IN_AREA_MACHINE;\n        this._flags[x][y] |= flag;\n    }\n    isAreaMachine(x, y) {\n        return !!(this._machine[x][y] & Flags.IN_AREA_MACHINE);\n    }\n    isInMachine(x, y) {\n        return this._machine[x][y] > 0;\n    }\n    getMachine(x, y) {\n        return this._machine[x][y];\n    }\n    needsMachine(_x, _y) {\n        // site.hasCellFlag(\n        //     i,\n        //     j,\n        //     GWM.flags.Cell.IS_WIRED | GWM.flags.Cell.IS_CIRCUIT_BREAKER\n        // );\n        return false;\n    }\n    updateDoorDirs() {\n        this._doors.update((_v, x, y) => {\n            return Utils.directionOfDoorSite(this, x, y);\n        });\n    }\n    getDoorDir(x, y) {\n        return this._doors[x][y];\n    }\n    // tileBlocksMove(tile: number): boolean {\n    //     return (\n    //         tile === WALL ||\n    //         tile === DEEP ||\n    //         tile === IMPREGNABLE ||\n    //         tile === DIG.NOTHING\n    //     );\n    // }\n    isOccupied(x, y) {\n        return this.hasActor(x, y) || this.hasItem(x, y);\n    }\n    canSpawnActor(x, y, _actor) {\n        // const cell = map.cell(x, y);\n        // if (actor.avoidsCell(cell)) return false;\n        // if (Map.isHallway(map, x, y)) {\n        //     return false;\n        // }\n        return this.isFloor(x, y);\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, a) {\n        a.x = x;\n        a.y = y;\n        this.actors.push(a);\n        return this.actors.length;\n    }\n    getActor(i) {\n        return this.actors[i];\n    }\n    // removeActor(a: HORDE.ActorInstance): void {\n    //     GWU.arrayDelete(this.actors, a);\n    // }\n    forbidsActor(x, y, _a) {\n        return !this.isFloor(x, y);\n    }\n    hasActor(x, y) {\n        return this.actors.some((a) => a.x === x && a.y === y);\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, i) {\n        i.x = x;\n        i.y = y;\n        this.items.push(i);\n        return this.items.length;\n    }\n    getItem(i) {\n        return this.items[i];\n    }\n    // removeItem(i: ITEM.ItemInstance): void {\n    //     GWU.arrayDelete(this.items, i);\n    // }\n    forbidsItem(x, y, _i) {\n        return !this.isFloor(x, y);\n    }\n    hasItem(x, y) {\n        return this.items.some((i) => i.x === x && i.y === y);\n    }\n}\n","export class NullLogger {\n    onDigFirstRoom() { }\n    onRoomCandidate() { }\n    onRoomFailed() { }\n    onRoomSuccess() { }\n    onLoopsAdded() { }\n    onLakesAdded() { }\n    onBridgesAdded() { }\n    onStairsAdded() { }\n    onBuildError() { }\n    onBlueprintPick() { }\n    onBlueprintCandidates() { }\n    onBlueprintStart() { }\n    onBlueprintInterior() { }\n    onBlueprintFail() { }\n    onBlueprintSuccess() { }\n    onStepStart() { }\n    onStepCandidates() { }\n    onStepInstanceSuccess() { }\n    onStepInstanceFail() { }\n    onStepSuccess() { }\n    onStepFail() { }\n}\n","import * as GWU from 'gw-utils';\nimport * as FEATURE from '../feature';\nconst Fl = GWU.flag.fl;\nexport var StepFlags;\n(function (StepFlags) {\n    StepFlags[StepFlags[\"BS_OUTSOURCE_ITEM_TO_MACHINE\"] = Fl(1)] = \"BS_OUTSOURCE_ITEM_TO_MACHINE\";\n    StepFlags[StepFlags[\"BS_BUILD_VESTIBULE\"] = Fl(2)] = \"BS_BUILD_VESTIBULE\";\n    StepFlags[StepFlags[\"BS_ADOPT_ITEM\"] = Fl(3)] = \"BS_ADOPT_ITEM\";\n    StepFlags[StepFlags[\"BS_BUILD_AT_ORIGIN\"] = Fl(4)] = \"BS_BUILD_AT_ORIGIN\";\n    StepFlags[StepFlags[\"BS_PERMIT_BLOCKING\"] = Fl(5)] = \"BS_PERMIT_BLOCKING\";\n    StepFlags[StepFlags[\"BS_TREAT_AS_BLOCKING\"] = Fl(6)] = \"BS_TREAT_AS_BLOCKING\";\n    StepFlags[StepFlags[\"BS_NEAR_ORIGIN\"] = Fl(7)] = \"BS_NEAR_ORIGIN\";\n    StepFlags[StepFlags[\"BS_FAR_FROM_ORIGIN\"] = Fl(8)] = \"BS_FAR_FROM_ORIGIN\";\n    StepFlags[StepFlags[\"BS_IN_VIEW_OF_ORIGIN\"] = Fl(9)] = \"BS_IN_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BS_IN_PASSABLE_VIEW_OF_ORIGIN\"] = Fl(10)] = \"BS_IN_PASSABLE_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BS_HORDE_TAKES_ITEM\"] = Fl(11)] = \"BS_HORDE_TAKES_ITEM\";\n    StepFlags[StepFlags[\"BS_HORDE_SLEEPING\"] = Fl(12)] = \"BS_HORDE_SLEEPING\";\n    StepFlags[StepFlags[\"BS_HORDE_FLEEING\"] = Fl(13)] = \"BS_HORDE_FLEEING\";\n    StepFlags[StepFlags[\"BS_HORDES_DORMANT\"] = Fl(14)] = \"BS_HORDES_DORMANT\";\n    StepFlags[StepFlags[\"BS_ITEM_IS_KEY\"] = Fl(15)] = \"BS_ITEM_IS_KEY\";\n    StepFlags[StepFlags[\"BS_ITEM_IDENTIFIED\"] = Fl(16)] = \"BS_ITEM_IDENTIFIED\";\n    StepFlags[StepFlags[\"BS_ITEM_PLAYER_AVOIDS\"] = Fl(17)] = \"BS_ITEM_PLAYER_AVOIDS\";\n    StepFlags[StepFlags[\"BS_EVERYWHERE\"] = Fl(18)] = \"BS_EVERYWHERE\";\n    StepFlags[StepFlags[\"BS_ALTERNATIVE\"] = Fl(19)] = \"BS_ALTERNATIVE\";\n    StepFlags[StepFlags[\"BS_ALTERNATIVE_2\"] = Fl(20)] = \"BS_ALTERNATIVE_2\";\n    StepFlags[StepFlags[\"BS_BUILD_IN_WALLS\"] = Fl(21)] = \"BS_BUILD_IN_WALLS\";\n    StepFlags[StepFlags[\"BS_BUILD_ANYWHERE_ON_LEVEL\"] = Fl(22)] = \"BS_BUILD_ANYWHERE_ON_LEVEL\";\n    StepFlags[StepFlags[\"BS_REPEAT_UNTIL_NO_PROGRESS\"] = Fl(23)] = \"BS_REPEAT_UNTIL_NO_PROGRESS\";\n    StepFlags[StepFlags[\"BS_IMPREGNABLE\"] = Fl(24)] = \"BS_IMPREGNABLE\";\n    StepFlags[StepFlags[\"BS_NO_BLOCK_ORIGIN\"] = Fl(25)] = \"BS_NO_BLOCK_ORIGIN\";\n    // TODO - BS_ALLOW_IN_HALLWAY instead?\n    StepFlags[StepFlags[\"BS_NOT_IN_HALLWAY\"] = Fl(27)] = \"BS_NOT_IN_HALLWAY\";\n    StepFlags[StepFlags[\"BS_ALLOW_BOUNDARY\"] = Fl(28)] = \"BS_ALLOW_BOUNDARY\";\n    StepFlags[StepFlags[\"BS_SKELETON_KEY\"] = Fl(29)] = \"BS_SKELETON_KEY\";\n    StepFlags[StepFlags[\"BS_KEY_DISPOSABLE\"] = Fl(30)] = \"BS_KEY_DISPOSABLE\";\n})(StepFlags || (StepFlags = {}));\nexport class BuildStep {\n    // next: null = null;\n    // id = 'n/a';\n    constructor(cfg = {}) {\n        this.tile = null;\n        this.flags = 0;\n        this.pad = 0;\n        this.item = null;\n        this.horde = null;\n        this.feature = null;\n        this.chance = 0;\n        this.index = -1;\n        this.tile = cfg.tile || null;\n        if (cfg.flags) {\n            this.flags = GWU.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GWU.range.make(cfg.count || 1);\n        if (typeof cfg.item === 'string') {\n            this.item = { tags: cfg.item };\n        }\n        else if (cfg.item) {\n            // @ts-ignore\n            this.item = Object.assign({ tags: '' }, cfg.item);\n            if (this.item.feature) {\n                this.item.feature = FEATURE.make(this.item.feature);\n            }\n        }\n        else {\n            this.item = null;\n        }\n        if (cfg.horde) {\n            if (cfg.horde === true) {\n                this.horde = { tags: '' };\n            }\n            else if (typeof cfg.horde === 'string') {\n                this.horde = { tags: cfg.horde };\n            }\n            else {\n                // @ts-ignore\n                this.horde = Object.assign({ tags: '' }, cfg.horde);\n                if (this.horde.feature) {\n                    this.horde.feature = FEATURE.make(this.horde.feature);\n                }\n            }\n        }\n        else {\n            this.horde = null;\n        }\n        if (cfg.feature) {\n            this.feature = FEATURE.make(cfg.feature);\n        }\n        else {\n            this.feature = null;\n        }\n        if (this.item && this.flags & StepFlags.BS_ADOPT_ITEM) {\n            throw new Error('Cannot have blueprint step with item and BS_ADOPT_ITEM.');\n        }\n        if (this.buildAtOrigin && this.count.hi > 1) {\n            throw new Error('Cannot have count > 1 for step with BS_BUILD_AT_ORIGIN.');\n        }\n        if (this.buildAtOrigin && this.repeatUntilNoProgress) {\n            throw new Error('Cannot have BS_BUILD_AT_ORIGIN and BS_REPEAT_UNTIL_NO_PROGRESS together in a build step.');\n        }\n        if (this.hordeTakesItem && !this.horde) {\n            throw new Error('Cannot have BS_HORDE_TAKES_ITEM without a horde configured.');\n        }\n    }\n    get allowBoundary() {\n        return !!(this.flags & StepFlags.BS_ALLOW_BOUNDARY);\n    }\n    get notInHallway() {\n        return !!(this.flags & StepFlags.BS_NOT_IN_HALLWAY);\n    }\n    get buildInWalls() {\n        return !!(this.flags & StepFlags.BS_BUILD_IN_WALLS);\n    }\n    get buildAnywhere() {\n        return !!(this.flags & StepFlags.BS_BUILD_ANYWHERE_ON_LEVEL);\n    }\n    get repeatUntilNoProgress() {\n        return !!(this.flags & StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS);\n    }\n    get permitBlocking() {\n        return !!(this.flags & StepFlags.BS_PERMIT_BLOCKING);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags &\n            (StepFlags.BS_TREAT_AS_BLOCKING | StepFlags.BS_NO_BLOCK_ORIGIN));\n    }\n    get noBlockOrigin() {\n        return !!(this.flags & StepFlags.BS_NO_BLOCK_ORIGIN);\n    }\n    get adoptItem() {\n        return !!(this.flags & StepFlags.BS_ADOPT_ITEM);\n    }\n    get itemIsKey() {\n        return !!(this.flags & StepFlags.BS_ITEM_IS_KEY);\n    }\n    get keyIsDisposable() {\n        return !!(this.flags & StepFlags.BS_KEY_DISPOSABLE);\n    }\n    get outsourceItem() {\n        return !!(this.flags & StepFlags.BS_OUTSOURCE_ITEM_TO_MACHINE);\n    }\n    get impregnable() {\n        return !!(this.flags & StepFlags.BS_IMPREGNABLE);\n    }\n    get buildVestibule() {\n        return !!(this.flags & StepFlags.BS_BUILD_VESTIBULE);\n    }\n    get hordeTakesItem() {\n        return !!(this.flags & StepFlags.BS_HORDE_TAKES_ITEM);\n    }\n    get generateEverywhere() {\n        return !!(this.flags &\n            StepFlags.BS_EVERYWHERE &\n            ~StepFlags.BS_BUILD_AT_ORIGIN);\n    }\n    get buildAtOrigin() {\n        return !!(this.flags & StepFlags.BS_BUILD_AT_ORIGIN);\n    }\n    get buildsInstances() {\n        return !!(this.feature ||\n            this.tile ||\n            this.item ||\n            this.horde ||\n            this.adoptItem);\n    }\n    // makeItem(data: BuildData): ITEM.ItemInfo | null {\n    //     if (!this.item) return null;\n    //     return ITEM.pick(data.depth, this.item);\n    // }\n    // cellIsCandidate(\n    //     builder: BuildData,\n    //     blueprint: Blueprint,\n    //     x: number,\n    //     y: number,\n    //     distanceBound: [number, number]\n    // ) {\n    //     return cellIsCandidate(builder, blueprint, this, x, y, distanceBound);\n    // }\n    // distanceBound(builder: BuildData): [number, number] {\n    //     return calcDistanceBound(builder, this);\n    // }\n    // updateViewMap(builder: BuildData): void {\n    //     updateViewMap(builder, this);\n    // }\n    // build(\n    //     builder: BuildData,\n    //     blueprint: Blueprint,\n    //     adoptedItem: GWM.item.Item | null\n    // ): boolean {\n    //     return buildStep(builder, blueprint, this, adoptedItem);\n    // }\n    markCandidates(data, candidates, distanceBound = [0, 10000]) {\n        updateViewMap(data, this);\n        const blueprint = data.blueprint;\n        let count = 0;\n        candidates.update((_v, i, j) => {\n            const candidateType = cellIsCandidate(data, blueprint, this, i, j, distanceBound);\n            if (candidateType === CandidateType.OK) {\n                count++;\n            }\n            return candidateType;\n        });\n        return count;\n    }\n    makePersonalSpace(_data, x, y, candidates) {\n        let count = 0;\n        if (this.pad < 1)\n            return 0; // do not mark occupied\n        // or...\n        // if (this.buildEverywhere) return 0;  // do not mark occupied\n        for (let i = x - this.pad; i <= x + this.pad; i++) {\n            for (let j = y - this.pad; j <= y + this.pad; j++) {\n                if (candidates.hasXY(i, j)) {\n                    if (candidates[i][j] == 1) {\n                        candidates[i][j] = 0;\n                        ++count;\n                    }\n                    // builder.occupied[i][j] = 1;\n                }\n            }\n        }\n        return count;\n    }\n    toString() {\n        let parts = [];\n        if (this.tile) {\n            parts.push('tile: ' + this.tile);\n        }\n        if (this.feature) {\n            parts.push('effect: ' + JSON.stringify(this.feature));\n        }\n        if (this.item) {\n            parts.push('item: ' + JSON.stringify(this.item));\n        }\n        if (this.horde) {\n            parts.push('horde: ' + JSON.stringify(this.horde));\n        }\n        if (this.pad > 1) {\n            parts.push('pad: ' + this.pad);\n        }\n        if (this.count.lo > 1 || this.count.hi > 1) {\n            parts.push('count: ' + this.count.toString());\n        }\n        if (this.chance) {\n            parts.push('chance: ' + this.chance);\n        }\n        if (this.flags) {\n            parts.push('flags: ' + GWU.flag.toString(StepFlags, this.flags));\n        }\n        return '{ ' + parts.join(', ') + ' }';\n    }\n}\nexport function updateViewMap(builder, buildStep) {\n    if (buildStep.flags &\n        (StepFlags.BS_IN_VIEW_OF_ORIGIN |\n            StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN)) {\n        const site = builder.site;\n        if (buildStep.flags & StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN) {\n            const fov = new GWU.fov.FOV({\n                isBlocked: (x, y) => {\n                    return site.blocksPathing(x, y) || site.blocksVision(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap[x][y] = 1;\n            });\n        }\n        else {\n            const fov = new GWU.fov.FOV({\n                isBlocked: (x, y) => {\n                    return site.blocksVision(x, y);\n                },\n                hasXY: (x, y) => {\n                    return site.hasXY(x, y);\n                },\n            });\n            fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                builder.viewMap[x][y] = 1;\n            });\n        }\n        builder.viewMap[builder.originX][builder.originY] = 1;\n    }\n}\nexport function calcDistanceBound(builder, buildStep) {\n    const distanceBound = [0, 10000];\n    if (buildStep.flags & StepFlags.BS_NEAR_ORIGIN) {\n        distanceBound[1] = builder.distance25;\n    }\n    if (buildStep.flags & StepFlags.BS_FAR_FROM_ORIGIN) {\n        distanceBound[0] = builder.distance75;\n    }\n    return distanceBound;\n}\nexport var CandidateType;\n(function (CandidateType) {\n    CandidateType[CandidateType[\"NOT_CANDIDATE\"] = 0] = \"NOT_CANDIDATE\";\n    CandidateType[CandidateType[\"OK\"] = 1] = \"OK\";\n    CandidateType[CandidateType[\"IN_HALLWAY\"] = 2] = \"IN_HALLWAY\";\n    CandidateType[CandidateType[\"ON_BOUNDARY\"] = 3] = \"ON_BOUNDARY\";\n    CandidateType[CandidateType[\"MUST_BE_ORIGIN\"] = 4] = \"MUST_BE_ORIGIN\";\n    CandidateType[CandidateType[\"NOT_ORIGIN\"] = 5] = \"NOT_ORIGIN\";\n    CandidateType[CandidateType[\"OCCUPIED\"] = 6] = \"OCCUPIED\";\n    CandidateType[CandidateType[\"NOT_IN_VIEW\"] = 7] = \"NOT_IN_VIEW\";\n    CandidateType[CandidateType[\"TOO_FAR\"] = 8] = \"TOO_FAR\";\n    CandidateType[CandidateType[\"TOO_CLOSE\"] = 9] = \"TOO_CLOSE\";\n    CandidateType[CandidateType[\"INVALID_WALL\"] = 10] = \"INVALID_WALL\";\n    CandidateType[CandidateType[\"BLOCKED\"] = 11] = \"BLOCKED\";\n    CandidateType[CandidateType[\"FAILED\"] = 12] = \"FAILED\";\n})(CandidateType || (CandidateType = {}));\nexport function cellIsCandidate(builder, blueprint, buildStep, x, y, distanceBound) {\n    const site = builder.site;\n    // No building in the hallway if it's prohibited.\n    // This check comes before the origin check, so an area machine will fail altogether\n    // if its origin is in a hallway and the feature that must be built there does not permit as much.\n    if (buildStep.notInHallway &&\n        GWU.xy.arcCount(x, y, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n        return CandidateType.IN_HALLWAY;\n    }\n    // if (buildStep.noBlockOrigin) {\n    //     let ok = true;\n    //     GWU.xy.eachNeighbor(\n    //         x,\n    //         y,\n    //         (nx, ny) => {\n    //             if (nx === builder.originX && ny === builder.originY) {\n    //                 ok = false;\n    //             }\n    //         },\n    //         true\n    //     );\n    //     if (!ok) return false;\n    // }\n    // No building along the perimeter of the level if it's prohibited.\n    if ((x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1) &&\n        !buildStep.allowBoundary) {\n        return CandidateType.ON_BOUNDARY;\n    }\n    // The origin is a candidate if the feature is flagged to be built at the origin.\n    // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n    if (buildStep.buildAtOrigin) {\n        if (x == builder.originX && y == builder.originY)\n            return CandidateType.OK;\n        return CandidateType.MUST_BE_ORIGIN;\n    }\n    else if (blueprint.isRoom &&\n        x == builder.originX &&\n        y == builder.originY) {\n        return CandidateType.NOT_ORIGIN;\n    }\n    // No building in another feature's personal space!\n    if (builder.occupied[x][y]) {\n        return CandidateType.OCCUPIED;\n    }\n    // Must be in the viewmap if the appropriate flag is set.\n    if (buildStep.flags &\n        (StepFlags.BS_IN_VIEW_OF_ORIGIN |\n            StepFlags.BS_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n        !builder.viewMap[x][y]) {\n        return CandidateType.NOT_IN_VIEW;\n    }\n    // Do a distance check if the feature requests it.\n    let distance = 10000;\n    if (site.isWall(x, y)) {\n        // Distance is calculated for walls too.\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (!builder.distanceMap.hasXY(i, j))\n                return;\n            if (!site.blocksPathing(i, j) &&\n                distance > builder.distanceMap[i][j] + 1) {\n                distance = builder.distanceMap[i][j] + 1;\n            }\n        }, true);\n    }\n    else {\n        distance = builder.distanceMap[x][y];\n    }\n    if (distance > distanceBound[1])\n        return CandidateType.TOO_FAR; // distance exceeds max\n    if (distance < distanceBound[0])\n        return CandidateType.TOO_CLOSE;\n    if (buildStep.buildInWalls) {\n        // If we're supposed to build in a wall...\n        const cellMachine = site.getMachine(x, y);\n        if (!builder.interior[x][y] &&\n            (!cellMachine || cellMachine == builder.machineNumber) &&\n            site.isWall(x, y)) {\n            let ok = false;\n            let failed = false;\n            // ...and this location is a wall that's not already machined...\n            GWU.xy.eachNeighbor(x, y, (newX, newY) => {\n                if (failed)\n                    return;\n                if (!site.hasXY(newX, newY))\n                    return;\n                if (!builder.interior[newX][newY] &&\n                    !buildStep.buildAnywhere) {\n                    return;\n                }\n                // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                const neighborMachine = site.getMachine(newX, newY);\n                if (!site.blocksPathing(newX, newY) &&\n                    (!neighborMachine ||\n                        neighborMachine == builder.machineNumber) &&\n                    !(newX == builder.originX && newY == builder.originY)) {\n                    if (buildStep.notInHallway &&\n                        GWU.xy.arcCount(newX, newY, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n                        // return CandidateType.IN_HALLWAY;\n                        failed = true;\n                        ok = false;\n                    }\n                    else {\n                        ok = true;\n                    }\n                }\n            }, true);\n            return ok ? CandidateType.OK : CandidateType.INVALID_WALL;\n        }\n        return CandidateType.NOT_CANDIDATE;\n    }\n    else if (site.isWall(x, y)) {\n        // Can't build in a wall unless instructed to do so.\n        return CandidateType.INVALID_WALL;\n    }\n    else if (buildStep.buildAnywhere) {\n        if (buildStep.item && site.blocksItems(x, y)) {\n            return CandidateType.BLOCKED;\n        }\n        else {\n            return CandidateType.OK;\n        }\n    }\n    else if (builder.interior[x][y]) {\n        return CandidateType.OK;\n    }\n    return CandidateType.FAILED;\n}\n// export function buildStep(\n//     builder: BuildData,\n//     blueprint: Blueprint,\n//     buildStep: BuildStep,\n//     adoptedItem: GWM.item.Item | null\n// ): boolean {\n//     let wantCount = 0;\n//     let builtCount = 0;\n//     const site = builder.site;\n//     const candidates = GWU.grid.alloc(site.width, site.height);\n//     // Figure out the distance bounds.\n//     const distanceBound = calcDistanceBound(builder, buildStep);\n//     buildStep.updateViewMap(builder);\n//     // If the StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n//     // Make a master map of candidate locations for this feature.\n//     let qualifyingTileCount = markCandidates(\n//         candidates,\n//         builder,\n//         blueprint,\n//         buildStep,\n//         distanceBound\n//     );\n//     if (!buildStep.generateEverywhere) {\n//         wantCount = buildStep.count.value();\n//     }\n//     if (!qualifyingTileCount || qualifyingTileCount < buildStep.count.lo) {\n//         console.log(\n//             ' - Only %s qualifying tiles - want at least %s.',\n//             qualifyingTileCount,\n//             buildStep.count.lo\n//         );\n//         GWU.grid.free(candidates);\n//         return false;\n//     }\n//     let x = 0,\n//         y = 0;\n//     let success = true;\n//     let didSomething = false;\n//     do {\n//         success = true;\n//         // Find a location for the feature.\n//         if (buildStep.buildAtOrigin) {\n//             // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n//             x = builder.originX;\n//             y = builder.originY;\n//         } else {\n//             // Pick our candidate location randomly, and also strike it from\n//             // the candidates map so that subsequent instances of this same feature can't choose it.\n//             [x, y] = site.rng.matchingLoc(\n//                 candidates.width,\n//                 candidates.height,\n//                 (x, y) => candidates[x][y] > 0\n//             );\n//         }\n//         // Don't waste time trying the same place again whether or not this attempt succeeds.\n//         candidates[x][y] = 0;\n//         qualifyingTileCount--;\n//         // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n//         if (buildStep.effect) {\n//             success = site.fireEffect(buildStep.effect, x, y);\n//             didSomething = success;\n//         }\n//         // Now try to place the terrain tile, if any.\n//         if (success && buildStep.tile !== -1) {\n//             const tile = GWM.tile.get(buildStep.tile);\n//             if (\n//                 !(buildStep.flags & StepFlags.BS_PERMIT_BLOCKING) &&\n//                 (tile.blocksMove() ||\n//                     buildStep.flags & StepFlags.BS_TREAT_AS_BLOCKING)\n//             ) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y, {\n//                     machine: site.machineCount,\n//                 });\n//             }\n//             if (success) {\n//                 success = site.setTile(x, y, tile);\n//                 didSomething = didSomething || success;\n//             }\n//         }\n//         // Generate an actor, if necessary\n//         // Generate an item, if necessary\n//         if (success && buildStep.item) {\n//             const item = site.makeRandomItem(buildStep.item);\n//             if (!item) {\n//                 success = false;\n//             }\n//             if (buildStep.flags & StepFlags.BS_ITEM_IS_KEY) {\n//                 item.key = GWM.entity.makeKeyInfo(\n//                     x,\n//                     y,\n//                     !!(buildStep.flags & StepFlags.BS_KEY_DISPOSABLE)\n//                 );\n//             }\n//             if (buildStep.flags & StepFlags.BS_OUTSOURCE_ITEM_TO_MACHINE) {\n//                 success = builder.buildRandom(\n//                     Flags.BP_ADOPT_ITEM,\n//                     -1,\n//                     -1,\n//                     item\n//                 );\n//                 if (success) {\n//                     didSomething = true;\n//                 }\n//             } else {\n//                 success = site.addItem(x, y, item);\n//                 didSomething = didSomething || success;\n//             }\n//         } else if (success && buildStep.flags & StepFlags.BS_ADOPT_ITEM) {\n//             // adopt item if necessary\n//             if (!adoptedItem) {\n//                 GWU.grid.free(candidates);\n//                 throw new Error(\n//                     'Failed to build blueprint because there is no adopted item.'\n//                 );\n//             }\n//             if (buildStep.flags & StepFlags.BS_TREAT_AS_BLOCKING) {\n//                 // Yes, check for blocking.\n//                 success = !SITE.siteDisruptedByXY(site, x, y);\n//             }\n//             if (success) {\n//                 success = site.addItem(x, y, adoptedItem);\n//                 if (success) {\n//                     didSomething = true;\n//                 } else {\n//                     console.log('- failed to add item', x, y);\n//                 }\n//             } else {\n//                 // console.log('- blocks map', x, y);\n//             }\n//         }\n//         if (success && didSomething) {\n//             // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n//             qualifyingTileCount -= makePersonalSpace(\n//                 builder,\n//                 x,\n//                 y,\n//                 candidates,\n//                 buildStep.pad\n//             );\n//             builtCount++; // we've placed an instance\n//             // Mark the feature location as part of the machine, in case it is not already inside of it.\n//             if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n//                 site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n//             }\n//             // Mark the feature location as impregnable if requested.\n//             if (buildStep.flags & StepFlags.BS_IMPREGNABLE) {\n//                 site.setCellFlag(x, y, GWM.flags.Cell.IMPREGNABLE);\n//             }\n//         }\n//         // Finished with this instance!\n//     } while (\n//         qualifyingTileCount > 0 &&\n//         (buildStep.generateEverywhere ||\n//             builtCount < wantCount ||\n//             buildStep.flags & StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS)\n//     );\n//     if (success && buildStep.flags & StepFlags.BS_BUILD_VESTIBULE) {\n//         // Generate a door guard machine.\n//         // Try to create a sub-machine that qualifies.\n//         success = builder.buildRandom(\n//             Flags.BP_VESTIBULE,\n//             builder.originX,\n//             builder.originY\n//         );\n//         if (!success) {\n//             // console.log(\n//             //     `Depth ${builder.depth}: Failed to place blueprint ${blueprint.id} because it requires a vestibule and we couldn't place one.`\n//             // );\n//             // failure! abort!\n//             GWU.grid.free(candidates);\n//             return false;\n//         }\n//         ++builtCount;\n//     }\n//     //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n//     //DEBUG logBuffer(candidates);\n//     success = builtCount > 0;\n//     GWU.grid.free(candidates);\n//     return success;\n// }\n","import * as GWU from 'gw-utils';\nimport { StepFlags } from '../../build/buildStep';\nexport class ConsoleLogger {\n    onDigFirstRoom(site) {\n        console.group('dig first room');\n        site.dump();\n        console.groupEnd();\n    }\n    onRoomCandidate(room, roomSite) {\n        console.group('room candidate: ' + room.toString());\n        roomSite.dump();\n        console.groupEnd();\n    }\n    onRoomFailed(_site, _room, _roomSite, error) {\n        console.log('Room Failed - ', error);\n    }\n    onRoomSuccess(site, room) {\n        console.group('Added Room - ' + room.toString());\n        site.dump();\n        console.groupEnd();\n    }\n    onLoopsAdded(_site) {\n        console.log('loops added');\n    }\n    onLakesAdded(_site) {\n        console.log('lakes added');\n    }\n    onBridgesAdded(_site) {\n        console.log('bridges added');\n    }\n    onStairsAdded(_site) {\n        console.log('stairs added');\n    }\n    //\n    onBuildError(error) {\n        console.log(`onBuildError - error: ${error}`);\n    }\n    onBlueprintPick(data, flags, depth) {\n        console.log(`onBlueprintPick - ${data.blueprint.id}, depth = ${depth}, matchingFlags = ${GWU.flag.toString(StepFlags, flags)}`);\n    }\n    onBlueprintCandidates(data) {\n        const label = `onBlueprintCandidates - ${data.blueprint.id}`;\n        console.group(label);\n        data.candidates.dump();\n        console.groupEnd();\n    }\n    onBlueprintStart(data) {\n        console.group(`onBlueprintStart - ${data.blueprint.id} @ ${data.originX},${data.originY} : stepCount: ${data.blueprint.steps.length}, size: [${data.blueprint.size.toString()}], flags: ${GWU.flag.toString(StepFlags, data.blueprint.flags)}`);\n    }\n    onBlueprintInterior(data) {\n        console.group(`onBlueprintInterior - ${data.blueprint.id}`);\n        data.interior.dump();\n        console.groupEnd();\n    }\n    onBlueprintFail(data, error) {\n        console.log(`onBlueprintFail - ${data.blueprint.id} @ ${data.originX},${data.originY} : error: ${error}`);\n        console.groupEnd();\n    }\n    onBlueprintSuccess(data) {\n        console.log(`onBlueprintSuccess - ${data.blueprint.id} @ ${data.originX},${data.originY}`);\n        console.groupEnd();\n    }\n    onStepStart(data, step) {\n        console.group(`onStepStart - ${data.blueprint.id}[${data.blueprint.steps.indexOf(step) + 1}/${data.blueprint.steps.length}] @ ${data.originX},${data.originY} : count: [${step.count.toString()}], flags: ${GWU.flag.toString(StepFlags, step.flags)}`);\n        console.log(step.toString());\n    }\n    onStepCandidates(data, step, candidates, wantCount) {\n        const haveCount = candidates.count((v) => v == 1);\n        console.log(`onStepCandidates - ${data.blueprint.id}[${data.blueprint.steps.indexOf(step) + 1}/${data.blueprint.steps.length}] @ ${data.originX},${data.originY} : wantCount: ${wantCount}, have: ${haveCount}`);\n        candidates.dump();\n        if (haveCount == 0) {\n            console.log('No candidates - check interior');\n            data.interior.dump();\n        }\n    }\n    onStepInstanceSuccess(_data, _step, x, y) {\n        console.log(`onStepInstance @ ${x},${y}`);\n    }\n    onStepInstanceFail(_data, _step, x, y, error) {\n        console.log(`onStepInstanceFail @ ${x},${y} - error: ${error}`);\n    }\n    onStepSuccess(data, step) {\n        console.log(`onStepSuccess - ${data.blueprint.id}[${data.blueprint.steps.indexOf(step) + 1}/${data.blueprint.steps.length}] @ ${data.originX},${data.originY} : count: [${step.count.toString()}], flags: ${GWU.flag.toString(StepFlags, step.flags)}`);\n        console.groupEnd();\n    }\n    onStepFail(data, step, error) {\n        console.log(`onStepFail - ${data.blueprint.id}[${data.blueprint.steps.indexOf(step) + 1}/${data.blueprint.steps.length}] @ ${data.originX},${data.originY} : error : ${error}`);\n        console.groupEnd();\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Hall extends GWU.xy.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport function makeHall(loc, dirIndex, hallLength, hallWidth = 1) {\n    const dir = GWU.xy.DIRS[dirIndex];\n    const x = Math.min(loc[0], loc[0] + dir[0] * (hallLength - 1));\n    const y = Math.min(loc[1], loc[1] + dir[1] * (hallLength - 1));\n    const width = Math.abs(dir[0] * hallLength) || hallWidth;\n    const height = Math.abs(dir[1] * hallLength) || hallWidth;\n    return new Hall(x, y, width, height);\n}\nexport class Room extends GWU.xy.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GWU.xy.Loc[] | null;\n//     door: number;\n// }\n","import * as GWU from 'gw-utils';\nimport * as TYPES from './types';\nimport * as SITE from './site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GWU.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = SITE.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = (rng) => rng.item(choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = (rng) => rng.weighted(choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom(site.rng);\n        const room = rooms[id];\n        if (!room) {\n            GWU.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const blobGrid = GWU.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GWU.blob.Blob({\n            rng: site.rng,\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GWU.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GWU.xy.DOWN] = [Math.floor(site.width / 2), site.height - 2];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * site.rng.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * site.rng.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX + site.rng.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            site.rng.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GWU.xy.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GWU.xy.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        let minorWidth = Math.max(3, Math.floor((width * site.rng.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * site.rng.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GWU.xy.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GWU.xy.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value(site.rng);\n        const ringMinWidth = this.options.ringMinWidth.value(site.rng);\n        const holeMinSize = this.options.holeMinSize.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GWU.xy.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            site.rng.chance(this.options.holeChance.value(site.rng))) {\n            GWU.xy.forCircle(x, y, site.rng.range(holeMinSize, radius - holeMinSize), (x, y) => site.clearTile(x, y));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value(site.rng);\n        const width = this.options.width.value(site.rng);\n        const height = this.options.height.value(site.rng);\n        const tile = this.options.tile || 'FLOOR';\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GWU.xy.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = site.rng.range(minX, maxX);\n            y = site.rng.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GWU.xy.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as TYPES from './types';\nconst DIRS = GWU.xy.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(width, rng) {\n    return GWU.clamp(_pickWidth(width, rng), 1, 3);\n}\nfunction _pickWidth(width, rng) {\n    if (!width)\n        return 1;\n    if (typeof width === 'number')\n        return width;\n    rng = rng !== null && rng !== void 0 ? rng : GWU.rng.random;\n    if (Array.isArray(width)) {\n        width = rng.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GWU.range.make(width).value(rng);\n    }\n    else if (width instanceof GWU.range.Range) {\n        width = width.value(rng);\n    }\n    else {\n        const weights = width;\n        width = Number.parseInt(rng.weighted(weights));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths, rng) {\n    if (dir == GWU.xy.UP || dir == GWU.xy.DOWN) {\n        return lengths[1].value(rng);\n    }\n    else {\n        return lengths[0].value(rng);\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GWU.xy.NO_DIRECTION;\n    if (dir == GWU.xy.NO_DIRECTION) {\n        const dirs = site.rng.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GWU.xy.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = site.rng.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: 1,\n            length: [GWU.range.make('2-15'), GWU.range.make('2-9')],\n            tile: 'FLOOR',\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = options.width;\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GWU.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || SITE.chooseRandomDoorSites(site);\n        if (!site.rng.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GWU.xy.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = pickWidth(this.config.width, site.rng);\n        const length = pickLength(dir, this.config.length, site.rng);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = TYPES.makeHall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GWU.xy.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = TYPES.makeHall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        // hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GWU from 'gw-utils';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: 'SHALLOW',\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: 'DEEP',\n        };\n        GWU.object.assignObject(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = site.rng.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || 'SHALLOW';\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || 'DEEP';\n        const lakeGrid = GWU.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GWU.blob.Blob({\n                rng: site.rng,\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                // birthParameters: 'ffffftttt',\n                // survivalParameters: 'ffffttttt',\n            });\n            lakeGrid.fill(0);\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // console.log('LAKE ATTEMPT');\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = site.rng.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = site.rng.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    // if (site.hasTile(sx, sy, wreathTile)) {\n                                    //     site.clearTile(sx, sy, wreathTile);\n                                    // }\n                                    GWU.xy.forCircle(sx, sy, wreathSize, (i2, j2) => {\n                                        if (site.isPassable(i2, j2) &&\n                                            !lakeGrid[i2 - x][j2 - y]\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i2, j2, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n                attempts = 0;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GWU.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        GWU.object.assignObject(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GWU.path.OBSTRUCTION);\n        const seq = site.rng.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                (site.isBridge(x, y) || !site.isAnyLiquid(x, y))) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyLiquid(newX, newY) &&\n                        !site.isBridge(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (site.isBridge(newX, newY) ||\n                                !site.isAnyLiquid(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GWU.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, 'BRIDGE'); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, 'FLOOR'); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, _bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyLiquid(x, y))\n            return false;\n        // if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0])) return false;\n        // if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0])) return false;\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: 'UP_STAIRS',\n            downTile: 'DOWN_STAIRS',\n            wall: 'IMPREGNABLE',\n        };\n        GWU.object.assignObject(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc = null;\n        let downLoc = null;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = site.rng.matchingLoc(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = site.rng.matchingLocNear(GWU.xy.x(start), GWU.xy.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = site.rng.matchingLocNear(GWU.xy.x(up), GWU.xy.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = site.rng.matchingLocNear(GWU.xy.x(down), GWU.xy.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = site.rng.matchingLocNear(GWU.xy.x(up), GWU.xy.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = site.rng.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = site.rng.matchingLocNear(GWU.xy.x(down), GWU.xy.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = site.rng.matchingLoc(site.width, site.height, (x, y) => {\n                    if (GWU.xy.distanceBetween(x, y, downLoc[0], downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = site.rng.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = site.rng.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GWU.xy.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = site.rng.matchingLoc(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile, this.options.wall);\n            if (this.options.start === 'up') {\n                locations.start = locations.up;\n            }\n            else {\n                locations.end = locations.up;\n            }\n        }\n        if (downLoc) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile, this.options.wall);\n            if (this.options.start === 'down') {\n                locations.start = locations.down;\n            }\n            else {\n                locations.end = locations.down;\n            }\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GWU.xy.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile, wallTile) {\n        const indexes = site.rng.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GWU.xy.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GWU.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GWU.xy.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        for (let i = 0; i < GWU.xy.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GWU.xy.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wallTile);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n            doorChance: 50,\n        };\n        GWU.object.assignObject(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GWU.grid.alloc(site.width, site.height);\n        const costGrid = GWU.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        SITE.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        const seq = site.rng.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GWU.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, 'FLOOR');\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            const tile = site.rng.chance(this.options.doorChance)\n                                ? 'DOOR'\n                                : 'FLOOR';\n                            site.setTile(x, y, tile); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GWU.grid.free(pathGrid);\n        GWU.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GWU from 'gw-utils';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nimport * as LOGGER from './site/log/logger';\nimport { ConsoleLogger } from './site/log/consoleLogger';\nexport class Digger {\n    constructor(options = {}) {\n        var _a, _b;\n        this.seed = 0;\n        this.rooms = { fails: 20 };\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        // startLoc: GWU.xy.Loc = [-1, -1];\n        // endLoc: GWU.xy.Loc = [-1, -1];\n        this.locations = {};\n        this._locs = {};\n        this.goesUp = false;\n        this.seed = options.seed || 0;\n        if (typeof options.rooms === 'number') {\n            options.rooms = { count: options.rooms };\n        }\n        GWU.object.setOptions(this.rooms, options.rooms);\n        this.goesUp = options.goesUp || false;\n        if (options.startLoc) {\n            this._locs.start = options.startLoc;\n        }\n        if (options.endLoc) {\n            this._locs.end = options.endLoc;\n        }\n        // Doors\n        if (options.doors === false) {\n            options.doors = { chance: 0 };\n        }\n        else if (options.doors === true) {\n            options.doors = { chance: 100 };\n        }\n        GWU.object.setOptions(this.doors, options.doors);\n        // Halls\n        if (options.halls === false) {\n            options.halls = { chance: 0 };\n        }\n        else if (options.halls === true) {\n            options.halls = {};\n        }\n        GWU.object.setOptions(this.halls, options.halls);\n        // Loops\n        if (options.loops === false) {\n            this.loops = null;\n        }\n        else {\n            if (options.loops === true)\n                options.loops = {};\n            else if (typeof options.loops === 'number') {\n                options.loops = { maxLength: options.loops };\n            }\n            options.loops = options.loops || {};\n            options.loops.doorChance =\n                (_a = options.loops.doorChance) !== null && _a !== void 0 ? _a : (_b = options.doors) === null || _b === void 0 ? void 0 : _b.chance;\n            // @ts-ignore\n            GWU.object.setOptions(this.loops, options.loops);\n        }\n        // Lakes\n        if (options.lakes === false) {\n            this.lakes = null;\n        }\n        else {\n            if (options.lakes === true)\n                options.lakes = {};\n            else if (typeof options.lakes === 'number') {\n                options.lakes = { count: options.lakes };\n            }\n            options.lakes = options.lakes || {};\n            // @ts-ignore\n            GWU.object.setOptions(this.lakes, options.lakes);\n        }\n        // Bridges\n        if (options.bridges === false) {\n            this.bridges = null;\n        }\n        else {\n            if (typeof options.bridges === 'number') {\n                options.bridges = { maxLength: options.bridges };\n            }\n            if (options.bridges === true)\n                options.bridges = {};\n            // @ts-ignore\n            GWU.object.setOptions(this.bridges, options.bridges);\n        }\n        // Stairs\n        if (options.stairs === false) {\n            this.stairs = null;\n        }\n        else {\n            if (typeof options.stairs !== 'object')\n                options.stairs = {};\n            // @ts-ignore\n            GWU.object.setOptions(this.stairs, options.stairs);\n            this.stairs.start = this.goesUp ? 'down' : 'up';\n        }\n        // this.startLoc = options.startLoc || [-1, -1];\n        // this.endLoc = options.endLoc || [-1, -1];\n        if (options.log === true) {\n            this.log = new ConsoleLogger();\n        }\n        else if (options.log) {\n            this.log = options.log;\n        }\n        else {\n            this.log = new LOGGER.NullLogger();\n        }\n    }\n    _makeRoomSite(width, height) {\n        const site = new SITE.Site(width, height);\n        site.rng = this.site.rng;\n        return site;\n    }\n    _createSite(width, height) {\n        this.site = new SITE.Site(width, height);\n    }\n    create(...args) {\n        let needsFree = true;\n        if (args.length == 1) {\n            const dest = args[0];\n            if (dest instanceof SITE.Site) {\n                this.site = dest;\n                needsFree = false;\n            }\n            else {\n                this._createSite(dest.width, dest.height);\n            }\n        }\n        else {\n            this._createSite(args[0], args[1]);\n        }\n        const result = this._create(this.site);\n        const cb = args[2] || null;\n        if (cb) {\n            GWU.xy.forRect(this.site.width, this.site.height, (x, y) => {\n                const t = this.site._tiles[x][y];\n                if (t)\n                    cb(x, y, t);\n            });\n        }\n        else if (args.length == 1 && needsFree) {\n            const dest = args[0];\n            dest.copy(this.site._tiles);\n        }\n        needsFree && this.site.free();\n        return result;\n    }\n    _create(site) {\n        this.start(site);\n        this.addRooms(site);\n        if (this.loops) {\n            this.addLoops(site, this.loops);\n            this.log.onLoopsAdded(site);\n        }\n        if (this.lakes) {\n            this.addLakes(site, this.lakes);\n            this.log.onLakesAdded(site);\n        }\n        if (this.bridges) {\n            this.addBridges(site, this.bridges);\n            this.log.onBridgesAdded(site);\n        }\n        if (this.stairs) {\n            this.addStairs(site, this.stairs);\n            this.log.onStairsAdded(site);\n        }\n        this.finish(site);\n        return true;\n    }\n    start(site) {\n        this.site = site;\n        const seed = this.seed || GWU.rng.random.number();\n        site.setSeed(seed);\n        site.clear();\n        this.seq = site.rng.sequence(site.width * site.height);\n        this.locations = Object.assign({}, this._locs);\n        if (!this.locations.start || this.locations.start[0] < 0) {\n            const stair = this.goesUp ? 'down' : 'up';\n            if (this.stairs && Array.isArray(this.stairs[stair])) {\n                this.locations.start = this.stairs[stair];\n            }\n            else {\n                this.locations.start = [\n                    Math.floor(site.width / 2),\n                    site.height - 2,\n                ];\n                if (this.stairs && this.stairs[stair]) {\n                    this.stairs[stair] = this.locations.start;\n                }\n            }\n        }\n        if (!this.locations.end || this.locations.end[0] < 0) {\n            const stair = this.goesUp ? 'up' : 'down';\n            if (this.stairs && Array.isArray(this.stairs[stair])) {\n                this.locations.end = this.stairs[stair];\n            }\n        }\n        // if (this.startLoc[0] < 0 && this.startLoc[0] < 0) {\n        //     this.startLoc[0] = Math.floor(site.width / 2);\n        //     this.startLoc[1] = site.height - 2;\n        // }\n    }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addRooms(site) {\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        site.updateDoorDirs();\n        this.log.onDigFirstRoom(site);\n        // site.dump();\n        // console.log('- rng.number', site.rng.number());\n        let fails = 0;\n        let count = 1;\n        const maxFails = this.rooms.fails || 20;\n        while (fails < maxFails) {\n            if (this.addRoom(site)) {\n                fails = 0;\n                site.updateDoorDirs();\n                site.rng.shuffle(this.seq);\n                // site.dump();\n                // console.log('- rng.number', site.rng.number());\n                if (this.rooms.count && ++count >= this.rooms.count) {\n                    break; // we are done\n                }\n            }\n            else {\n                ++fails;\n            }\n        }\n    }\n    addFirstRoom(site) {\n        const roomSite = this._makeRoomSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.locations.start)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this._makeRoomSite(site.width, site.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (room && this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        // console.log('potential room');\n        // roomSite.dump();\n        if (room) {\n            this.log.onRoomCandidate(room, roomSite);\n            if (this._attachRoom(site, roomSite, room)) {\n                this.log.onRoomSuccess(site, room);\n            }\n            else {\n                this.log.onRoomFailed(site, room, roomSite, 'Did not fit.');\n                room = null;\n            }\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        let i = 0;\n        const len = this.seq.length;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (i = 0; i < len; i++) {\n            const x = Math.floor(this.seq[i] / site.height);\n            const y = this.seq[i] % site.height;\n            const dir = site.getDoorDir(x, y);\n            if (dir != GWU.xy.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, room, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    site.copyTiles(roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = site.rng.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, room, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                site.copyTiles(roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GWU.xy.Loc;\n                //     return [x0, y0] as GWU.xy.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, room, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        const hall = room.hall || room;\n        const left = Math.min(room.left, hall.left);\n        const top = Math.min(room.top, hall.top);\n        const right = Math.max(room.right, hall.right);\n        const bottom = Math.max(room.bottom, hall.bottom);\n        for (xRoom = left; xRoom <= right; xRoom++) {\n            for (yRoom = top; yRoom <= bottom; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    if (!map.hasXY(xSite, ySite) ||\n                        map.isBoundaryXY(xSite, ySite)) {\n                        return false;\n                    }\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(site, room, x, y, dir) {\n        const opts = this.doors;\n        let isDoor = false;\n        if (opts.chance && site.rng.chance(opts.chance)) {\n            isDoor = true;\n        }\n        const tile = isDoor ? opts.tile || 'DOOR' : 'FLOOR';\n        site.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || room.hall.width == 1 || room.hall.height == 1) {\n            return;\n        }\n        if (dir === GWU.xy.UP || dir === GWU.xy.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (site.isNothing(x - k, y)) {\n                    if (site.isSet(x - k, y - 1) && site.isSet(x - k, y + 1)) {\n                        site.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (site.isNothing(x + k, y)) {\n                    if (site.isSet(x + k, y - 1) && site.isSet(x + k, y + 1)) {\n                        site.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (site.isNothing(x, y - k)) {\n                    if (site.isSet(x - 1, y - k) && site.isSet(x + 1, y - k)) {\n                        site.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (site.isNothing(x, y + k)) {\n                    if (site.isSet(x - 1, y + k) && site.isSet(x + 1, y + k)) {\n                        site.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        const locs = digger.create(site);\n        if (locs)\n            Object.assign(this.locations, locs);\n        return !!locs;\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < site.width - 1; i++) {\n                for (j = 0; j < site.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (!site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)) {\n                            if (site.rng.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, 'FLOOR'); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                // if (\n                //     // TODO - isPassable\n                //     (site.isPassable(x + 1, y) || site.isPassable(x - 1, y)) &&\n                //     (site.isPassable(x, y + 1) || site.isPassable(x, y - 1))\n                // ) {\n                //     // If there's passable terrain to the left or right, and there's passable terrain\n                //     // above or below, then the door is orphaned and must be removed.\n                //     site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                // } else\n                if ((site.isWall(x + 1, y) ? 1 : 0) +\n                    (site.isWall(x - 1, y) ? 1 : 0) +\n                    (site.isWall(x, y + 1) ? 1 : 0) +\n                    (site.isWall(x, y - 1) ? 1 : 0) !=\n                    2) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, 'FLOOR', { superpriority: true }); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? 'IMPREGNABLE' : 'WALL';\n        GWU.xy.forRect(site.width, site.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, 'WALL');\n                }\n            }\n        });\n    }\n}\n// export function digMap(map: GWM.map.Map, options: Partial<DiggerOptions> = {}) {\n//     const digger = new Digger(options);\n//     return digger.create(map);\n// }\n","import * as GWU from 'gw-utils';\nimport * as SITE from '../site';\nexport class BuildData {\n    // depth = 0;\n    // seed = 0;\n    constructor(site, blueprint, machine = 0) {\n        this.originX = -1;\n        this.originY = -1;\n        this.distance25 = -1;\n        this.distance75 = -1;\n        this.site = site;\n        this.blueprint = blueprint;\n        this.interior = GWU.grid.alloc(site.width, site.height);\n        this.occupied = GWU.grid.alloc(site.width, site.height);\n        this.viewMap = GWU.grid.alloc(site.width, site.height);\n        this.distanceMap = GWU.grid.alloc(site.width, site.height);\n        this.candidates = GWU.grid.alloc(site.width, site.height);\n        this.machineNumber = machine;\n    }\n    free() {\n        GWU.grid.free(this.interior);\n        GWU.grid.free(this.occupied);\n        GWU.grid.free(this.viewMap);\n        GWU.grid.free(this.distanceMap);\n        GWU.grid.free(this.candidates);\n    }\n    get rng() {\n        return this.site.rng;\n    }\n    reset(originX, originY) {\n        this.interior.fill(0);\n        this.occupied.fill(0);\n        this.viewMap.fill(0);\n        this.distanceMap.fill(0);\n        // this.candidates.fill(0);\n        this.originX = originX;\n        this.originY = originY;\n        this.distance25 = 0;\n        this.distance75 = 0;\n        // if (this.seed) {\n        //     this.site.setSeed(this.seed);\n        // }\n    }\n    calcDistances(maxSize) {\n        this.distanceMap.fill(0);\n        SITE.computeDistanceMap(this.site, this.distanceMap, this.originX, this.originY, maxSize);\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n        this.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const dist = this.distanceMap[x][y];\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            }\n            else {\n                distance25 -= distances[i];\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            }\n            else {\n                distance75 -= distances[i];\n            }\n        }\n        this.distance25 = distance25;\n        this.distance75 = distance75;\n    }\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport * as STEP from './buildStep';\nconst Fl = GWU.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(0)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(2)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(3)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(4)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(5)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(6)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(7)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(8)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(9)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(10)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(11)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(12)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(13)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(14)] = \"BP_NO_INTERIOR_FLAG\";\n    Flags[Flags[\"BP_NOT_IN_HALLWAY\"] = Fl(15)] = \"BP_NOT_IN_HALLWAY\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.flags = 0;\n        this.steps = [];\n        this.id = 'n/a';\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GWU.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            this.size = GWU.range.make(opts.size);\n            if (this.size.lo <= 0)\n                this.size.lo = 1;\n            if (this.size.hi < this.size.lo)\n                this.size.hi = this.size.lo;\n        }\n        else {\n            this.size = GWU.range.make([1, 1]); // Anything bigger makes weird things happen\n        }\n        if (opts.flags) {\n            this.flags = GWU.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n            this.steps.forEach((s, i) => (s.index = i));\n        }\n        if (opts.id) {\n            this.id = opts.id;\n        }\n        if (this.flags & Flags.BP_ADOPT_ITEM) {\n            if (!this.steps.some((step) => {\n                if (step.adoptItem)\n                    return true;\n                if (step.hordeTakesItem && !step.item)\n                    return true;\n                return false;\n            })) {\n                throw new Error('Blueprint calls for BP_ADOPT_ITEM, but has no adoptive step.');\n            }\n        }\n    }\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n    get notInHallway() {\n        return !!(this.flags & Flags.BP_NOT_IN_HALLWAY);\n    }\n    qualifies(requiredFlags, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return false;\n        }\n        if (\n        // Must have the required flags:\n        ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags) {\n            return false;\n        }\n        return true;\n    }\n    pickComponents(rng) {\n        const alternativeFlags = [\n            STEP.StepFlags.BS_ALTERNATIVE,\n            STEP.StepFlags.BS_ALTERNATIVE_2,\n        ];\n        const keepFeature = new Array(this.steps.length).fill(true);\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = rng.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n    fillInterior(builder) {\n        const interior = builder.interior;\n        const site = builder.site;\n        interior.fill(0);\n        // Find a location and map out the machine interior.\n        if (this.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n            // Now map out the interior into interior[][].\n            // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n            // same or lower choke value, ignoring any tiles that are already part of a machine.\n            // If we get false from this, try again. If we've tried too many times already, abort.\n            return addTileToInteriorAndIterate(builder, builder.originX, builder.originY);\n        }\n        else if (this.isVestiblue) {\n            return computeVestibuleInterior(builder, this);\n            // success\n        }\n        else {\n            // Find a location and map out the interior for a non-room machine.\n            // The strategy here is simply to pick a random location on the map,\n            // expand it along a pathing map by one space in all directions until the size reaches\n            // the chosen size, and then make sure the resulting space qualifies.\n            // If not, try again. If we've tried too many times already, abort.\n            let distanceMap = builder.distanceMap;\n            SITE.computeDistanceMap(site, distanceMap, builder.originX, builder.originY, this.size.hi);\n            const seq = site.rng.sequence(site.width * site.height);\n            let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n            let goalSize = this.size.value(); // Keeps track of the goal size.\n            for (let k = 0; k < 1000 && qualifyingTileCount < goalSize; k++) {\n                for (let n = 0; n < seq.length && qualifyingTileCount < goalSize; n++) {\n                    const i = Math.floor(seq[n] / site.height);\n                    const j = seq[n] % site.height;\n                    if (distanceMap[i][j] == k) {\n                        interior[i][j] = 1;\n                        qualifyingTileCount++;\n                        const machine = site.getMachine(i, j);\n                        if (site.isOccupied(i, j) ||\n                            (machine > 0 && machine !== builder.machineNumber) // in different machine\n                        ) {\n                            // Abort if we've entered another machine or engulfed another machine's item or monster.\n                            return 0;\n                        }\n                    }\n                }\n            }\n            // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n            // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n            return qualifyingTileCount;\n        }\n    }\n}\nexport function markCandidates(buildData) {\n    const site = buildData.site;\n    const candidates = buildData.candidates;\n    const blueprint = buildData.blueprint;\n    candidates.fill(0);\n    // Find a location and map out the machine interior.\n    if (blueprint.isRoom) {\n        // If it's a room machine, count up the gates of appropriate\n        // choke size and remember where they are. The origin of the room will be the gate location.\n        candidates.update((_v, x, y) => {\n            return site.isGateSite(x, y) &&\n                blueprint.size.contains(site.getChokeCount(x, y))\n                ? 1\n                : 0;\n        });\n    }\n    else if (blueprint.isVestiblue) {\n        //  Door machines must have locations passed in. We can't pick one ourselves.\n        throw new Error('ERROR: Attempted to build a vestiblue without a location being provided.');\n    }\n    else {\n        candidates.update((_v, x, y) => {\n            if (!site.isPassable(x, y))\n                return 0;\n            if (blueprint.notInHallway) {\n                const count = GWU.xy.arcCount(x, y, (i, j) => site.isPassable(i, j));\n                return count <= 1 ? 1 : 0;\n            }\n            return 1;\n        });\n    }\n    return candidates.count((v) => v == 1);\n}\nexport function pickCandidateLoc(buildData) {\n    const site = buildData.site;\n    const candidates = buildData.candidates;\n    const randSite = site.rng.matchingLoc(site.width, site.height, (x, y) => candidates[x][y] == 1);\n    if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n        // If no suitable sites, abort.\n        return null;\n    }\n    return randSite;\n}\n// // Assume site has been analyzed (aka GateSites and ChokeCounts set)\n// export function computeInterior(\n//     builder: BuildData,\n//     blueprint: Blueprint\n// ): boolean {\n//     let failsafe = blueprint.isRoom ? 10 : 20;\n//     let tryAgain;\n//     const interior = builder.interior;\n//     const site = builder.site;\n//     do {\n//         tryAgain = false;\n//         if (--failsafe <= 0) {\n//             // console.log(\n//             //     `Failed to build blueprint ${blueprint.id}; failed repeatedly to find a suitable blueprint location.`\n//             // );\n//             return false;\n//         }\n//         let count = fillInterior(builder, blueprint);\n//         // Now make sure the interior map satisfies the machine's qualifications.\n//         if (!count) {\n//             console.debug('- no interior');\n//             tryAgain = true;\n//         } else if (!blueprint.size.contains(count)) {\n//             console.debug('- too small');\n//             tryAgain = true;\n//         } else if (\n//             blueprint.treatAsBlocking &&\n//             SITE.siteDisruptedBy(site, interior, { machine: site.machineCount })\n//         ) {\n//             console.debug('- blocks');\n//             tryAgain = true;\n//         } else if (\n//             blueprint.requireBlocking &&\n//             SITE.siteDisruptedSize(site, interior) < 100\n//         ) {\n//             console.debug('- does not block');\n//             tryAgain = true;\n//         }\n//         // Now loop if necessary.\n//     } while (tryAgain);\n//     // console.log(tryAgain, failsafe);\n//     return true;\n// }\nexport function computeVestibuleInterior(builder, blueprint) {\n    let success = true;\n    const site = builder.site;\n    const interior = builder.interior;\n    interior.fill(0);\n    if (blueprint.size.hi == 1) {\n        interior[builder.originX][builder.originY] = 1;\n        return 1;\n    }\n    // If this is a wall - it is really an error (maybe manually trying a build location?)\n    const doorChokeCount = site.getChokeCount(builder.originX, builder.originY);\n    if (doorChokeCount > 10000) {\n        return 0;\n    }\n    const vestibuleLoc = [-1, -1];\n    let vestibuleChokeCount = doorChokeCount;\n    GWU.xy.eachNeighbor(builder.originX, builder.originY, (x, y) => {\n        const count = site.getChokeCount(x, y);\n        if (count == doorChokeCount)\n            return;\n        if (count > 10000)\n            return;\n        if (count < 0)\n            return;\n        vestibuleLoc[0] = x;\n        vestibuleLoc[1] = y;\n        vestibuleChokeCount = count;\n    }, true);\n    const roomSize = vestibuleChokeCount - doorChokeCount;\n    if (blueprint.size.contains(roomSize)) {\n        // The room entirely fits within the vestibule desired size\n        const count = interior.floodFill(vestibuleLoc[0], vestibuleLoc[1], (_v, i, j) => {\n            if (site.isOccupied(i, j)) {\n                success = false;\n            }\n            return site.getChokeCount(i, j) === vestibuleChokeCount;\n        }, 1);\n        if (success && blueprint.size.contains(count))\n            return roomSize;\n    }\n    let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n    const wantSize = blueprint.size.value(site.rng); // Keeps track of the goal size.\n    const distMap = builder.distanceMap;\n    SITE.computeDistanceMap(site, distMap, builder.originX, builder.originY, blueprint.size.hi);\n    const cells = site.rng.sequence(site.width * site.height);\n    success = true;\n    for (let k = 0; k < 1000 && qualifyingTileCount < wantSize; k++) {\n        for (let i = 0; i < cells.length && qualifyingTileCount < wantSize; ++i) {\n            const x = Math.floor(cells[i] / site.height);\n            const y = cells[i] % site.height;\n            const dist = distMap[x][y];\n            if (dist != k)\n                continue;\n            if (site.isOccupied(x, y)) {\n                success = false;\n                qualifyingTileCount = wantSize;\n            }\n            if (site.getChokeCount(x, y) <= doorChokeCount)\n                continue;\n            interior[x][y] = 1;\n            qualifyingTileCount += 1;\n        }\n    }\n    return qualifyingTileCount;\n}\n// Assumes (startX, startY) is in the machine.\n// Returns true if everything went well, and false if we ran into a machine component\n// that was already there, as we don't want to build a machine around it.\nfunction addTileToInteriorAndIterate(builder, startX, startY) {\n    let goodSoFar = true;\n    const interior = builder.interior;\n    const site = builder.site;\n    let count = 1;\n    interior[startX][startY] = 1;\n    const startChokeCount = site.getChokeCount(startX, startY);\n    for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n        const newX = startX + GWU.xy.DIRS[dir][0];\n        const newY = startY + GWU.xy.DIRS[dir][1];\n        if (!site.hasXY(newX, newY))\n            continue;\n        if (interior[newX][newY])\n            continue; // already done\n        if (site.isOccupied(newX, newY) ||\n            (site.getMachine(newX, newY) && !site.isGateSite(newX, newY))) {\n            // Abort if there's an item in the room.\n            // Items haven't been populated yet, so the only way this could happen is if another machine\n            // previously placed an item here.\n            // Also abort if we're touching another machine at any point other than a gate tile.\n            return 0;\n        }\n        if (site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n            !site.getMachine(newX, newY)) {\n            let additional = addTileToInteriorAndIterate(builder, newX, newY);\n            if (additional <= 0)\n                return 0;\n            count += additional;\n        }\n    }\n    return count;\n}\nexport function maximizeInterior(data, minimumInteriorNeighbors = 1) {\n    const interior = data.interior;\n    const site = data.site;\n    let interiorNeighborCount = 0;\n    // let openNeighborCount = 0;\n    let madeChange = true;\n    let interiorCount = 0;\n    let maxInteriorCount = data.blueprint.size.hi;\n    let gen = 0;\n    while (madeChange && interiorCount < maxInteriorCount) {\n        madeChange = false;\n        interiorCount = 0;\n        ++gen;\n        interior.forEach((i, x, y) => {\n            if (!i)\n                return;\n            ++interiorCount;\n            if (i != gen)\n                return;\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j) || interior[i][j])\n                    return;\n                if (interior.isBoundaryXY(i, j))\n                    return;\n                interiorNeighborCount = 0;\n                let ok = true;\n                GWU.xy.eachNeighbor(i, j, (x2, y2) => {\n                    if (interior[x2][y2]) {\n                        ++interiorNeighborCount;\n                    }\n                    else if (!site.isWall(x2, y2)) {\n                        ok = false; // non-interior and not wall\n                    }\n                    else if (site.getMachine(x2, y2)) {\n                        ok = false; // in another machine\n                    }\n                }, false // 8 dirs\n                );\n                if (!ok || interiorNeighborCount < minimumInteriorNeighbors)\n                    return;\n                interior[i][j] = gen + 1;\n                ++interiorCount;\n                if (site.blocksPathing(i, j)) {\n                    site.setTile(i, j, 'FLOOR');\n                }\n                madeChange = true;\n            }, true // 4 dirs\n            );\n        });\n    }\n    interior.update((v) => (v > 0 ? 1 : 0));\n}\nexport function prepareInterior(builder) {\n    const interior = builder.interior;\n    const site = builder.site;\n    const blueprint = builder.blueprint;\n    // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n    if (blueprint.maximizeInterior) {\n        maximizeInterior(builder, 1);\n    }\n    else if (blueprint.openInterior) {\n        maximizeInterior(builder, 4);\n    }\n    // If requested, cleanse the interior -- no interesting terrain allowed.\n    if (blueprint.purgeInterior) {\n        interior.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x, y, 'FLOOR');\n        });\n    }\n    else {\n        if (blueprint.purgeBlockers) {\n            // If requested, purge pathing blockers -- no traps allowed.\n            interior.forEach((v, x, y) => {\n                if (!v)\n                    return;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, 'FLOOR');\n                }\n            });\n        }\n        // If requested, purge the liquid layer in the interior -- no liquids allowed.\n        if (blueprint.purgeLiquids) {\n            interior.forEach((v, x, y) => {\n                if (v && site.isAnyLiquid(x, y)) {\n                    site.setTile(x, y, 'FLOOR');\n                }\n            });\n        }\n    }\n    // Surround with walls if requested.\n    if (blueprint.surroundWithWalls) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.isGateSite(x, y))\n                return;\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return; // Not valid x,y\n                if (interior[i][j])\n                    return; // is part of machine\n                if (site.isWall(i, j))\n                    return; // is already a wall (of some sort)\n                if (site.isGateSite(i, j))\n                    return; // is a door site\n                if (site.getMachine(i, j))\n                    return; // is part of a machine\n                if (site.blocksPathing(i, j))\n                    return; // is a blocker for the player (water?)\n                site.setTile(i, j, 'WALL');\n            }, false // all 8 directions\n            );\n        });\n    }\n    // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n    // Then zero out any portion of the interior that is still wall.\n    // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n    //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n    // }\n    // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n    if (blueprint.makeImpregnable) {\n        interior.forEach((v, x, y) => {\n            if (!v || site.isGateSite(x, y))\n                return;\n            site.makeImpregnable(x, y);\n            GWU.xy.eachNeighbor(x, y, (i, j) => {\n                if (!interior.hasXY(i, j))\n                    return;\n                if (interior[i][j])\n                    return;\n                if (site.isGateSite(i, j))\n                    return;\n                site.makeImpregnable(i, j);\n            }, false);\n        });\n    }\n    // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n    const machineNumber = builder.machineNumber;\n    interior.forEach((v, x, y) => {\n        if (!v)\n            return;\n        if (!blueprint.noInteriorFlag) {\n            site.setMachine(x, y, machineNumber, blueprint.isRoom);\n        }\n        // secret doors mess up machines\n        // TODO - is this still true?\n        if (site.isSecretDoor(x, y)) {\n            site.setTile(x, y, 'DOOR');\n        }\n    });\n}\n// export function expandMachineInterior(\n//     builder: BuildData,\n//     minimumInteriorNeighbors = 1\n// ) {\n//     let madeChange;\n//     const interior = builder.interior;\n//     const site = builder.site;\n//     do {\n//         madeChange = false;\n//         interior.forEach((_v, x, y) => {\n//             // if (v && site.isDoor(x, y)) {\n//             //     site.setTile(x, y, SITE.FLOOR); // clean out the doors...\n//             //     return;\n//             // }\n//             if (site.hasCellFlag(x, y, GWM.flags.Cell.IS_IN_MACHINE)) return;\n//             if (!site.blocksPathing(x, y)) return;\n//             let nbcount = 0;\n//             GWU.xy.eachNeighbor(\n//                 x,\n//                 y,\n//                 (i, j) => {\n//                     if (!interior.hasXY(i, j)) return; // Not in map\n//                     if (interior.isBoundaryXY(i, j)) return; // Not on boundary\n//                     if (interior[i][j] && !site.blocksPathing(i, j)) {\n//                         ++nbcount; // in machine and open tile\n//                     }\n//                 },\n//                 false\n//             );\n//             if (nbcount < minimumInteriorNeighbors) return;\n//             nbcount = 0;\n//             GWU.xy.eachNeighbor(\n//                 x,\n//                 y,\n//                 (i, j) => {\n//                     if (!interior.hasXY(i, j)) return; // not on map\n//                     if (interior[i][j]) return; // already part of machine\n//                     if (\n//                         !site.isWall(i, j) ||\n//                         site.hasCellFlag(i, j, GWM.flags.Cell.IS_IN_MACHINE)\n//                     ) {\n//                         ++nbcount; // tile is not a wall or is in a machine\n//                     }\n//                 },\n//                 false\n//             );\n//             if (nbcount) return;\n//             // Eliminate this obstruction; welcome its location into the machine.\n//             madeChange = true;\n//             interior[x][y] = 1;\n//             if (site.blocksPathing(x, y)) {\n//                 site.setTile(x, y, SITE.FLOOR);\n//             }\n//             GWU.xy.eachNeighbor(x, y, (i, j) => {\n//                 if (!interior.hasXY(i, j)) return;\n//                 if (site.isSet(i, j)) return;\n//                 site.setTile(i, j, SITE.WALL);\n//             });\n//         });\n//     } while (madeChange);\n// }\n///////////////////////////\n// INSTALL\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\nexport function random(requiredFlags, depth, rng) {\n    const matches = Object.values(blueprints).filter((b) => b.qualifies(requiredFlags) && b.frequency(depth));\n    rng = rng || GWU.rng.random;\n    return rng.item(matches);\n}\nexport function get(id) {\n    if (id instanceof Blueprint)\n        return id;\n    return blueprints[id];\n}\nexport function make(config) {\n    // if (!config.id) throw new Error('id is required to make Blueprint.');\n    return new Blueprint(config);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\nimport * as SITE from '../site';\nimport * as BLUE from './blueprint';\nimport * as STEP from './buildStep';\nimport * as ITEM from '../site/item';\nimport * as HORDE from '../site/horde';\nimport { BuildData } from './data';\nimport { NullLogger } from '../site/log/logger';\nimport { ConsoleLogger } from '../site/log/consoleLogger';\nexport class Builder {\n    constructor(options = {}) {\n        this.blueprints = null;\n        if (options.blueprints) {\n            if (!Array.isArray(options.blueprints)) {\n                options.blueprints = Object.values(options.blueprints);\n            }\n            this.blueprints = options.blueprints.map((v) => BLUE.get(v));\n        }\n        if (options.log === true) {\n            this.log = new ConsoleLogger();\n        }\n        else {\n            this.log = options.log || new NullLogger();\n        }\n        if (options.seed) {\n            this.seed = options.seed;\n        }\n        else {\n            this.seed = 0;\n        }\n    }\n    _pickRandom(requiredFlags, depth, rng) {\n        rng = rng || GWU.rng.random;\n        const blueprints = this.blueprints || Object.values(BLUE.blueprints);\n        const weights = blueprints.map((b) => {\n            if (!b.qualifies(requiredFlags))\n                return 0;\n            return b.frequency(depth);\n        });\n        const index = rng.weighted(weights);\n        return blueprints[index] || null;\n    }\n    buildRandom(site, requiredMachineFlags = BLUE.Flags.BP_ROOM, x = -1, y = -1, adoptedItem = null) {\n        const depth = site.depth;\n        let tries = 0;\n        while (tries < 10) {\n            const blueprint = this._pickRandom(requiredMachineFlags, depth, site.rng);\n            if (!blueprint) {\n                this.log.onBuildError(`Failed to find matching blueprint: requiredMachineFlags : ${GWU.flag.toString(BLUE.Flags, requiredMachineFlags)}, depth: ${depth}`);\n                return null;\n            }\n            const data = new BuildData(site, blueprint);\n            site.analyze();\n            this.log.onBlueprintPick(data, requiredMachineFlags, depth);\n            if (this._buildAt(data, x, y, adoptedItem)) {\n                return { x, y };\n            }\n            ++tries;\n        }\n        // console.log(\n        //     'Failed to build random blueprint matching flags: ' +\n        //         GWU.flag.toString(BLUE.Flags, requiredMachineFlags) +\n        //         ' tried : ' +\n        //         tries.join(', ')\n        // );\n        return null;\n    }\n    build(site, blueprint, x = -1, y = -1, adoptedItem = null) {\n        if (typeof blueprint === 'string') {\n            const id = blueprint;\n            blueprint = BLUE.blueprints[id];\n            if (!blueprint)\n                throw new Error('Failed to find blueprint - ' + id);\n        }\n        if (this.seed) {\n            site.rng.seed(this.seed);\n        }\n        const data = new BuildData(site, blueprint);\n        site.analyze();\n        return this._buildAt(data, x, y, adoptedItem);\n    }\n    _buildAt(data, x = -1, y = -1, adoptedItem = null) {\n        if (x >= 0 && y >= 0) {\n            return this._build(data, x, y, adoptedItem);\n        }\n        let count = this._markCandidates(data);\n        if (!count) {\n            return null;\n        }\n        let tries = 20; // TODO - Make property of Blueprint\n        while (count-- && tries--) {\n            const loc = BLUE.pickCandidateLoc(data) || false;\n            if (loc) {\n                if (this._build(data, loc[0], loc[1], adoptedItem)) {\n                    return { x: loc[0], y: loc[1] };\n                }\n            }\n        }\n        this.log.onBlueprintFail(data, 'No suitable locations found to build blueprint.');\n        return null;\n    }\n    //////////////////////////////////////////\n    // Returns true if the machine got built; false if it was aborted.\n    // If empty array spawnedItems or spawnedMonsters is given, will pass those back for deletion if necessary.\n    _build(data, originX, originY, adoptedItem = null) {\n        data.reset(originX, originY);\n        this.log.onBlueprintStart(data, adoptedItem);\n        if (!this._computeInterior(data)) {\n            return null;\n        }\n        // This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.\n        const snapshot = data.site.snapshot();\n        data.machineNumber = data.site.nextMachineId(); // Reserve this machine number, starting with 1.\n        // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.\n        BLUE.prepareInterior(data);\n        // Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)\n        // and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.\n        data.calcDistances(data.blueprint.size.hi);\n        // Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.\n        // Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.\n        const components = data.blueprint.pickComponents(data.site.rng);\n        // Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.\n        // Now tick through the features and build them.\n        for (let index = 0; index < components.length; index++) {\n            const component = components[index];\n            // console.log('BUILD COMPONENT', component);\n            if (!this._buildStep(data, component, adoptedItem)) {\n                // failure! abort!\n                // Restore the map to how it was before we touched it.\n                this.log.onBlueprintFail(data, `Failed to build step ${component.index + 1}/${data.blueprint.steps.length}.`);\n                data.site.restore(snapshot);\n                snapshot.free();\n                // abortItemsAndMonsters(spawnedItems, spawnedMonsters);\n                return null;\n            }\n        }\n        // Clear out the interior flag for all non-wired cells, if requested.\n        if (data.blueprint.noInteriorFlag) {\n            SITE.clearInteriorFlag(data.site, data.machineNumber);\n        }\n        // if (torchBearer && torch) {\n        // \tif (torchBearer->carriedItem) {\n        // \t\tdeleteItem(torchBearer->carriedItem);\n        // \t}\n        // \tremoveItemFromChain(torch, floorItems);\n        // \ttorchBearer->carriedItem = torch;\n        // }\n        this.log.onBlueprintSuccess(data);\n        snapshot.free();\n        // console.log('Built a machine from blueprint:', originX, originY);\n        return { x: originX, y: originY };\n    }\n    _markCandidates(data) {\n        const count = BLUE.markCandidates(data);\n        if (count <= 0) {\n            this.log.onBlueprintFail(data, 'No suitable candidate locations found.');\n            return 0;\n        }\n        this.log.onBlueprintCandidates(data);\n        return count;\n    }\n    _computeInterior(data) {\n        let fail = null;\n        let count = data.blueprint.fillInterior(data);\n        // Now make sure the interior map satisfies the machine's qualifications.\n        if (!count) {\n            fail = 'Interior error.';\n        }\n        else if (!data.blueprint.size.contains(count)) {\n            fail = `Interior wrong size - have: ${count}, want: ${data.blueprint.size.toString()}`;\n        }\n        else if (data.blueprint.treatAsBlocking &&\n            SITE.siteDisruptedBy(data.site, data.interior, {\n                machine: data.site.machineCount,\n            })) {\n            fail = 'Interior blocks map.';\n        }\n        else if (data.blueprint.requireBlocking &&\n            SITE.siteDisruptedSize(data.site, data.interior) < 100) {\n            fail = 'Interior does not block enough cells.';\n        }\n        if (!fail) {\n            this.log.onBlueprintInterior(data);\n            return true;\n        }\n        this.log.onBlueprintFail(data, fail);\n        return false;\n    }\n    _buildStep(data, buildStep, adoptedItem) {\n        let wantCount = 0;\n        let builtCount = 0;\n        const site = data.site;\n        this.log.onStepStart(data, buildStep, adoptedItem);\n        // console.log(\n        //     'buildComponent',\n        //     blueprint.id,\n        //     blueprint.steps.indexOf(buildStep)\n        // );\n        // Figure out the distance bounds.\n        const distanceBound = STEP.calcDistanceBound(data, buildStep);\n        // If the StepFlags.BS_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n        // Make a master map of candidate locations for this feature.\n        let qualifyingTileCount = 0;\n        if (buildStep.buildVestibule) {\n            // Generate a door guard machine.\n            // Try to create a sub-machine that qualifies.\n            let success = this.buildRandom(data.site, BLUE.Flags.BP_VESTIBULE, data.originX, data.originY);\n            if (!success) {\n                this.log.onStepFail(data, buildStep, 'Failed to build vestibule');\n                return false;\n            }\n        }\n        // If we are just building a vestibule, then we can exit here...\n        if (!buildStep.buildsInstances) {\n            this.log.onStepSuccess(data, buildStep);\n            return true;\n        }\n        const candidates = GWU.grid.alloc(site.width, site.height);\n        let didSomething = false;\n        do {\n            didSomething = false;\n            if (buildStep.buildAtOrigin) {\n                candidates[data.originX][data.originY] = 1;\n                qualifyingTileCount = 1;\n                wantCount = 1;\n            }\n            else {\n                qualifyingTileCount = buildStep.markCandidates(data, candidates, distanceBound);\n                if (buildStep.generateEverywhere ||\n                    buildStep.repeatUntilNoProgress) {\n                    wantCount = qualifyingTileCount;\n                }\n                else {\n                    wantCount = buildStep.count.value(site.rng);\n                }\n                this.log.onStepCandidates(data, buildStep, candidates, wantCount);\n                // get rid of all error/invalid codes\n                candidates.update((v) => (v == 1 ? 1 : 0));\n                if (!qualifyingTileCount ||\n                    qualifyingTileCount < buildStep.count.lo) {\n                    this.log.onStepFail(data, buildStep, `Only ${qualifyingTileCount} qualifying tiles - want ${buildStep.count.toString()}.`);\n                    return false;\n                }\n            }\n            let x = 0, y = 0;\n            while (qualifyingTileCount > 0 && builtCount < wantCount) {\n                // Find a location for the feature.\n                if (buildStep.buildAtOrigin) {\n                    // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                    x = data.originX;\n                    y = data.originY;\n                }\n                else {\n                    // Pick our candidate location randomly, and also strike it from\n                    // the candidates map so that subsequent instances of this same feature can't choose it.\n                    [x, y] = data.rng.matchingLoc(candidates.width, candidates.height, (x, y) => candidates[x][y] == 1);\n                }\n                // Don't waste time trying the same place again whether or not this attempt succeeds.\n                candidates[x][y] = 0;\n                qualifyingTileCount--;\n                const snapshot = data.site.snapshot();\n                if (this._buildStepInstance(data, buildStep, x, y, adoptedItem)) {\n                    // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n                    qualifyingTileCount -= buildStep.makePersonalSpace(data, x, y, candidates);\n                    builtCount++; // we've placed an instance\n                    didSomething = true;\n                    snapshot.free(); // This snapshot is useless b/c we made changes...\n                }\n                else {\n                    data.site.restore(snapshot); // need to undo any changes...\n                    snapshot.free();\n                }\n                // Finished with this instance!\n            }\n        } while (didSomething && buildStep.repeatUntilNoProgress);\n        GWU.grid.free(candidates);\n        if (!buildStep.count.contains(builtCount) &&\n            !buildStep.generateEverywhere &&\n            !buildStep.repeatUntilNoProgress) {\n            this.log.onStepFail(data, buildStep, `Failed to build enough instances - want: ${buildStep.count.toString()}, built: ${builtCount}`);\n            return false;\n        }\n        this.log.onStepSuccess(data, buildStep);\n        return true;\n    }\n    _buildStepInstance(data, buildStep, x, y, adoptedItem = null) {\n        let success = true;\n        let didSomething = true;\n        const site = data.site;\n        if (success && buildStep.treatAsBlocking) {\n            // Yes, check for blocking.\n            const options = {\n                machine: site.machineCount,\n            };\n            if (buildStep.noBlockOrigin) {\n                options.updateWalkable = (g) => {\n                    g[data.originX][data.originY] = 1;\n                    return true;\n                };\n            }\n            if (SITE.siteDisruptedByXY(site, x, y, options)) {\n                this.log.onStepInstanceFail(data, buildStep, x, y, 'instance blocks map');\n                success = false;\n            }\n        }\n        // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n        if (success && buildStep.feature) {\n            success = buildStep.feature(site, x, y);\n            didSomething = success;\n            if (!success) {\n                this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to build effect - ' +\n                    JSON.stringify(buildStep.feature));\n            }\n        }\n        // Now try to place the terrain tile, if any.\n        if (success && buildStep.tile) {\n            if (!buildStep.permitBlocking &&\n                site.tileBlocksMove(buildStep.tile) &&\n                !buildStep.treatAsBlocking // already did treatAsBlocking\n            ) {\n                if (SITE.siteDisruptedByXY(site, x, y, {\n                    machine: site.machineCount,\n                })) {\n                    this.log.onStepInstanceFail(data, buildStep, x, y, 'tile blocks site');\n                    success = false;\n                }\n            }\n            if (success) {\n                success = site.setTile(x, y, buildStep.tile);\n                didSomething = didSomething || success;\n                if (!success) {\n                    this.log.onStepInstanceFail(data, buildStep, x, y, 'failed to set tile - ' + buildStep.tile);\n                }\n            }\n        }\n        let torch = adoptedItem;\n        // Generate an item, if necessary\n        if (success && buildStep.item) {\n            const itemInfo = ITEM.pickItem(data.site.depth, buildStep.item);\n            if (!itemInfo) {\n                success = false;\n                this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to make random item - ' +\n                    JSON.stringify(buildStep.item));\n            }\n            else {\n                const item = ITEM.makeItem(itemInfo);\n                if (buildStep.itemIsKey) {\n                    item.key = {\n                        x,\n                        y,\n                        disposable: !!buildStep.keyIsDisposable,\n                    };\n                }\n                if (buildStep.outsourceItem) {\n                    const result = this.buildRandom(data.site, BLUE.Flags.BP_ADOPT_ITEM, -1, -1, item);\n                    if (result) {\n                        didSomething = true;\n                    }\n                    else {\n                        this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to build machine to adopt item - ' + item.id);\n                        success = false;\n                    }\n                }\n                else if (buildStep.hordeTakesItem) {\n                    torch = item;\n                }\n                else {\n                    success = site.addItem(x, y, item) > 0;\n                    didSomething = didSomething || success;\n                    if (!success) {\n                        this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to add item to site - ' + item.id);\n                    }\n                }\n            }\n        }\n        else if (success && buildStep.adoptItem) {\n            // adopt item if necessary\n            if (!adoptedItem) {\n                throw new Error('Failed to build blueprint because there is no adopted item.');\n            }\n            if (success) {\n                success = site.addItem(x, y, adoptedItem) > 0;\n                if (success) {\n                    didSomething = true;\n                }\n                else {\n                    this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to add adopted item to site - ' + adoptedItem.id);\n                }\n            }\n        }\n        let torchBearer = null;\n        if (success && buildStep.horde) {\n            let horde = HORDE.pickHorde(data.site.depth, buildStep.horde, site.rng);\n            // if (buildStep.horde.random) {\n            //     horde = GWM.horde.random({ rng: site.rng });\n            // } else if (buildStep.horde.id) {\n            //     horde = GWM.horde.from(buildStep.horde.id);\n            // } else {\n            //     buildStep.horde.rng = site.rng;\n            //     horde = GWM.horde.random(buildStep.horde);\n            // }\n            if (!horde) {\n                success = false;\n                this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to pick horde - ' + JSON.stringify(buildStep.horde));\n            }\n            else {\n                if (horde.blueprint) {\n                    const blueprint = BLUE.get(horde.blueprint);\n                    const newData = new BuildData(data.site, blueprint, data.machineNumber);\n                    const result = this._build(newData, x, y, null);\n                    newData.free();\n                    if (!result) {\n                        return false;\n                    }\n                }\n                const leader = HORDE.spawnHorde(horde, site, x, y, {\n                    machine: site.machineCount,\n                });\n                if (!leader) {\n                    success = false;\n                    this.log.onStepInstanceFail(data, buildStep, x, y, 'Failed to build horde - ' + horde);\n                }\n                else {\n                    // What to do now?\n                    didSomething = true;\n                    // leader adopts item...\n                    if (torch && buildStep.hordeTakesItem) {\n                        torchBearer = leader;\n                        torchBearer.item = torch;\n                        torch.x = -1;\n                        torch.y = -1;\n                    }\n                    if (horde.feature) {\n                        horde.feature(site, x, y);\n                    }\n                    if (buildStep.horde.feature) {\n                        buildStep.horde.feature(site, x, y);\n                    }\n                }\n            }\n        }\n        if (success && didSomething) {\n            // Mark the feature location as part of the machine, in case it is not already inside of it.\n            if (!data.blueprint.noInteriorFlag) {\n                site.setMachine(x, y, data.machineNumber, data.blueprint.isRoom);\n            }\n            // Mark the feature location as impregnable if requested.\n            if (buildStep.impregnable) {\n                site.makeImpregnable(x, y);\n            }\n            this.log.onStepInstanceSuccess(data, buildStep, x, y);\n        }\n        else if (didSomething) {\n            // roll back any changes?\n        }\n        return success && didSomething;\n    }\n}\n////////////////////////////////////////////////////\n// TODO - Change this!!!\n// const blue = BLUE.get(id | blue);\n// const result =  blue.buildAt(map, x, y);\n//\nexport function build(blueprint, site, x, y, opts) {\n    const builder = new Builder(opts);\n    return builder.build(site, blueprint, x, y);\n}\n","import * as GWU from 'gw-utils';\n// import * as GWM from 'gw-map';\nimport * as LEVEL from './digger';\nexport class Dungeon {\n    constructor(options) {\n        // @ts-ignore\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { fails: 20 },\n            // rooms: { count: 20, digger: 'DEFAULT' },\n            // halls: {},\n            // loops: {},\n            // lakes: {},\n            // bridges: {},\n            // stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GWU.object.setOptions(this.config, options);\n        if (this.config.seed) {\n            GWU.rng.random.seed(this.config.seed);\n        }\n        if (typeof this.config.stairs === 'boolean' || !this.config.stairs) {\n            this.config.stairs = {};\n        }\n        if (!this.config.rooms) {\n            this.config.rooms = {};\n        }\n        else if (typeof this.config.rooms === 'number') {\n            this.config.rooms = { count: this.config.rooms };\n        }\n        this._initSeeds();\n        this._initStairLocs();\n    }\n    get length() {\n        return this.config.levels;\n    }\n    _initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GWU.rng.random.number(2 ** 32);\n        }\n    }\n    _initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        let needUpdate = false;\n        for (let i = 0; i < this.config.levels; ++i) {\n            let endLoc;\n            if (this.stairLocs[i] &&\n                this.stairLocs[i][1] &&\n                this.stairLocs[i][1][0] > 0) {\n                endLoc = this.stairLocs[i][1];\n                needUpdate =\n                    GWU.xy.distanceBetween(startLoc[0], startLoc[1], endLoc[0], endLoc[1]) < minDistance;\n            }\n            else {\n                endLoc = GWU.rng.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                    return (GWU.xy.distanceBetween(startLoc[0], startLoc[1], x, y) > minDistance);\n                });\n            }\n            this.stairLocs[i] = [\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ];\n            startLoc = endLoc;\n        }\n        if (needUpdate) {\n            // loop does not go all the way to level 0\n            for (let i = this.config.levels - 1; i > 0; --i) {\n                let [startLoc, endLoc] = this.stairLocs[i];\n                if (GWU.xy.distanceBetween(startLoc[0], startLoc[1], endLoc[0], endLoc[1]) > minDistance) {\n                    break;\n                }\n                startLoc = GWU.rng.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                    return (GWU.xy.distanceBetween(endLoc[0], endLoc[1], x, y) >\n                        minDistance);\n                });\n                this.stairLocs[i][0] = startLoc;\n                this.stairLocs[i - 1][1] = startLoc;\n            }\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && this.config.entrance) {\n            rooms.first = this.config.entrance;\n        }\n        let width = this.config.width, height = this.config.height;\n        // if (cb instanceof GWM.map.Map) {\n        //     width = cb.width;\n        //     height = cb.height;\n        // }\n        const levelOpts = {\n            seed: this.seeds[id],\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            goesUp: this.config.goesUp,\n            width,\n            height,\n        };\n        return this._makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    _makeLevel(id, opts, cb) {\n        const digger = new LEVEL.Digger(opts);\n        let result = false;\n        // if (cb instanceof GWM.map.Map) {\n        //     result = digger.create(cb);\n        // } else {\n        result = digger.create(this.config.width, this.config.height, cb);\n        // }\n        this.stairLocs[id] = [digger.locations.start, digger.locations.end];\n        // if (cb instanceof GWM.map.Map) {\n        //     const locs = this.stairLocs[id];\n        //     if (this.config.goesUp) {\n        //         cb.locations.down = cb.locations.start = locs[0];\n        //         cb.locations.up = cb.locations.end = locs[1];\n        //     } else {\n        //         cb.locations.down = cb.locations.start = locs[1];\n        //         cb.locations.up = cb.locations.end = locs[0];\n        //     }\n        // }\n        return result;\n    }\n}\n"],"names":["tiles","all","installTile","id","opts","base","index","length","priority","tags","extends","root","getTile","Error","Object","assign","info","GWU","object","assignOmitting","make","text","replace","search","Number","parseInt","tile","substring","delta","undefined","blocksPathing","blocksMove","push","name","tileId","_a","ch","blocksVision","door","secretDoor","stairs","liquid","impregnable","features","types","installType","fn","feature","Array","isArray","featureFeature","bind","site","x","y","feat","config","FALSE","parts","split","shift","toLowerCase","handler","steps","map","filter","a","entries","key","every","step","makeArray","cfg","c","s","src","includes","superpriority","blockedByActors","blockedByItems","tileAction","machine","setTile","chance","endsWith","parseFloat","chanceAction","rng","Fl","flag","fl","Flags","spread","args","t","trim","grow","decrement","flags","from","matchTile","indexOf","action","spreadFeature","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","didSomething","spawnMap","grid","alloc","width","height","computeSpawnMap","mapDisruptedBy","free","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","update","v","forEach","i","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","xy","forRect","j","lakeX","lakeY","get","isStairs","first","floodFill","cellIsOk","effect","isStart","hasXY","isProtected","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","hasTile","dir","x2","y2","madeChange","startProb","probDec","fill","count","DIRS","_flags","clearTile","blockingMap","eachActor","loc","matchingLocNear","forbidsActor","eachItem","forbidsItem","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","hordes","pickHorde","depth","rules","tagMatch","random","makeMatch","find","h","choices","horde","freq","frequency","weighted","spawnHorde","canSpawn","TRUE","leader","canSpawnActor","matchingLoc","hasActor","_pickLeaderLoc","_opts","addActor","_addLeader","_spawnLeader","members","kindId","value","_spawnMember","_spawnMembers","member","instance","actor","_pickMemberLoc","_addMember","items","pickItem","tagRules","item","makeItem","directionOfDoorSite","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","isFloor","chooseRandomDoorSites","k","doorSiteFailed","DOORS","w","isDiggable","isSet","doorSites","fillCostGrid","source","costGrid","_v","isPassable","path","OBSTRUCTION","siteDisruptedByXY","options","_b","_c","offsetX","offsetY","arcCount","result","siteDisruptedBy","blockingX","blockingY","getMachine","updateWalkable","siteDisruptedSize","nextId","minSize","disrupted","Math","min","computeDistanceMap","distanceMap","originX","originY","maxDistance","calculateDistances","clearInteriorFlag","needsMachine","setMachine","analyze","updateChokeCounts","updateLoopiness","updateChokepoints","updateCounts","passMap","isSecretDoor","passableArcCount","clearChokepoint","isInLoop","oldX","CLOCK_DIRS","oldY","setChokepoint","setChokeCount","isChokepoint","cellCount","floodFillCount","i2","j2","getChokeCount","clearGateSite","setGateSite","results","startX","startY","getCount","isAreaMachine","todo","pop","resetLoopiness","checkLoopiness","cleanLoopiness","setInLoop","clearInLoop","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","designationSurvives","Site","[object Object]","this","actors","machineCount","_tiles","_doors","_machine","_chokeCounts","fmt","dump","TILE.getTile","other","copy","slice","otherX","otherY","seed","isBoundaryXY","isDoor","isBridge","isShallow","_x","_y","isNothing","isDeep","TILE.tileId","IMPREGNABLE","CHOKEPOINT","GATE_SITE","IN_LOOP","ANALYZE.analyze","snapshot","isRoom","IN_MACHINE","IN_AREA_MACHINE","Utils.directionOfDoorSite","hasItem","_actor","cb","some","_i","NullLogger","StepFlags","CandidateType","BuildStep","pad","range","FEATURE.make","BS_ADOPT_ITEM","buildAtOrigin","hi","repeatUntilNoProgress","hordeTakesItem","allowBoundary","BS_ALLOW_BOUNDARY","notInHallway","BS_NOT_IN_HALLWAY","buildInWalls","BS_BUILD_IN_WALLS","buildAnywhere","BS_BUILD_ANYWHERE_ON_LEVEL","BS_REPEAT_UNTIL_NO_PROGRESS","permitBlocking","BS_PERMIT_BLOCKING","treatAsBlocking","BS_TREAT_AS_BLOCKING","BS_NO_BLOCK_ORIGIN","noBlockOrigin","adoptItem","itemIsKey","BS_ITEM_IS_KEY","keyIsDisposable","BS_KEY_DISPOSABLE","outsourceItem","BS_OUTSOURCE_ITEM_TO_MACHINE","BS_IMPREGNABLE","buildVestibule","BS_BUILD_VESTIBULE","BS_HORDE_TAKES_ITEM","generateEverywhere","BS_EVERYWHERE","BS_BUILD_AT_ORIGIN","buildsInstances","data","candidates","distanceBound","updateViewMap","blueprint","candidateType","cellIsCandidate","OK","_data","JSON","stringify","lo","toString","join","builder","buildStep","BS_IN_VIEW_OF_ORIGIN","BS_IN_PASSABLE_VIEW_OF_ORIGIN","fov","FOV","isBlocked","calculate","viewMap","calcDistanceBound","BS_NEAR_ORIGIN","distance25","BS_FAR_FROM_ORIGIN","distance75","IN_HALLWAY","ON_BOUNDARY","MUST_BE_ORIGIN","NOT_ORIGIN","occupied","OCCUPIED","NOT_IN_VIEW","distance","TOO_FAR","TOO_CLOSE","cellMachine","interior","machineNumber","failed","neighborMachine","INVALID_WALL","NOT_CANDIDATE","blocksItems","BLOCKED","FAILED","ConsoleLogger","console","group","groupEnd","room","roomSite","_site","_room","_roomSite","error","log","label","size","wantCount","haveCount","_step","requiredTile","cells","line","Hall","Bounds","super","doors","dx","dy","d","makeHall","dirIndex","hallLength","hallWidth","abs","Room","hall","cx","floor","cy","translate","checkConfig","expected","expect","have","RoomDigger","_setOptions","carve","SITE.chooseRandomDoorSites","rooms","ChoiceRoom","randomRoom","ERROR","create","Cavern","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","DOWN","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickWidth","clamp","Range","weights","_pickWidth","pickLength","lengths","UP","pickHallDirection","dirs","sequence","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.makeHall","lower","higher","actual","halls","Lakes","tries","canDisrupt","wreathTile","wreathChance","wreathSize","assignObject","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","dirCoords","seq","isAnyLiquid","bridgeDir","NO_PATH","isBridgeCandidate","_bridgeDir","Stairs","up","down","start","upTile","downTile","wall","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","distanceBetween","setupStairs","end","wallTile","indexes","x0","y0","findIndex","r","LoopDigger","doorChance","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","Digger","fails","loops","lakes","bridges","boundary","_locs","goesUp","setOptions","startLoc","endLoc","LOGGER.NullLogger","SITE.Site","needsFree","dest","_createSite","_create","addRooms","addLoops","onLoopsAdded","addLakes","onLakesAdded","addBridges","onBridgesAdded","addStairs","onStairsAdded","finish","number","setSeed","clear","stair","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","addFirstRoom","updateDoorDirs","onDigFirstRoom","maxFails","addRoom","shuffle","_makeRoomSite","getDigger","_attachRoomAtLoc","HALL.dig","onRoomCandidate","_attachRoom","onRoomSuccess","onRoomFailed","len","getDoorDir","oppDir","_roomFitsAt","copyTiles","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","locs","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","blocksDiagonal","boundaryTile","BuildData","maxSize","SITE.computeDistanceMap","qualifyingTileCount","distances","dist","Blueprint","STEP.BuildStep","BP_ADOPT_ITEM","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","BP_NO_INTERIOR_FLAG","BP_NOT_IN_HALLWAY","requiredFlags","want","alternativeFlags","STEP.StepFlags","BS_ALTERNATIVE","BS_ALTERNATIVE_2","keepFeature","totalFreq","randIndex","_f","addTileToInteriorAndIterate","computeVestibuleInterior","goalSize","n","isOccupied","markCandidates","buildData","isGateSite","contains","pickCandidateLoc","randSite","doorChokeCount","vestibuleLoc","vestibuleChokeCount","roomSize","wantSize","distMap","startChokeCount","additional","minimumInteriorNeighbors","interiorNeighborCount","interiorCount","maxInteriorCount","gen","prepareInterior","blueprints","Builder","values","BLUE.get","BLUE.blueprints","b","qualifies","requiredMachineFlags","BLUE.Flags","adoptedItem","_pickRandom","onBuildError","onBlueprintPick","_buildAt","_build","_markCandidates","BLUE.pickCandidateLoc","onBlueprintFail","reset","onBlueprintStart","_computeInterior","nextMachineId","BLUE.prepareInterior","calcDistances","components","pickComponents","component","_buildStep","restore","SITE.clearInteriorFlag","onBlueprintSuccess","BLUE.markCandidates","onBlueprintCandidates","fail","fillInterior","SITE.siteDisruptedBy","SITE.siteDisruptedSize","onBlueprintInterior","builtCount","onStepStart","STEP.calcDistanceBound","buildRandom","onStepFail","onStepSuccess","onStepCandidates","_buildStepInstance","makePersonalSpace","g","SITE.siteDisruptedByXY","onStepInstanceFail","tileBlocksMove","torch","itemInfo","ITEM.pickItem","ITEM.makeItem","disposable","addItem","torchBearer","HORDE.pickHorde","newData","HORDE.spawnHorde","onStepInstanceSuccess","build","matches","levels","seeds","stairLocs","_initSeeds","_initStairLocs","stairDistance","needUpdate","stairOpts","startTile","endTile","entrance","levelOpts","_makeLevel","LEVEL.Digger"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/dig/site.js","../js/dig/types.js","../js/dig/utils.js","../js/dig/room.js","../js/dig/hall.js","../js/dig/lake.js","../js/dig/bridge.js","../js/dig/stairs.js","../js/dig/loop.js","../js/dig/level.js","../js/dig/dungeon.js","../js/build/site.js","../js/build/spawn.js","../js/build/buildStep.js","../js/build/blueprint.js","../js/build/chokeFinder.js","../js/build/loopFinder.js","../js/build/index.js"],"sourcesContent":["var _a, _b;\nimport * as GW from 'gw-utils';\nexport const NOTHING = GW.tile.get('NULL').index;\nexport const FLOOR = GW.tile.get('FLOOR').index;\nexport const DOOR = GW.tile.get('DOOR').index;\nexport const SECRET_DOOR = (_b = (_a = GW.tile.get('DOOR_SECRET')) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;\nexport const WALL = GW.tile.get('WALL').index;\nexport const DEEP = GW.tile.get('LAKE').index;\nexport const SHALLOW = GW.tile.get('SHALLOW').index;\nexport const BRIDGE = GW.tile.get('BRIDGE').index;\nexport const UP_STAIRS = GW.tile.get('UP_STAIRS').index;\nexport const DOWN_STAIRS = GW.tile.get('DOWN_STAIRS').index;\nexport const IMPREGNABLE = GW.tile.get('IMPREGNABLE').index;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport class GridSite {\n    constructor(width, height) {\n        this.tiles = GW.grid.alloc(width, height);\n    }\n    free() {\n        GW.grid.free(this.tiles);\n    }\n    get width() {\n        return this.tiles.width;\n    }\n    get height() {\n        return this.tiles.height;\n    }\n    hasXY(x, y) {\n        return this.tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.tiles.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === DOOR;\n    }\n    isSecretDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === SECRET_DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    blocksMove(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y) || this.isDeep(x, y);\n    }\n    blocksDiagonal(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksPathing(x, y) {\n        return (this.isNothing(x, y) ||\n            this.isWall(x, y) ||\n            this.isDeep(x, y) ||\n            this.isStairs(x, y));\n    }\n    blocksVision(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    blocksItems(x, y) {\n        return this.blocksPathing(x, y) || this.blocksPathing(x, y);\n    }\n    blocksEffects(x, y) {\n        return this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.tiles.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.tiles.get(x, y) === SHALLOW;\n    }\n    isAnyLiquid(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.tiles.get(x, y) || 0) > 0;\n    }\n    getTileIndex(x, y) {\n        return this.tiles.get(x, y) || 0;\n    }\n    setTile(x, y, tile) {\n        if (typeof tile === 'string') {\n            const obj = GW.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        if (!this.tiles.hasXY(x, y))\n            return false;\n        this.tiles[x][y] = tile;\n        return true;\n    }\n    hasTile(x, y, tile) {\n        if (typeof tile === 'string') {\n            const obj = GW.tile.tiles[tile];\n            if (!obj)\n                throw new Error('Failed to find tie: ' + tile);\n            tile = obj.index;\n        }\n        return this.tiles.hasXY(x, y) && this.tiles[x][y] == tile;\n    }\n    tileBlocksMove(tile) {\n        return (tile === WALL ||\n            tile === DEEP ||\n            tile === IMPREGNABLE ||\n            tile === NOTHING);\n    }\n}\n","import * as GW from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        // console.log('Hall', loc, d, length, width);\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        // console.log(' - ', [this.x2, this.y2]);\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room extends GW.utils.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GW.utils.Loc[] | null;\n//     door: number;\n// }\n","import * as GW from 'gw-utils';\n// import * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\n// export function attachRoom(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GW.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GW.utils.DIRS[dir][0];\n                    newY = j + GW.utils.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GW.utils.DIRS[dir][0];\n                        newY += GW.utils.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GW.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GW.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GW.grid.NumGrid,\n//     xy: GW.utils.Loc,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GW.grid.NumGrid,\n//     mapDoors: GW.utils.Loc[],\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorIndexes = GW.random.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GW.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = GW.random.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n//             //     return [x0, y0] as GW.utils.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function copySite(dest, source, offsetX = 0, offsetY = 0) {\n    GW.utils.forRect(dest.width, dest.height, (x, y) => {\n        const otherX = x - offsetX;\n        const otherY = y - offsetY;\n        const v = source.getTileIndex(otherX, otherY);\n        if (!v)\n            return;\n        dest.setTile(x, y, v);\n    });\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n}\nexport function siteDisruptedBy(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GW.grid.alloc(site.width, site.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GW.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = true;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GW.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function siteDisruptedSize(site, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GW.grid.alloc(site.width, site.height);\n    let disrupts = 0;\n    // Get all walkable locations after lake added\n    GW.utils.forRect(site.width, site.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (site.isStairs(i, j)) {\n                disrupts = site.width * site.height;\n            }\n        }\n        else if (site.isPassable(i, j)) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    if (disrupts)\n        return disrupts;\n    let first = true;\n    let nextId = 2;\n    let minSize = site.width * site.height;\n    for (let i = 0; i < walkableGrid.width; ++i) {\n        for (let j = 0; j < walkableGrid.height; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                const disrupted = walkableGrid.floodFill(i, j, 1, nextId++);\n                minSize = Math.min(minSize, disrupted);\n                if (first) {\n                    first = false;\n                }\n                else {\n                    disrupts = minSize;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GW.grid.free(walkableGrid);\n    return disrupts;\n}\nexport function computeDistanceMap(site, distanceMap, originX, originY, maxDistance) {\n    const costGrid = GW.grid.alloc(site.width, site.height);\n    fillCostGrid(site, costGrid);\n    GW.path.calculateDistances(distanceMap, originX, originY, costGrid, false, maxDistance + 1 // max distance is the same as max size of this blueprint\n    );\n    GW.grid.free(costGrid);\n}\n","import * as GW from 'gw-utils';\nimport * as TYPES from './types';\nimport * as UTILS from './utils';\nimport * as SITE from './site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = UTILS.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GW.random.item.bind(GW.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GW.random.weighted.bind(GW.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GW.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GW.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GW.blob.Blob({\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GW.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GW.utils.DOWN] = [\n            Math.floor(site.width / 2),\n            site.height - 2,\n        ];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GW.utils.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GW.random.chance(this.options.holeChance.value())) {\n            GW.utils.forCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GW.utils.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GW.random.range(minX, maxX);\n            y = GW.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GW.utils.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nimport * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GW.range.make(1),\n            length: [GW.range.make('2-15'), GW.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GW.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GW.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || UTILS.chooseRandomDoorSites(site);\n        if (!GW.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GW.utils.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = new TYPES.Hall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GW.utils.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = new TYPES.Hall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: SITE.SHALLOW,\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = GW.random.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GW.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GW.blob.Blob({\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    GW.utils.forCircle(sx, sy, wreathSize, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GW.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GW.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GW.utils.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GW.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n        const seq = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyLiquid(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyLiquid(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyLiquid(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GW.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyLiquid(x, y))\n            return false;\n        if (!site.isAnyLiquid(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyLiquid(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc;\n        let downLoc;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GW.random.matchingLocNear(GW.utils.x(start), GW.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingLocNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GW.random.matchingLocNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingLocNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GW.random.matchingLocNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (GW.utils.distanceBetween(x, y, \n                    // @ts-ignore\n                    downLoc[0], \n                    // @ts-ignore\n                    downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingLoc(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GW.random.matchingLoc(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc !== undefined) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GW.utils.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GW.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GW.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GW.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GW.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GW.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GW.utils.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as UTILS from './utils';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        UTILS.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        const seq = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < seq.length; i++) {\n            x = Math.floor(seq[i] / site.height);\n            y = seq[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, SITE.FLOOR);\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            site.setTile(x, y, SITE.DOOR); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nimport * as UTILS from './utils';\nexport class Level {\n    constructor(width, height, options = {}) {\n        this.rooms = {};\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        this.startLoc = [-1, -1];\n        this.endLoc = [-1, -1];\n        this.height = height;\n        this.width = width;\n        this.seq = GW.random.sequence(width * height);\n        if (options.seed) {\n            GW.random.seed(options.seed);\n        }\n        GW.utils.setOptions(this.rooms, options.rooms);\n        GW.utils.setOptions(this.halls, options.halls);\n        GW.utils.setOptions(this.loops, options.loops);\n        GW.utils.setOptions(this.lakes, options.lakes);\n        GW.utils.setOptions(this.bridges, options.bridges);\n        GW.utils.setOptions(this.stairs, options.stairs);\n        GW.utils.setOptions(this.doors, options.doors);\n        this.startLoc = options.startLoc || [Math.floor(width / 2), height - 2];\n        this.endLoc = options.endLoc || [-1, -1];\n    }\n    makeSite(width, height) {\n        return new SITE.GridSite(width, height);\n    }\n    create(setFn) {\n        const site = this.makeSite(this.width, this.height);\n        this.start(site);\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        let fails = 0;\n        while (fails < 20) {\n            if (this.addRoom(site)) {\n                fails = 0;\n            }\n            else {\n                ++fails;\n            }\n        }\n        this.addLoops(site, this.loops);\n        this.addLakes(site, this.lakes);\n        this.addBridges(site, this.bridges);\n        this.addStairs(site, this.stairs);\n        this.finish(site);\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            const t = site.getTileIndex(x, y);\n            if (t)\n                setFn(x, y, t);\n        });\n        site.free();\n        return true;\n    }\n    start(_site) { }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addFirstRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.startLoc)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        if (room && !this._attachRoom(site, roomSite, room)) {\n            room = null;\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (let i = 0; i < this.seq.length; i++) {\n            const x = Math.floor(this.seq[i] / this.height);\n            const y = this.seq[i] % this.height;\n            if (!site.isNothing(x, y))\n                continue;\n            const dir = UTILS.directionOfDoorSite(site, x, y);\n            if (dir != GW.utils.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    UTILS.copySite(site, roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = GW.random.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                UTILS.copySite(site, roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n                //     return [x0, y0] as GW.utils.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n            for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.hasXY(i, j) ||\n                                map.isBoundaryXY(i, j) ||\n                                !map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(map, room, x, y, dir) {\n        const opts = this.doors;\n        if (opts.chance === 0)\n            return; // no door at all\n        const isDoor = opts.chance && GW.random.chance(opts.chance); // did not pass chance\n        const tile = isDoor ? opts.tile || SITE.DOOR : SITE.FLOOR;\n        map.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n            return;\n        }\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x - k, y)) {\n                    if (map.isSet(x - k, y - 1) && map.isSet(x - k, y + 1)) {\n                        map.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x + k, y)) {\n                    if (map.isSet(x + k, y - 1) && map.isSet(x + k, y + 1)) {\n                        map.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x, y - k)) {\n                    if (map.isSet(x - 1, y - k) && map.isSet(x + 1, y - k)) {\n                        map.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x, y + k)) {\n                    if (map.isSet(x - 1, y + k) && map.isSet(x + 1, y + k)) {\n                        map.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        return digger.create(site);\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < this.width - 1; i++) {\n                for (j = 0; j < this.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (!site.blocksMove(i + k, j) &&\n                            site.blocksMove(i + (1 - k), j) &&\n                            site.blocksDiagonal(i + (1 - k), j) &&\n                            site.blocksMove(i + k, j + 1) &&\n                            site.blocksDiagonal(i + k, j + 1) &&\n                            !site.blocksMove(i + (1 - k), j + 1)) {\n                            if (GW.random.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, SITE.FLOOR); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                if (\n                // TODO - isPassable\n                (site.isFloor(x + 1, y) || site.isFloor(x - 1, y)) &&\n                    (site.isFloor(x, y + 1) || site.isFloor(x, y - 1))) {\n                    // If there's passable terrain to the left or right, and there's passable terrain\n                    // above or below, then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                }\n                else if ((site.blocksPathing(x + 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x - 1, y) ? 1 : 0) +\n                    (site.blocksPathing(x, y + 1) ? 1 : 0) +\n                    (site.blocksPathing(x, y - 1) ? 1 : 0) >=\n                    3) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? SITE.IMPREGNABLE : SITE.WALL;\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, SITE.WALL);\n                }\n            }\n        });\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as LEVEL from './level';\nexport class Dungeon {\n    constructor(options = {}) {\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { count: 20, digger: 'DEFAULT' },\n            halls: {},\n            loops: {},\n            lakes: {},\n            bridges: {},\n            stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GW.utils.setOptions(this.config, options);\n        if (this.config.seed) {\n            GW.random.seed(this.config.seed);\n        }\n        this.initSeeds();\n        this.initStairLocs();\n    }\n    get levels() {\n        return this.config.levels;\n    }\n    initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GW.random.number(2 ** 32);\n        }\n    }\n    initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        for (let i = 0; i < this.config.levels; ++i) {\n            const endLoc = GW.random.matchingLoc(this.config.width, this.config.height, (x, y) => {\n                return (GW.utils.distanceBetween(startLoc[0], startLoc[1], x, y) > minDistance);\n            });\n            this.stairLocs.push([\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ]);\n            startLoc = endLoc;\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        GW.random.seed(this.seeds[id]);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && rooms.entrance) {\n            rooms.first = rooms.entrance;\n        }\n        const levelOpts = {\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            width: this.config.width,\n            height: this.config.height,\n        };\n        return this.makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    makeLevel(id, opts, cb) {\n        const level = new LEVEL.Level(this.config.width, this.config.height, opts);\n        const result = level.create(cb);\n        if (!GW.utils.equalsXY(level.endLoc, opts.endLoc) ||\n            !GW.utils.equalsXY(level.startLoc, opts.startLoc)) {\n            this.stairLocs[id] = [level.startLoc, level.endLoc];\n        }\n        return result;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as DigSite from '../dig/site';\nconst Fl = GW.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"IS_IN_LOOP\"] = Fl(0)] = \"IS_IN_LOOP\";\n    Flags[Flags[\"IS_CHOKEPOINT\"] = Fl(1)] = \"IS_CHOKEPOINT\";\n    Flags[Flags[\"IS_GATE_SITE\"] = Fl(2)] = \"IS_GATE_SITE\";\n    Flags[Flags[\"IS_IN_ROOM_MACHINE\"] = Fl(3)] = \"IS_IN_ROOM_MACHINE\";\n    Flags[Flags[\"IS_IN_AREA_MACHINE\"] = Fl(4)] = \"IS_IN_AREA_MACHINE\";\n    Flags[Flags[\"IMPREGNABLE\"] = Fl(5)] = \"IMPREGNABLE\";\n    Flags[Flags[\"IS_WIRED\"] = Fl(6)] = \"IS_WIRED\";\n    Flags[Flags[\"IS_CIRCUIT_BREAKER\"] = Fl(7)] = \"IS_CIRCUIT_BREAKER\";\n    Flags[Flags[\"IS_IN_MACHINE\"] = Flags.IS_IN_ROOM_MACHINE | Flags.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n})(Flags || (Flags = {}));\nexport class GridSite extends DigSite.GridSite {\n    constructor(width, height) {\n        super(width, height);\n        this.machineCount = 0;\n        this.flags = GW.grid.alloc(width, height);\n        this.choke = GW.grid.alloc(width, height);\n        this.machine = GW.grid.alloc(width, height);\n    }\n    free() {\n        GW.grid.free(this.flags);\n        GW.grid.free(this.choke);\n        GW.grid.free(this.machine);\n        super.free();\n    }\n    backup() {\n        const backup = new GridSite(this.width, this.height);\n        backup.tiles.copy(this.tiles);\n        backup.flags.copy(this.flags);\n        backup.choke.copy(this.choke);\n        return backup;\n    }\n    restore(backup) {\n        this.tiles.copy(backup.tiles);\n        this.flags.copy(backup.flags);\n        this.choke.copy(backup.choke);\n        backup.free();\n    }\n    deleteBackup(backup) {\n        backup.free();\n    }\n    hasSiteFlag(x, y, flag) {\n        const have = this.flags.get(x, y) || 0;\n        return !!(have & flag);\n    }\n    setSiteFlag(x, y, flag) {\n        const value = (this.flags.get(x, y) || 0) | flag;\n        this.flags.set(x, y, value);\n    }\n    clearSiteFlag(x, y, flag) {\n        const value = (this.flags.get(x, y) || 0) & ~flag;\n        this.flags.set(x, y, value);\n    }\n    getChokeCount(x, y) {\n        return this.choke.get(x, y) || 0;\n    }\n    setChokeCount(x, y, count) {\n        this.choke.set(x, y, count);\n    }\n    isOccupied(_x, _y) {\n        return false;\n    }\n    hasItem(_x, _y) {\n        return false;\n    }\n    hasActor(_x, _y) {\n        return false;\n    }\n    placeTile(x, y, tile, _options) {\n        return this.setTile(x, y, tile);\n    }\n    nextMachineId() {\n        return ++this.machineCount;\n    }\n    getMachine(x, y) {\n        return this.machine[x][y];\n    }\n    setMachine(x, y, id, isRoom = true) {\n        this.machine[x][y] = id;\n        if (id == 0) {\n            this.clearSiteFlag(x, y, Flags.IS_IN_MACHINE);\n        }\n        else {\n            this.setSiteFlag(x, y, isRoom ? Flags.IS_IN_ROOM_MACHINE : Flags.IS_IN_AREA_MACHINE);\n        }\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as DIG_UTILS from '../dig/utils';\n// {\n//     tile: number;\n//     grow: number;\n//     decrement: number;\n//     matchTile: number;\n//     flags: number;\n//     volume: number;\n//     next: string | null;\n// }\n// export class SpawnEffect implements GW.effect.EffectHandler {\n//     make(\n//         src: Partial<GW.effect.EffectConfig>,\n//         dest: GW.effect.EffectInfo\n//     ): boolean {\n//         if (!src.tile) return true; // no error\n//         let config = src.tile;\n//         if (typeof config === 'string') {\n//             const parts = config.split(/[,|]/).map((p) => p.trim());\n//             config = {\n//                 tile: parts[0],\n//                 grow: Number.parseInt(parts[1]),\n//                 decrement: Number.parseInt(parts[2]),\n//             };\n//         } else if (typeof config === 'number') {\n//             config = { tile: config };\n//         }\n//         const info: SpawnInfo = {\n//             tile: 0,\n//             grow: config.grow || 100,\n//             decrement: config.decrement || 0,\n//             matchTile: 0,\n//             flags: GW.flag.from(GW.effect.Flags, config.flags),\n//             volume: config.volume || 0,\n//             next: config.next || null,\n//         };\n//         if (typeof config.tile === 'string') {\n//             const obj = MAP.tile.tiles[config.tile];\n//             if (!obj) {\n//                 throw new Error(\n//                     'Failed to find tile with name: ' + config.tile\n//                 );\n//             }\n//             info.tile = obj.index;\n//         } else {\n//             info.tile = config.tile || 0;\n//         }\n//         if (!info.tile) {\n//             throw new Error('Must have tile.');\n//         }\n//         if (typeof config.matchTile === 'string') {\n//             const obj = MAP.tile.tiles[config.matchTile];\n//             if (!obj) {\n//                 throw new Error(\n//                     'Failed to find tile with name: ' + config.tile\n//                 );\n//             }\n//             info.matchTile = obj.index;\n//         } else {\n//             info.matchTile = config.matchTile || 0;\n//         }\n//         dest.tile = info;\n//         return true;\n//     }\n//     async fire(\n//         config: any,\n//         map: GW.types.MapType,\n//         x: number,\n//         y: number,\n//         ctx: Partial<GW.effect.EffectCtx>\n//     ): Promise<boolean> {\n//         if (!config.tile) return false; // did nothing\n//         const spawner = new Spawner(config.tile);\n//         const locs = GW.grid.alloc(site.width, site.height);\n//         const count = spawner.fill(x, y, site, locs);\n//         if (spawner.abortIfBlocks) {\n//             if (DIG_UTILS.siteDisruptedBy(site, locs)) {\n//                 return false;\n//             }\n//         }\n//         spawner.spawnTiles(site, locs);\n//         GW.grid.free(locs);\n//         return count > 0;\n//     }\n// }\nexport function spawn(effect, x, y, site) {\n    const spawner = new Spawner(effect);\n    const locs = GW.grid.alloc(site.width, site.height);\n    const count = spawner.fill(x, y, site, locs);\n    if (!count) {\n        GW.grid.free(locs);\n        return false;\n    }\n    if (spawner.abortIfBlocks) {\n        if (DIG_UTILS.siteDisruptedBy(site, locs)) {\n            GW.grid.free(locs);\n            return false;\n        }\n    }\n    const didSomething = spawner.spawnTiles(site, locs);\n    GW.grid.free(locs);\n    return didSomething;\n}\nexport class Spawner {\n    constructor(info) {\n        this.info = info;\n        if (!info.tile)\n            throw new Error('Invalid effect - requires \"tile\".');\n        // if (this.growProb >= 100) {\n        //     this.probDecrement = this.probDecrement || 100;\n        //     if (this.probDecrement <= 0) {\n        //         this.probDecrement = growProb;\n        //     }\n        // }\n    }\n    get abortIfBlocks() {\n        return !!(this.info.flags & GW.effect.Flags.E_ABORT_IF_BLOCKS_MAP);\n    }\n    spawn(x, y, site) {\n        const locs = GW.grid.alloc(site.width, site.height);\n        const count = this.fill(x, y, site, locs);\n        if (this.abortIfBlocks) {\n            if (DIG_UTILS.siteDisruptedBy(site, locs)) {\n                return false;\n            }\n        }\n        this.spawnTiles(site, locs);\n        GW.grid.free(locs);\n        return count;\n    }\n    compute(x, y, cb) {\n        const config = this.info.tile;\n        let growProb = config.grow;\n        let probDec = config.decrement;\n        if (!cb(x, y)) {\n            return 0;\n        }\n        let todo = [\n            [x + 1, y],\n            [x - 1, y],\n            [x, y + 1],\n            [x, y - 1],\n        ];\n        let working = [];\n        const done = new Set([`${x},${y}`]);\n        let count = 1;\n        while (todo.length && growProb > 0) {\n            [working, todo] = [todo, working];\n            while (working.length) {\n                let [i, j] = working.pop();\n                if (GW.random.chance(growProb) && cb(i, j)) {\n                    count++;\n                    GW.utils.eachNeighbor(i, j, (i2, j2) => {\n                        const index = i2 + ',' + j2;\n                        if (done.has(index))\n                            return;\n                        done.add(index);\n                        todo.push([i2, j2]);\n                    }, true);\n                }\n            }\n            growProb -= probDec;\n        }\n        return count;\n    }\n    fill(x, y, site, grid) {\n        return this.compute(x, y, (i, j) => {\n            if (!this.cellIsOk(site, i, j, i == x && j == y))\n                return false;\n            grid[i][j] = 1;\n            return true;\n        });\n    }\n    cellIsOk(site, x, y, isStart) {\n        if (!site.hasXY(x, y))\n            return false;\n        if (site.blocksEffects(x, y) && !this.info.tile.matchTile && !isStart) {\n            return false;\n        }\n        if (this.info.flags & GW.effect.Flags.E_BUILD_IN_WALLS) {\n            if (!site.isWall(x, y))\n                return false;\n        }\n        else if (this.info.flags & GW.effect.Flags.E_MUST_TOUCH_WALLS) {\n            let ok = false;\n            GW.utils.eachNeighbor(x, y, (i, j) => {\n                if (site.isWall(i, j)) {\n                    ok = true;\n                }\n            }, true);\n            if (!ok)\n                return false;\n        }\n        else if (this.info.flags & GW.effect.Flags.E_NO_TOUCH_WALLS) {\n            let ok = true;\n            if (site.isWall(x, y))\n                return false; // or on wall\n            GW.utils.eachNeighbor(x, y, (i, j) => {\n                if (site.isWall(i, j)) {\n                    ok = false;\n                }\n            }, true);\n            if (!ok)\n                return false;\n        }\n        if (this.info.tile.matchTile &&\n            !isStart &&\n            !site.hasTile(x, y, this.info.tile.matchTile)) {\n            return false;\n        }\n        return true;\n    }\n    spawnTiles(site, locs) {\n        let didSomething = false;\n        const options = {\n            superpriority: !!(this.info.flags & GW.effect.Flags.E_SUPERPRIORITY),\n            blockedByOtherLayers: !!(this.info.flags & GW.effect.Flags.E_BLOCKED_BY_OTHER_LAYERS),\n            blockedByActors: !!(this.info.flags & GW.effect.Flags.E_BLOCKED_BY_ACTORS),\n            blockedByItems: !!(this.info.flags & GW.effect.Flags.E_BLOCKED_BY_ITEMS),\n            volume: this.info.tile.volume,\n        };\n        locs.forEach((v, i, j) => {\n            if (v) {\n                locs[i][j] = 0;\n                if (site.placeTile(i, j, this.info.tile, options)) {\n                    locs[i][j] = 1;\n                    didSomething = true;\n                }\n            }\n        });\n        return didSomething;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as DIG_UTILS from '../dig/utils';\nimport { Flags } from './blueprint';\nimport { Spawner } from './spawn';\nconst Fl = GW.flag.fl;\nexport var StepFlags;\n(function (StepFlags) {\n    // BF_GENERATE_ITEM\t\t\t\t= Fl(0),\t// feature entails generating an item (overridden if the machine is adopting an item)\n    // BF_GENERATE_HORDE\t\t\t= Fl(5),\t// generate a monster horde that has all of the horde flags\n    // BF_NO_THROWING_WEAPONS\t    = Fl(4),\t// the generated item cannot be a throwing weapon\n    // BF_REQUIRE_GOOD_RUNIC\t\t= Fl(18),\t// generated item must be uncursed runic\n    StepFlags[StepFlags[\"BF_OUTSOURCE_ITEM_TO_MACHINE\"] = Fl(1)] = \"BF_OUTSOURCE_ITEM_TO_MACHINE\";\n    StepFlags[StepFlags[\"BF_BUILD_VESTIBULE\"] = Fl(2)] = \"BF_BUILD_VESTIBULE\";\n    StepFlags[StepFlags[\"BF_ADOPT_ITEM\"] = Fl(3)] = \"BF_ADOPT_ITEM\";\n    StepFlags[StepFlags[\"BF_BUILD_AT_ORIGIN\"] = Fl(6)] = \"BF_BUILD_AT_ORIGIN\";\n    // unused                   = Fl(7),\t//\n    StepFlags[StepFlags[\"BF_PERMIT_BLOCKING\"] = Fl(8)] = \"BF_PERMIT_BLOCKING\";\n    StepFlags[StepFlags[\"BF_TREAT_AS_BLOCKING\"] = Fl(9)] = \"BF_TREAT_AS_BLOCKING\";\n    StepFlags[StepFlags[\"BF_NEAR_ORIGIN\"] = Fl(10)] = \"BF_NEAR_ORIGIN\";\n    StepFlags[StepFlags[\"BF_FAR_FROM_ORIGIN\"] = Fl(11)] = \"BF_FAR_FROM_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_VIEW_OF_ORIGIN\"] = Fl(25)] = \"BF_IN_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_IN_PASSABLE_VIEW_OF_ORIGIN\"] = Fl(26)] = \"BF_IN_PASSABLE_VIEW_OF_ORIGIN\";\n    StepFlags[StepFlags[\"BF_MONSTER_TAKE_ITEM\"] = Fl(12)] = \"BF_MONSTER_TAKE_ITEM\";\n    StepFlags[StepFlags[\"BF_MONSTER_SLEEPING\"] = Fl(13)] = \"BF_MONSTER_SLEEPING\";\n    StepFlags[StepFlags[\"BF_MONSTER_FLEEING\"] = Fl(14)] = \"BF_MONSTER_FLEEING\";\n    StepFlags[StepFlags[\"BF_MONSTERS_DORMANT\"] = Fl(19)] = \"BF_MONSTERS_DORMANT\";\n    StepFlags[StepFlags[\"BF_ITEM_IS_KEY\"] = Fl(0)] = \"BF_ITEM_IS_KEY\";\n    StepFlags[StepFlags[\"BF_ITEM_IDENTIFIED\"] = Fl(5)] = \"BF_ITEM_IDENTIFIED\";\n    StepFlags[StepFlags[\"BF_ITEM_PLAYER_AVOIDS\"] = Fl(4)] = \"BF_ITEM_PLAYER_AVOIDS\";\n    StepFlags[StepFlags[\"BF_EVERYWHERE\"] = Fl(15)] = \"BF_EVERYWHERE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE\"] = Fl(16)] = \"BF_ALTERNATIVE\";\n    StepFlags[StepFlags[\"BF_ALTERNATIVE_2\"] = Fl(17)] = \"BF_ALTERNATIVE_2\";\n    // unused                       = Fl(20),\t//\n    StepFlags[StepFlags[\"BF_BUILD_IN_WALLS\"] = Fl(21)] = \"BF_BUILD_IN_WALLS\";\n    StepFlags[StepFlags[\"BF_BUILD_ANYWHERE_ON_LEVEL\"] = Fl(22)] = \"BF_BUILD_ANYWHERE_ON_LEVEL\";\n    StepFlags[StepFlags[\"BF_REPEAT_UNTIL_NO_PROGRESS\"] = Fl(23)] = \"BF_REPEAT_UNTIL_NO_PROGRESS\";\n    StepFlags[StepFlags[\"BF_IMPREGNABLE\"] = Fl(24)] = \"BF_IMPREGNABLE\";\n    StepFlags[StepFlags[\"BF_NOT_IN_HALLWAY\"] = Fl(27)] = \"BF_NOT_IN_HALLWAY\";\n    StepFlags[StepFlags[\"BF_NOT_ON_LEVEL_PERIMETER\"] = Fl(28)] = \"BF_NOT_ON_LEVEL_PERIMETER\";\n    StepFlags[StepFlags[\"BF_SKELETON_KEY\"] = Fl(29)] = \"BF_SKELETON_KEY\";\n    StepFlags[StepFlags[\"BF_KEY_DISPOSABLE\"] = Fl(30)] = \"BF_KEY_DISPOSABLE\";\n})(StepFlags || (StepFlags = {}));\nexport class BuildStep {\n    constructor(cfg = {}) {\n        this.tile = 0;\n        this.flags = 0;\n        this.pad = 0;\n        this.item = null;\n        this.horde = null;\n        this.spawn = null;\n        if (cfg.tile) {\n            if (typeof cfg.tile === 'string') {\n                const t = GW.tile.tiles[cfg.tile];\n                if (!t) {\n                    throw new Error('Failed to find tile: ' + cfg.tile);\n                }\n                this.tile = t.index;\n            }\n            else {\n                this.tile = cfg.tile;\n            }\n        }\n        if (cfg.flags) {\n            this.flags = GW.flag.from(StepFlags, cfg.flags);\n        }\n        if (cfg.pad) {\n            this.pad = cfg.pad;\n        }\n        this.count = GW.range.make(cfg.count || 1);\n        this.item = cfg.item || null;\n        this.horde = cfg.horde || null;\n        if (cfg.spawn) {\n            this.spawn = GW.effect.from(cfg.spawn);\n        }\n    }\n    cellIsCandidate(builder, blueprint, x, y, distanceBound) {\n        const site = builder.site;\n        // No building in the hallway if it's prohibited.\n        // This check comes before the origin check, so an area machine will fail altogether\n        // if its origin is in a hallway and the feature that must be built there does not permit as much.\n        if (this.flags & StepFlags.BF_NOT_IN_HALLWAY &&\n            GW.utils.arcCount(x, y, (i, j) => site.hasXY(i, j) && site.isPassable(i, j)) > 1) {\n            return false;\n        }\n        // No building along the perimeter of the level if it's prohibited.\n        if (this.flags & StepFlags.BF_NOT_ON_LEVEL_PERIMETER &&\n            (x == 0 || x == site.width - 1 || y == 0 || y == site.height - 1)) {\n            return false;\n        }\n        // The origin is a candidate if the feature is flagged to be built at the origin.\n        // If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.\n        if (this.flags & StepFlags.BF_BUILD_AT_ORIGIN) {\n            return x == builder.originX && y == builder.originY ? true : false;\n        }\n        else if (blueprint.isRoom &&\n            x == builder.originX &&\n            y == builder.originY) {\n            return false;\n        }\n        // No building in another feature's personal space!\n        if (builder.occupied[x][y]) {\n            return false;\n        }\n        // Must be in the viewmap if the appropriate flag is set.\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) &&\n            !builder.viewMap[x][y]) {\n            return false;\n        }\n        // Do a distance check if the feature requests it.\n        let distance = 10000;\n        if (site.isWall(x, y)) {\n            // Distance is calculated for walls too.\n            GW.utils.eachNeighbor(x, y, (i, j) => {\n                if (!builder.distanceMap.hasXY(i, j))\n                    return;\n                if (!site.blocksPathing(i, j) &&\n                    distance > builder.distanceMap[i][j] + 1) {\n                    distance = builder.distanceMap[i][j] + 1;\n                }\n            }, true);\n        }\n        else {\n            distance = builder.distanceMap[x][y];\n        }\n        if (distance > distanceBound[1] || // distance exceeds max\n            distance < distanceBound[0]) {\n            // distance falls short of min\n            return false;\n        }\n        if (this.flags & StepFlags.BF_BUILD_IN_WALLS) {\n            // If we're supposed to build in a wall...\n            const cellMachine = site.getMachine(x, y);\n            if (!builder.interior[x][y] &&\n                (!cellMachine || cellMachine == builder.machineNumber) &&\n                site.isWall(x, y)) {\n                let ok = false;\n                // ...and this location is a wall that's not already machined...\n                GW.utils.eachNeighbor(x, y, (newX, newY) => {\n                    if (site.hasXY(newX, newY) && // ...and it's next to an interior spot or permitted elsewhere and next to passable spot...\n                        ((builder.interior[newX][newY] &&\n                            !(newX == builder.originX &&\n                                newY == builder.originY)) ||\n                            (this.flags &\n                                StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL &&\n                                !site.blocksPathing(newX, newY) &&\n                                !site.getMachine(newX, newY)))) {\n                        ok = true;\n                    }\n                });\n                return ok;\n            }\n            return false;\n        }\n        else if (site.isWall(x, y)) {\n            // Can't build in a wall unless instructed to do so.\n            return false;\n        }\n        else if (this.flags & StepFlags.BF_BUILD_ANYWHERE_ON_LEVEL) {\n            if ((this.item && site.blocksItems(x, y)) ||\n                site.hasSiteFlag(x, y, SITE.Flags.IS_CHOKEPOINT |\n                    SITE.Flags.IS_IN_LOOP |\n                    SITE.Flags.IS_IN_MACHINE)) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        else if (builder.interior[x][y]) {\n            return true;\n        }\n        return false;\n    }\n    makePersonalSpace(builder, x, y, candidates) {\n        const personalSpace = this.pad;\n        let count = 0;\n        for (let i = x - personalSpace + 1; i <= x + personalSpace - 1; i++) {\n            for (let j = y - personalSpace + 1; j <= y + personalSpace - 1; j++) {\n                if (builder.site.hasXY(i, j)) {\n                    if (candidates[i][j]) {\n                        candidates[i][j] = 0;\n                        ++count;\n                    }\n                    builder.occupied[i][j] = 1;\n                }\n            }\n        }\n        return count;\n    }\n    build(builder, blueprint) {\n        let generateEverywhere = false;\n        let instanceCount = 0;\n        let instance = 0;\n        const site = builder.site;\n        const candidates = GW.grid.alloc(site.width, site.height);\n        // Figure out the distance bounds.\n        const distanceBound = [0, 10000];\n        if (this.flags & StepFlags.BF_NEAR_ORIGIN) {\n            distanceBound[1] = builder.distance25;\n        }\n        if (this.flags & StepFlags.BF_FAR_FROM_ORIGIN) {\n            distanceBound[0] = builder.distance75;\n        }\n        if (this.flags &\n            (StepFlags.BF_IN_VIEW_OF_ORIGIN |\n                StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN)) {\n            if (this.flags & StepFlags.BF_IN_PASSABLE_VIEW_OF_ORIGIN) {\n                const fov = new GW.fov.FOV({\n                    isBlocked: (x, y) => {\n                        return site.blocksPathing(x, y);\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            else {\n                const fov = new GW.fov.FOV({\n                    // TileFlags.T_OBSTRUCTS_PASSABILITY |\n                    //     TileFlags.T_OBSTRUCTS_VISION,\n                    isBlocked: (x, y) => {\n                        return (site.blocksPathing(x, y) || site.blocksVision(x, y));\n                    },\n                    hasXY: (x, y) => {\n                        return site.hasXY(x, y);\n                    },\n                });\n                fov.calculate(builder.originX, builder.originY, 50, (x, y) => {\n                    builder.viewMap[x][y] = 1;\n                });\n            }\n            builder.viewMap[builder.originX][builder.originY] = 1;\n        }\n        do {\n            // If the StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.\n            // Make a master map of candidate locations for this feature.\n            let qualifyingTileCount = 0;\n            candidates.update((_v, i, j) => {\n                if (this.cellIsCandidate(builder, blueprint, i, j, distanceBound)) {\n                    qualifyingTileCount++;\n                    return 1;\n                }\n                else {\n                    return 0;\n                }\n            });\n            if (this.flags &\n                StepFlags.BF_EVERYWHERE &\n                ~StepFlags.BF_BUILD_AT_ORIGIN) {\n                // Generate everywhere that qualifies -- instead of randomly picking tiles, keep spawning until we run out of eligible tiles.\n                generateEverywhere = true;\n            }\n            else {\n                // build as many instances as required\n                generateEverywhere = false;\n                instanceCount = this.count.value();\n            }\n            if (!qualifyingTileCount || qualifyingTileCount < this.count.lo) {\n                console.warn('Only %s qualifying tiles - want at least %s.', qualifyingTileCount, this.count.lo);\n            }\n            let x = 0, y = 0;\n            for (instance = 0; (generateEverywhere || instance < instanceCount) &&\n                qualifyingTileCount > 0;) {\n                // Find a location for the feature.\n                if (this.flags & StepFlags.BF_BUILD_AT_ORIGIN) {\n                    // Does the feature want to be at the origin? If so, put it there. (Just an optimization.)\n                    x = builder.originX;\n                    y = builder.originY;\n                }\n                else {\n                    // Pick our candidate location randomly, and also strike it from\n                    // the candidates map so that subsequent instances of this same feature can't choose it.\n                    x = -1;\n                    let randIndex = GW.random.range(1, qualifyingTileCount);\n                    candidates.forEach((v, i, j) => {\n                        if (!v)\n                            return;\n                        if (randIndex == 1) {\n                            // This is the place!\n                            x = i;\n                            y = j;\n                            return false;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    });\n                }\n                // Don't waste time trying the same place again whether or not this attempt succeeds.\n                candidates[x][y] = 0;\n                qualifyingTileCount--;\n                let DFSucceeded = true;\n                let terrainSucceeded = true;\n                // Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.\n                if (this.spawn) {\n                    const spawner = new Spawner(this.spawn);\n                    spawner.spawn(x, y, site);\n                }\n                // Now try to place the terrain tile, if any.\n                if (DFSucceeded && this.tile) {\n                    let tile = this.tile;\n                    if (typeof tile == 'string')\n                        tile = GW.tile.tiles[tile].index;\n                    if (!tile) {\n                        terrainSucceeded = false;\n                        console.error('placing invalid tile', this.tile, x, y);\n                    }\n                    else if (!(this.flags & StepFlags.BF_PERMIT_BLOCKING) &&\n                        (site.tileBlocksMove(tile) ||\n                            this.flags & StepFlags.BF_TREAT_AS_BLOCKING)) {\n                        // Yes, check for blocking.\n                        const blockingMap = GW.grid.alloc(site.width, site.height);\n                        blockingMap[x][y] = 1;\n                        terrainSucceeded = !DIG_UTILS.siteDisruptedBy(site, blockingMap);\n                        GW.grid.free(blockingMap);\n                    }\n                    if (terrainSucceeded) {\n                        site.setTile(x, y, tile);\n                    }\n                }\n                // OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.\n                // Personal space of 0 means nothing gets cleared, 1 means that only the tile itself gets cleared, and 2 means the 3x3 grid centered on it.\n                if (DFSucceeded && terrainSucceeded) {\n                    qualifyingTileCount -= this.makePersonalSpace(builder, x, y, candidates);\n                    instance++; // we've placed an instance\n                    //DEBUG printf(\"\\nPlaced instance #%i of feature %i at (%i, %i).\", instance, feat, featX, featY);\n                }\n                if (DFSucceeded && terrainSucceeded) {\n                    // Proceed only if the terrain stuff for this instance succeeded.\n                    // Mark the feature location as part of the machine, in case it is not already inside of it.\n                    if (!(blueprint.flags & Flags.BP_NO_INTERIOR_FLAG)) {\n                        site.setMachine(x, y, builder.machineNumber, blueprint.isRoom);\n                    }\n                    // Mark the feature location as impregnable if requested.\n                    if (this.flags & StepFlags.BF_IMPREGNABLE) {\n                        site.setSiteFlag(x, y, SITE.Flags.IMPREGNABLE);\n                    }\n                    // let success = RUT.Component.generateAdoptItem(\n                    //     component,\n                    //     blueprint,\n                    //     map,\n                    //     xy.x,\n                    //     xy.y,\n                    //     context\n                    // );\n                    // if (!success) {\n                    //     GW.grid.free(candidates);\n                    //     return false;\n                    // }\n                    // // Generate a horde as necessary.\n                    // success = RUT.Component.generateMonsters(\n                    //     component,\n                    //     blueprint,\n                    //     map,\n                    //     xy.x,\n                    //     xy.y,\n                    //     context\n                    // );\n                    // if (!success) {\n                    //     GW.grid.free(candidates);\n                    //     return false;\n                    // }\n                }\n                // Finished with this instance!\n            }\n        } while (this.flags & StepFlags.BF_REPEAT_UNTIL_NO_PROGRESS &&\n            instance <= this.count.lo);\n        //DEBUG printf(\"\\nFinished feature %i. Here's the candidates map:\", feat);\n        //DEBUG logBuffer(candidates);\n        GW.grid.free(candidates);\n        return instance;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as DIG_SITE from '../dig/site';\nimport * as STEP from './buildStep';\nimport * as DIG_UTILS from '../dig/utils';\nconst Fl = GW.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(10)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(7)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(0)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(2)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(3)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(4)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(5)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(6)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(8)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(9)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(14)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(11)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(12)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(13)] = \"BP_NO_INTERIOR_FLAG\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.size = [-1, -1];\n        this.flags = 0;\n        this.steps = [];\n        this.id = 'n/a';\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GW.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            if (typeof opts.size === 'string') {\n                const parts = opts.size\n                    .split(/-/)\n                    .map((v) => v.trim())\n                    .map((v) => Number.parseInt(v));\n                if (parts.length !== 2)\n                    throw new Error('Blueprint size must be of format: #-#');\n                this.size = [parts[0], parts[1]];\n            }\n            else if (Array.isArray(opts.size)) {\n                if (opts.size.length !== 2)\n                    throw new Error('Blueprint size must be [min, max]');\n                this.size = [opts.size[0], opts.size[1]];\n            }\n            else {\n                throw new Error('size must be string or array.');\n            }\n            if (this.size[0] > this.size[1])\n                throw new Error('Blueprint size must be small to large.');\n        }\n        if (opts.flags) {\n            this.flags = GW.flag.from(Flags, opts.flags);\n        }\n        if (opts.steps) {\n            this.steps = opts.steps.map((cfg) => new STEP.BuildStep(cfg));\n        }\n    }\n    getChance(level, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return 0;\n        }\n        return this.frequency(level);\n    }\n    get isRoom() {\n        return !!(this.flags & Flags.BP_ROOM);\n    }\n    get isReward() {\n        return !!(this.flags & Flags.BP_REWARD);\n    }\n    get isVestiblue() {\n        return !!(this.flags & Flags.BP_VESTIBULE);\n    }\n    get adoptsItem() {\n        return !!(this.flags & Flags.BP_ADOPT_ITEM);\n    }\n    get treatAsBlocking() {\n        return !!(this.flags & Flags.BP_TREAT_AS_BLOCKING);\n    }\n    get requireBlocking() {\n        return !!(this.flags & Flags.BP_REQUIRE_BLOCKING);\n    }\n    get purgeInterior() {\n        return !!(this.flags & Flags.BP_PURGE_INTERIOR);\n    }\n    get purgeBlockers() {\n        return !!(this.flags & Flags.BP_PURGE_PATHING_BLOCKERS);\n    }\n    get purgeLiquids() {\n        return !!(this.flags & Flags.BP_PURGE_LIQUIDS);\n    }\n    get surroundWithWalls() {\n        return !!(this.flags & Flags.BP_SURROUND_WITH_WALLS);\n    }\n    get makeImpregnable() {\n        return !!(this.flags & Flags.BP_IMPREGNABLE);\n    }\n    get maximizeInterior() {\n        return !!(this.flags & Flags.BP_MAXIMIZE_INTERIOR);\n    }\n    get openInterior() {\n        return !!(this.flags & Flags.BP_OPEN_INTERIOR);\n    }\n    get noInteriorFlag() {\n        return !!(this.flags & Flags.BP_NO_INTERIOR_FLAG);\n    }\n    qualifies(requiredFlags, depth) {\n        if (this.frequency(depth) <= 0 ||\n            // Must have the required flags:\n            ~this.flags & requiredFlags ||\n            // May NOT have BP_ADOPT_ITEM unless that flag is required:\n            this.flags & Flags.BP_ADOPT_ITEM & ~requiredFlags ||\n            // May NOT have BP_VESTIBULE unless that flag is required:\n            this.flags & Flags.BP_VESTIBULE & ~requiredFlags) {\n            return false;\n        }\n        return true;\n    }\n    pickLocation(site) {\n        // Find a location and map out the machine interior.\n        if (this.isRoom) {\n            // If it's a room machine, count up the gates of appropriate\n            // choke size and remember where they are. The origin of the room will be the gate location.\n            // RUT.Map.analyze(map, true); // Make sure the chokeMap is up to date.\n            const randSite = GW.random.matchingLoc(site.width, site.height, (x, y) => site.hasSiteFlag(x, y, SITE.Flags.IS_GATE_SITE));\n            if (!randSite || randSite[0] < 0 || randSite[1] < 0) {\n                // If no suitable sites, abort.\n                console.log('Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint.');\n                return false;\n            }\n            return randSite;\n        }\n        else if (this.isVestiblue) {\n            //  Door machines must have locations passed in. We can't pick one ourselves.\n            console.log('ERROR: Attempted to build a vestiblue without a location being provided.');\n            return false;\n        }\n        // Pick a random origin location.\n        const pos = GW.random.matchingLoc(site.width, site.height, (x, y) => site.isPassable(x, y));\n        if (!pos || pos[0] < 0 || pos[1] < 0)\n            return false;\n        return pos;\n    }\n    // Assume site has been analyzed (aka GateSites and ChokeCounts set)\n    computeInterior(builder) {\n        let failsafe = this.isRoom ? 10 : 20;\n        let tryAgain;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            tryAgain = false;\n            if (--failsafe <= 0) {\n                console.log('Failed to build a machine; failed repeatedly to find a suitable blueprint location.');\n                return false;\n            }\n            interior.fill(0);\n            // Find a location and map out the machine interior.\n            if (this.isRoom) {\n                // If it's a room machine, count up the gates of appropriate\n                // choke size and remember where they are. The origin of the room will be the gate location.\n                // Now map out the interior into interior[][].\n                // Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the\n                // same or lower choke value, ignoring any tiles that are already part of a machine.\n                // If we get false from this, try again. If we've tried too many times already, abort.\n                tryAgain = !this.addTileToInteriorAndIterate(builder, builder.originX, builder.originY);\n            }\n            else if (this.isVestiblue) {\n                if (!this.computeInteriorForVestibuleMachine(builder)) {\n                    // TODO - tryagain = true?\n                    console.error('ERROR: Attempted to build a door machine from blueprint: not enough room.');\n                    return false;\n                }\n                // success\n            }\n            else {\n                // Find a location and map out the interior for a non-room machine.\n                // The strategy here is simply to pick a random location on the map,\n                // expand it along a pathing map by one space in all directions until the size reaches\n                // the chosen size, and then make sure the resulting space qualifies.\n                // If not, try again. If we've tried too many times already, abort.\n                let distanceMap = GW.grid.alloc(interior.width, interior.height);\n                DIG_UTILS.computeDistanceMap(site, distanceMap, builder.originX, builder.originY, this.size[1]);\n                const seq = GW.random.sequence(site.width * site.height);\n                let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n                let totalFreq = GW.random.range(this.size[0], this.size[1]); // Keeps track of the goal size.\n                for (let k = 0; k < 1000 && qualifyingTileCount < totalFreq; k++) {\n                    for (let n = 0; n < seq.length && qualifyingTileCount < totalFreq; n++) {\n                        const i = Math.floor(seq[n] / site.height);\n                        const j = seq[n] % site.height;\n                        if (distanceMap[i][j] == k) {\n                            interior[i][j] = 1;\n                            qualifyingTileCount++;\n                            if (site.isOccupied(i, j) ||\n                                site.hasSiteFlag(i, j, SITE.Flags.IS_IN_MACHINE)) {\n                                // Abort if we've entered another machine or engulfed another machine's item or monster.\n                                tryAgain = true;\n                                qualifyingTileCount = totalFreq; // This is a hack to drop out of these three for-loops.\n                            }\n                        }\n                    }\n                }\n                // Now make sure the interior map satisfies the machine's qualifications.\n                if (qualifyingTileCount < totalFreq) {\n                    tryAgain = true;\n                    console.log('too small');\n                }\n                else if (this.treatAsBlocking &&\n                    DIG_UTILS.siteDisruptedBy(site, interior)) {\n                    console.log('disconnected');\n                    tryAgain = true;\n                }\n                else if (this.requireBlocking &&\n                    DIG_UTILS.siteDisruptedSize(site, interior) < 100) {\n                    console.log('not disconnected enough');\n                    tryAgain = true; // BP_REQUIRE_BLOCKING needs some work to make sure the disconnect is interesting.\n                }\n                // If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.\n                // If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.\n                GW.grid.free(distanceMap);\n            }\n            // Now loop if necessary.\n        } while (tryAgain);\n        console.log(tryAgain, failsafe);\n        return true;\n    }\n    // Assumes (startX, startY) is in the machine.\n    // Returns true if everything went well, and false if we ran into a machine component\n    // that was already there, as we don't want to build a machine around it.\n    addTileToInteriorAndIterate(builder, startX, startY) {\n        let goodSoFar = true;\n        const interior = builder.interior;\n        const site = builder.site;\n        interior[startX][startY] = 1;\n        const startChokeCount = site.getChokeCount(startX, startY);\n        for (let dir = 0; dir < 4 && goodSoFar; dir++) {\n            const newX = startX + GW.utils.DIRS[dir][0];\n            const newY = startY + GW.utils.DIRS[dir][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            if (interior[newX][newY])\n                continue; // already done\n            if (site.isOccupied(newX, newY) ||\n                (site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_MACHINE) &&\n                    !site.hasSiteFlag(newX, newY, SITE.Flags.IS_GATE_SITE))) {\n                // Abort if there's an item in the room.\n                // Items haven't been populated yet, so the only way this could happen is if another machine\n                // previously placed an item here.\n                // Also abort if we're touching another machine at any point other than a gate tile.\n                return false;\n            }\n            if (site.getChokeCount(newX, newY) <= startChokeCount && // don't have to worry about walls since they're all 30000\n                !site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_MACHINE)) {\n                goodSoFar = this.addTileToInteriorAndIterate(builder, newX, newY);\n            }\n        }\n        return goodSoFar;\n    }\n    computeInteriorForVestibuleMachine(builder) {\n        let success = true;\n        const interior = builder.interior;\n        const site = builder.site;\n        interior.fill(0);\n        let qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.\n        const totalFreq = GW.random.range(this.size[0], this.size[1]); // Keeps track of the goal size.\n        const distMap = GW.grid.alloc(site.width, site.height);\n        DIG_UTILS.computeDistanceMap(site, distMap, builder.originX, builder.originY, this.size[1]);\n        // console.log('DISTANCE MAP', originX, originY);\n        // RUT.Grid.dump(distMap);\n        const cells = GW.random.sequence(site.width * site.height);\n        for (let k = 0; k < 1000 && qualifyingTileCount < totalFreq; k++) {\n            for (let i = 0; i < cells.length && qualifyingTileCount < totalFreq; ++i) {\n                const x = Math.floor(cells[i] / site.height);\n                const y = cells[i] % site.height;\n                const dist = distMap[x][y];\n                if (dist != k)\n                    continue;\n                if (site.isOccupied(x, y)) {\n                    success = false;\n                    qualifyingTileCount = totalFreq;\n                }\n                interior[x][y] = 1;\n                qualifyingTileCount += 1;\n            }\n        }\n        // Now make sure the interior map satisfies the machine's qualifications.\n        if (this.treatAsBlocking && DIG_UTILS.siteDisruptedBy(site, interior)) {\n            success = false;\n        }\n        else if (this.requireBlocking &&\n            DIG_UTILS.siteDisruptedSize(site, interior) < 100) {\n            success = false;\n        }\n        GW.grid.free(distMap);\n        return success;\n    }\n    prepareInteriorWithMachineFlags(builder) {\n        const interior = builder.interior;\n        const site = builder.site;\n        // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms\n        if (this.maximizeInterior) {\n            this.expandMachineInterior(builder, 1);\n        }\n        else if (this.openInterior) {\n            this.expandMachineInterior(builder, 4);\n        }\n        // If requested, cleanse the interior -- no interesting terrain allowed.\n        if (this.purgeInterior) {\n            interior.forEach((v, x, y) => {\n                if (v)\n                    site.setTile(x, y, DIG_SITE.FLOOR);\n            });\n        }\n        // If requested, purge pathing blockers -- no traps allowed.\n        if (this.purgeBlockers) {\n            interior.forEach((v, x, y) => {\n                if (!v)\n                    return;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, DIG_SITE.FLOOR);\n                }\n            });\n        }\n        // If requested, purge the liquid layer in the interior -- no liquids allowed.\n        if (this.purgeLiquids) {\n            interior.forEach((v, x, y) => {\n                if (v && site.isAnyLiquid(x, y)) {\n                    site.setTile(x, y, DIG_SITE.FLOOR);\n                }\n            });\n        }\n        // Surround with walls if requested.\n        if (this.surroundWithWalls) {\n            interior.forEach((v, x, y) => {\n                if (!v || site.hasSiteFlag(x, y, SITE.Flags.IS_GATE_SITE))\n                    return;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not valid x,y\n                    if (interior[i][j])\n                        return; // is part of machine\n                    if (site.isWall(i, j))\n                        return; // is already a wall (of some sort)\n                    if (site.hasSiteFlag(i, j, SITE.Flags.IS_GATE_SITE))\n                        return; // is a door site\n                    if (site.hasSiteFlag(i, j, SITE.Flags.IS_IN_MACHINE))\n                        return; // is part of a machine\n                    if (!site.blocksPathing(i, j))\n                        return; // is not a blocker for the player (water?)\n                    site.setTile(i, j, DIG_SITE.WALL);\n                }, false);\n            });\n        }\n        // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.\n        // Then zero out any portion of the interior that is still wall.\n        // if (flags & BPFlags.BP_REDESIGN_INTERIOR) {\n        //     RUT.Map.Blueprint.redesignInterior(map, interior, originX, originY, dungeonProfileIndex);\n        // }\n        // Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.\n        if (this.makeImpregnable) {\n            interior.forEach((v, x, y) => {\n                if (!v || site.hasSiteFlag(x, y, SITE.Flags.IS_GATE_SITE))\n                    return;\n                site.setSiteFlag(x, y, SITE.Flags.IMPREGNABLE);\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (interior[i][j])\n                        return;\n                    if (site.hasSiteFlag(i, j, SITE.Flags.IS_GATE_SITE))\n                        return;\n                    site.setSiteFlag(i, j, SITE.Flags.IMPREGNABLE);\n                }, false);\n            });\n        }\n        // If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.\n        const machineNumber = builder.machineNumber;\n        interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            site.setMachine(x, y, machineNumber, this.isRoom);\n            // secret doors mess up machines\n            if (site.isSecretDoor(x, y)) {\n                site.setTile(x, y, DIG_SITE.DOOR);\n            }\n        });\n    }\n    expandMachineInterior(builder, minimumInteriorNeighbors = 1) {\n        let madeChange;\n        const interior = builder.interior;\n        const site = builder.site;\n        do {\n            madeChange = false;\n            interior.forEach((_v, x, y) => {\n                // if (v && site.isDoor(x, y)) {\n                //     site.setTile(x, y, DIG_SITE.FLOOR); // clean out the doors...\n                //     return;\n                // }\n                if (site.hasSiteFlag(x, y, SITE.Flags.IS_IN_MACHINE))\n                    return;\n                if (!site.blocksPathing(x, y))\n                    return;\n                let nbcount = 0;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // Not in map\n                    if (interior[i][j] && !site.blocksPathing(i, j)) {\n                        ++nbcount; // in machine and open tile\n                    }\n                }, false);\n                if (nbcount < minimumInteriorNeighbors)\n                    return;\n                nbcount = 0;\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return; // not on map\n                    if (interior[i][j])\n                        return; // already part of machine\n                    if (!site.isWall(i, j) ||\n                        site.hasSiteFlag(i, j, SITE.Flags.IS_IN_MACHINE)) {\n                        ++nbcount; // tile is not a wall or is in a machine\n                    }\n                }, false);\n                if (nbcount)\n                    return;\n                // Eliminate this obstruction; welcome its location into the machine.\n                madeChange = true;\n                interior[x][y] = 1;\n                if (site.blocksPathing(x, y)) {\n                    site.setTile(x, y, DIG_SITE.FLOOR);\n                }\n                GW.utils.eachNeighbor(x, y, (i, j) => {\n                    if (!interior.hasXY(i, j))\n                        return;\n                    if (site.isSet(i, j))\n                        return;\n                    site.setTile(i, j, DIG_SITE.WALL);\n                });\n            });\n        } while (madeChange);\n    }\n    calcDistances(builder) {\n        builder.distanceMap.fill(0);\n        DIG_UTILS.computeDistanceMap(builder.site, builder.distanceMap, builder.originX, builder.originY, this.size[1]);\n        let qualifyingTileCount = 0;\n        const distances = new Array(100).fill(0);\n        builder.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const dist = builder.distanceMap[x][y];\n            if (dist < 100) {\n                distances[dist]++; // create a histogram of distances -- poor man's sort function\n                qualifyingTileCount++;\n            }\n        });\n        let distance25 = Math.round(qualifyingTileCount / 4);\n        let distance75 = Math.round((3 * qualifyingTileCount) / 4);\n        for (let i = 0; i < 100; i++) {\n            if (distance25 <= distances[i]) {\n                distance25 = i;\n                break;\n            }\n            else {\n                distance25 -= distances[i];\n            }\n        }\n        for (let i = 0; i < 100; i++) {\n            if (distance75 <= distances[i]) {\n                distance75 = i;\n                break;\n            }\n            else {\n                distance75 -= distances[i];\n            }\n        }\n        builder.distance25 = distance25;\n        builder.distance75 = distance75;\n    }\n    pickComponents() {\n        const alternativeFlags = [\n            STEP.StepFlags.BF_ALTERNATIVE,\n            STEP.StepFlags.BF_ALTERNATIVE_2,\n        ];\n        const keepFeature = new Array(this.steps.length).fill(true);\n        for (let j = 0; j <= 1; j++) {\n            let totalFreq = 0;\n            for (let i = 0; i < keepFeature.length; i++) {\n                if (this.steps[i].flags & alternativeFlags[j]) {\n                    keepFeature[i] = false;\n                    totalFreq++;\n                }\n            }\n            if (totalFreq > 0) {\n                let randIndex = GW.random.range(1, totalFreq);\n                for (let i = 0; i < keepFeature.length; i++) {\n                    if (this.steps[i].flags & alternativeFlags[j]) {\n                        if (randIndex == 1) {\n                            keepFeature[i] = true; // This is the alternative that gets built. The rest do not.\n                            break;\n                        }\n                        else {\n                            randIndex--;\n                        }\n                    }\n                }\n            }\n        }\n        return this.steps.filter((_f, i) => keepFeature[i]);\n    }\n    clearInteriorFlag(builder) {\n        builder.interior.forEach((v, x, y) => {\n            if (!v)\n                return;\n            if (!builder.site.hasSiteFlag(x, y, SITE.Flags.IS_WIRED | SITE.Flags.IS_CIRCUIT_BREAKER)) {\n                builder.site.setMachine(x, y, 0);\n            }\n        });\n        // for (i = 0; i < map.width; i++) {\n        //     for (j = 0; j < map.height; j++) {\n        //         const cell = RUT.Map.getCell(map, i, j);\n        //         if (\n        //             cell.machineNumber == map.machineNumber &&\n        //             !RUT.Cell.hasMechFlag(\n        //                 cell,\n        //                 MechFlags.TM_IS_WIRED |\n        //                     MechFlags.TM_IS_CIRCUIT_BREAKER\n        //             )\n        //         ) {\n        //             cell.flags &= ~CellFlags.IS_IN_MACHINE;\n        //             cell.machineNumber = 0;\n        //         }\n        //     }\n        // }\n    }\n}\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    if (!(blueprint instanceof Blueprint)) {\n        blueprint = new Blueprint(blueprint);\n    }\n    blueprints[id] = blueprint;\n    blueprint.id = id;\n    return blueprint;\n}\nexport function random(requiredFlags, depth) {\n    const matches = Object.values(blueprints).filter((b) => b.qualifies(requiredFlags, depth));\n    return GW.random.item(matches);\n}\n","import * as GW from 'gw-utils';\nimport { Flags } from './site';\n// import { LoopFinder } from './loopFinder';\nexport class ChokeFinder {\n    constructor(withCounts = false) {\n        this.withCounts = withCounts;\n    }\n    /////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////\n    // TODO - Move to Map?\n    compute(site) {\n        const floodGrid = GW.grid.alloc(site.width, site.height);\n        const passMap = GW.grid.alloc(site.width, site.height);\n        passMap.update((_v, x, y) => (site.isPassable(x, y) ? 1 : 0));\n        // Assume loops are done already!\n        // const loopFinder = new LoopFinder();\n        // loopFinder.compute(\n        //     site\n        // );\n        let passableArcCount;\n        // done finding loops; now flag chokepoints\n        for (let i = 1; i < passMap.width - 1; i++) {\n            for (let j = 1; j < passMap.height - 1; j++) {\n                site.clearSiteFlag(i, j, Flags.IS_CHOKEPOINT);\n                site.setChokeCount(i, j, 30000);\n                if (passMap[i][j] && !site.hasSiteFlag(i, j, Flags.IS_IN_LOOP)) {\n                    passableArcCount = 0;\n                    for (let dir = 0; dir < 8; dir++) {\n                        const oldX = i + GW.utils.CLOCK_DIRS[(dir + 7) % 8][0];\n                        const oldY = j + GW.utils.CLOCK_DIRS[(dir + 7) % 8][1];\n                        const newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                        const newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                        if (passMap.hasXY(newX, newY) &&\n                            passMap.hasXY(oldX, oldY) &&\n                            passMap[newX][newY] != passMap[oldX][oldY]) {\n                            if (++passableArcCount > 2) {\n                                if ((!passMap[i - 1][j] &&\n                                    !passMap[i + 1][j]) ||\n                                    (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                    site.setSiteFlag(i, j, Flags.IS_CHOKEPOINT);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (this.withCounts) {\n            // Done finding chokepoints; now create a chokepoint map.\n            // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n            // then the number indicates the number of tiles that would be rendered unreachable if the\n            // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n            // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n            // were blocked.\n            // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n            // Start by roping off room machines.\n            passMap.update((v, x, y) => v && site.hasSiteFlag(x, y, Flags.IS_IN_ROOM_MACHINE) ? 0 : v);\n            // Scan through and find a chokepoint next to an open point.\n            for (let i = 0; i < site.width; i++) {\n                for (let j = 0; j < site.height; j++) {\n                    if (passMap[i][j] &&\n                        site.hasSiteFlag(i, j, Flags.IS_CHOKEPOINT)) {\n                        for (let dir = 0; dir < 4; dir++) {\n                            const newX = i + GW.utils.DIRS[dir][0];\n                            const newY = j + GW.utils.DIRS[dir][1];\n                            if (passMap.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                                passMap[newX][newY] &&\n                                !(site.hasSiteFlag(newX, newY, Flags.IS_CHOKEPOINT))) {\n                                // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                                // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                                // Keep track of the flooded region in grid[][].\n                                floodGrid.fill(0);\n                                passMap[i][j] = 0;\n                                let cellCount = floodFillCount(site, floodGrid, passMap, newX, newY);\n                                passMap[i][j] = 1;\n                                // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                                // CellCounts less than 4 are not useful, so we skip those cases.\n                                if (cellCount >= 4) {\n                                    // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                    for (let i2 = 0; i2 < floodGrid.width; i2++) {\n                                        for (let j2 = 0; j2 < floodGrid.height; j2++) {\n                                            if (floodGrid[i2][j2] &&\n                                                cellCount < site.getChokeCount(i2, j2)) {\n                                                site.setChokeCount(i2, j2, cellCount);\n                                                site.clearSiteFlag(i2, j2, Flags.IS_GATE_SITE);\n                                            }\n                                        }\n                                    }\n                                    // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                    if (cellCount < site.getChokeCount(i, j)) {\n                                        site.setChokeCount(i, j, cellCount);\n                                        site.setSiteFlag(i, j, Flags.IS_GATE_SITE);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(passMap);\n        GW.grid.free(floodGrid);\n    }\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(site, results, passMap, startX, startY) {\n    let count = passMap[startX][startY] == 2 ? 5000 : 1;\n    if (site.isDeep(startX, startY)\n    // map.cells[startX][startY].flags.cellMech &\n    // FLAGS.CellMech.IS_IN_AREA_MACHINE\n    ) {\n        count = 10000;\n    }\n    results[startX][startY] = 1;\n    for (let dir = 0; dir < 4; dir++) {\n        const newX = startX + GW.utils.DIRS[dir][0];\n        const newY = startY + GW.utils.DIRS[dir][1];\n        if (site.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n            passMap[newX][newY] &&\n            !results[newX][newY]) {\n            count += floodFillCount(site, results, passMap, newX, newY);\n        }\n    }\n    return Math.min(count, 10000);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\nexport class LoopFinder {\n    constructor() { }\n    compute(site) {\n        // const grid = GW.grid.alloc(site.width, site.height);\n        this._initGrid(site);\n        GW.utils.forRect(site.width, site.height, (x, y) => this._checkCell(site, x, y));\n        // grid.forEach((_v, x, y) => this._checkCell(site, grid, x, y));\n        // grid.forEach((v, x, y) => cb(x, y, !!v));\n        // GW.grid.free(grid);\n    }\n    _initGrid(site) {\n        GW.utils.forRect(site.width, site.height, (x, y) => {\n            if (site.isPassable(x, y)) {\n                site.setSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            }\n            else {\n                site.clearSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            }\n        });\n    }\n    _checkCell(site, x, y) {\n        let inString;\n        let newX, newY, dir, sdir;\n        let numStrings, maxStringLength, currentStringLength;\n        const v = site.hasSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n        if (!v)\n            return;\n        // find an unloopy neighbor to start on\n        for (sdir = 0; sdir < 8; sdir++) {\n            newX = x + GW.utils.CLOCK_DIRS[sdir][0];\n            newY = y + GW.utils.CLOCK_DIRS[sdir][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            if (!site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP)) {\n                break;\n            }\n        }\n        if (sdir == 8) {\n            // no unloopy neighbors\n            return; // leave cell loopy\n        }\n        // starting on this unloopy neighbor,\n        // work clockwise and count up:\n        // (a) the number of strings of loopy neighbors, and\n        // (b) the length of the longest such string.\n        numStrings = maxStringLength = currentStringLength = 0;\n        inString = false;\n        for (dir = sdir; dir < sdir + 8; dir++) {\n            newX = x + GW.utils.CLOCK_DIRS[dir % 8][0];\n            newY = y + GW.utils.CLOCK_DIRS[dir % 8][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            const newCell = site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP);\n            if (newCell) {\n                currentStringLength++;\n                if (!inString) {\n                    if (numStrings > 0) {\n                        return false; // more than one string here; leave loopy\n                    }\n                    numStrings++;\n                    inString = true;\n                }\n            }\n            else if (inString) {\n                if (currentStringLength > maxStringLength) {\n                    maxStringLength = currentStringLength;\n                }\n                currentStringLength = 0;\n                inString = false;\n            }\n        }\n        if (inString && currentStringLength > maxStringLength) {\n            maxStringLength = currentStringLength;\n        }\n        if (numStrings == 1 && maxStringLength <= 4) {\n            site.clearSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            for (dir = 0; dir < 8; dir++) {\n                const newX = x + GW.utils.CLOCK_DIRS[dir][0];\n                const newY = y + GW.utils.CLOCK_DIRS[dir][1];\n                if (site.hasXY(newX, newY)) {\n                    this._checkCell(site, newX, newY);\n                }\n            }\n        }\n    }\n    _fillInnerLoopGrid(site, innerGrid) {\n        for (let x = 0; x < site.width; ++x) {\n            for (let y = 0; y < site.height; ++y) {\n                if (site.hasSiteFlag(x, y, SITE.Flags.IS_IN_LOOP)) {\n                    innerGrid[x][y] = 1;\n                }\n                else if (x > 0 && y > 0) {\n                    const up = site.hasSiteFlag(x, y - 1, SITE.Flags.IS_IN_LOOP);\n                    const left = site.hasSiteFlag(x - 1, y, SITE.Flags.IS_IN_LOOP);\n                    if (up && left) {\n                        innerGrid[x][y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    _update(site) {\n        // remove extraneous loop markings\n        const innerLoop = GW.grid.alloc(site.width, site.height);\n        this._fillInnerLoopGrid(site, innerLoop);\n        // const xy = { x: 0, y: 0 };\n        let designationSurvives;\n        for (let i = 0; i < site.width; i++) {\n            for (let j = 0; j < site.height; j++) {\n                if (site.hasSiteFlag(i, j, SITE.Flags.IS_IN_LOOP)) {\n                    designationSurvives = false;\n                    for (let dir = 0; dir < 8; dir++) {\n                        let newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                        let newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                        if (site.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                            !innerLoop[newX][newY] &&\n                            !site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP)) {\n                            designationSurvives = true;\n                            break;\n                        }\n                    }\n                    if (!designationSurvives) {\n                        innerLoop[i][j] = 1;\n                        site.clearSiteFlag(i, j, SITE.Flags.IS_IN_LOOP);\n                    }\n                }\n            }\n        }\n        GW.grid.free(innerLoop);\n    }\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as blueprint_1 from './blueprint';\nexport { blueprint_1 as blueprint };\nimport { ChokeFinder } from './chokeFinder';\nimport { LoopFinder } from './loopFinder';\nimport * as site_1 from './site';\nexport { site_1 as site };\nexport const analyze = { ChokeFinder, LoopFinder };\nexport * from './blueprint';\nexport * from './buildStep';\nexport function analyzeSite(site) {\n    const loops = new LoopFinder();\n    loops.compute(site);\n    const chokes = new ChokeFinder(true);\n    chokes.compute(site);\n}\n"],"names":["_a","_b","NOTHING","GW.tile","get","index","FLOOR","DOOR","SECRET_DOOR","WALL","DEEP","SHALLOW","BRIDGE","UP_STAIRS","DOWN_STAIRS","IMPREGNABLE","TILEMAP","[object Object]","GridSite","width","height","this","tiles","GW.grid","alloc","free","x","y","hasXY","isBoundaryXY","isFloor","isDoor","isBridge","isStairs","isShallow","v","isNothing","isWall","isDeep","blocksPathing","tile","obj","Error","Hall","loc","dir","length","doors","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","Bounds","super","hall","cx","Math","floor","cy","translate","directionOfDoorSite","site","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","chooseRandomDoorSites","i","j","k","doorSiteFailed","DOORS","h","w","isDiggable","isSet","push","doorSites","GW.random","item","copySite","dest","source","offsetX","offsetY","forRect","otherX","otherY","getTileIndex","setTile","fillCostGrid","costGrid","update","_v","isPassable","GW.path","OBSTRUCTION","siteDisruptedBy","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","lakeX","lakeY","first","floodFill","siteDisruptedSize","nextId","minSize","disrupted","min","computeDistanceMap","distanceMap","originX","originY","maxDistance","calculateDistances","checkConfig","config","expected","Object","entries","key","expect","have","undefined","Array","isArray","range","GW.range","make","RoomDigger","options","_setOptions","result","carve","every","UTILS.chooseRandomDoorSites","rooms","ChoiceRoom","choices","randomRoom","bind","weighted","id","room","ERROR","create","Cavern","value","SITE.FLOOR","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","GW.blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","max","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","chance","ChunkyRoom","count","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickLength","lengths","pickHallDirection","dirs","sequence","hi","door","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.Hall","lower","higher","actual","startX","startY","halls","opts","clamp","Number","parseInt","_pickWidth","Lakes","tries","canDisrupt","wreathTile","SITE.SHALLOW","wreathChance","wreathSize","SITE.DEEP","assign","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","Bridges","minDistance","maxLength","pathGrid","dirCoords","seq","isAnyLiquid","bridgeDir","NO_PATH","isBridgeCandidate","SITE.BRIDGE","Stairs","up","down","start","upTile","SITE.UP_STAIRS","downTile","SITE.DOWN_STAIRS","wall","SITE.IMPREGNABLE","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingLoc","matchingLocNear","distanceBetween","slice","setupStairs","indexes","x0","y0","dirIndex","CLOCK_DIRS","findIndex","r","LoopDigger","endX","endY","isValidTunnelStart","isValidTunnelEnd","UTILS.fillCostGrid","map","SITE.DOOR","Level","loops","lakes","bridges","stairs","boundary","startLoc","endLoc","seed","setOptions","SITE.GridSite","setFn","makeSite","addFirstRoom","fails","addRoom","addLoops","addLakes","addBridges","addStairs","finish","t","_site","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","roomSite","getDigger","_attachRoomAtLoc","HALL.dig","_attachRoom","UTILS.directionOfDoorSite","oppDir","_roomFitsAt","UTILS.copySite","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","didSomething","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","blocksMove","blocksDiagonal","boundaryTile","SITE.WALL","levels","seeds","stairLocs","initSeeds","initStairLocs","number","stairDistance","cb","stairOpts","goesUp","startTile","endTile","entrance","levelOpts","makeLevel","level","LEVEL.Level","equalsXY","Fl","GW.flag","fl","Flags","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","DigSite.GridSite","machineCount","flags","choke","machine","backup","copy","flag","set","_x","_y","_options","isRoom","clearSiteFlag","IS_IN_MACHINE","setSiteFlag","Spawner","info","abortIfBlocks","GW.effect","E_ABORT_IF_BLOCKS_MAP","locs","fill","DIG_UTILS.siteDisruptedBy","spawnTiles","growProb","grow","probDec","decrement","todo","working","done","Set","pop","eachNeighbor","i2","j2","has","add","grid","compute","cellIsOk","isStart","blocksEffects","matchTile","E_BUILD_IN_WALLS","E_MUST_TOUCH_WALLS","ok","E_NO_TOUCH_WALLS","hasTile","superpriority","E_SUPERPRIORITY","blockedByOtherLayers","E_BLOCKED_BY_OTHER_LAYERS","blockedByActors","E_BLOCKED_BY_ACTORS","blockedByItems","E_BLOCKED_BY_ITEMS","volume","placeTile","StepFlags","BuildStep","cfg","pad","horde","spawn","from","builder","blueprint","distanceBound","BF_NOT_IN_HALLWAY","arcCount","BF_NOT_ON_LEVEL_PERIMETER","BF_BUILD_AT_ORIGIN","occupied","BF_IN_VIEW_OF_ORIGIN","BF_IN_PASSABLE_VIEW_OF_ORIGIN","viewMap","distance","BF_BUILD_IN_WALLS","cellMachine","getMachine","interior","machineNumber","BF_BUILD_ANYWHERE_ON_LEVEL","blocksItems","hasSiteFlag","SITE.Flags","IS_CHOKEPOINT","IS_IN_LOOP","candidates","personalSpace","generateEverywhere","instanceCount","instance","BF_NEAR_ORIGIN","distance25","BF_FAR_FROM_ORIGIN","distance75","GW.fov","FOV","isBlocked","calculate","blocksVision","qualifyingTileCount","cellIsCandidate","BF_EVERYWHERE","lo","console","warn","randIndex","terrainSucceeded","BF_PERMIT_BLOCKING","tileBlocksMove","BF_TREAT_AS_BLOCKING","blockingMap","error","makePersonalSpace","BP_NO_INTERIOR_FLAG","setMachine","BF_IMPREGNABLE","BF_REPEAT_UNTIL_NO_PROGRESS","Blueprint","tags","size","steps","split","trim","frequency","GW.frequency","parts","STEP.BuildStep","want","includes","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_ADOPT_ITEM","treatAsBlocking","BP_TREAT_AS_BLOCKING","requireBlocking","BP_REQUIRE_BLOCKING","purgeInterior","BP_PURGE_INTERIOR","purgeBlockers","BP_PURGE_PATHING_BLOCKERS","purgeLiquids","BP_PURGE_LIQUIDS","surroundWithWalls","BP_SURROUND_WITH_WALLS","makeImpregnable","BP_IMPREGNABLE","maximizeInterior","BP_MAXIMIZE_INTERIOR","openInterior","BP_OPEN_INTERIOR","noInteriorFlag","requiredFlags","depth","randSite","IS_GATE_SITE","log","pos","tryAgain","failsafe","addTileToInteriorAndIterate","computeInteriorForVestibuleMachine","DIG_UTILS.computeDistanceMap","totalFreq","n","isOccupied","DIG_UTILS.siteDisruptedSize","goodSoFar","startChokeCount","getChokeCount","distMap","cells","expandMachineInterior","DIG_SITE.FLOOR","DIG_SITE.WALL","isSecretDoor","DIG_SITE.DOOR","minimumInteriorNeighbors","madeChange","nbcount","distances","dist","alternativeFlags","STEP.StepFlags","BF_ALTERNATIVE","BF_ALTERNATIVE_2","keepFeature","filter","_f","IS_WIRED","IS_CIRCUIT_BREAKER","blueprints","random","matches","values","b","qualifies","ChokeFinder","withCounts","floodGrid","passMap","passableArcCount","setChokeCount","oldX","oldY","cellCount","floodFillCount","results","LoopFinder","_initGrid","_checkCell","inString","sdir","numStrings","maxStringLength","currentStringLength","innerGrid","innerLoop","designationSurvives","_fillInnerLoopGrid"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/room.js","../js/gw.js","../js/hall.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    rooms[id] = data;\n    return data;\n}\ninstall('DEFAULT', rectangular);\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    Object.entries(opts).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                GW.utils.WARN('Missing required config for digger: ' + key);\n                return;\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n            return;\n        }\n        const range = GW.range.make(have);\n        if (!range) {\n            GW.utils.ERROR('Invalid configuration for digger: ' + key);\n        }\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GW.random.item.bind(GW.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GW.random.weighted.bind(GW.random, config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n        return null;\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        GW.utils.ERROR('Missing digger choice: ' + id);\n        return null;\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (height % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GW.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nexport var halls = {};\nexport function install(id, fn, config = {}) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    halls[id] = data;\n    return data;\n}\ninstall('DEFAULT', dig, { chance: 15 });\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (typeof opts === 'number')\n        return opts;\n    if (!opts)\n        return 1;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLengthRange(dir, opts) {\n    if (!opts.length)\n        opts.length = [];\n    if (Array.isArray(opts.length)) {\n        if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n            return GW.range.make(opts.length[1] || [2, 9]);\n        }\n        else {\n            return GW.range.make(opts.length[0] || [9, 15]);\n        }\n    }\n    else {\n        return GW.range.make(opts.length);\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickLengthRange(dir, opts).hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digWide(opts, grid, room) {\n    opts = opts || {};\n    if (!opts.width) {\n        opts.width = 2;\n    }\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const width = pickWidth(opts) || 2;\n    const door = room.doors[dir];\n    const tile = opts.tile || CONST.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new Hall([door[0], y0], dir, length, width);\n    }\n    hall.doors = hallDoors;\n    hall.width = width;\n    return hall;\n}\nexport function dig(opts, grid, room) {\n    opts = opts || {};\n    opts.width = 1;\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || CONST.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport * as HALL from './hall';\nimport * as ROOM from './room';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nimport * as room_1 from './room';\nexport { room_1 as room };\nexport { Room, Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts) {\n    opts = opts || { room: 'DEFAULT', hall: 'DEFAULT', tries: 10 };\n    if (typeof opts === 'string') {\n        opts = { room: opts };\n    }\n    if (opts.loc) {\n        opts.locs = [opts.loc];\n    }\n    if (!opts.room)\n        opts.room = 'DEFAULT';\n    if (typeof opts.room === 'string') {\n        const name = opts.room;\n        opts.room = ROOM.rooms[name];\n        if (!opts.room) {\n            GW.utils.ERROR('Failed to find room: ' + name);\n        }\n    }\n    const roomConfig = opts.room;\n    if (opts.hall === true)\n        opts.hall = 'DEFAULT';\n    if (opts.hall !== false && !opts.hall)\n        opts.hall = 'DEFAULT';\n    if (typeof opts.hall === 'string') {\n        const name = opts.hall;\n        opts.hall = HALL.halls[name];\n        if (!opts.hall) {\n            GW.utils.ERROR('Failed to find hall: ' + name);\n            return null;\n        }\n    }\n    const hallConfig = opts.hall ? opts.hall : null;\n    let locs = opts.locs || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        // @ts-ignore\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const digger = opts.room;\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    let attachHall = false;\n    if (hallConfig) {\n        let hallChance = hallConfig.chance !== undefined ? hallConfig.chance : 15;\n        attachHall = GW.random.chance(hallChance);\n    }\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(roomConfig, roomGrid);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = HALL.dig(hallConfig, roomGrid, room);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, opts);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, opts);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door)\n                continue;\n            const offsetX = x - door[0];\n            const offsetY = y - door[1];\n            if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || CONST.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? CONST.DOOR\n                        : opts.room.door;\n                    map[x][y] = door; // Door site.\n                }\n                // door[0] = -1;\n                // door[1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || CONST.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? CONST.DOOR\n                        : opts.room.door;\n                    map[xy[0]][xy[1]] = door; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.room.tile || CONST.FLOOR;\n            });\n            if (opts.room.door !== false) {\n                const door = opts.room.door === true || !opts.room.door\n                    ? CONST.DOOR\n                    : opts.room.door;\n                map[x][y] = door; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n"],"names":["Hall","[object Object]","loc","dir","length","width","this","doors","x","y","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","rooms","install","id","fn","config","data","checkConfig","opts","Object","entries","key","expect","have","undefined","WARN","Array","isArray","range","GW.range","make","ERROR","rectangular","grid","value","tile","fill","fillRect","destX","destY","blobGrid","GW.grid","alloc","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","offsetZip","free","choices","GW.random","item","bind","weighted","digConfig","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","min","max","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","chance","count","i","minX","maxX","minY","maxY","chunkCount","valueBounds","halls","pickLengthRange","dig","room","NO_DIRECTION","dirs","sequence","hi","door","hasXY","pickHallDirection","DIR","newX","newY","obliqueChance","firstOpt","allowObliqueHallwayExit","hallDoors","dir2","pickHallExits","SEQ","attachRoom","map","roomGrid","doorSites","get","directionOfDoorSite","offsetX","offsetY","roomFitsAt","_d","_s","j","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","attachRoomAtMapDoor","mapDoors","doorIndexes","attachRoomAtXY","offX","offY","chooseRandomDoorSites","sourceGrid","k","doorSiteFailed","copy","randomMatchingLoc","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","tries","locs","name","ROOM.rooms","roomConfig","HALL.halls","hallConfig","attachHall","hallChance","result","HALL.dig","xy"],"mappings":"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"}
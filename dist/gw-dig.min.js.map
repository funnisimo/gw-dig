{"version":3,"file":"gw-dig.min.js","sources":["../js/site.js","../js/room.js","../js/hall.js","../js/lake.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nexport const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\nexport const UP_STAIRS = 6;\nexport const DOWN_STAIRS = 7;\nexport const SHALLOW = 8;\nexport function fillCostGrid(source, costGrid) {\n    source.forEach((_v, x, y) => {\n        costGrid[x][y] = isPassable(source, x, y) ? 1 : GW.path.OBSTRUCTION;\n    });\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return (v === FLOOR ||\n        v === DOOR ||\n        v === BRIDGE ||\n        v === UP_STAIRS ||\n        v === DOWN_STAIRS ||\n        v === SHALLOW);\n}\nexport function isDoor(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === DOOR;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === NOTHING || v === WALL;\n}\nexport function isStairs(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === UP_STAIRS || v === DOWN_STAIRS;\n}\nexport function isLake(grid, x, y) {\n    return grid.get(x, y) === LAKE;\n}\nexport function isAnyWater(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === LAKE || v === SHALLOW;\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './site';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var rooms = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    rooms[id] = data;\n    return data;\n}\ninstall('DEFAULT', rectangular);\nexport function checkConfig(config, expected) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                return GW.utils.ERROR('Missing required config for digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * width); // 6\n    const maxWidth = width;\n    const minHeight = Math.floor(0.5 * height); // 4\n    const maxHeight = height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, tile);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = GW.random.item.bind(GW.random, config.choices);\n    }\n    else if (typeof config.choices == 'object') {\n        choices = GW.random.weighted.bind(GW.random, config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of room ids or map - ex: { ROOM_ID: weight }');\n    }\n    if (!grid)\n        return config;\n    let id = choices();\n    const digger = rooms[id];\n    if (!digger) {\n        GW.utils.ERROR('Missing digger choice: ' + id);\n    }\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entrance(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = Math.floor(0.4 * width); // 8\n    const roomHeight = height;\n    const roomWidth2 = width;\n    const roomHeight2 = Math.floor(0.5 * height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function cross(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    const roomWidth = width;\n    const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n    const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomHeight2 = height;\n    const roomX = Math.floor((grid.width - roomWidth) / 2);\n    const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n    const roomY2 = Math.floor((grid.height - roomHeight2) / 2);\n    const roomY = roomY2 + GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, tile);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, tile);\n    return new Room(config.id, roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCross(config, grid) {\n    config = checkConfig(config, { width: 7, height: 7 });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n    // if (height % 2 == 0 && minorWidth > 2) {\n    //     minorWidth -= 1;\n    // }\n    let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    // if (width % 2 == 0 && minorHeight > 2) {\n    //     minorHeight -= 1;\n    // }\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, width, minorHeight, tile);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x2, y2, minorWidth, height, tile);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n}\nexport function rectangular(config, grid) {\n    config = checkConfig(config, { width: [3, 6], height: [3, 6] });\n    if (!grid)\n        return config;\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, tile);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circular(config, grid) {\n    config = checkConfig(config, { radius: [3, 4] });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, tile);\n    }\n    return new Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        radius: [5, 10],\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = config.radius.value();\n    const ringMinWidth = config.ringMinWidth.value();\n    const holeMinSize = config.holeMinSize.value();\n    const tile = config.tile || CONST.FLOOR;\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, tile);\n    if (radius > ringMinWidth + holeMinSize &&\n        GW.random.chance(config.holeChance.value())) {\n        grid.fillCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), 0);\n    }\n    return new Room(config.id, x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, {\n        count: [2, 12],\n        width: [5, 20],\n        height: [5, 20],\n    });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = config.count.value();\n    const width = config.width.value();\n    const height = config.height.value();\n    const tile = config.tile || CONST.FLOOR;\n    minX = Math.floor(grid.width / 2) - Math.floor(width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, tile);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, tile);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    const bounds = grid.valueBounds(tile);\n    return new Room(config.id, bounds.x, bounds.y, bounds.width, bounds.height);\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './site';\nimport { Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nexport var halls = {};\nexport function install(id, fn, config = {}) {\n    // @ts-ignore\n    const data = fn(config || {}); // call to have function setup the config\n    data.fn = fn;\n    data.id = id;\n    halls[id] = data;\n    return data;\n}\ninstall('DEFAULT', dig, { chance: 15 });\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLengthRange(dir, opts) {\n    if (!opts.length)\n        opts.length = [];\n    if (Array.isArray(opts.length)) {\n        if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n            return GW.range.make(opts.length[1] || [2, 9]);\n        }\n        else {\n            return GW.range.make(opts.length[0] || [9, 15]);\n        }\n    }\n    else {\n        return GW.range.make(opts.length);\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickLengthRange(dir, opts).hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (grid.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport function digWide(opts, grid, room) {\n    opts = opts || {};\n    if (!opts.width) {\n        opts.width = 2;\n    }\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const width = pickWidth(opts) || 2;\n    const door = room.doors[dir];\n    const tile = opts.tile || CONST.FLOOR;\n    const hallDoors = [];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = GW.utils.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = GW.utils.clamp(door[0], room.x, room.x + room.width - width);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + width; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = GW.utils.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = GW.utils.clamp(door[1], room.y, room.y + room.height - width);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + width; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new Hall([door[0], y0], dir, length, width);\n    }\n    hall.doors = hallDoors;\n    hall.width = width;\n    return hall;\n}\nexport function dig(opts, grid, room) {\n    opts = opts || {};\n    opts.width = 1;\n    if (!grid) {\n        return opts;\n    }\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    const length = pickLengthRange(dir, opts).value();\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || CONST.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nexport function digLakes(map, opts = {}) {\n    let i, j, k;\n    let x, y;\n    let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n    let count = 0;\n    lakeMaxHeight = opts.height || 15; // TODO - Make this a range \"5-15\"\n    lakeMaxWidth = opts.width || 30; // TODO - Make this a range \"5-30\"\n    lakeMinSize = opts.minSize || 5;\n    tries = opts.tries || 20;\n    maxCount = opts.count || 1;\n    canDisrupt = opts.canDisrupt || false;\n    const wreath = opts.wreath || 0; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n    const wreathTile = opts.wreathTile || SITE.SHALLOW;\n    const tile = opts.tile || SITE.LAKE;\n    const lakeGrid = GW.grid.alloc(map.width, map.height, 0);\n    let attempts = 0;\n    while (attempts < maxCount && count < maxCount) {\n        // lake generations\n        const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n            maxCount) + lakeMinSize;\n        const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n            maxCount) + lakeMinSize;\n        lakeGrid.fill(SITE.NOTHING);\n        const bounds = lakeGrid.fillBlob(5, 4, 4, width, height, 55, 'ffffftttt', 'ffffttttt');\n        // lakeGrid.dump();\n        let success = false;\n        for (k = 0; k < tries && !success; k++) {\n            // placement attempts\n            // propose a position for the top-left of the lakeGrid in the dungeon\n            x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n            y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n            if (canDisrupt || !lakeDisruptsPassability(map, lakeGrid, -x, -y)) {\n                // level with lake is completely connected\n                //   dungeon.debug(\"Placed a lake!\", x, y);\n                success = true;\n                // copy in lake\n                for (i = 0; i < bounds.width; i++) {\n                    // skip boundary\n                    for (j = 0; j < bounds.height; j++) {\n                        // skip boundary\n                        if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                            const sx = i + bounds.x + x;\n                            const sy = j + bounds.y + y;\n                            map[sx][sy] = tile;\n                            if (wreath) {\n                                map.forCircle(sx, sy, wreath, (v, i, j) => {\n                                    if (v === SITE.FLOOR || v === SITE.DOOR) {\n                                        map[i][j] = wreathTile;\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        if (success) {\n            ++count;\n        }\n        else {\n            ++attempts;\n        }\n    }\n    GW.grid.free(lakeGrid);\n    return count;\n}\nfunction lakeDisruptsPassability(map, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n    const walkableGrid = GW.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    map.forEach((v, i, j) => {\n        const lakeX = i + lakeToMapX;\n        const lakeY = j + lakeToMapY;\n        if (!v) {\n            return; // not walkable\n        }\n        else if (SITE.isStairs(map, i, j)) {\n            if (lakeGrid.get(lakeX, lakeY)) {\n                disrupts = true;\n            }\n            else {\n                walkableGrid[i][j] = 1;\n            }\n        }\n        else if (SITE.isPassable(map, i, j)) {\n            if (lakeGrid.get(lakeX, lakeY))\n                return;\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGrid.dump();\n    GW.grid.free(walkableGrid);\n    return disrupts;\n}\nfunction isBridgeCandidate(map, x, y, bridgeDir) {\n    if (map.get(x, y) === SITE.BRIDGE)\n        return true;\n    if (!SITE.isAnyWater(map, x, y))\n        return false;\n    if (!SITE.isAnyWater(map, x + bridgeDir[1], y + bridgeDir[0]))\n        return false;\n    if (!SITE.isAnyWater(map, x - bridgeDir[1], y - bridgeDir[0]))\n        return false;\n    return true;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digBridges(map, minimumPathingDistance, maxConnectionLength) {\n    let newX, newY;\n    let i, j, d, x, y;\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const siteGrid = map;\n    const pathGrid = GW.grid.alloc(map.width, map.height);\n    const costGrid = GW.grid.alloc(map.width, map.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(map, costGrid);\n    const SEQ = GW.random.sequence(map.width * map.height);\n    for (i = 0; i < SEQ.length; i++) {\n        x = Math.floor(SEQ[i] / siteGrid.height);\n        y = SEQ[i] % siteGrid.height;\n        if (map.hasXY(x, y) &&\n            map.get(x, y) &&\n            SITE.isPassable(map, x, y) &&\n            !SITE.isAnyWater(map, x, y)) {\n            for (d = 0; d <= 1; d++) {\n                // Try right, then down\n                const bridgeDir = dirCoords[d];\n                newX = x + bridgeDir[0];\n                newY = y + bridgeDir[1];\n                j = maxConnectionLength;\n                if (!map.hasXY(newX, newY))\n                    continue;\n                // check for line of lake tiles\n                // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                if (SITE.isAnyWater(map, newX, newY)) {\n                    for (j = 0; j < maxConnectionLength; ++j) {\n                        newX += bridgeDir[0];\n                        newY += bridgeDir[1];\n                        // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                        if (!SITE.isAnyWater(map, newX, newY)) {\n                            break;\n                        }\n                    }\n                }\n                if (map.get(newX, newY) &&\n                    SITE.isPassable(map, newX, newY) &&\n                    j < maxConnectionLength) {\n                    GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[newX][newY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[x][y] > minimumPathingDistance &&\n                        pathGrid[x][y] < GW.path.NO_PATH) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Bridge',\n                        //     x,\n                        //     y,\n                        //     ' => ',\n                        //     newX,\n                        //     newY\n                        // );\n                        while (x !== newX || y !== newY) {\n                            if (isBridgeCandidate(map, x, y, bridgeDir)) {\n                                map[x][y] = SITE.BRIDGE;\n                                costGrid[x][y] = 1; // (Cost map also needs updating.)\n                            }\n                            else {\n                                map[x][y] = SITE.FLOOR;\n                                costGrid[x][y] = 1;\n                            }\n                            x += bridgeDir[0];\n                            y += bridgeDir[1];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GW.grid.free(pathGrid);\n    GW.grid.free(costGrid);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from './site';\nimport * as HALL from './hall';\nimport * as ROOM from './room';\nimport * as LAKE from './lake';\n// import * as MAP from 'gw-map.js';\nexport * from './site';\nimport * as room_1 from './room';\nexport { room_1 as room };\nimport * as hall_1 from './hall';\nexport { hall_1 as hall };\nexport { Room, Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts) {\n    opts = opts || { room: 'DEFAULT', hall: 'DEFAULT', tries: 10 };\n    if (typeof opts === 'string') {\n        opts = { room: opts };\n    }\n    if (opts.loc) {\n        opts.locs = [opts.loc];\n    }\n    if (!opts.room)\n        opts.room = 'DEFAULT';\n    if (typeof opts.room === 'function')\n        opts.room = { fn: opts.room };\n    if (typeof opts.room === 'string') {\n        const name = opts.room;\n        opts.room = ROOM.rooms[name];\n        if (!opts.room) {\n            GW.utils.ERROR('Failed to find room: ' + name);\n        }\n    }\n    const roomConfig = opts.room;\n    let hallConfig = null;\n    if (opts.hall === true)\n        opts.hall = 'DEFAULT';\n    if (opts.hall !== false && !opts.hall)\n        opts.hall = 'DEFAULT';\n    if (typeof opts.hall === 'function')\n        opts.hall = { fn: opts.hall };\n    if (typeof opts.hall === 'string') {\n        const name = opts.hall;\n        opts.hall = HALL.halls[name];\n        if (!opts.hall) {\n            GW.utils.ERROR('Failed to find hall: ' + name);\n            return null;\n        }\n        hallConfig = opts.hall;\n    }\n    else {\n        if (opts.hall && opts.hall.fn) {\n            hallConfig = opts.hall;\n        }\n    }\n    if (opts.door === false) {\n        opts.door = SITE.FLOOR;\n    }\n    else if (opts.door === true || !opts.door) {\n        opts.door = SITE.DOOR;\n    }\n    let locs = opts.locs || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(SITE.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        // @ts-ignore\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const digger = opts.room;\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    let attachHall = false;\n    if (hallConfig) {\n        let hallChance = hallConfig.chance !== undefined ? hallConfig.chance : 15;\n        attachHall = GW.random.chance(hallChance);\n    }\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = opts.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(SITE.NOTHING);\n        // dig the room in the center\n        room = digger.fn(roomConfig, roomGrid);\n        // TODO - Allow choice of floor tile...\n        room.doors = chooseRandomDoorSites(roomGrid, SITE.FLOOR);\n        if (attachHall && hallConfig) {\n            room.hall = hallConfig.fn(hallConfig, roomGrid, room);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, opts);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, opts);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == SITE.NOTHING))\n            continue;\n        const dir = directionOfDoorSite(map, x, y, SITE.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door)\n                continue;\n            const offsetX = x - door[0];\n            const offsetY = y - door[1];\n            if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                attachDoor(map, room, opts, x, y, oppDir);\n                // door[0] = -1;\n                // door[1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function attachDoor(map, room, opts, x, y, dir) {\n    const tile = opts.door || SITE.DOOR;\n    map[x][y] = tile; // Door site.\n    // most cases...\n    if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n        return;\n    }\n    if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x - k, y) === 0) {\n                if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n                    map[x - k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x + k, y) === 0) {\n                if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n                    map[x + k][y] = tile;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n    else {\n        let didSomething = true;\n        let k = 1;\n        while (didSomething) {\n            didSomething = false;\n            if (map.get(x, y - k) === 0) {\n                if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n                    map[x][y - k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            if (map.get(x, y + k) === 0) {\n                if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n                    map[x][y + k] = opts.door;\n                    didSomething = true;\n                }\n            }\n            ++k;\n        }\n    }\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === SITE.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(grid, x, y, isOpen) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    const fnOpen = typeof isOpen === 'function'\n        ? isOpen\n        : (v) => v == isOpen;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (grid.hasXY(oppX, oppY) &&\n            grid.hasXY(newX, newY) &&\n            fnOpen(grid[oppX][oppY], oppX, oppY, grid)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = directionOfDoorSite(roomGrid, x, y, SITE.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.room.tile || SITE.FLOOR;\n                });\n                if (opts.room.door !== false) {\n                    const door = opts.room.door === true || !opts.room.door\n                        ? SITE.DOOR\n                        : opts.room.door;\n                    map[xy[0]][xy[1]] = door; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.room.tile || SITE.FLOOR;\n            });\n            attachDoor(map, room, opts, x, y, oppDir);\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid, floorTile) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    floorTile = floorTile || SITE.FLOOR;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = directionOfDoorSite(grid, i, j, floorTile);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function addLoops(grid, minimumPathingDistance, maxConnectionLength) {\n    let startX, startY, endX, endY;\n    let i, j, d, x, y;\n    minimumPathingDistance =\n        minimumPathingDistance ||\n            Math.floor(Math.min(grid.width, grid.height) / 2);\n    maxConnectionLength = maxConnectionLength || 1; // by default only break walls down\n    const siteGrid = grid;\n    const pathGrid = GW.grid.alloc(grid.width, grid.height);\n    const costGrid = GW.grid.alloc(grid.width, grid.height);\n    const dirCoords = [\n        [1, 0],\n        [0, 1],\n    ];\n    SITE.fillCostGrid(grid, costGrid);\n    function isValidTunnelStart(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return false;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return false;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return false;\n        return true;\n    }\n    function isValidTunnelEnd(x, y, dir) {\n        if (!grid.hasXY(x, y))\n            return false;\n        if (!grid.hasXY(x + dir[1], y + dir[0]))\n            return false;\n        if (!grid.hasXY(x - dir[1], y - dir[0]))\n            return false;\n        if (grid.get(x, y))\n            return true;\n        if (grid.get(x + dir[1], y + dir[0]))\n            return true;\n        if (grid.get(x - dir[1], y - dir[0]))\n            return true;\n        return false;\n    }\n    for (i = 0; i < SEQ.length; i++) {\n        x = Math.floor(SEQ[i] / siteGrid.height);\n        y = SEQ[i] % siteGrid.height;\n        const cell = siteGrid[x][y];\n        if (!cell) {\n            for (d = 0; d <= 1; d++) {\n                // Try a horizontal door, and then a vertical door.\n                let dir = dirCoords[d];\n                if (!isValidTunnelStart(x, y, dir))\n                    continue;\n                j = maxConnectionLength;\n                // check up/left\n                if (grid.hasXY(x + dir[0], y + dir[1]) &&\n                    SITE.isPassable(grid, x + dir[0], y + dir[1])) {\n                    // just can't build directly into a door\n                    if (!grid.hasXY(x - dir[0], y - dir[1]) ||\n                        SITE.isDoor(grid, x - dir[0], y - dir[1])) {\n                        continue;\n                    }\n                }\n                else if (grid.hasXY(x - dir[0], y - dir[1]) &&\n                    SITE.isPassable(grid, x - dir[0], y - dir[1])) {\n                    if (!grid.hasXY(x + dir[0], y + dir[1]) ||\n                        SITE.isDoor(grid, x + dir[0], y + dir[1])) {\n                        continue;\n                    }\n                    dir = dir.map((v) => -1 * v);\n                }\n                else {\n                    continue; // not valid start for tunnel\n                }\n                startX = x + dir[0];\n                startY = y + dir[1];\n                endX = x;\n                endY = y;\n                for (j = 0; j < maxConnectionLength; ++j) {\n                    endX -= dir[0];\n                    endY -= dir[1];\n                    // if (grid.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                    if (isValidTunnelEnd(endX, endY, dir)) {\n                        break;\n                    }\n                }\n                if (j < maxConnectionLength) {\n                    GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                    // pathGrid.fill(30000);\n                    // pathGrid[startX][startY] = 0;\n                    // dijkstraScan(pathGrid, costGrid, false);\n                    if (pathGrid[endX][endY] > minimumPathingDistance &&\n                        pathGrid[endX][endY] < 30000) {\n                        // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,\n                        // dungeon.debug(\n                        //     'Adding Loop',\n                        //     startX,\n                        //     startY,\n                        //     ' => ',\n                        //     endX,\n                        //     endY,\n                        //     ' : ',\n                        //     pathGrid[endX][endY]\n                        // );\n                        while (endX !== startX || endY !== startY) {\n                            if (grid.get(endX, endY) == 0) {\n                                grid[endX][endY] = SITE.FLOOR;\n                                costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                            }\n                            endX += dir[0];\n                            endY += dir[1];\n                        }\n                        // TODO - Door is optional\n                        grid[x][y] = SITE.DOOR; // then turn the tile into a doorway.\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    GW.grid.free(pathGrid);\n    GW.grid.free(costGrid);\n}\nexport function addLakes(map, opts = {}) {\n    return LAKE.digLakes(map, opts);\n}\nexport function addBridges(map, minimumPathingDistance, maxConnectionLength) {\n    return LAKE.digBridges(map, minimumPathingDistance, maxConnectionLength);\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (SITE.isPassable(grid, i + k, j) &&\n                        !SITE.isPassable(grid, i + (1 - k), j) &&\n                        SITE.isObstruction(grid, i + (1 - k), j) &&\n                        !SITE.isPassable(grid, i + k, j + 1) &&\n                        SITE.isObstruction(grid, i + k, j + 1) &&\n                        SITE.isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = SITE.FLOOR; // todo - pick one of the passable tiles around it...\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        // todo - isDoorway...\n        if (cell == SITE.DOOR) {\n            if (\n            // TODO - isPassable\n            (grid.get(x + 1, y) == SITE.FLOOR ||\n                grid.get(x - 1, y) == SITE.FLOOR) &&\n                (grid.get(x, y + 1) == SITE.FLOOR ||\n                    grid.get(x, y - 1) == SITE.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor value\n            }\n            else if (\n            // todo - isPassable\n            (grid.get(x + 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== SITE.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== SITE.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = SITE.FLOOR; // todo - take passable neighbor\n            }\n        }\n    });\n}\nexport function finishWalls(grid, tile = SITE.WALL) {\n    grid.forEach((cell, i, j) => {\n        if (cell == SITE.NOTHING) {\n            grid[i][j] = tile;\n        }\n    });\n}\n"],"names":["fillCostGrid","source","costGrid","forEach","_v","x","y","isPassable","GW.path","OBSTRUCTION","grid","v","get","isDoor","isObstruction","isStairs","isAnyWater","Hall","[object Object]","loc","dir","length","width","this","doors","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","Room","digger","height","hall","cx","Math","floor","cy","translate","rooms","install","id","fn","config","data","checkConfig","expected","Object","entries","key","expect","have","undefined","ERROR","Array","isArray","range","GW.range","make","rectangular","value","tile","fill","fillRect","destX","destY","blobGrid","GW.grid","alloc","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","offsetZip","free","choices","GW.random","item","bind","weighted","digConfig","opts","assign","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","min","max","minorWidth","minorHeight","radius","fillCircle","ringMinWidth","holeMinSize","holeChance","chance","count","i","minX","maxX","minY","maxY","chunkCount","valueBounds","halls","pickWidth","clamp","Number","parseInt","_pickWidth","pickLengthRange","pickHallDirection","room","NO_DIRECTION","dirs","sequence","hi","door","hasXY","pickHallExits","newX","newY","obliqueChance","firstOpt","allowObliqueHallwayExit","hallDoors","dir2","dig","DIR","x0","y0","LEFT","lakeDisruptsPassability","map","lakeGrid","lakeToMapX","lakeToMapY","walkableGrid","disrupts","j","lakeX","lakeY","SITE.isStairs","SITE.isPassable","first","floodFill","isBridgeCandidate","bridgeDir","SITE.isAnyWater","SEQ","attachRoom","roomGrid","doorSites","directionOfDoorSite","oppDir","offsetX","offsetY","roomFitsAt","_d","_s","attachDoor","didSomething","k","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","isOpen","solutionDir","oppX","oppY","fnOpen","attachRoomAtMapDoor","mapDoors","doorIndexes","attachRoomAtXY","offX","offY","chooseRandomDoorSites","sourceGrid","floorTile","doorSiteFailed","copy","randomMatchingLoc","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","SITE.isObstruction","finishDoors","cell","finishWalls","tries","locs","name","ROOM.rooms","roomConfig","hallConfig","HALL.halls","attachHall","hallChance","result","xy","minimumPathingDistance","maxConnectionLength","startX","startY","endX","endY","siteGrid","pathGrid","dirCoords","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.isDoor","calculateDistances","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","canDisrupt","minSize","wreath","wreathTile","attempts","round","success","sx","sy","forCircle","LAKE.digLakes","NO_PATH","LAKE.digBridges"],"mappings":"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"}
{"version":3,"file":"gw-dig.min.js","sources":["../js/room.js","../js/hall.js","../js/gw.js","../js/dig.js"],"sourcesContent":["import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room {\n    constructor(digger, x, y, width, height) {\n        this.doors = [];\n        this.hall = null;\n        this.digger = digger;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\nexport var diggers = {};\nexport function install(id, fn, config) {\n    // @ts-ignore\n    config = fn(config || {}); // call to have function setup the config\n    config.fn = fn;\n    config.id = id;\n    diggers[id] = config;\n    return config;\n}\nexport function checkConfig(config, opts) {\n    config = config || {};\n    opts = opts || {};\n    if (!config.width || !config.height)\n        GW.utils.ERROR('All diggers require config to include width and height.');\n    Object.entries(opts).forEach(([key, expect]) => {\n        const have = config[key];\n        if (expect === true) {\n            // needs to be a number > 0\n            if (typeof have !== 'number') {\n                GW.utils.ERROR('Invalid configuration for digger: ' +\n                    key +\n                    ' expected number received ' +\n                    typeof have);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            const have = config[key];\n            if (typeof have !== 'number') {\n                config[key] = expect; // provide default\n            }\n        }\n        else if (Array.isArray(expect)) {\n            // needs to be an array with this size, these are the defaults\n            if (typeof have === 'number') {\n                config[key] = new Array(expect.length).fill(have);\n            }\n            else if (!Array.isArray(have)) {\n                GW.utils.WARN('Received unexpected config for digger : ' +\n                    key +\n                    ' expected array, received ' +\n                    typeof have +\n                    ', using defaults.');\n                config[key] = expect.slice();\n            }\n            else if (expect.length > have.length) {\n                for (let i = have.length; i < expect.length; ++i) {\n                    have[i] = expect[i];\n                }\n            }\n        }\n        else {\n            GW.utils.WARN('Unexpected digger configuration parameter: ', key, '' + expect);\n        }\n    });\n    return config;\n}\nexport function cavern(config, grid) {\n    config = checkConfig(config, { width: 12, height: 8 });\n    if (!grid)\n        return config;\n    let destX, destY;\n    let blobGrid;\n    blobGrid = GW.grid.alloc(grid.width, grid.height, 0);\n    const minWidth = Math.floor(0.5 * config.width); // 6\n    const maxWidth = config.width;\n    const minHeight = Math.floor(0.5 * config.height); // 4\n    const maxHeight = config.height;\n    grid.fill(0);\n    const bounds = blobGrid.fillBlob(5, minWidth, minHeight, maxWidth, maxHeight, 55, 'ffffffttt', 'ffffttttt');\n    // Position the new cave in the middle of the grid...\n    destX = Math.floor((grid.width - bounds.width) / 2);\n    destY = Math.floor((grid.height - bounds.height) / 2);\n    // ...and copy it to the master grid.\n    GW.grid.offsetZip(grid, blobGrid, destX - bounds.x, destY - bounds.y, CONST.FLOOR);\n    GW.grid.free(blobGrid);\n    return new Room(config.id, destX, destY, bounds.width, bounds.height);\n}\nexport function choiceRoom(config, grid) {\n    config = config || {};\n    let choices;\n    if (Array.isArray(config.choices)) {\n        choices = config.choices;\n    }\n    else if (typeof config.choices == 'object') {\n        choices = Object.keys(config.choices);\n    }\n    else {\n        GW.utils.ERROR('Expected choices to be either array of choices or map { digger: weight }');\n    }\n    for (let choice of choices) {\n        if (!diggers[choice]) {\n            GW.utils.ERROR('Missing digger choice: ' + choice);\n        }\n    }\n    if (!grid)\n        return config;\n    let id;\n    if (Array.isArray(config.choices)) {\n        id = GW.random.item(config.choices);\n    }\n    else {\n        id = GW.random.weighted(config.choices);\n    }\n    const digger = diggers[id];\n    let digConfig = digger;\n    if (config.opts) {\n        digConfig = Object.assign({}, digger, config.opts);\n    }\n    // debug('Chose room: ', id);\n    return digger.fn(digConfig, grid);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport function entranceRoom(config, grid) {\n    config = checkConfig(config, { width: 20, height: 10 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.floor(0.4 * config.width); // 8\n    const roomHeight = config.height;\n    const roomWidth2 = config.width;\n    const roomHeight2 = Math.floor(0.5 * config.height); // 5\n    // ALWAYS start at bottom+center of map\n    const roomX = Math.floor(grid.width / 2 - roomWidth / 2 - 1);\n    const roomY = grid.height - roomHeight - 2;\n    const roomX2 = Math.floor(grid.width / 2 - roomWidth2 / 2 - 1);\n    const roomY2 = grid.height - roomHeight2 - 2;\n    grid.fill(0);\n    grid.fillRect(roomX, roomY, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2, roomY2, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function crossRoom(config, grid) {\n    config = checkConfig(config, { width: 12, height: 20 });\n    if (!grid)\n        return config;\n    const roomWidth = Math.max(2, Math.floor((config.width * GW.random.range(15, 60)) / 100)); // [3,12]\n    const roomWidth2 = Math.max(2, Math.floor((config.width * GW.random.range(20, 100)) / 100)); // [4,20]\n    const roomHeight = Math.max(2, Math.floor((config.height * GW.random.range(50, 100)) / 100)); // [3,7]\n    const roomHeight2 = Math.max(2, Math.floor((config.height * GW.random.range(25, 75)) / 100)); // [2,5]\n    const roomX = GW.random.range(Math.max(0, Math.floor(grid.width / 2) - (roomWidth - 1)), Math.min(grid.width, Math.floor(grid.width / 2)));\n    const roomX2 = roomX +\n        Math.floor(roomWidth / 2) +\n        GW.random.range(0, 2) +\n        GW.random.range(0, 2) -\n        3 -\n        Math.floor(roomWidth2 / 2);\n    const roomY = Math.floor(grid.height / 2 - roomHeight);\n    const roomY2 = Math.floor(grid.height / 2 -\n        roomHeight2 -\n        (GW.random.range(0, 2) + GW.random.range(0, 1)));\n    grid.fill(0);\n    grid.fillRect(roomX - 5, roomY + 5, roomWidth, roomHeight, CONST.FLOOR);\n    grid.fillRect(roomX2 - 5, roomY2 + 5, roomWidth2, roomHeight2, CONST.FLOOR);\n    return new Room(config.id, Math.min(roomX, roomX2) - 5, Math.min(roomY, roomY2) - 5, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n}\nexport function symmetricalCrossRoom(config, grid) {\n    config = checkConfig(config, { width: 8, height: 5 });\n    if (!grid)\n        return config;\n    let majorWidth = Math.floor((config.width * GW.random.range(50, 100)) / 100); // [4,8]\n    let majorHeight = Math.floor((config.height * GW.random.range(75, 100)) / 100); // [4,5]\n    let minorWidth = Math.max(2, Math.floor((config.width * GW.random.range(25, 50)) / 100)); // [2,4]\n    if (majorHeight % 2 == 0 && minorWidth > 2) {\n        minorWidth -= 1;\n    }\n    let minorHeight = Math.max(2, Math.floor((config.height * GW.random.range(25, 50)) / 100)); // [2,3]?\n    if (majorWidth % 2 == 0 && minorHeight > 2) {\n        minorHeight -= 1;\n    }\n    grid.fill(0);\n    const x = Math.floor((grid.width - majorWidth) / 2);\n    const y = Math.floor((grid.height - minorHeight) / 2);\n    grid.fillRect(x, y, majorWidth, minorHeight, CONST.FLOOR);\n    const x2 = Math.floor((grid.width - minorWidth) / 2);\n    const y2 = Math.floor((grid.height - majorHeight) / 2);\n    grid.fillRect(x2, y2, minorWidth, majorHeight, CONST.FLOOR);\n    return new Room(config.id, Math.min(x, x2), Math.min(y, y2), Math.max(majorWidth, minorWidth), Math.max(majorHeight, minorHeight));\n}\nexport function rectangularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 4, minPct: 50 });\n    if (!grid)\n        return config;\n    const width = Math.floor((config.width * GW.random.range(config.minPct, 100)) / 100); // [3,6]\n    const height = Math.floor((config.height * GW.random.range(config.minPct, 100)) / 100); // [2,4]\n    grid.fill(0);\n    const x = Math.floor((grid.width - width) / 2);\n    const y = Math.floor((grid.height - height) / 2);\n    grid.fillRect(x, y, width, height, CONST.FLOOR);\n    return new Room(config.id, x, y, width, height);\n}\nexport function circularRoom(config, grid) {\n    config = checkConfig(config, { width: 6, height: 6 });\n    if (!grid)\n        return config;\n    const radius = Math.floor(((Math.min(config.width, config.height) - 1) *\n        GW.random.range(75, 100)) /\n        200); // [3,4]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    if (radius > 1) {\n        grid.fillCircle(x, y, radius, CONST.FLOOR);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function brogueDonut(config, grid) {\n    config = checkConfig(config, {\n        width: 10,\n        height: 10,\n        altChance: 5,\n        ringMinWidth: 3,\n        holeMinSize: 3,\n        holeChance: 50,\n    });\n    if (!grid)\n        return config;\n    const radius = Math.floor((Math.min(config.width, config.height) * GW.random.range(75, 100)) / 100); // [5,10]\n    grid.fill(0);\n    const x = Math.floor(grid.width / 2);\n    const y = Math.floor(grid.height / 2);\n    grid.fillCircle(x, y, radius, CONST.FLOOR);\n    if (radius > config.ringMinWidth + config.holeMinSize &&\n        GW.random.chance(config.holeChance)) {\n        grid.fillCircle(x, y, GW.random.range(config.holeMinSize, radius - config.holeMinSize), 0);\n    }\n    return new Room(config.id, x, y, radius * 2, radius * 2);\n}\nexport function chunkyRoom(config, grid) {\n    config = checkConfig(config, { count: 8 });\n    if (!grid)\n        return config;\n    let i, x, y;\n    let minX, maxX, minY, maxY;\n    let chunkCount = Math.floor((config.count * GW.random.range(25, 100)) / 100); // [2,8]\n    minX = Math.floor(grid.width / 2) - Math.floor(config.width / 2);\n    maxX = Math.floor(grid.width / 2) + Math.floor(config.width / 2);\n    minY = Math.floor(grid.height / 2) - Math.floor(config.height / 2);\n    maxY = Math.floor(grid.height / 2) + Math.floor(config.height / 2);\n    grid.fill(0);\n    grid.fillCircle(Math.floor(grid.width / 2), Math.floor(grid.height / 2), 2, CONST.FLOOR);\n    for (i = 0; i < chunkCount;) {\n        x = GW.random.range(minX, maxX);\n        y = GW.random.range(minY, maxY);\n        if (grid[x][y]) {\n            //            colorOverDungeon(/* Color. */darkGray);\n            //            hiliteGrid(grid, /* Color. */white, 100);\n            if (x - 2 < minX)\n                continue;\n            if (x + 2 > maxX)\n                continue;\n            if (y - 2 < minY)\n                continue;\n            if (y + 2 > maxY)\n                continue;\n            grid.fillCircle(x, y, 2, CONST.FLOOR);\n            i++;\n            //            hiliteGrid(grid, /* Color. */green, 50);\n            //            temporaryMessage(\"Added a chunk:\", true);\n        }\n    }\n    return new Room(config.id, minX, minY, maxX - minX + 1, maxY - minY + 1);\n}\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { Hall } from './room';\nconst DIRS = GW.utils.DIRS;\nexport function pickHallWidth(opts = {}) {\n    return GW.utils.clamp(_pickHallWidth(opts), 1, 3);\n}\nfunction _pickHallWidth(opts) {\n    if (typeof opts === 'number')\n        return opts;\n    if (!opts)\n        return 1;\n    if (opts.hallWidth === undefined)\n        return 1;\n    let width = opts.hallWidth;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else {\n        width = GW.random.weighted(width);\n    }\n    if (typeof width === 'string')\n        return Number.parseInt(width);\n    return width;\n}\nexport function pickHallLength(dir, opts) {\n    const horizontalLength = GW.utils.firstOpt('horizontalHallLength', opts, [\n        9,\n        15,\n    ]);\n    const verticalLength = GW.utils.firstOpt('verticalHallLength', opts, [\n        2,\n        9,\n    ]);\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return verticalLength;\n    }\n    else {\n        return horizontalLength;\n    }\n}\nexport function pickHallDirection(grid, room, opts) {\n    const doors = room.doors;\n    // Pick a direction.\n    let dir = opts.dir || GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = pickHallLength(dir, opts)[1]; // biggest measurement\n            const dx = doors[dir][0] + Math.floor(DIRS[dir][0] * length);\n            const dy = doors[dir][1] + Math.floor(DIRS[dir][1] * length);\n            if (doors[dir][0] != -1 &&\n                doors[dir][1] != -1 &&\n                grid.hasXY(dx, dy)) {\n                break; // That's our direction!\n            }\n            else {\n                dir = GW.utils.NO_DIRECTION;\n            }\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(grid, x, y, dir, opts) {\n    let newX, newY;\n    const obliqueChance = GW.utils.firstOpt('obliqueChance', opts, 15);\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !grid.hasXY(newX, newY) ||\n            grid[newX][newY]) {\n            hallDoors[dir2][0] = -1;\n            hallDoors[dir2][1] = -1;\n        }\n        else {\n            hallDoors[dir2][0] = newX;\n            hallDoors[dir2][1] = newY;\n        }\n    }\n    return hallDoors;\n}\nexport function digHall(grid, dir, length, room, opts) {\n    const door = room.doors[dir];\n    const DIR = DIRS[dir];\n    let x = door[0];\n    let y = door[1];\n    const tile = opts.tile || CONST.FLOOR;\n    for (let i = 0; i < length; i++) {\n        grid[x][y] = tile;\n        x += DIR[0];\n        y += DIR[1];\n    }\n    x -= DIR[0];\n    y -= DIR[1];\n    const hall = new Hall(door, dir, length);\n    hall.doors = pickHallExits(grid, x, y, dir, opts);\n    return hall;\n}\nexport function digHallTwo(grid, dir, length, room, opts) {\n    const door = room.doors[dir];\n    const tile = opts.tile || CONST.FLOOR;\n    const hallDoors = [\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n        [-1, -1],\n    ];\n    let x0, y0;\n    let hall;\n    if (dir === GW.utils.UP) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] - length + 1;\n        for (let x = x0; x < x0 + 2; ++x) {\n            for (let y = y0; y < y0 + length; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 - 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.DOWN) {\n        x0 = Math.max(door[0] - 1, room.x);\n        y0 = door[1] + length - 1;\n        for (let x = x0; x < x0 + 2; ++x) {\n            for (let y = y0; y > y0 - length; --y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0, y0 + 1];\n        hall = new Hall([x0, door[1]], dir, length, 2);\n    }\n    else if (dir === GW.utils.LEFT) {\n        x0 = door[0] - length + 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x < x0 + length; ++x) {\n            for (let y = y0; y < y0 + 2; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 - 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    else {\n        //if (dir === GW.utils.RIGHT) {\n        x0 = door[0] + length - 1;\n        y0 = Math.max(door[1] - 1, room.y);\n        for (let x = x0; x > x0 - length; --x) {\n            for (let y = y0; y < y0 + 2; ++y) {\n                grid[x][y] = tile;\n            }\n        }\n        hallDoors[dir] = [x0 + 1, y0];\n        hall = new Hall([door[0], y0], dir, length, 2);\n    }\n    hall.doors = hallDoors;\n    hall.width = 2;\n    return hall;\n}\nexport function attachHallway(grid, room, opts) {\n    opts = opts || {};\n    const dir = pickHallDirection(grid, room, opts);\n    if (dir === GW.utils.NO_DIRECTION)\n        return null;\n    console.log('dir', dir);\n    const length = GW.random.range(...pickHallLength(dir, opts));\n    console.log('length', length);\n    const width = opts.width || 1;\n    console.log('width', width);\n    if (width > 1) {\n        return digHallTwo(grid, dir, length, room, opts);\n    }\n    return digHall(grid, dir, length, room, opts);\n}\n","export const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const LAKE = 4;\nexport const BRIDGE = 5;\n","import * as GW from 'gw-utils';\nimport * as CONST from './gw';\nimport { attachHallway } from './hall';\n// import * as MAP from 'gw-map.js';\nexport * from './gw';\nexport * from './room';\nimport { diggers as DIGGERS } from './room';\nconst DIRS = GW.utils.DIRS;\nvar SEQ;\nexport function start(map) {\n    SEQ = GW.random.sequence(map.width * map.height);\n    map.fill(0);\n}\nexport function finish(map) {\n    removeDiagonalOpenings(map);\n    finishWalls(map);\n    finishDoors(map);\n}\n// Returns an array of door sites if successful\nexport function dig(map, opts = {}) {\n    if (typeof opts === 'string') {\n        opts = { digger: opts };\n    }\n    const diggerId = opts.digger || opts.id || 'SMALL'; // TODO - get random id\n    const digger = DIGGERS[diggerId];\n    if (!digger) {\n        GW.utils.ERROR('Failed to find digger: ' + diggerId);\n    }\n    let locs = opts.locs || opts.loc || null;\n    if (!locs || !Array.isArray(locs)) {\n        locs = null;\n        if (map.count(CONST.FLOOR) === 0) {\n            // empty map\n            const x = Math.floor(map.width / 2);\n            const y = map.height - 2;\n            locs = [[x, y]];\n        }\n    }\n    else if (locs &&\n        locs.length &&\n        locs.length == 2 &&\n        typeof locs[0] == 'number') {\n        locs = [locs];\n    }\n    else if (locs.length == 0) {\n        locs = null;\n    }\n    const config = Object.assign({}, digger, opts);\n    const roomGrid = GW.grid.alloc(map.width, map.height);\n    const hallChance = config.hallChance || config.hallway || 0;\n    const attachHall = GW.random.chance(hallChance);\n    // const force = config.force || false;\n    let result = false;\n    let room;\n    let tries = config.tries || 10;\n    while (--tries >= 0 && !result) {\n        roomGrid.fill(CONST.NOTHING);\n        // dig the room in the center\n        room = digger.fn(config, roomGrid);\n        room.doors = chooseRandomDoorSites(roomGrid);\n        if (attachHall) {\n            room.hall = attachHallway(roomGrid, room, config);\n        }\n        if (locs) {\n            // try the doors first\n            result = attachRoomAtMapDoor(map, locs, roomGrid, room, config);\n        }\n        else {\n            result = attachRoom(map, roomGrid, room, config);\n        }\n        // console.log(\n        //     'try',\n        //     room.hall ? 'hall: ' + room.hall.dir : 'no hall',\n        //     result\n        // );\n        // if (!result) {\n        //     roomGrid.dump();\n        //     map.dump();\n        //     console.log(\n        //         'room doors',\n        //         (room.hall ? room.hall.doors : room.doors).join(', ')\n        //     );\n        //     console.log('map locs', locs.join(', '));\n        // }\n    }\n    GW.grid.free(roomGrid);\n    return room && result ? room : null;\n}\nexport function attachRoom(map, roomGrid, room, opts = {}) {\n    // console.log('attachRoom');\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (!(map.get(x, y) == CONST.NOTHING))\n            continue;\n        const dir = GW.grid.directionOfDoorSite(map, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const oppDir = (dir + 2) % 4;\n            const offsetX = x - doorSites[oppDir][0];\n            const offsetY = y - doorSites[oppDir][1];\n            if (doorSites[oppDir][0] != -1 &&\n                roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n                // Room fits here.\n                GW.grid.offsetZip(map, roomGrid, offsetX, offsetY, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[x][y] = opts.door || CONST.DOOR; // Door site.\n                }\n                // doorSites[oppDir][0] = -1;\n                // doorSites[oppDir][1] = -1;\n                room.translate(offsetX, offsetY);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n    let xRoom, yRoom, xSite, ySite, i, j;\n    // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n    for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n        for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n            if (roomGrid[xRoom][yRoom]) {\n                xSite = xRoom + roomToSiteX;\n                ySite = yRoom + roomToSiteY;\n                for (i = xSite - 1; i <= xSite + 1; i++) {\n                    for (j = ySite - 1; j <= ySite + 1; j++) {\n                        if (!map.hasXY(i, j) ||\n                            map.isBoundaryXY(i, j) ||\n                            !(map.get(i, j) === CONST.NOTHING)) {\n                            // console.log('- NO');\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // console.log('- YES');\n    return true;\n}\nexport function forceRoomAtMapLoc(map, xy, roomGrid, room, opts = {}) {\n    // console.log('forceRoomAtMapLoc', xy);\n    // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < SEQ.length; i++) {\n        const x = Math.floor(SEQ[i] / map.height);\n        const y = SEQ[i] % map.height;\n        if (roomGrid[x][y])\n            continue;\n        const dir = GW.grid.directionOfDoorSite(roomGrid, x, y, CONST.FLOOR);\n        if (dir != GW.utils.NO_DIRECTION) {\n            const dx = xy[0] - x;\n            const dy = xy[1] - y;\n            if (roomFitsAt(map, roomGrid, dx, dy)) {\n                GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n                    map[i][j] = opts.tile || CONST.FLOOR;\n                });\n                if (opts.door || opts.placeDoor !== false) {\n                    map[xy[0]][xy[1]] = opts.door || CONST.DOOR; // Door site.\n                }\n                // TODO - Update doors - we may have to erase one...\n                room.translate(dx, dy);\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction attachRoomAtMapDoor(map, mapDoors, roomGrid, room, opts = {}) {\n    const doorIndexes = GW.random.sequence(mapDoors.length);\n    // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n    // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n    for (let i = 0; i < doorIndexes.length; i++) {\n        const index = doorIndexes[i];\n        const door = mapDoors[index];\n        if (!door)\n            continue;\n        const x = door[0];\n        const y = door[1];\n        if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction attachRoomAtXY(map, x, y, roomGrid, room, opts = {}) {\n    const doorSites = room.hall ? room.hall.doors : room.doors;\n    const dirs = GW.random.sequence(4);\n    // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n    for (let dir of dirs) {\n        const oppDir = (dir + 2) % 4;\n        const door = doorSites[oppDir];\n        if (!door)\n            continue;\n        if (door[0] != -1 &&\n            roomFitsAt(map, roomGrid, x - door[0], y - door[1])) {\n            // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n            // Room fits here.\n            const offX = x - door[0];\n            const offY = y - door[1];\n            GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n                map[i][j] = opts.tile || CONST.FLOOR;\n            });\n            if (opts.door || opts.placeDoor !== false) {\n                map[x][y] = opts.door || CONST.DOOR; // Door site.\n            }\n            room.translate(offX, offY);\n            // const newDoors = doorSites.map((site) => {\n            //     const x0 = site[0] + offX;\n            //     const y0 = site[1] + offY;\n            //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n            //     return [x0, y0] as GW.utils.Loc;\n            // });\n            return true;\n        }\n    }\n    return false;\n}\nexport function chooseRandomDoorSites(sourceGrid) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    grid.copy(sourceGrid);\n    for (i = 0; i < grid.width; i++) {\n        for (j = 0; j < grid.height; j++) {\n            if (!grid[i][j]) {\n                dir = GW.grid.directionOfDoorSite(grid, i, j, 1);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + DIRS[dir][0];\n                    newY = j + DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && grid.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (grid[newX][newY]) {\n                            doorSiteFailed = true;\n                        }\n                        newX += DIRS[dir][0];\n                        newY += DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        grid[i][j] = dir + 200; // So as not to conflict with other tiles.\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = grid.randomMatchingLoc(dir + 200) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    GW.grid.free(grid);\n    return doorSites;\n}\nexport function isPassable(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.FLOOR || v === CONST.DOOR || v === CONST.BRIDGE;\n}\nexport function isObstruction(grid, x, y) {\n    const v = grid.get(x, y);\n    return v === CONST.NOTHING || v === CONST.WALL;\n}\nexport function removeDiagonalOpenings(grid) {\n    let i, j, k, x1, y1;\n    let diagonalCornerRemoved;\n    do {\n        diagonalCornerRemoved = false;\n        for (i = 0; i < grid.width - 1; i++) {\n            for (j = 0; j < grid.height - 1; j++) {\n                for (k = 0; k <= 1; k++) {\n                    if (isPassable(grid, i + k, j) &&\n                        !isPassable(grid, i + (1 - k), j) &&\n                        isObstruction(grid, i + (1 - k), j) &&\n                        !isPassable(grid, i + k, j + 1) &&\n                        isObstruction(grid, i + k, j + 1) &&\n                        isPassable(grid, i + (1 - k), j + 1)) {\n                        if (GW.random.chance(50)) {\n                            x1 = i + (1 - k);\n                            y1 = j;\n                        }\n                        else {\n                            x1 = i + k;\n                            y1 = j + 1;\n                        }\n                        diagonalCornerRemoved = true;\n                        grid[x1][y1] = CONST.FLOOR;\n                    }\n                }\n            }\n        }\n    } while (diagonalCornerRemoved == true);\n}\nexport function finishDoors(grid) {\n    grid.forEach((cell, x, y) => {\n        if (grid.isBoundaryXY(x, y))\n            return;\n        if (cell == CONST.DOOR) {\n            if ((grid.get(x + 1, y) == CONST.FLOOR ||\n                grid.get(x - 1, y) == CONST.FLOOR) &&\n                (grid.get(x, y + 1) == CONST.FLOOR ||\n                    grid.get(x, y - 1) == CONST.FLOOR)) {\n                // If there's passable terrain to the left or right, and there's passable terrain\n                // above or below, then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n            else if ((grid.get(x + 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x - 1, y) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y + 1) !== CONST.FLOOR ? 1 : 0) +\n                (grid.get(x, y - 1) !== CONST.FLOOR ? 1 : 0) >=\n                3) {\n                // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                // then the door is orphaned and must be removed.\n                grid[x][y] = CONST.FLOOR;\n            }\n        }\n    });\n}\nexport function finishWalls(grid) {\n    grid.forEach((cell, i, j) => {\n        if (cell == CONST.NOTHING) {\n            grid[i][j] = CONST.WALL;\n        }\n    });\n}\n"],"names":["Hall","[object Object]","loc","dir","length","width","this","doors","x","y","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","digger","height","hall","cx","Math","floor","cy","translate","diggers","checkConfig","config","opts","ERROR","Object","entries","key","expect","have","Array","isArray","fill","i","WARN","slice","pickHallLength","horizontalLength","firstOpt","verticalLength","digHall","grid","room","door","DIR","tile","newX","newY","obliqueChance","allowObliqueHallwayExit","GW.random","chance","hallDoors","dir2","hasXY","pickHallExits","attachHallway","NO_DIRECTION","dirs","sequence","pickHallDirection","console","log","range","x0","y0","max","LEFT","digHallTwo","SEQ","attachRoom","map","roomGrid","doorSites","get","GW.grid","directionOfDoorSite","oppDir","offsetX","offsetY","roomFitsAt","offsetZip","_d","_s","j","placeDoor","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","isBoundaryXY","attachRoomAtMapDoor","mapDoors","doorIndexes","attachRoomAtXY","offX","offY","chooseRandomDoorSites","sourceGrid","k","doorSiteFailed","alloc","copy","randomMatchingLoc","free","isPassable","v","isObstruction","removeDiagonalOpenings","x1","y1","diagonalCornerRemoved","finishDoors","cell","finishWalls","diggerId","id","DIGGERS","locs","count","assign","hallChance","hallway","attachHall","result","tries","fn","xy","destX","destY","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","fillBlob","choices","keys","choice","item","weighted","digConfig","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","fillRect","min","majorWidth","majorHeight","minorWidth","minorHeight","minPct","radius","fillCircle","altChance","ringMinWidth","holeMinSize","holeChance","minX","maxX","minY","maxY","chunkCount"],"mappings":"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"}
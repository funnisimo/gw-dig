{"version":3,"file":"gw-dig.min.js","sources":["../js/dig/types.js","../js/dig/utils.js","../js/site.js","../js/dig/room.js","../js/dig/hall.js","../js/dig/lake.js","../js/dig/bridge.js","../js/dig/stairs.js","../js/dig/loop.js","../js/dig/level.js","../js/dig/dungeon.js","../js/build/blueprint.js","../js/build/chokeFinder.js","../js/build/loopFinder.js","../js/build/index.js"],"sourcesContent":["import * as GW from 'gw-utils';\nexport class Hall {\n    constructor(loc, dir, length, width = 1) {\n        this.width = 1;\n        this.doors = [];\n        this.x = loc[0];\n        this.y = loc[1];\n        const d = GW.utils.DIRS[dir];\n        this.length = length;\n        this.width = width;\n        // console.log('Hall', loc, d, length, width);\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            this.x2 = this.x + (width - 1);\n            this.y2 = this.y + (length - 1) * d[1];\n        }\n        else {\n            this.x2 = this.x + (length - 1) * d[0];\n            this.y2 = this.y + (width - 1);\n        }\n        // console.log(' - ', [this.x2, this.y2]);\n        this.dir = dir;\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        this.x2 += dx;\n        this.y2 += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n    }\n}\nexport class Room extends GW.utils.Bounds {\n    constructor(x, y, width, height) {\n        super(x, y, width, height);\n        this.doors = [];\n        this.hall = null;\n    }\n    get cx() {\n        return this.x + Math.floor(this.width / 2);\n    }\n    get cy() {\n        return this.y + Math.floor(this.height / 2);\n    }\n    translate(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n        if (this.doors) {\n            this.doors.forEach((d) => {\n                if (!d)\n                    return;\n                if (d[0] < 0 || d[1] < 0)\n                    return;\n                d[0] += dx;\n                d[1] += dy;\n            });\n        }\n        if (this.hall) {\n            this.hall.translate(dx, dy);\n        }\n    }\n}\n// export interface DigInfo {\n//     room: RoomData;\n//     hall: HallData | null;\n//     tries: number;\n//     locs: GW.utils.Loc[] | null;\n//     door: number;\n// }\n","import * as GW from 'gw-utils';\n// import * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\n// export function attachRoom(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ) {\n//     // console.log('attachRoom');\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const site = new SITE.GridSite(map);\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (!(map.get(x, y) == SITE.NOTHING)) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const oppDir = (dir + 2) % 4;\n//             const door = doorSites[oppDir];\n//             if (!door) continue;\n//             const offsetX = x - door[0];\n//             const offsetY = y - door[1];\n//             if (door[0] != -1 && roomFitsAt(map, roomGrid, offsetX, offsetY)) {\n//                 // TYPES.Room fits here.\n//                 GW.grid.offsetZip(\n//                     map,\n//                     roomGrid,\n//                     offsetX,\n//                     offsetY,\n//                     (_d, _s, i, j) => {\n//                         map[i][j] = opts.room.tile || SITE.FLOOR;\n//                     }\n//                 );\n//                 attachDoor(map, room, opts, x, y, oppDir);\n//                 // door[0] = -1;\n//                 // door[1] = -1;\n//                 room.translate(offsetX, offsetY);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachDoor(\n//     map: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo,\n//     x: number,\n//     y: number,\n//     dir: number\n// ) {\n//     if (opts.door === 0) return; // no door at all\n//     const tile = opts.door || SITE.DOOR;\n//     map[x][y] = tile; // Door site.\n//     // most cases...\n//     if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n//         return;\n//     }\n//     if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x - k, y) === 0) {\n//                 if (map.get(x - k, y - 1) && map.get(x - k, y + 1)) {\n//                     map[x - k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x + k, y) === 0) {\n//                 if (map.get(x + k, y - 1) && map.get(x + k, y + 1)) {\n//                     map[x + k][y] = tile;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     } else {\n//         let didSomething = true;\n//         let k = 1;\n//         while (didSomething) {\n//             didSomething = false;\n//             if (map.get(x, y - k) === 0) {\n//                 if (map.get(x - 1, y - k) && map.get(x + 1, y - k)) {\n//                     map[x][y - k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             if (map.get(x, y + k) === 0) {\n//                 if (map.get(x - 1, y + k) && map.get(x + 1, y + k)) {\n//                     map[x][y + k] = opts.door;\n//                     didSomething = true;\n//                 }\n//             }\n//             ++k;\n//         }\n//     }\n// }\n// export function roomFitsAt(\n//     map: GW.grid.NumGrid,\n//     roomGrid: GW.grid.NumGrid,\n//     roomToSiteX: number,\n//     roomToSiteY: number\n// ) {\n//     let xRoom, yRoom, xSite, ySite, i, j;\n//     // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n//     for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n//         for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n//             if (roomGrid[xRoom][yRoom]) {\n//                 xSite = xRoom + roomToSiteX;\n//                 ySite = yRoom + roomToSiteY;\n//                 for (i = xSite - 1; i <= xSite + 1; i++) {\n//                     for (j = ySite - 1; j <= ySite + 1; j++) {\n//                         if (\n//                             !map.hasXY(i, j) ||\n//                             map.isBoundaryXY(i, j) ||\n//                             !(map.get(i, j) === SITE.NOTHING)\n//                         ) {\n//                             // console.log('- NO');\n//                             return false;\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//     // console.log('- YES');\n//     return true;\n// }\n// If the indicated tile is a wall on the room stored in grid, and it could be the site of\n// a door out of that room, then return the outbound direction that the door faces.\n// Otherwise, return def.NO_DIRECTION.\nexport function directionOfDoorSite(site, x, y) {\n    let dir, solutionDir;\n    let newX, newY, oppX, oppY;\n    solutionDir = GW.utils.NO_DIRECTION;\n    for (dir = 0; dir < 4; dir++) {\n        newX = x + DIRS[dir][0];\n        newY = y + DIRS[dir][1];\n        oppX = x - DIRS[dir][0];\n        oppY = y - DIRS[dir][1];\n        if (site.hasXY(oppX, oppY) &&\n            site.hasXY(newX, newY) &&\n            site.isFloor(oppX, oppY)) {\n            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.\n            if (solutionDir != GW.utils.NO_DIRECTION) {\n                // Already claimed by another direction; no doors here!\n                return GW.utils.NO_DIRECTION;\n            }\n            solutionDir = dir;\n        }\n    }\n    return solutionDir;\n}\nexport function chooseRandomDoorSites(site) {\n    let i, j, k, newX, newY;\n    let dir;\n    let doorSiteFailed;\n    const DOORS = [[], [], [], []];\n    // const grid = GW.grid.alloc(sourceGrid.width, sourceGrid.height);\n    // grid.copy(sourceGrid);\n    const h = site.height;\n    const w = site.width;\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < h; j++) {\n            if (site.isDiggable(i, j)) {\n                dir = directionOfDoorSite(site, i, j);\n                if (dir != GW.utils.NO_DIRECTION) {\n                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.\n                    // If it does, it's not a valid door site.\n                    newX = i + GW.utils.DIRS[dir][0];\n                    newY = j + GW.utils.DIRS[dir][1];\n                    doorSiteFailed = false;\n                    for (k = 0; k < 10 && site.hasXY(newX, newY) && !doorSiteFailed; k++) {\n                        if (site.isSet(newX, newY)) {\n                            doorSiteFailed = true;\n                        }\n                        newX += GW.utils.DIRS[dir][0];\n                        newY += GW.utils.DIRS[dir][1];\n                    }\n                    if (!doorSiteFailed) {\n                        DOORS[dir].push([i, j]);\n                    }\n                }\n            }\n        }\n    }\n    let doorSites = [];\n    // Pick four doors, one in each direction, and store them in doorSites[dir].\n    for (dir = 0; dir < 4; dir++) {\n        const loc = GW.random.item(DOORS[dir]) || [-1, -1];\n        doorSites[dir] = [loc[0], loc[1]];\n    }\n    // GW.grid.free(grid);\n    return doorSites;\n}\n// export function forceRoomAtMapLoc(\n//     map: GW.grid.NumGrid,\n//     xy: GW.utils.Loc,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigConfig\n// ) {\n//     // console.log('forceRoomAtMapLoc', xy);\n//     const site = new SITE.GridSite(map);\n//     // Slide room across map, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < SITE.SEQ.length; i++) {\n//         const x = Math.floor(SITE.SEQ[i] / map.height);\n//         const y = SITE.SEQ[i] % map.height;\n//         if (roomGrid[x][y]) continue;\n//         const dir = directionOfDoorSite(site, x, y);\n//         if (dir != GW.utils.NO_DIRECTION) {\n//             const dx = xy[0] - x;\n//             const dy = xy[1] - y;\n//             if (roomFitsAt(map, roomGrid, dx, dy)) {\n//                 GW.grid.offsetZip(map, roomGrid, dx, dy, (_d, _s, i, j) => {\n//                     map[i][j] = opts.room.tile || SITE.FLOOR;\n//                 });\n//                 if (opts.room.door !== false) {\n//                     const door =\n//                         opts.room.door === true || !opts.room.door\n//                             ? SITE.DOOR\n//                             : opts.room.door;\n//                     map[xy[0]][xy[1]] = door; // Door site.\n//                 }\n//                 // TODO - Update doors - we may have to erase one...\n//                 room.translate(dx, dy);\n//                 return true;\n//             }\n//         }\n//     }\n//     return false;\n// }\n// export function attachRoomAtMapDoor(\n//     map: GW.grid.NumGrid,\n//     mapDoors: GW.utils.Loc[],\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorIndexes = GW.random.sequence(mapDoors.length);\n//     // console.log('attachRoomAtMapDoor', mapDoors.join(', '));\n//     // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n//     for (let i = 0; i < doorIndexes.length; i++) {\n//         const index = doorIndexes[i];\n//         const door = mapDoors[index];\n//         if (!door) continue;\n//         const x = door[0];\n//         const y = door[1];\n//         if (attachRoomAtXY(map, x, y, roomGrid, room, opts)) {\n//             return true;\n//         }\n//     }\n//     return false;\n// }\n// function attachRoomAtXY(\n//     map: GW.grid.NumGrid,\n//     x: number,\n//     y: number,\n//     roomGrid: GW.grid.NumGrid,\n//     room: TYPES.Room,\n//     opts: TYPES.DigInfo\n// ): boolean | GW.utils.Loc[] {\n//     const doorSites = room.hall ? room.hall.doors : room.doors;\n//     const dirs = GW.random.sequence(4);\n//     // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n//     for (let dir of dirs) {\n//         const oppDir = (dir + 2) % 4;\n//         const door = doorSites[oppDir];\n//         if (!door) continue;\n//         if (\n//             door[0] != -1 &&\n//             roomFitsAt(map, roomGrid, x - door[0], y - door[1])\n//         ) {\n//             // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n//             // TYPES.Room fits here.\n//             const offX = x - door[0];\n//             const offY = y - door[1];\n//             GW.grid.offsetZip(map, roomGrid, offX, offY, (_d, _s, i, j) => {\n//                 map[i][j] = opts.room.tile || SITE.FLOOR;\n//             });\n//             attachDoor(map, room, opts, x, y, oppDir);\n//             room.translate(offX, offY);\n//             // const newDoors = doorSites.map((site) => {\n//             //     const x0 = site[0] + offX;\n//             //     const y0 = site[1] + offY;\n//             //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n//             //     return [x0, y0] as GW.utils.Loc;\n//             // });\n//             return true;\n//         }\n//     }\n//     return false;\n// }\nexport function copySite(dest, source, offsetX = 0, offsetY = 0) {\n    GW.utils.forRect(dest.width, dest.height, (x, y) => {\n        const otherX = x - offsetX;\n        const otherY = y - offsetY;\n        const v = source.getTile(otherX, otherY);\n        if (!v)\n            return;\n        dest.setTile(x, y, v);\n    });\n}\n","import * as GW from 'gw-utils';\nexport const NOTHING = 0;\nexport const FLOOR = 1;\nexport const DOOR = 2;\nexport const WALL = 3;\nexport const DEEP = 4;\nexport const SHALLOW = 5;\nexport const BRIDGE = 6;\nexport const UP_STAIRS = 7;\nexport const DOWN_STAIRS = 17;\nexport const IMPREGNABLE = 8;\nexport const TILEMAP = {\n    [NOTHING]: 'NULL',\n    [FLOOR]: 'FLOOR',\n    [DOOR]: 'DOOR',\n    [WALL]: 'WALL',\n    [IMPREGNABLE]: 'IMPREGNABLE',\n    [DEEP]: 'LAKE',\n    [SHALLOW]: 'SHALLOW',\n    [BRIDGE]: 'BRIDGE',\n    [UP_STAIRS]: 'UP_STAIRS',\n    [DOWN_STAIRS]: 'DOWN_STAIRS',\n};\nexport const SEQ = [];\nexport function initSeqence(length) {\n    SEQ.length = length;\n    for (let i = 0; i < length; ++i) {\n        SEQ[i] = i;\n    }\n    GW.random.shuffle(SEQ);\n}\nexport function fillCostGrid(source, costGrid) {\n    costGrid.update((_v, x, y) => source.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n}\nconst Fl = GW.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"IS_IN_LOOP\"] = Fl(0)] = \"IS_IN_LOOP\";\n    Flags[Flags[\"IS_CHOKEPOINT\"] = Fl(1)] = \"IS_CHOKEPOINT\";\n    Flags[Flags[\"IS_GATE_SITE\"] = Fl(2)] = \"IS_GATE_SITE\";\n    Flags[Flags[\"IS_IN_ROOM_MACHINE\"] = Fl(3)] = \"IS_IN_ROOM_MACHINE\";\n    Flags[Flags[\"IS_IN_AREA_MACHINE\"] = Fl(4)] = \"IS_IN_AREA_MACHINE\";\n    Flags[Flags[\"IMPREGNABLE\"] = Fl(5)] = \"IMPREGNABLE\";\n    Flags[Flags[\"IS_IN_MACHINE\"] = Flags.IS_IN_ROOM_MACHINE | Flags.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n})(Flags || (Flags = {}));\nexport class GridSite {\n    constructor(width, height) {\n        this.tiles = GW.grid.alloc(width, height);\n        this.flags = GW.grid.alloc(width, height);\n        this.choke = GW.grid.alloc(width, height);\n    }\n    free() {\n        GW.grid.free(this.tiles);\n        GW.grid.free(this.flags);\n        GW.grid.free(this.choke);\n    }\n    get width() {\n        return this.tiles.width;\n    }\n    get height() {\n        return this.tiles.height;\n    }\n    hasXY(x, y) {\n        return this.tiles.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.tiles.isBoundaryXY(x, y);\n    }\n    isPassable(x, y) {\n        return (this.isFloor(x, y) ||\n            this.isDoor(x, y) ||\n            this.isBridge(x, y) ||\n            this.isStairs(x, y) ||\n            this.isShallow(x, y));\n    }\n    isNothing(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isDiggable(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === NOTHING;\n    }\n    isFloor(x, y) {\n        return this.tiles.get(x, y) == FLOOR;\n    }\n    isDoor(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === DOOR;\n    }\n    isBridge(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === BRIDGE;\n    }\n    isWall(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === WALL || v === IMPREGNABLE;\n    }\n    isObstruction(x, y) {\n        return this.isNothing(x, y) || this.isWall(x, y);\n    }\n    isStairs(x, y) {\n        const v = this.tiles.get(x, y);\n        return v === UP_STAIRS || v === DOWN_STAIRS;\n    }\n    isDeep(x, y) {\n        return this.tiles.get(x, y) === DEEP;\n    }\n    isShallow(x, y) {\n        return this.tiles.get(x, y) === SHALLOW;\n    }\n    isAnyWater(x, y) {\n        return this.isDeep(x, y) || this.isShallow(x, y);\n    }\n    isSet(x, y) {\n        return (this.tiles.get(x, y) || 0) > 0;\n    }\n    getTile(x, y) {\n        return this.tiles.get(x, y) || 0;\n    }\n    setTile(x, y, tile) {\n        if (this.tiles.hasXY(x, y))\n            this.tiles[x][y] = tile;\n    }\n    hasSiteFlag(x, y, flag) {\n        const have = this.flags.get(x, y) || 0;\n        return !!(have & flag);\n    }\n    setSiteFlag(x, y, flag) {\n        const value = (this.flags.get(x, y) || 0) | flag;\n        this.flags.set(x, y, value);\n    }\n    clearSiteFlag(x, y, flag) {\n        const value = (this.flags.get(x, y) || 0) & ~flag;\n        this.flags.set(x, y, value);\n    }\n    getChokeCount(x, y) {\n        return this.choke.get(x, y) || 0;\n    }\n    setChokeCount(x, y, count) {\n        this.choke.set(x, y, count);\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as TYPES from './types';\nimport * as UTILS from './utils';\nimport * as SITE from '../site';\nexport function checkConfig(config, expected = {}) {\n    config = config || {};\n    expected = expected || {};\n    Object.entries(expected).forEach(([key, expect]) => {\n        let have = config[key];\n        if (key === 'tile') {\n            if (have === undefined) {\n                config[key] = expect;\n            }\n            return;\n        }\n        if (expect === true) {\n            // needs to be present\n            if (!have) {\n                throw new Error('Missing required config for room digger: ' + key);\n            }\n        }\n        else if (typeof expect === 'number') {\n            // needs to be a number, this is the default\n            have = have || expect;\n        }\n        else if (Array.isArray(expect)) {\n            have = have || expect;\n        }\n        else {\n            // just set the value\n            have = have || expect;\n        }\n        const range = GW.range.make(have); // throws if invalid\n        config[key] = range;\n    });\n    return config;\n}\nexport class RoomDigger {\n    constructor(config, expected = {}) {\n        this.options = {};\n        this.doors = [];\n        this._setOptions(config, expected);\n    }\n    _setOptions(config, expected = {}) {\n        this.options = checkConfig(config, expected);\n    }\n    create(site) {\n        const result = this.carve(site);\n        if (result) {\n            if (!result.doors ||\n                result.doors.length == 0 ||\n                result.doors.every((loc) => !loc || loc[0] == -1)) {\n                result.doors = UTILS.chooseRandomDoorSites(site);\n            }\n        }\n        return result;\n    }\n}\nexport var rooms = {};\nexport class ChoiceRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            choices: ['DEFAULT'],\n        });\n    }\n    _setOptions(config, expected = {}) {\n        const choices = config.choices || expected.choices;\n        if (Array.isArray(choices)) {\n            this.randomRoom = GW.random.item.bind(GW.random, choices);\n        }\n        else if (typeof choices == 'object') {\n            this.randomRoom = GW.random.weighted.bind(GW.random, choices);\n        }\n        else {\n            throw new Error('Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }');\n        }\n    }\n    carve(site) {\n        let id = this.randomRoom();\n        const room = rooms[id];\n        if (!room) {\n            GW.utils.ERROR('Missing room digger choice: ' + id);\n        }\n        // debug('Chose room: ', id);\n        return room.create(site);\n    }\n}\nexport function choiceRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChoiceRoom(config);\n    return digger.create(site);\n}\nexport class Cavern extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 12,\n            height: 8,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const blobGrid = GW.grid.alloc(site.width, site.height, 0);\n        const minWidth = Math.floor(0.5 * width); // 6\n        const maxWidth = width;\n        const minHeight = Math.floor(0.5 * height); // 4\n        const maxHeight = height;\n        const blob = new GW.blob.Blob({\n            rounds: 5,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            percentSeeded: 55,\n            birthParameters: 'ffffftttt',\n            survivalParameters: 'ffffttttt',\n        });\n        const bounds = blob.carve(blobGrid.width, blobGrid.height, (x, y) => (blobGrid[x][y] = 1));\n        // Position the new cave in the middle of the grid...\n        const destX = Math.floor((site.width - bounds.width) / 2);\n        const dx = destX - bounds.x;\n        const destY = Math.floor((site.height - bounds.height) / 2);\n        const dy = destY - bounds.y;\n        // ...and copy it to the destination.\n        blobGrid.forEach((v, x, y) => {\n            if (v)\n                site.setTile(x + dx, y + dy, tile);\n        });\n        GW.grid.free(blobGrid);\n        return new TYPES.Room(destX, destY, bounds.width, bounds.height);\n    }\n}\nexport function cavern(config, site) {\n    // grid.fill(0);\n    const digger = new Cavern(config);\n    return digger.create(site);\n}\n// From BROGUE => This is a special room that appears at the entrance to the dungeon on depth 1.\nexport class BrogueEntrance extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: 20,\n            height: 10,\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = Math.floor(0.4 * width); // 8\n        const roomHeight = height;\n        const roomWidth2 = width;\n        const roomHeight2 = Math.floor(0.5 * height); // 5\n        // ALWAYS start at bottom+center of map\n        const roomX = Math.floor(site.width / 2 - roomWidth / 2 - 1);\n        const roomY = site.height - roomHeight - 2;\n        const roomX2 = Math.floor(site.width / 2 - roomWidth2 / 2 - 1);\n        const roomY2 = site.height - roomHeight2 - 2;\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        const room = new TYPES.Room(Math.min(roomX, roomX2), Math.min(roomY, roomY2), Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n        room.doors[GW.utils.DOWN] = [\n            Math.floor(site.width / 2),\n            site.height - 2,\n        ];\n        return room;\n    }\n}\nexport function brogueEntrance(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueEntrance(config);\n    return digger.create(site);\n}\nexport class Cross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 12, height: 20 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const roomWidth = width;\n        const roomWidth2 = Math.max(3, Math.floor((width * GW.random.range(25, 75)) / 100)); // [4,20]\n        const roomHeight = Math.max(3, Math.floor((height * GW.random.range(25, 75)) / 100)); // [2,5]\n        const roomHeight2 = height;\n        const roomX = Math.floor((site.width - roomWidth) / 2);\n        const roomX2 = roomX + GW.random.range(2, Math.max(2, roomWidth - roomWidth2 - 2));\n        const roomY2 = Math.floor((site.height - roomHeight2) / 2);\n        const roomY = roomY2 +\n            GW.random.range(2, Math.max(2, roomHeight2 - roomHeight - 2));\n        GW.utils.forRect(roomX, roomY, roomWidth, roomHeight, (x, y) => site.setTile(x, y, tile));\n        GW.utils.forRect(roomX2, roomY2, roomWidth2, roomHeight2, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(roomX, roomY2, Math.max(roomWidth, roomWidth2), Math.max(roomHeight, roomHeight2));\n    }\n}\nexport function cross(config, site) {\n    // grid.fill(0);\n    const digger = new Cross(config);\n    return digger.create(site);\n}\nexport class SymmetricalCross extends RoomDigger {\n    constructor(config = {}) {\n        super(config, { width: 7, height: 7 });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        let minorWidth = Math.max(3, Math.floor((width * GW.random.range(25, 50)) / 100)); // [2,4]\n        // if (height % 2 == 0 && minorWidth > 2) {\n        //     minorWidth -= 1;\n        // }\n        let minorHeight = Math.max(3, Math.floor((height * GW.random.range(25, 50)) / 100)); // [2,3]?\n        // if (width % 2 == 0 && minorHeight > 2) {\n        //     minorHeight -= 1;\n        // }\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - minorHeight) / 2);\n        GW.utils.forRect(x, y, width, minorHeight, (x, y) => site.setTile(x, y, tile));\n        const x2 = Math.floor((site.width - minorWidth) / 2);\n        const y2 = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x2, y2, minorWidth, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(Math.min(x, x2), Math.min(y, y2), Math.max(width, minorWidth), Math.max(height, minorHeight));\n    }\n}\nexport function symmetricalCross(config, site) {\n    // grid.fill(0);\n    const digger = new SymmetricalCross(config);\n    return digger.create(site);\n}\nexport class Rectangular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            width: [3, 6],\n            height: [3, 6],\n        });\n    }\n    carve(site) {\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor((site.width - width) / 2);\n        const y = Math.floor((site.height - height) / 2);\n        GW.utils.forRect(x, y, width, height, (x, y) => site.setTile(x, y, tile));\n        return new TYPES.Room(x, y, width, height);\n    }\n}\nexport function rectangular(config, site) {\n    // grid.fill(0);\n    const digger = new Rectangular(config);\n    return digger.create(site);\n}\nexport class Circular extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [3, 4],\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        if (radius > 1) {\n            GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function circular(config, site) {\n    // grid.fill(0);\n    const digger = new Circular(config);\n    return digger.create(site);\n}\nexport class BrogueDonut extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            radius: [5, 10],\n            ringMinWidth: 3,\n            holeMinSize: 3,\n            holeChance: 50,\n        });\n    }\n    carve(site) {\n        const radius = this.options.radius.value();\n        const ringMinWidth = this.options.ringMinWidth.value();\n        const holeMinSize = this.options.holeMinSize.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const x = Math.floor(site.width / 2);\n        const y = Math.floor(site.height / 2);\n        GW.utils.forCircle(x, y, radius, (x, y) => site.setTile(x, y, tile));\n        if (radius > ringMinWidth + holeMinSize &&\n            GW.random.chance(this.options.holeChance.value())) {\n            GW.utils.forCircle(x, y, GW.random.range(holeMinSize, radius - holeMinSize), (x, y) => site.setTile(x, y, 0));\n        }\n        return new TYPES.Room(x - radius, y - radius, radius * 2 + 1, radius * 2 + 1);\n    }\n}\nexport function brogueDonut(config, site) {\n    // grid.fill(0);\n    const digger = new BrogueDonut(config);\n    return digger.create(site);\n}\nexport class ChunkyRoom extends RoomDigger {\n    constructor(config = {}) {\n        super(config, {\n            count: [2, 12],\n            width: [5, 20],\n            height: [5, 20],\n        });\n    }\n    carve(site) {\n        let i, x, y;\n        let chunkCount = this.options.count.value();\n        const width = this.options.width.value();\n        const height = this.options.height.value();\n        const tile = this.options.tile || SITE.FLOOR;\n        const minX = Math.floor(site.width / 2) - Math.floor(width / 2);\n        const maxX = Math.floor(site.width / 2) + Math.floor(width / 2);\n        const minY = Math.floor(site.height / 2) - Math.floor(height / 2);\n        const maxY = Math.floor(site.height / 2) + Math.floor(height / 2);\n        let left = Math.floor(site.width / 2);\n        let right = left;\n        let top = Math.floor(site.height / 2);\n        let bottom = top;\n        GW.utils.forCircle(left, top, 2, (x, y) => site.setTile(x, y, tile));\n        left -= 2;\n        right += 2;\n        top -= 2;\n        bottom += 2;\n        for (i = 0; i < chunkCount;) {\n            x = GW.random.range(minX, maxX);\n            y = GW.random.range(minY, maxY);\n            if (site.isSet(x, y)) {\n                if (x - 2 < minX)\n                    continue;\n                if (x + 2 > maxX)\n                    continue;\n                if (y - 2 < minY)\n                    continue;\n                if (y + 2 > maxY)\n                    continue;\n                left = Math.min(x - 2, left);\n                right = Math.max(x + 2, right);\n                top = Math.min(y - 2, top);\n                bottom = Math.max(y + 2, bottom);\n                GW.utils.forCircle(x, y, 2, (x, y) => site.setTile(x, y, tile));\n                i++;\n            }\n        }\n        return new TYPES.Room(left, top, right - left + 1, bottom - top + 1);\n    }\n}\nexport function chunkyRoom(config, site) {\n    // grid.fill(0);\n    const digger = new ChunkyRoom(config);\n    return digger.create(site);\n}\nexport function install(id, room) {\n    rooms[id] = room;\n    return room;\n}\ninstall('DEFAULT', new Rectangular());\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nimport * as UTILS from './utils';\nimport * as TYPES from './types';\nconst DIRS = GW.utils.DIRS;\nexport function isDoorLoc(site, loc, dir) {\n    if (!site.hasXY(loc[0], loc[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isDiggable(loc[0], loc[1]))\n        return false; // must be a wall/diggable space\n    const room = [loc[0] - dir[0], loc[1] - dir[1]];\n    if (!site.hasXY(room[0], room[1]))\n        return false;\n    // TODO - boundary?\n    if (!site.isFloor(room[0], room[1]))\n        return false; // must have floor in opposite direction\n    return true;\n}\nexport function pickWidth(opts = {}) {\n    return GW.utils.clamp(_pickWidth(opts), 1, 3);\n}\nfunction _pickWidth(opts) {\n    if (!opts)\n        return 1;\n    if (typeof opts === 'number')\n        return opts;\n    if (opts.width === undefined)\n        return 1;\n    let width = opts.width;\n    if (typeof width === 'number')\n        return width;\n    else if (Array.isArray(width)) {\n        // @ts-ignore\n        width = GW.random.weighted(width) + 1;\n    }\n    else if (typeof width === 'string') {\n        width = GW.range.make(width).value();\n    }\n    else {\n        width = Number.parseInt(GW.random.weighted(width));\n    }\n    return width;\n}\nexport function pickLength(dir, lengths) {\n    if (dir == GW.utils.UP || dir == GW.utils.DOWN) {\n        return lengths[1].value();\n    }\n    else {\n        return lengths[0].value();\n    }\n}\nexport function pickHallDirection(site, doors, lengths) {\n    // Pick a direction.\n    let dir = GW.utils.NO_DIRECTION;\n    if (dir == GW.utils.NO_DIRECTION) {\n        const dirs = GW.random.sequence(4);\n        for (let i = 0; i < 4; i++) {\n            dir = dirs[i];\n            const length = lengths[(i + 1) % 2].hi; // biggest measurement\n            const door = doors[dir];\n            if (door && door[0] != -1 && door[1] != -1) {\n                const dx = door[0] + Math.floor(DIRS[dir][0] * length);\n                const dy = door[1] + Math.floor(DIRS[dir][1] * length);\n                if (site.hasXY(dx, dy)) {\n                    break; // That's our direction!\n                }\n            }\n            dir = GW.utils.NO_DIRECTION;\n        }\n    }\n    return dir;\n}\nexport function pickHallExits(site, x, y, dir, obliqueChance) {\n    let newX, newY;\n    const allowObliqueHallwayExit = GW.random.chance(obliqueChance);\n    const hallDoors = [\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    // [-1, -1],\n    ];\n    for (let dir2 = 0; dir2 < 4; dir2++) {\n        newX = x + DIRS[dir2][0];\n        newY = y + DIRS[dir2][1];\n        if ((dir2 != dir && !allowObliqueHallwayExit) ||\n            !site.hasXY(newX, newY) ||\n            site.isSet(newX, newY)) {\n            // do nothing\n        }\n        else {\n            hallDoors[dir2] = [newX, newY];\n        }\n    }\n    return hallDoors;\n}\nexport class HallDigger {\n    constructor(options = {}) {\n        this.config = {\n            width: GW.range.make(1),\n            length: [GW.range.make('2-15'), GW.range.make('2-9')],\n            tile: SITE.FLOOR,\n            obliqueChance: 15,\n            chance: 100,\n        };\n        this._setOptions(options);\n    }\n    _setOptions(options = {}) {\n        if (options.width) {\n            this.config.width = GW.range.make(options.width);\n        }\n        if (options.length) {\n            if (typeof options.length === 'number') {\n                const l = GW.range.make(options.length);\n                this.config.length = [l, l];\n            }\n        }\n        if (options.tile) {\n            this.config.tile = options.tile;\n        }\n        if (options.chance) {\n            this.config.chance = options.chance;\n        }\n    }\n    create(site, doors = []) {\n        doors = doors || UTILS.chooseRandomDoorSites(site);\n        if (!GW.random.chance(this.config.chance))\n            return null;\n        const dir = pickHallDirection(site, doors, this.config.length);\n        if (dir === GW.utils.NO_DIRECTION)\n            return null;\n        if (!doors[dir])\n            return null;\n        const width = this.config.width.value();\n        const length = pickLength(dir, this.config.length);\n        const doorLoc = doors[dir];\n        if (width == 1) {\n            return this.dig(site, dir, doorLoc, length);\n        }\n        else {\n            return this.digWide(site, dir, doorLoc, length, width);\n        }\n    }\n    _digLine(site, door, dir, length) {\n        let x = door[0];\n        let y = door[1];\n        const tile = this.config.tile;\n        for (let i = 0; i < length; i++) {\n            site.setTile(x, y, tile);\n            x += dir[0];\n            y += dir[1];\n        }\n        x -= dir[0];\n        y -= dir[1];\n        return [x, y];\n    }\n    dig(site, dir, door, length) {\n        const DIR = DIRS[dir];\n        const [x, y] = this._digLine(site, door, DIR, length);\n        const hall = new TYPES.Hall(door, dir, length);\n        hall.doors = pickHallExits(site, x, y, dir, this.config.obliqueChance);\n        return hall;\n    }\n    digWide(site, dir, door, length, width) {\n        const DIR = GW.utils.DIRS[dir];\n        const lower = [door[0] - DIR[1], door[1] - DIR[0]];\n        const higher = [door[0] + DIR[1], door[1] + DIR[0]];\n        this._digLine(site, door, DIR, length);\n        let actual = 1;\n        let startX = door[0];\n        let startY = door[1];\n        if (actual < width && isDoorLoc(site, lower, DIR)) {\n            this._digLine(site, lower, DIR, length);\n            startX = Math.min(lower[0], startX);\n            startY = Math.min(lower[1], startY);\n            ++actual;\n        }\n        if (actual < width && isDoorLoc(site, higher, DIR)) {\n            this._digLine(site, higher, DIR, length);\n            startX = Math.min(higher[0], startX);\n            startY = Math.min(higher[1], startY);\n            ++actual;\n        }\n        const hall = new TYPES.Hall([startX, startY], dir, length, width);\n        hall.doors = [];\n        hall.doors[dir] = [\n            door[0] + length * DIR[0],\n            door[1] + length * DIR[1],\n        ];\n        hall.width = width;\n        return hall;\n    }\n}\nexport function dig(config, site, doors) {\n    const digger = new HallDigger(config);\n    return digger.create(site, doors);\n}\nexport var halls = {};\nexport function install(id, hall) {\n    // @ts-ignore\n    halls[id] = hall;\n    return hall;\n}\ninstall('DEFAULT', new HallDigger({ chance: 15 }));\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nexport class Lakes {\n    constructor(options = {}) {\n        this.options = {\n            height: 15,\n            width: 30,\n            minSize: 5,\n            tries: 20,\n            count: 1,\n            canDisrupt: false,\n            wreathTile: SITE.SHALLOW,\n            wreathChance: 50,\n            wreathSize: 1,\n            tile: SITE.DEEP,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let i, j, k;\n        let x, y;\n        let lakeMaxHeight, lakeMaxWidth, lakeMinSize, tries, maxCount, canDisrupt;\n        let count = 0;\n        lakeMaxHeight = this.options.height || 15; // TODO - Make this a range \"5-15\"\n        lakeMaxWidth = this.options.width || 30; // TODO - Make this a range \"5-30\"\n        lakeMinSize = this.options.minSize || 5;\n        tries = this.options.tries || 20;\n        maxCount = this.options.count || 1;\n        canDisrupt = this.options.canDisrupt || false;\n        const hasWreath = GW.random.chance(this.options.wreathChance)\n            ? true\n            : false;\n        const wreathTile = this.options.wreathTile || SITE.SHALLOW;\n        const wreathSize = this.options.wreathSize || 1; // TODO - make this a range \"0-2\" or a weighted choice { 0: 50, 1: 40, 2\" 10 }\n        const tile = this.options.tile || SITE.DEEP;\n        const lakeGrid = GW.grid.alloc(site.width, site.height, 0);\n        let attempts = 0;\n        while (attempts < maxCount && count < maxCount) {\n            // lake generations\n            const width = Math.round(((lakeMaxWidth - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const height = Math.round(((lakeMaxHeight - lakeMinSize) * (maxCount - attempts)) /\n                maxCount) + lakeMinSize;\n            const blob = new GW.blob.Blob({\n                rounds: 5,\n                minWidth: 4,\n                minHeight: 4,\n                maxWidth: width,\n                maxHeight: height,\n                percentSeeded: 55,\n                birthParameters: 'ffffftttt',\n                survivalParameters: 'ffffttttt',\n            });\n            const bounds = blob.carve(lakeGrid.width, lakeGrid.height, (x, y) => (lakeGrid[x][y] = 1));\n            // lakeGrid.dump();\n            let success = false;\n            for (k = 0; k < tries && !success; k++) {\n                // placement attempts\n                // propose a position for the top-left of the lakeGrid in the dungeon\n                x = GW.random.range(1 - bounds.x, lakeGrid.width - bounds.width - bounds.x - 2);\n                y = GW.random.range(1 - bounds.y, lakeGrid.height - bounds.height - bounds.y - 2);\n                if (canDisrupt || !this.isDisruptedBy(site, lakeGrid, -x, -y)) {\n                    // level with lake is completely connected\n                    //   dungeon.debug(\"Placed a lake!\", x, y);\n                    success = true;\n                    // copy in lake\n                    for (i = 0; i < bounds.width; i++) {\n                        // skip boundary\n                        for (j = 0; j < bounds.height; j++) {\n                            // skip boundary\n                            if (lakeGrid[i + bounds.x][j + bounds.y]) {\n                                const sx = i + bounds.x + x;\n                                const sy = j + bounds.y + y;\n                                site.setTile(sx, sy, tile);\n                                if (hasWreath) {\n                                    GW.utils.forCircle(sx, sy, wreathSize, (i, j) => {\n                                        if (site.isPassable(i, j)\n                                        // SITE.isFloor(map, i, j) ||\n                                        // SITE.isDoor(map, i, j)\n                                        ) {\n                                            site.setTile(i, j, wreathTile);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (success) {\n                ++count;\n            }\n            else {\n                ++attempts;\n            }\n        }\n        GW.grid.free(lakeGrid);\n        return count;\n    }\n    isDisruptedBy(site, lakeGrid, lakeToMapX = 0, lakeToMapY = 0) {\n        const walkableGrid = GW.grid.alloc(site.width, site.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GW.utils.forRect(site.width, site.height, (i, j) => {\n            const lakeX = i + lakeToMapX;\n            const lakeY = j + lakeToMapY;\n            if (lakeGrid.get(lakeX, lakeY)) {\n                if (site.isStairs(i, j)) {\n                    disrupts = true;\n                }\n            }\n            else if (site.isPassable(i, j)) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGrid.dump();\n        GW.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nexport class Bridges {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 20,\n            maxLength: 5,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let count = 0;\n        let newX, newY;\n        let i, j, d, x, y;\n        const maxLength = this.options.maxLength;\n        const minDistance = this.options.minDistance;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        costGrid.update((_v, x, y) => site.isPassable(x, y) ? 1 : GW.path.OBSTRUCTION);\n        const SEQ = GW.random.sequence(site.width * site.height);\n        for (i = 0; i < SEQ.length; i++) {\n            x = Math.floor(SEQ[i] / site.height);\n            y = SEQ[i] % site.height;\n            if (\n            // map.hasXY(x, y) &&\n            // map.get(x, y) &&\n            site.isPassable(x, y) &&\n                !site.isAnyWater(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try right, then down\n                    const bridgeDir = dirCoords[d];\n                    newX = x + bridgeDir[0];\n                    newY = y + bridgeDir[1];\n                    j = maxLength;\n                    // if (!map.hasXY(newX, newY)) continue;\n                    // check for line of lake tiles\n                    // if (isBridgeCandidate(newX, newY, bridgeDir)) {\n                    if (site.isAnyWater(newX, newY)) {\n                        for (j = 0; j < maxLength; ++j) {\n                            newX += bridgeDir[0];\n                            newY += bridgeDir[1];\n                            // if (!isBridgeCandidate(newX, newY, bridgeDir)) {\n                            if (!site.isAnyWater(newX, newY)) {\n                                break;\n                            }\n                        }\n                    }\n                    if (\n                    // map.get(newX, newY) &&\n                    site.isPassable(newX, newY) &&\n                        j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, newX, newY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[newX][newY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[x][y] > minDistance &&\n                            pathGrid[x][y] < GW.path.NO_PATH) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Bridge',\n                            //     x,\n                            //     y,\n                            //     ' => ',\n                            //     newX,\n                            //     newY\n                            // );\n                            while (x !== newX || y !== newY) {\n                                if (this.isBridgeCandidate(site, x, y, bridgeDir)) {\n                                    site.setTile(x, y, SITE.BRIDGE); // map[x][y] = SITE.BRIDGE;\n                                    costGrid[x][y] = 1; // (Cost map also needs updating.)\n                                }\n                                else {\n                                    site.setTile(x, y, SITE.FLOOR); // map[x][y] = SITE.FLOOR;\n                                    costGrid[x][y] = 1;\n                                }\n                                x += bridgeDir[0];\n                                y += bridgeDir[1];\n                            }\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n    isBridgeCandidate(site, x, y, bridgeDir) {\n        if (site.isBridge(x, y))\n            return true;\n        if (!site.isAnyWater(x, y))\n            return false;\n        if (!site.isAnyWater(x + bridgeDir[1], y + bridgeDir[0]))\n            return false;\n        if (!site.isAnyWater(x - bridgeDir[1], y - bridgeDir[0]))\n            return false;\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nexport class Stairs {\n    constructor(options = {}) {\n        this.options = {\n            up: true,\n            down: true,\n            minDistance: 10,\n            start: false,\n            upTile: SITE.UP_STAIRS,\n            downTile: SITE.DOWN_STAIRS,\n            wall: SITE.IMPREGNABLE,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let needUp = this.options.up !== false;\n        let needDown = this.options.down !== false;\n        const minDistance = this.options.minDistance ||\n            Math.floor(Math.max(site.width, site.height) / 2);\n        const locations = {};\n        let upLoc;\n        let downLoc;\n        const isValidLoc = this.isStairXY.bind(this, site);\n        if (this.options.start && typeof this.options.start !== 'string') {\n            let start = this.options.start;\n            if (start === true) {\n                start = GW.random.matchingXY(site.width, site.height, isValidLoc);\n            }\n            else {\n                start = GW.random.matchingXYNear(GW.utils.x(start), GW.utils.y(start), isValidLoc);\n            }\n            locations.start = start;\n        }\n        if (Array.isArray(this.options.up) &&\n            Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            const down = this.options.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n        }\n        else if (Array.isArray(this.options.up) &&\n            !Array.isArray(this.options.down)) {\n            const up = this.options.up;\n            upLoc = GW.random.matchingXYNear(GW.utils.x(up), GW.utils.y(up), isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (Array.isArray(this.options.down) &&\n            !Array.isArray(this.options.up)) {\n            const down = this.options.down;\n            downLoc = GW.random.matchingXYNear(GW.utils.x(down), GW.utils.y(down), isValidLoc);\n            if (needUp) {\n                upLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (GW.utils.distanceBetween(x, y, \n                    // @ts-ignore\n                    downLoc[0], \n                    // @ts-ignore\n                    downLoc[1]) < minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needUp) {\n            upLoc = GW.random.matchingXY(site.width, site.height, isValidLoc);\n            if (needDown) {\n                downLoc = GW.random.matchingXY(site.width, site.height, (x, y) => {\n                    if (\n                    // @ts-ignore\n                    GW.utils.distanceBetween(x, y, upLoc[0], upLoc[1]) <\n                        minDistance)\n                        return false;\n                    return isValidLoc(x, y);\n                });\n            }\n        }\n        else if (needDown) {\n            downLoc = GW.random.matchingXY(site.width, site.height, isValidLoc);\n        }\n        if (upLoc) {\n            locations.up = upLoc.slice();\n            this.setupStairs(site, upLoc[0], upLoc[1], this.options.upTile);\n            if (this.options.start === 'up')\n                locations.start = locations.up;\n        }\n        if (downLoc !== undefined) {\n            locations.down = downLoc.slice();\n            this.setupStairs(site, downLoc[0], downLoc[1], this.options.downTile);\n            if (this.options.start === 'down')\n                locations.start = locations.down;\n        }\n        return upLoc || downLoc ? locations : null;\n    }\n    hasXY(site, x, y) {\n        if (x < 0 || y < 0)\n            return false;\n        if (x >= site.width || y >= site.height)\n            return false;\n        return true;\n    }\n    isStairXY(site, x, y) {\n        let count = 0;\n        if (!this.hasXY(site, x, y) || !site.isDiggable(x, y))\n            return false;\n        for (let i = 0; i < 4; ++i) {\n            const dir = GW.utils.DIRS[i];\n            if (!this.hasXY(site, x + dir[0], y + dir[1]))\n                return false;\n            if (!this.hasXY(site, x - dir[0], y - dir[1]))\n                return false;\n            if (site.isFloor(x + dir[0], y + dir[1])) {\n                count += 1;\n                if (!site.isDiggable(x - dir[0] + dir[1], y - dir[1] + dir[0]))\n                    return false;\n                if (!site.isDiggable(x - dir[0] - dir[1], y - dir[1] - dir[0]))\n                    return false;\n            }\n            else if (!site.isDiggable(x + dir[0], y + dir[1])) {\n                return false;\n            }\n        }\n        return count == 1;\n    }\n    setupStairs(site, x, y, tile) {\n        const indexes = GW.random.sequence(4);\n        let dir = null;\n        for (let i = 0; i < indexes.length; ++i) {\n            dir = GW.utils.DIRS[i];\n            const x0 = x + dir[0];\n            const y0 = y + dir[1];\n            if (site.isFloor(x0, y0)) {\n                if (site.isDiggable(x - dir[0], y - dir[1]))\n                    break;\n            }\n            dir = null;\n        }\n        if (!dir)\n            GW.utils.ERROR('No stair direction found!');\n        site.setTile(x, y, tile);\n        const dirIndex = GW.utils.CLOCK_DIRS.findIndex(\n        // @ts-ignore\n        (d) => d[0] == dir[0] && d[1] == dir[1]);\n        const wall = this.options.wall;\n        for (let i = 0; i < GW.utils.CLOCK_DIRS.length; ++i) {\n            const l = i ? i - 1 : 7;\n            const r = (i + 1) % 8;\n            if (i == dirIndex || l == dirIndex || r == dirIndex)\n                continue;\n            const d = GW.utils.CLOCK_DIRS[i];\n            site.setTile(x + d[0], y + d[1], wall);\n            // map.setCellFlags(x + d[0], y + d[1], Flags.Cell.IMPREGNABLE);\n        }\n        // dungeon.debug('setup stairs', x, y, tile);\n        return true;\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nexport class LoopDigger {\n    constructor(options = {}) {\n        this.options = {\n            minDistance: 100,\n            maxLength: 1,\n        };\n        Object.assign(this.options, options);\n    }\n    create(site) {\n        let startX, startY, endX, endY;\n        let i, j, d, x, y;\n        const minDistance = Math.min(this.options.minDistance, Math.floor(Math.max(site.width, site.height) / 2));\n        const maxLength = this.options.maxLength;\n        const pathGrid = GW.grid.alloc(site.width, site.height);\n        const costGrid = GW.grid.alloc(site.width, site.height);\n        const dirCoords = [\n            [1, 0],\n            [0, 1],\n        ];\n        SITE.fillCostGrid(site, costGrid);\n        function isValidTunnelStart(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return false;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return false;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return false;\n            return true;\n        }\n        function isValidTunnelEnd(x, y, dir) {\n            if (!site.hasXY(x, y))\n                return false;\n            if (!site.hasXY(x + dir[1], y + dir[0]))\n                return false;\n            if (!site.hasXY(x - dir[1], y - dir[0]))\n                return false;\n            if (site.isSet(x, y))\n                return true;\n            if (site.isSet(x + dir[1], y + dir[0]))\n                return true;\n            if (site.isSet(x - dir[1], y - dir[0]))\n                return true;\n            return false;\n        }\n        let count = 0;\n        for (i = 0; i < SITE.SEQ.length; i++) {\n            x = Math.floor(SITE.SEQ[i] / site.height);\n            y = SITE.SEQ[i] % site.height;\n            if (!site.isSet(x, y)) {\n                for (d = 0; d <= 1; d++) {\n                    // Try a horizontal door, and then a vertical door.\n                    let dir = dirCoords[d];\n                    if (!isValidTunnelStart(x, y, dir))\n                        continue;\n                    j = maxLength;\n                    // check up/left\n                    if (site.hasXY(x + dir[0], y + dir[1]) &&\n                        site.isPassable(x + dir[0], y + dir[1])) {\n                        // just can't build directly into a door\n                        if (!site.hasXY(x - dir[0], y - dir[1]) ||\n                            site.isDoor(x - dir[0], y - dir[1])) {\n                            continue;\n                        }\n                    }\n                    else if (site.hasXY(x - dir[0], y - dir[1]) &&\n                        site.isPassable(x - dir[0], y - dir[1])) {\n                        if (!site.hasXY(x + dir[0], y + dir[1]) ||\n                            site.isDoor(x + dir[0], y + dir[1])) {\n                            continue;\n                        }\n                        dir = dir.map((v) => -1 * v);\n                    }\n                    else {\n                        continue; // not valid start for tunnel\n                    }\n                    startX = x + dir[0];\n                    startY = y + dir[1];\n                    endX = x;\n                    endY = y;\n                    for (j = 0; j < maxLength; ++j) {\n                        endX -= dir[0];\n                        endY -= dir[1];\n                        // if (site.hasXY(endX, endY) && !grid.cell(endX, endY).isNull()) {\n                        if (isValidTunnelEnd(endX, endY, dir)) {\n                            break;\n                        }\n                    }\n                    if (j < maxLength) {\n                        GW.path.calculateDistances(pathGrid, startX, startY, costGrid, false);\n                        // pathGrid.fill(30000);\n                        // pathGrid[startX][startY] = 0;\n                        // dijkstraScan(pathGrid, costGrid, false);\n                        if (pathGrid[endX][endY] > minDistance &&\n                            pathGrid[endX][endY] < 30000) {\n                            // and if the pathing distance between the two flanking floor tiles exceeds minDistance,\n                            // dungeon.debug(\n                            //     'Adding Loop',\n                            //     startX,\n                            //     startY,\n                            //     ' => ',\n                            //     endX,\n                            //     endY,\n                            //     ' : ',\n                            //     pathGrid[endX][endY]\n                            // );\n                            while (endX !== startX || endY !== startY) {\n                                if (site.isNothing(endX, endY)) {\n                                    site.setTile(endX, endY, SITE.FLOOR);\n                                    costGrid[endX][endY] = 1; // (Cost map also needs updating.)\n                                }\n                                endX += dir[0];\n                                endY += dir[1];\n                            }\n                            // TODO - Door is optional\n                            site.setTile(x, y, SITE.DOOR); // then turn the tile into a doorway.\n                            ++count;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(pathGrid);\n        GW.grid.free(costGrid);\n        return count;\n    }\n}\n// Add some loops to the otherwise simply connected network of rooms.\nexport function digLoops(site, opts = {}) {\n    const digger = new LoopDigger(opts);\n    return digger.create(site);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\nimport * as ROOM from './room';\nimport * as HALL from './hall';\nimport * as LOOP from './loop';\nimport * as LAKE from './lake';\nimport * as BRIDGE from './bridge';\nimport * as STAIRS from './stairs';\nimport * as UTILS from './utils';\nexport class Level {\n    constructor(width, height, options = {}) {\n        this.rooms = {};\n        this.doors = { chance: 15 };\n        this.halls = { chance: 15 };\n        this.loops = {};\n        this.lakes = {};\n        this.bridges = {};\n        this.stairs = {};\n        this.boundary = true;\n        this.startLoc = [-1, -1];\n        this.endLoc = [-1, -1];\n        this.height = height;\n        this.width = width;\n        if (options.seed) {\n            GW.random.seed(options.seed);\n        }\n        GW.utils.setOptions(this.rooms, options.rooms);\n        GW.utils.setOptions(this.halls, options.halls);\n        GW.utils.setOptions(this.loops, options.loops);\n        GW.utils.setOptions(this.lakes, options.lakes);\n        GW.utils.setOptions(this.bridges, options.bridges);\n        GW.utils.setOptions(this.stairs, options.stairs);\n        GW.utils.setOptions(this.doors, options.doors);\n        this.startLoc = options.startLoc || [Math.floor(width / 2), height - 2];\n        this.endLoc = options.endLoc || [-1, -1];\n    }\n    makeSite(width, height) {\n        return new SITE.GridSite(width, height);\n    }\n    create(setFn) {\n        const site = this.makeSite(this.width, this.height);\n        this.start(site);\n        let tries = 20;\n        while (--tries) {\n            if (this.addFirstRoom(site))\n                break;\n        }\n        if (!tries)\n            throw new Error('Failed to place first room!');\n        let fails = 0;\n        while (fails < 20) {\n            if (this.addRoom(site)) {\n                fails = 0;\n            }\n            else {\n                ++fails;\n            }\n        }\n        this.addLoops(site, this.loops);\n        this.addLakes(site, this.lakes);\n        this.addBridges(site, this.bridges);\n        this.addStairs(site, this.stairs);\n        this.finish(site);\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            const t = site.getTile(x, y);\n            if (t)\n                setFn(x, y, t);\n        });\n        site.free();\n        return true;\n    }\n    start(_site) {\n        SITE.initSeqence(this.width * this.height);\n    }\n    getDigger(id) {\n        if (!id)\n            throw new Error('Missing digger!');\n        if (id instanceof ROOM.RoomDigger)\n            return id;\n        if (typeof id === 'string') {\n            const digger = ROOM.rooms[id];\n            if (!digger) {\n                throw new Error('Failed to find digger - ' + id);\n            }\n            return digger;\n        }\n        return new ROOM.ChoiceRoom(id);\n    }\n    addFirstRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.first || this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        if (room &&\n            !this._attachRoomAtLoc(site, roomSite, room, this.startLoc)) {\n            room = null;\n        }\n        roomSite.free();\n        // Should we add the starting stairs now too?\n        return room;\n    }\n    addRoom(site) {\n        const roomSite = this.makeSite(this.width, this.height);\n        let digger = this.getDigger(this.rooms.digger || 'DEFAULT');\n        let room = digger.create(roomSite);\n        // attach hall?\n        if (this.halls.chance) {\n            let hall = HALL.dig(this.halls, roomSite, room.doors);\n            if (hall) {\n                room.hall = hall;\n            }\n        }\n        if (room && !this._attachRoom(site, roomSite, room)) {\n            room = null;\n        }\n        roomSite.free();\n        return room;\n    }\n    _attachRoom(site, roomSite, room) {\n        // console.log('attachRoom');\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.\n        for (let i = 0; i < SITE.SEQ.length; i++) {\n            const x = Math.floor(SITE.SEQ[i] / this.height);\n            const y = SITE.SEQ[i] % this.height;\n            if (!site.isNothing(x, y))\n                continue;\n            const dir = UTILS.directionOfDoorSite(site, x, y);\n            if (dir != GW.utils.NO_DIRECTION) {\n                const oppDir = (dir + 2) % 4;\n                const door = doorSites[oppDir];\n                if (!door)\n                    continue;\n                const offsetX = x - door[0];\n                const offsetY = y - door[1];\n                if (door[0] != -1 &&\n                    this._roomFitsAt(site, roomSite, offsetX, offsetY)) {\n                    // TYPES.Room fits here.\n                    UTILS.copySite(site, roomSite, offsetX, offsetY);\n                    this._attachDoor(site, room, x, y, oppDir);\n                    // door[0] = -1;\n                    // door[1] = -1;\n                    room.translate(offsetX, offsetY);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _attachRoomAtLoc(site, roomSite, room, attachLoc) {\n        const [x, y] = attachLoc;\n        const doorSites = room.hall ? room.hall.doors : room.doors;\n        const dirs = GW.random.sequence(4);\n        // console.log('attachRoomAtXY', x, y, doorSites.join(', '));\n        for (let dir of dirs) {\n            const oppDir = (dir + 2) % 4;\n            const door = doorSites[oppDir];\n            if (!door || door[0] == -1)\n                continue;\n            const offX = x - door[0];\n            const offY = y - door[1];\n            if (this._roomFitsAt(site, roomSite, offX, offY)) {\n                // dungeon.debug(\"attachRoom: \", x, y, oppDir);\n                // TYPES.Room fits here.\n                UTILS.copySite(site, roomSite, offX, offY);\n                // this._attachDoor(site, room, x, y, oppDir);  // No door on first room!\n                room.translate(offX, offY);\n                // const newDoors = doorSites.map((site) => {\n                //     const x0 = site[0] + offX;\n                //     const y0 = site[1] + offY;\n                //     if (x0 == x && y0 == y) return [-1, -1] as GW.utils.Loc;\n                //     return [x0, y0] as GW.utils.Loc;\n                // });\n                return true;\n            }\n        }\n        return false;\n    }\n    _roomFitsAt(map, roomGrid, roomToSiteX, roomToSiteY) {\n        let xRoom, yRoom, xSite, ySite, i, j;\n        // console.log('roomFitsAt', roomToSiteX, roomToSiteY);\n        for (xRoom = 0; xRoom < roomGrid.width; xRoom++) {\n            for (yRoom = 0; yRoom < roomGrid.height; yRoom++) {\n                if (roomGrid.isSet(xRoom, yRoom)) {\n                    xSite = xRoom + roomToSiteX;\n                    ySite = yRoom + roomToSiteY;\n                    for (i = xSite - 1; i <= xSite + 1; i++) {\n                        for (j = ySite - 1; j <= ySite + 1; j++) {\n                            if (!map.hasXY(i, j) ||\n                                map.isBoundaryXY(i, j) ||\n                                !map.isNothing(i, j)) {\n                                // console.log('- NO');\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // console.log('- YES');\n        return true;\n    }\n    _attachDoor(map, room, x, y, dir) {\n        const opts = this.doors;\n        if (opts.chance === 0)\n            return; // no door at all\n        const isDoor = opts.chance && GW.random.chance(opts.chance); // did not pass chance\n        const tile = isDoor ? opts.tile || SITE.DOOR : SITE.FLOOR;\n        map.setTile(x, y, tile); // Door site.\n        // most cases...\n        if (!room.hall || !(room.hall.width > 1) || room.hall.dir !== dir) {\n            return;\n        }\n        if (dir === GW.utils.UP || dir === GW.utils.DOWN) {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x - k, y)) {\n                    if (map.isSet(x - k, y - 1) && map.isSet(x - k, y + 1)) {\n                        map.setTile(x - k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x + k, y)) {\n                    if (map.isSet(x + k, y - 1) && map.isSet(x + k, y + 1)) {\n                        map.setTile(x + k, y, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n        else {\n            let didSomething = true;\n            let k = 1;\n            while (didSomething) {\n                didSomething = false;\n                if (map.isNothing(x, y - k)) {\n                    if (map.isSet(x - 1, y - k) && map.isSet(x + 1, y - k)) {\n                        map.setTile(x, y - k, tile);\n                        didSomething = true;\n                    }\n                }\n                if (map.isNothing(x, y + k)) {\n                    if (map.isSet(x - 1, y + k) && map.isSet(x + 1, y + k)) {\n                        map.setTile(x, y + k, tile);\n                        didSomething = true;\n                    }\n                }\n                ++k;\n            }\n        }\n    }\n    addLoops(site, opts) {\n        const digger = new LOOP.LoopDigger(opts);\n        return digger.create(site);\n    }\n    addLakes(site, opts) {\n        const digger = new LAKE.Lakes(opts);\n        return digger.create(site);\n    }\n    addBridges(site, opts) {\n        const digger = new BRIDGE.Bridges(opts);\n        return digger.create(site);\n    }\n    addStairs(site, opts) {\n        const digger = new STAIRS.Stairs(opts);\n        return digger.create(site);\n    }\n    finish(site) {\n        this._removeDiagonalOpenings(site);\n        this._finishWalls(site);\n        this._finishDoors(site);\n    }\n    _removeDiagonalOpenings(site) {\n        let i, j, k, x1, y1;\n        let diagonalCornerRemoved;\n        do {\n            diagonalCornerRemoved = false;\n            for (i = 0; i < this.width - 1; i++) {\n                for (j = 0; j < this.height - 1; j++) {\n                    for (k = 0; k <= 1; k++) {\n                        if (site.isPassable(i + k, j) &&\n                            !site.isPassable(i + (1 - k), j) &&\n                            site.isObstruction(i + (1 - k), j) &&\n                            !site.isPassable(i + k, j + 1) &&\n                            site.isObstruction(i + k, j + 1) &&\n                            site.isPassable(i + (1 - k), j + 1)) {\n                            if (GW.random.chance(50)) {\n                                x1 = i + (1 - k);\n                                y1 = j;\n                            }\n                            else {\n                                x1 = i + k;\n                                y1 = j + 1;\n                            }\n                            diagonalCornerRemoved = true;\n                            site.setTile(x1, y1, SITE.FLOOR); // todo - pick one of the passable tiles around it...\n                        }\n                    }\n                }\n            }\n        } while (diagonalCornerRemoved == true);\n    }\n    _finishDoors(site) {\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isBoundaryXY(x, y))\n                return;\n            // todo - isDoorway...\n            if (site.isDoor(x, y)) {\n                if (\n                // TODO - isPassable\n                (site.isFloor(x + 1, y) || site.isFloor(x - 1, y)) &&\n                    (site.isFloor(x, y + 1) || site.isFloor(x, y - 1))) {\n                    // If there's passable terrain to the left or right, and there's passable terrain\n                    // above or below, then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor value\n                }\n                else if ((site.isObstruction(x + 1, y) ? 1 : 0) +\n                    (site.isObstruction(x - 1, y) ? 1 : 0) +\n                    (site.isObstruction(x, y + 1) ? 1 : 0) +\n                    (site.isObstruction(x, y - 1) ? 1 : 0) >=\n                    3) {\n                    // If the door has three or more pathing blocker neighbors in the four cardinal directions,\n                    // then the door is orphaned and must be removed.\n                    site.setTile(x, y, SITE.FLOOR); // todo - take passable neighbor\n                }\n            }\n        });\n    }\n    _finishWalls(site) {\n        const boundaryTile = this.boundary ? SITE.IMPREGNABLE : SITE.WALL;\n        GW.utils.forRect(this.width, this.height, (x, y) => {\n            if (site.isNothing(x, y)) {\n                if (site.isBoundaryXY(x, y)) {\n                    site.setTile(x, y, boundaryTile);\n                }\n                else {\n                    site.setTile(x, y, SITE.WALL);\n                }\n            }\n        });\n    }\n}\n","import * as GW from 'gw-utils';\nimport * as LEVEL from './level';\nexport class Dungeon {\n    constructor(options = {}) {\n        this.config = {\n            levels: 1,\n            width: 80,\n            height: 34,\n            rooms: { count: 20, digger: 'DEFAULT' },\n            halls: {},\n            loops: {},\n            lakes: {},\n            bridges: {},\n            stairs: {},\n            boundary: true,\n        };\n        this.seeds = [];\n        this.stairLocs = [];\n        GW.utils.setOptions(this.config, options);\n        if (this.config.seed) {\n            GW.random.seed(this.config.seed);\n        }\n        this.initSeeds();\n        this.initStairLocs();\n    }\n    get levels() {\n        return this.config.levels;\n    }\n    initSeeds() {\n        for (let i = 0; i < this.config.levels; ++i) {\n            this.seeds[i] = GW.random.number(2 ** 32);\n        }\n    }\n    initStairLocs() {\n        let startLoc = this.config.startLoc || [\n            Math.floor(this.config.width / 2),\n            this.config.height - 2,\n        ];\n        const minDistance = this.config.stairDistance ||\n            Math.floor(Math.max(this.config.width / 2, this.config.height / 2));\n        for (let i = 0; i < this.config.levels; ++i) {\n            const endLoc = GW.random.matchingXY(this.config.width, this.config.height, (x, y) => {\n                return (GW.utils.distanceBetween(startLoc[0], startLoc[1], x, y) > minDistance);\n            });\n            this.stairLocs.push([\n                [startLoc[0], startLoc[1]],\n                [endLoc[0], endLoc[1]],\n            ]);\n            startLoc = endLoc;\n        }\n    }\n    getLevel(id, cb) {\n        if (id < 0 || id > this.config.levels)\n            throw new Error('Invalid level id: ' + id);\n        GW.random.seed(this.seeds[id]);\n        // Generate the level\n        const [startLoc, endLoc] = this.stairLocs[id];\n        const stairOpts = Object.assign({}, this.config.stairs);\n        if (this.config.goesUp) {\n            stairOpts.down = startLoc;\n            stairOpts.up = endLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.downTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.upTile = this.config.endTile;\n            }\n        }\n        else {\n            stairOpts.down = endLoc;\n            stairOpts.up = startLoc;\n            if (id == 0 && this.config.startTile) {\n                stairOpts.upTile = this.config.startTile;\n            }\n            if (id == this.config.levels - 1 && this.config.endTile) {\n                stairOpts.downTile = this.config.endTile;\n            }\n        }\n        const rooms = Object.assign({}, this.config.rooms);\n        if (id === 0 && rooms.entrance) {\n            rooms.first = rooms.entrance;\n        }\n        const levelOpts = {\n            loops: this.config.loops,\n            lakes: this.config.lakes,\n            bridges: this.config.bridges,\n            rooms: rooms,\n            stairs: stairOpts,\n            boundary: this.config.boundary,\n            width: this.config.width,\n            height: this.config.height,\n        };\n        return this.makeLevel(id, levelOpts, cb);\n        // TODO - Update startLoc, endLoc\n    }\n    makeLevel(id, opts, cb) {\n        const level = new LEVEL.Level(this.config.width, this.config.height, opts);\n        const result = level.create(cb);\n        if (!GW.utils.equalsXY(level.endLoc, opts.endLoc) ||\n            !GW.utils.equalsXY(level.startLoc, opts.startLoc)) {\n            this.stairLocs[id] = [level.startLoc, level.endLoc];\n        }\n        return result;\n    }\n}\n","import * as GW from 'gw-utils';\nconst Fl = GW.flag.fl;\nexport var Flags;\n(function (Flags) {\n    Flags[Flags[\"BP_ROOM\"] = Fl(10)] = \"BP_ROOM\";\n    Flags[Flags[\"BP_VESTIBULE\"] = Fl(1)] = \"BP_VESTIBULE\";\n    Flags[Flags[\"BP_REWARD\"] = Fl(7)] = \"BP_REWARD\";\n    Flags[Flags[\"BP_ADOPT_ITEM\"] = Fl(0)] = \"BP_ADOPT_ITEM\";\n    Flags[Flags[\"BP_PURGE_PATHING_BLOCKERS\"] = Fl(2)] = \"BP_PURGE_PATHING_BLOCKERS\";\n    Flags[Flags[\"BP_PURGE_INTERIOR\"] = Fl(3)] = \"BP_PURGE_INTERIOR\";\n    Flags[Flags[\"BP_PURGE_LIQUIDS\"] = Fl(4)] = \"BP_PURGE_LIQUIDS\";\n    Flags[Flags[\"BP_SURROUND_WITH_WALLS\"] = Fl(5)] = \"BP_SURROUND_WITH_WALLS\";\n    Flags[Flags[\"BP_IMPREGNABLE\"] = Fl(6)] = \"BP_IMPREGNABLE\";\n    Flags[Flags[\"BP_OPEN_INTERIOR\"] = Fl(8)] = \"BP_OPEN_INTERIOR\";\n    Flags[Flags[\"BP_MAXIMIZE_INTERIOR\"] = Fl(9)] = \"BP_MAXIMIZE_INTERIOR\";\n    Flags[Flags[\"BP_REDESIGN_INTERIOR\"] = Fl(14)] = \"BP_REDESIGN_INTERIOR\";\n    Flags[Flags[\"BP_TREAT_AS_BLOCKING\"] = Fl(11)] = \"BP_TREAT_AS_BLOCKING\";\n    Flags[Flags[\"BP_REQUIRE_BLOCKING\"] = Fl(12)] = \"BP_REQUIRE_BLOCKING\";\n    Flags[Flags[\"BP_NO_INTERIOR_FLAG\"] = Fl(13)] = \"BP_NO_INTERIOR_FLAG\";\n})(Flags || (Flags = {}));\nexport class Blueprint {\n    constructor(opts = {}) {\n        this.tags = [];\n        this.size = [-1, -1];\n        this.flags = 0;\n        if (opts.tags) {\n            if (typeof opts.tags === 'string') {\n                opts.tags = opts.tags.split(/[,|]/).map((v) => v.trim());\n            }\n            this.tags = opts.tags;\n        }\n        this.frequency = GW.frequency.make(opts.frequency || 100);\n        if (opts.size) {\n            if (typeof opts.size === 'string') {\n                const parts = opts.size\n                    .split(/-/)\n                    .map((v) => v.trim())\n                    .map((v) => Number.parseInt(v));\n                if (parts.length !== 2)\n                    throw new Error('Blueprint size must be of format: #-#');\n                this.size = [parts[0], parts[1]];\n            }\n            else if (Array.isArray(opts.size)) {\n                if (opts.size.length !== 2)\n                    throw new Error('Blueprint size must be [min, max]');\n                this.size = [opts.size[0], opts.size[1]];\n            }\n            else {\n                throw new Error('size must be string or array.');\n            }\n            if (this.size[0] > this.size[1])\n                throw new Error('Blueprint size must be small to large.');\n        }\n        if (opts.flags) {\n            this.flags = GW.flag.from(Flags, opts.flags);\n        }\n    }\n    getChance(level, tags) {\n        if (tags && tags.length) {\n            if (typeof tags === 'string') {\n                tags = tags.split(/[,|]/).map((v) => v.trim());\n            }\n            // Must match all tags!\n            if (!tags.every((want) => this.tags.includes(want)))\n                return 0;\n        }\n        return this.frequency(level);\n    }\n    get isRoom() {\n        return this.flags & Flags.BP_ROOM;\n    }\n    get isReward() {\n        return this.flags & Flags.BP_REWARD;\n    }\n    get isVestiblue() {\n        return this.flags & Flags.BP_VESTIBULE;\n    }\n    get adoptsItem() {\n        return this.flags & Flags.BP_ADOPT_ITEM;\n    }\n}\nexport const blueprints = {};\nexport function install(id, blueprint) {\n    blueprints[id] = blueprint;\n}\n","import * as GW from 'gw-utils';\nimport { Flags } from '../site';\n// import { LoopFinder } from './loopFinder';\nexport class ChokeFinder {\n    constructor(withCounts = false) {\n        this.withCounts = withCounts;\n    }\n    /////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////\n    // TODO - Move to Map?\n    compute(site) {\n        const floodGrid = GW.grid.alloc(site.width, site.height);\n        const passMap = GW.grid.alloc(site.width, site.height);\n        passMap.update((_v, x, y) => (site.isPassable(x, y) ? 1 : 0));\n        // Assume loops are done already!\n        // const loopFinder = new LoopFinder();\n        // loopFinder.compute(\n        //     site\n        // );\n        let passableArcCount;\n        // done finding loops; now flag chokepoints\n        for (let i = 1; i < passMap.width - 1; i++) {\n            for (let j = 1; j < passMap.height - 1; j++) {\n                site.clearSiteFlag(i, j, Flags.IS_CHOKEPOINT);\n                site.setChokeCount(i, j, 30000);\n                if (passMap[i][j] && !site.hasSiteFlag(i, j, Flags.IS_IN_LOOP)) {\n                    passableArcCount = 0;\n                    for (let dir = 0; dir < 8; dir++) {\n                        const oldX = i + GW.utils.CLOCK_DIRS[(dir + 7) % 8][0];\n                        const oldY = j + GW.utils.CLOCK_DIRS[(dir + 7) % 8][1];\n                        const newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                        const newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                        if (passMap.hasXY(newX, newY) &&\n                            passMap.hasXY(oldX, oldY) &&\n                            passMap[newX][newY] != passMap[oldX][oldY]) {\n                            if (++passableArcCount > 2) {\n                                if ((!passMap[i - 1][j] &&\n                                    !passMap[i + 1][j]) ||\n                                    (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                    site.setSiteFlag(i, j, Flags.IS_CHOKEPOINT);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (this.withCounts) {\n            // Done finding chokepoints; now create a chokepoint map.\n            // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n            // then the number indicates the number of tiles that would be rendered unreachable if the\n            // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n            // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n            // were blocked.\n            // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n            // Start by roping off room machines.\n            passMap.update((v, x, y) => v && site.hasSiteFlag(x, y, Flags.IS_IN_ROOM_MACHINE) ? 0 : v);\n            // Scan through and find a chokepoint next to an open point.\n            for (let i = 0; i < site.width; i++) {\n                for (let j = 0; j < site.height; j++) {\n                    if (passMap[i][j] &&\n                        site.hasSiteFlag(i, j, Flags.IS_CHOKEPOINT)) {\n                        for (let dir = 0; dir < 4; dir++) {\n                            const newX = i + GW.utils.DIRS[dir][0];\n                            const newY = j + GW.utils.DIRS[dir][1];\n                            if (passMap.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                                passMap[newX][newY] &&\n                                !(site.hasSiteFlag(newX, newY, Flags.IS_CHOKEPOINT))) {\n                                // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                                // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                                // Keep track of the flooded region in grid[][].\n                                floodGrid.fill(0);\n                                passMap[i][j] = 0;\n                                let cellCount = floodFillCount(site, floodGrid, passMap, newX, newY);\n                                passMap[i][j] = 1;\n                                // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                                // CellCounts less than 4 are not useful, so we skip those cases.\n                                if (cellCount >= 4) {\n                                    // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                    for (let i2 = 0; i2 < floodGrid.width; i2++) {\n                                        for (let j2 = 0; j2 < floodGrid.height; j2++) {\n                                            if (floodGrid[i2][j2] &&\n                                                cellCount < site.getChokeCount(i2, j2)) {\n                                                site.setChokeCount(i2, j2, cellCount);\n                                                site.clearSiteFlag(i2, j2, Flags.IS_GATE_SITE);\n                                            }\n                                        }\n                                    }\n                                    // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                    if (cellCount < site.getChokeCount(i, j)) {\n                                        site.setChokeCount(i, j, cellCount);\n                                        site.setSiteFlag(i, j, Flags.IS_GATE_SITE);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        GW.grid.free(passMap);\n        GW.grid.free(floodGrid);\n    }\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(site, results, passMap, startX, startY) {\n    let count = passMap[startX][startY] == 2 ? 5000 : 1;\n    if (site.isDeep(startX, startY)\n    // map.cells[startX][startY].flags.cellMech &\n    // FLAGS.CellMech.IS_IN_AREA_MACHINE\n    ) {\n        count = 10000;\n    }\n    results[startX][startY] = 1;\n    for (let dir = 0; dir < 4; dir++) {\n        const newX = startX + GW.utils.DIRS[dir][0];\n        const newY = startY + GW.utils.DIRS[dir][1];\n        if (site.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n            passMap[newX][newY] &&\n            !results[newX][newY]) {\n            count += floodFillCount(site, results, passMap, newX, newY);\n        }\n    }\n    return Math.min(count, 10000);\n}\n","import * as GW from 'gw-utils';\nimport * as SITE from '../site';\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\nexport class LoopFinder {\n    constructor() { }\n    compute(site) {\n        // const grid = GW.grid.alloc(site.width, site.height);\n        this._initGrid(site);\n        GW.utils.forRect(site.width, site.height, (x, y) => this._checkCell(site, x, y));\n        // grid.forEach((_v, x, y) => this._checkCell(site, grid, x, y));\n        // grid.forEach((v, x, y) => cb(x, y, !!v));\n        // GW.grid.free(grid);\n    }\n    _initGrid(site) {\n        GW.utils.forRect(site.width, site.height, (x, y) => {\n            if (site.isPassable(x, y)) {\n                site.setSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            }\n            else {\n                site.clearSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            }\n        });\n    }\n    _checkCell(site, x, y) {\n        let inString;\n        let newX, newY, dir, sdir;\n        let numStrings, maxStringLength, currentStringLength;\n        const v = site.hasSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n        if (!v)\n            return;\n        // find an unloopy neighbor to start on\n        for (sdir = 0; sdir < 8; sdir++) {\n            newX = x + GW.utils.CLOCK_DIRS[sdir][0];\n            newY = y + GW.utils.CLOCK_DIRS[sdir][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            if (!site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP)) {\n                break;\n            }\n        }\n        if (sdir == 8) {\n            // no unloopy neighbors\n            return; // leave cell loopy\n        }\n        // starting on this unloopy neighbor,\n        // work clockwise and count up:\n        // (a) the number of strings of loopy neighbors, and\n        // (b) the length of the longest such string.\n        numStrings = maxStringLength = currentStringLength = 0;\n        inString = false;\n        for (dir = sdir; dir < sdir + 8; dir++) {\n            newX = x + GW.utils.CLOCK_DIRS[dir % 8][0];\n            newY = y + GW.utils.CLOCK_DIRS[dir % 8][1];\n            if (!site.hasXY(newX, newY))\n                continue;\n            const newCell = site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP);\n            if (newCell) {\n                currentStringLength++;\n                if (!inString) {\n                    if (numStrings > 0) {\n                        return false; // more than one string here; leave loopy\n                    }\n                    numStrings++;\n                    inString = true;\n                }\n            }\n            else if (inString) {\n                if (currentStringLength > maxStringLength) {\n                    maxStringLength = currentStringLength;\n                }\n                currentStringLength = 0;\n                inString = false;\n            }\n        }\n        if (inString && currentStringLength > maxStringLength) {\n            maxStringLength = currentStringLength;\n        }\n        if (numStrings == 1 && maxStringLength <= 4) {\n            site.clearSiteFlag(x, y, SITE.Flags.IS_IN_LOOP);\n            for (dir = 0; dir < 8; dir++) {\n                const newX = x + GW.utils.CLOCK_DIRS[dir][0];\n                const newY = y + GW.utils.CLOCK_DIRS[dir][1];\n                if (site.hasXY(newX, newY)) {\n                    this._checkCell(site, newX, newY);\n                }\n            }\n        }\n    }\n    _fillInnerLoopGrid(site, innerGrid) {\n        for (let x = 0; x < site.width; ++x) {\n            for (let y = 0; y < site.height; ++y) {\n                if (site.hasSiteFlag(x, y, SITE.Flags.IS_IN_LOOP)) {\n                    innerGrid[x][y] = 1;\n                }\n                else if (x > 0 && y > 0) {\n                    const up = site.hasSiteFlag(x, y - 1, SITE.Flags.IS_IN_LOOP);\n                    const left = site.hasSiteFlag(x - 1, y, SITE.Flags.IS_IN_LOOP);\n                    if (up && left) {\n                        innerGrid[x][y] = 1;\n                    }\n                }\n            }\n        }\n    }\n    _update(site) {\n        // remove extraneous loop markings\n        const innerLoop = GW.grid.alloc(site.width, site.height);\n        this._fillInnerLoopGrid(site, innerLoop);\n        // const xy = { x: 0, y: 0 };\n        let designationSurvives;\n        for (let i = 0; i < site.width; i++) {\n            for (let j = 0; j < site.height; j++) {\n                if (site.hasSiteFlag(i, j, SITE.Flags.IS_IN_LOOP)) {\n                    designationSurvives = false;\n                    for (let dir = 0; dir < 8; dir++) {\n                        let newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                        let newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                        if (site.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                            !innerLoop[newX][newY] &&\n                            !site.hasSiteFlag(newX, newY, SITE.Flags.IS_IN_LOOP)) {\n                            designationSurvives = true;\n                            break;\n                        }\n                    }\n                    if (!designationSurvives) {\n                        innerLoop[i][j] = 1;\n                        site.clearSiteFlag(i, j, SITE.Flags.IS_IN_LOOP);\n                    }\n                }\n            }\n        }\n        GW.grid.free(innerLoop);\n    }\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as blueprint_1 from './blueprint';\nexport { blueprint_1 as blueprint };\nimport { ChokeFinder } from './chokeFinder';\nimport { LoopFinder } from './loopFinder';\nexport * from './loopFinder';\nexport * from './chokeFinder';\nexport function analyze(site) {\n    const loops = new LoopFinder();\n    loops.compute(site);\n    const chokes = new ChokeFinder(true);\n    chokes.compute(site);\n}\n"],"names":["Hall","[object Object]","loc","dir","length","width","this","doors","x","y","d","GW.utils","DIRS","UP","DOWN","x2","y2","dx","dy","forEach","Room","Bounds","height","super","hall","cx","Math","floor","cy","translate","directionOfDoorSite","site","solutionDir","newX","newY","oppX","oppY","NO_DIRECTION","hasXY","isFloor","chooseRandomDoorSites","i","j","k","doorSiteFailed","DOORS","h","w","isDiggable","isSet","push","doorSites","GW.random","item","copySite","dest","source","offsetX","offsetY","forRect","otherX","otherY","v","getTile","setTile","TILEMAP","0","1","2","3","8","4","5","6","7","17","SEQ","initSeqence","shuffle","fillCostGrid","costGrid","update","_v","isPassable","GW.path","OBSTRUCTION","Fl","GW.flag","fl","Flags","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","GridSite","tiles","GW.grid","alloc","flags","choke","free","isBoundaryXY","isDoor","isBridge","isStairs","isShallow","get","isNothing","isWall","isDeep","tile","flag","value","set","count","checkConfig","config","expected","Object","entries","key","expect","have","undefined","Error","Array","isArray","range","GW.range","make","RoomDigger","options","_setOptions","result","carve","every","UTILS.chooseRandomDoorSites","rooms","ChoiceRoom","choices","randomRoom","bind","weighted","id","room","ERROR","create","Cavern","blobGrid","minWidth","maxWidth","minHeight","maxHeight","bounds","GW.blob","Blob","rounds","percentSeeded","birthParameters","survivalParameters","destX","destY","TYPES.Room","BrogueEntrance","roomWidth","roomHeight","roomWidth2","roomHeight2","roomX","roomY","roomX2","roomY2","min","max","Cross","SymmetricalCross","minorWidth","minorHeight","Rectangular","Circular","radius","forCircle","BrogueDonut","ringMinWidth","holeMinSize","holeChance","chance","ChunkyRoom","chunkCount","minX","maxX","minY","maxY","left","right","top","bottom","install","isDoorLoc","pickLength","lengths","pickHallDirection","dirs","sequence","hi","door","pickHallExits","obliqueChance","allowObliqueHallwayExit","hallDoors","dir2","HallDigger","l","doorLoc","dig","digWide","DIR","_digLine","TYPES.Hall","lower","higher","actual","startX","startY","halls","opts","clamp","Number","parseInt","_pickWidth","Lakes","minSize","tries","canDisrupt","wreathTile","wreathChance","wreathSize","assign","lakeMaxHeight","lakeMaxWidth","lakeMinSize","maxCount","hasWreath","lakeGrid","attempts","round","success","isDisruptedBy","sx","sy","lakeToMapX","lakeToMapY","walkableGrid","disrupts","lakeX","lakeY","first","floodFill","Bridges","minDistance","maxLength","pathGrid","dirCoords","isAnyWater","bridgeDir","calculateDistances","NO_PATH","isBridgeCandidate","Stairs","up","down","start","upTile","downTile","wall","needUp","needDown","locations","upLoc","downLoc","isValidLoc","isStairXY","matchingXY","matchingXYNear","distanceBetween","slice","setupStairs","indexes","x0","y0","dirIndex","CLOCK_DIRS","findIndex","r","LoopDigger","endX","endY","isValidTunnelStart","isValidTunnelEnd","SITE.fillCostGrid","SITE.SEQ","map","Level","loops","lakes","bridges","stairs","boundary","startLoc","endLoc","seed","setOptions","SITE.GridSite","setFn","makeSite","addFirstRoom","fails","addRoom","addLoops","addLakes","addBridges","addStairs","finish","t","_site","SITE.initSeqence","ROOM.RoomDigger","digger","ROOM.rooms","ROOM.ChoiceRoom","roomSite","getDigger","_attachRoomAtLoc","HALL.dig","_attachRoom","UTILS.directionOfDoorSite","oppDir","_roomFitsAt","UTILS.copySite","_attachDoor","attachLoc","offX","offY","roomGrid","roomToSiteX","roomToSiteY","xRoom","yRoom","xSite","ySite","didSomething","LOOP.LoopDigger","LAKE.Lakes","BRIDGE.Bridges","STAIRS.Stairs","_removeDiagonalOpenings","_finishWalls","_finishDoors","x1","y1","diagonalCornerRemoved","isObstruction","boundaryTile","levels","seeds","stairLocs","initSeeds","initStairLocs","number","stairDistance","cb","stairOpts","goesUp","startTile","endTile","entrance","levelOpts","makeLevel","level","LEVEL.Level","equalsXY","blueprints","tags","size","split","trim","frequency","GW.frequency","parts","from","want","includes","isRoom","BP_ROOM","isReward","BP_REWARD","isVestiblue","BP_VESTIBULE","adoptsItem","BP_ADOPT_ITEM","blueprint","ChokeFinder","withCounts","floodGrid","passMap","passableArcCount","clearSiteFlag","IS_CHOKEPOINT","setChokeCount","hasSiteFlag","IS_IN_LOOP","oldX","oldY","setSiteFlag","fill","cellCount","floodFillCount","i2","j2","getChokeCount","IS_GATE_SITE","results","LoopFinder","_initGrid","_checkCell","SITE.Flags","inString","sdir","numStrings","maxStringLength","currentStringLength","innerGrid","innerLoop","designationSurvives","_fillInnerLoopGrid","compute"],"mappings":"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"}
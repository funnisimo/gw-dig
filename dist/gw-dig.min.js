!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWU,t.GWM)}(this,(function(t,i,e){"use strict";function s(t){if(t&&t.__esModule)return t;var i=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(i,e,s.get?s:{enumerable:!0,get:function(){return t[e]}})}})),i.default=t,i}var o,r,n=s(i),h=s(e);const a=h.tile.get("NULL").index,l=h.tile.get("FLOOR").index,c=h.tile.get("DOOR").index,g=null!==(r=null===(o=h.tile.get("DOOR_SECRET"))||void 0===o?void 0:o.index)&&void 0!==r?r:-1,f=h.tile.get("WALL").index,u=h.tile.get("LAKE").index,d=h.tile.get("SHALLOW").index,_=h.tile.get("BRIDGE").index,I=h.tile.get("UP_STAIRS").index,E=h.tile.get("DOWN_STAIRS").index,p=h.tile.get("IMPREGNABLE").index,m={[a]:"NULL",[l]:"FLOOR",[c]:"DOOR",[f]:"WALL",[p]:"IMPREGNABLE",[u]:"LAKE",[d]:"SHALLOW",[_]:"BRIDGE",[I]:"UP_STAIRS",[E]:"DOWN_STAIRS"};class T{constructor(t,i){this.tiles=n.grid.alloc(t,i)}free(){n.grid.free(this.tiles)}clear(){this.tiles.fill(0)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return this.tiles.get(t,i)===a}isDiggable(t,i){return this.tiles.get(t,i)===a}isFloor(t,i){return this.tiles.get(t,i)==l}isDoor(t,i){return this.tiles.get(t,i)===c}isSecretDoor(t,i){return this.tiles.get(t,i)===g}isBridge(t,i){return this.tiles.get(t,i)===_}isWall(t,i){const e=this.tiles.get(t,i);return e===f||e===p}blocksMove(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)}blocksDiagonal(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksPathing(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)||this.isStairs(t,i)}blocksVision(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksItems(t,i){return this.blocksPathing(t,i)||this.blocksPathing(t,i)}blocksEffects(t,i){return this.isWall(t,i)}isStairs(t,i){const e=this.tiles.get(t,i);return e===I||e===E}isDeep(t,i){return this.tiles.get(t,i)===u}isShallow(t,i){return this.tiles.get(t,i)===d}isAnyLiquid(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTileIndex(t,i){return this.tiles.get(t,i)||0}setTile(t,i,e){if(e instanceof h.tile.Tile&&(e=e.index),"string"==typeof e){const t=h.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return!!this.tiles.hasXY(t,i)&&(this.tiles[t][i]=e,!0)}hasTile(t,i,e){if(e instanceof h.tile.Tile&&(e=e.index),"string"==typeof e){const t=h.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return this.tiles.hasXY(t,i)&&this.tiles[t][i]==e}getMachine(t,i){return 0}}const R=h.flags.Cell;class B{constructor(t){this.machineCount=0,this.map=t}get width(){return this.map.width}get height(){return this.map.height}hasXY(t,i){return this.map.hasXY(t,i)}isBoundaryXY(t,i){return this.map.isBoundaryXY(t,i)}hasCellFlag(t,i,e){return this.map.cellInfo(t,i).hasCellFlag(e)}setCellFlag(t,i,e){this.map.cell(t,i).setCellFlag(e)}clearCellFlag(t,i,e){this.map.cell(t,i).clearCellFlag(e)}hasTile(t,i,e){return this.map.cellInfo(t,i).hasTile(e)}setTile(t,i,e,s){return this.map.setTile(t,i,e,s)}getTileIndex(t,i){if(!this.hasXY(t,i))return 0;return this.map.cell(t,i).highestPriorityTile().index}clear(){this.map.cells.forEach((t=>t.clear()))}hasItem(t,i){return this.map.cellInfo(t,i).hasItem()}makeRandomItem(t){return h.item.makeRandom(t)}addItem(t,i,e){return this.map.forceItem(t,i,e)}hasActor(t,i){return this.map.hasActor(t,i)}blocksMove(t,i){return this.map.cellInfo(t,i).blocksMove()}blocksVision(t,i){return this.map.cellInfo(t,i).blocksVision()}blocksDiagonal(t,i){return this.map.cellInfo(t,i).hasEntityFlag(h.flags.Entity.L_BLOCKS_DIAGONAL)}blocksPathing(t,i){const e=this.map.cellInfo(t,i);return e.hasEntityFlag(h.flags.Entity.L_BLOCKS_MOVE)||e.hasTileFlag(h.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,i){return this.map.cellInfo(t,i).hasEntityFlag(h.flags.Entity.L_BLOCKS_ITEMS)}blocksEffects(t,i){return this.map.cellInfo(t,i).hasEntityFlag(h.flags.Entity.L_BLOCKS_EFFECTS)}isWall(t,i){return this.map.cellInfo(t,i).isWall()}isStairs(t,i){return this.map.cellInfo(t,i).isStairs()}isSet(t,i){return this.hasXY(t,i)&&!this.map.cell(t,i).isEmpty()}isDiggable(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.isEmpty()||!!e.isWall()}isNothing(t,i){return this.hasXY(t,i)&&this.map.cell(t,i).isEmpty()}isFloor(t,i){return this.isPassable(t,i)}isBridge(t,i){return this.map.cellInfo(t,i).hasTileFlag(h.tile.flags.Tile.T_BRIDGE)}isDoor(t,i){return this.map.cellInfo(t,i).hasTileFlag(h.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,i){return this.map.cellInfo(t,i).hasEntityFlag(h.flags.Entity.L_SECRETLY_PASSABLE)}isDeep(t,i){return this.map.cellInfo(t,i).hasTileFlag(h.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.depthTile(h.flags.Depth.LIQUID)&&!e.hasTileFlag(h.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return e.hasDepthTile(h.flags.Depth.LIQUID)||e.hasTileFlag(h.tile.flags.Tile.T_IS_DEEP_LIQUID)}isOccupied(t,i){return this.hasItem(t,i)||this.hasActor(t,i)}isPassable(t,i){const e=this.map.cellInfo(t,i);return!(e.blocksMove()||e.blocksPathing())}backup(){const t=new B(this.map.clone());return t.machineCount=this.machineCount,t}restore(t){this.map.copy(t.map),this.machineCount=t.machineCount}free(){}getChokeCount(t,i){return this.map.cell(t,i).chokeCount}setChokeCount(t,i,e){this.map.cell(t,i).chokeCount=e}analyze(){h.map.analyze(this.map)}fireEffect(t,i,e){return h.effect.fireSync(t,this.map,i,e)}nextMachineId(){return++this.machineCount}getMachine(t,i){return this.map.cell(t,i).machineId}setMachine(t,i,e,s=!0){this.map.cell(t,i).machineId=e,0==e?this.map.clearCellFlag(t,i,R.IS_IN_MACHINE):this.map.setCellFlag(t,i,s?R.IS_IN_ROOM_MACHINE:R.IS_IN_AREA_MACHINE)}}const O=n.xy.DIRS;function L(t,i,e){let s,o,r,h,a,l;for(o=n.xy.NO_DIRECTION,s=0;s<4;s++)if(r=i+O[s][0],h=e+O[s][1],a=i-O[s][0],l=e-O[s][1],t.hasXY(a,l)&&t.hasXY(r,h)&&t.isFloor(a,l)){if(o!=n.xy.NO_DIRECTION)return n.xy.NO_DIRECTION;o=s}return o}function w(t){let i,e,s,o,r,h,a;const l=[[],[],[],[]],c=t.height,g=t.width;for(i=0;i<g;i++)for(e=0;e<c;e++)if(t.isDiggable(i,e)&&(h=L(t,i,e),h!=n.xy.NO_DIRECTION)){for(o=i+n.xy.DIRS[h][0],r=e+n.xy.DIRS[h][1],a=!1,s=0;s<10&&t.hasXY(o,r)&&!a;s++)t.isSet(o,r)&&(a=!0),o+=n.xy.DIRS[h][0],r+=n.xy.DIRS[h][1];a||l[h].push([i,e])}let f=[];for(h=0;h<4;h++){const t=n.random.item(l[h])||[-1,-1];f[h]=[t[0],t[1]]}return f}function N(t,i,e=0,s=0){n.xy.forRect(t.width,t.height,((o,r)=>{const n=o-e,h=r-s,a=i.getTileIndex(n,h);a&&t.setTile(o,r,a)}))}function M(t,i){i.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION))}function S(t,i,e={}){var s,o,r;null!==(s=e.offsetX)&&void 0!==s||(e.offsetX=0),null!==(o=e.offsetY)&&void 0!==o||(e.offsetY=0),null!==(r=e.machine)&&void 0!==r||(e.machine=0);const h=n.grid.alloc(t.width,t.height);let a=!1;n.xy.forRect(t.width,t.height,((s,o)=>{const r=s+e.offsetX,n=o+e.offsetY;i.get(r,n)?t.isStairs(s,o)&&(a=!0):!t.isPassable(s,o)||0!=t.getMachine(s,o)&&t.getMachine(s,o)!=e.machine||(h[s][o]=1)}));let l=!0;for(let t=0;t<h.width&&!a;++t)for(let i=0;i<h.height&&!a;++i)1==h[t][i]&&(l?(h.floodFill(t,i,1,2),l=!1):a=!0);return n.grid.free(h),a}function A(t,i,e=0,s=0){const o=n.grid.alloc(t.width,t.height);let r=0;if(n.xy.forRect(t.width,t.height,((n,h)=>{const a=n+e,l=h+s;i.get(a,l)?t.isStairs(n,h)&&(r=t.width*t.height):t.isPassable(n,h)&&(o[n][h]=1)})),r)return r;let h=!0,a=2,l=t.width*t.height;for(let t=0;t<o.width;++t)for(let i=0;i<o.height;++i)if(1==o[t][i]){const e=o.floodFill(t,i,1,a++);l=Math.min(l,e),h?h=!1:r=l}return n.grid.free(o),r}function y(t,i,e,s,o){const r=n.grid.alloc(t.width,t.height);M(t,r),n.path.calculateDistances(i,e,s,r,!1,o+1),n.grid.free(r)}function b(t,i){for(let e=0;e<t.width;e++)for(let s=0;s<t.height;s++)t.getMachine(e,s)!=i||t.hasCellFlag(e,s,h.flags.Cell.IS_WIRED|h.flags.Cell.IS_CIRCUIT_BREAKER)||t.setMachine(e,s,0)}var F={__proto__:null,NOTHING:a,FLOOR:l,DOOR:c,SECRET_DOOR:g,WALL:f,DEEP:u,SHALLOW:d,BRIDGE:_,UP_STAIRS:I,DOWN_STAIRS:E,IMPREGNABLE:p,TILEMAP:m,GridSite:T,MapSite:B,directionOfDoorSite:L,chooseRandomDoorSites:w,copySite:N,fillCostGrid:M,siteDisruptedBy:S,siteDisruptedSize:A,computeDistanceMap:y,clearInteriorFlag:b};class P{constructor(t,i,e,s=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const o=n.xy.DIRS[i];this.length=e,this.width=s,i===n.xy.UP||i===n.xy.DOWN?(this.x2=this.x+(s-1),this.y2=this.y+(e-1)*o[1]):(this.x2=this.x+(e-1)*o[0],this.y2=this.y+(s-1)),this.dir=i}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}class D extends n.xy.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}function C(t,i={}){return t=t||{},i=i||{},Object.entries(i).forEach((([i,e])=>{let s=t[i];if("tile"===i)return void(void 0===s&&(t[i]=e));if(!0===e){if(!s)throw new Error("Missing required config for room digger: "+i)}else s=("number"==typeof e||Array.isArray(e),s||e);const o=n.range.make(s);t[i]=o})),t}class x{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=C(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=w(t))),i}}var k={};class v extends x{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,i={}){const e=t.choices||i.choices;if(Array.isArray(e))this.randomRoom=n.random.item.bind(n.random,e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=n.random.weighted.bind(n.random,e)}}carve(t){let i=this.randomRoom();const e=k[i];return e||n.utils.ERROR("Missing room digger choice: "+i),e.create(t)}}class Y extends x{constructor(t={}){super(t,{width:12,height:8})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||l,o=n.grid.alloc(t.width,t.height,0),r=Math.floor(.5*i),h=i,a=Math.floor(.5*e),c=e,g=new n.blob.Blob({rounds:5,minWidth:r,minHeight:a,maxWidth:h,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(o.width,o.height,((t,i)=>o[t][i]=1)),f=Math.floor((t.width-g.width)/2),u=f-g.x,d=Math.floor((t.height-g.height)/2),_=d-g.y;return o.forEach(((i,e,o)=>{i&&t.setTile(e+u,o+_,s)})),n.grid.free(o),new D(f,d,g.width,g.height)}}class G extends x{constructor(t={}){super(t,{width:20,height:10})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||l,o=Math.floor(.4*i),r=e,h=i,a=Math.floor(.5*e),c=Math.floor(t.width/2-o/2-1),g=t.height-r-2,f=Math.floor(t.width/2-h/2-1),u=t.height-a-2;n.xy.forRect(c,g,o,r,((i,e)=>t.setTile(i,e,s))),n.xy.forRect(f,u,h,a,((i,e)=>t.setTile(i,e,s)));const d=new D(Math.min(c,f),Math.min(g,u),Math.max(o,h),Math.max(r,a));return d.doors[n.xy.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class W extends x{constructor(t={}){super(t,{width:12,height:20})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||l,o=i,r=Math.max(3,Math.floor(i*n.random.range(25,75)/100)),h=Math.max(3,Math.floor(e*n.random.range(25,75)/100)),a=e,c=Math.floor((t.width-o)/2),g=c+n.random.range(2,Math.max(2,o-r-2)),f=Math.floor((t.height-a)/2),u=f+n.random.range(2,Math.max(2,a-h-2));return n.xy.forRect(c,u,o,h,((i,e)=>t.setTile(i,e,s))),n.xy.forRect(g,f,r,a,((i,e)=>t.setTile(i,e,s))),new D(c,f,Math.max(o,r),Math.max(h,a))}}class X extends x{constructor(t={}){super(t,{width:7,height:7})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||l;let o=Math.max(3,Math.floor(i*n.random.range(25,50)/100)),r=Math.max(3,Math.floor(e*n.random.range(25,50)/100));const h=Math.floor((t.width-i)/2),a=Math.floor((t.height-r)/2);n.xy.forRect(h,a,i,r,((i,e)=>t.setTile(i,e,s)));const c=Math.floor((t.width-o)/2),g=Math.floor((t.height-e)/2);return n.xy.forRect(c,g,o,e,((i,e)=>t.setTile(i,e,s))),new D(Math.min(h,c),Math.min(a,g),Math.max(i,o),Math.max(e,r))}}class U extends x{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||l,o=Math.floor((t.width-i)/2),r=Math.floor((t.height-e)/2);return n.xy.forRect(o,r,i,e,((i,e)=>t.setTile(i,e,s))),new D(o,r,i,e)}}class H extends x{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const i=this.options.radius.value(),e=this.options.tile||l,s=Math.floor(t.width/2),o=Math.floor(t.height/2);return i>1&&n.xy.forCircle(s,o,i,((i,s)=>t.setTile(i,s,e))),new D(s-i,o-i,2*i+1,2*i+1)}}class V extends x{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const i=this.options.radius.value(),e=this.options.ringMinWidth.value(),s=this.options.holeMinSize.value(),o=this.options.tile||l,r=Math.floor(t.width/2),h=Math.floor(t.height/2);return n.xy.forCircle(r,h,i,((i,e)=>t.setTile(i,e,o))),i>e+s&&n.random.chance(this.options.holeChance.value())&&n.xy.forCircle(r,h,n.random.range(s,i-s),((i,e)=>t.setTile(i,e,0))),new D(r-i,h-i,2*i+1,2*i+1)}}class q extends x{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let i,e,s,o=this.options.count.value();const r=this.options.width.value(),h=this.options.height.value(),a=this.options.tile||l,c=Math.floor(t.width/2)-Math.floor(r/2),g=Math.floor(t.width/2)+Math.floor(r/2),f=Math.floor(t.height/2)-Math.floor(h/2),u=Math.floor(t.height/2)+Math.floor(h/2);let d=Math.floor(t.width/2),_=d,I=Math.floor(t.height/2),E=I;for(n.xy.forCircle(d,I,2,((i,e)=>t.setTile(i,e,a))),d-=2,_+=2,I-=2,E+=2,i=0;i<o;)if(e=n.random.range(c,g),s=n.random.range(f,u),t.isSet(e,s)){if(e-2<c)continue;if(e+2>g)continue;if(s-2<f)continue;if(s+2>u)continue;d=Math.min(e-2,d),_=Math.max(e+2,_),I=Math.min(s-2,I),E=Math.max(s+2,E),n.xy.forCircle(e,s,2,((i,e)=>t.setTile(i,e,a))),i++}return new D(d,I,_-d+1,E-I+1)}}function K(t,i){return k[t]=i,i}K("DEFAULT",new U);var z={__proto__:null,checkConfig:C,RoomDigger:x,rooms:k,ChoiceRoom:v,choiceRoom:function(t,i){return new v(t).create(i)},Cavern:Y,cavern:function(t,i){return new Y(t).create(i)},BrogueEntrance:G,brogueEntrance:function(t,i){return new G(t).create(i)},Cross:W,cross:function(t,i){return new W(t).create(i)},SymmetricalCross:X,symmetricalCross:function(t,i){return new X(t).create(i)},Rectangular:U,rectangular:function(t,i){return new U(t).create(i)},Circular:H,circular:function(t,i){return new H(t).create(i)},BrogueDonut:V,brogueDonut:function(t,i){return new V(t).create(i)},ChunkyRoom:q,chunkyRoom:function(t,i){return new q(t).create(i)},install:K};const j=n.xy.DIRS;function Q(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function Z(t,i){return t==n.xy.UP||t==n.xy.DOWN?i[1].value():i[0].value()}function $(t,i,e){let s=n.xy.NO_DIRECTION;if(s==n.xy.NO_DIRECTION){const o=n.random.sequence(4);for(let r=0;r<4;r++){s=o[r];const h=e[(r+1)%2].hi,a=i[s];if(a&&-1!=a[0]&&-1!=a[1]){const i=a[0]+Math.floor(j[s][0]*h),e=a[1]+Math.floor(j[s][1]*h);if(t.hasXY(i,e))break}s=n.xy.NO_DIRECTION}}return s}function J(t,i,e,s,o){let r,h;const a=n.random.chance(o),l=[];for(let o=0;o<4;o++)r=i+j[o][0],h=e+j[o][1],o!=s&&!a||!t.hasXY(r,h)||t.isSet(r,h)||(l[o]=[r,h]);return l}class tt{constructor(t={}){this.config={width:n.range.make(1),length:[n.range.make("2-15"),n.range.make("2-9")],tile:l,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=n.range.make(t.width)),t.length&&"number"==typeof t.length){const i=n.range.make(t.length);this.config.length=[i,i]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,i=[]){if(i=i||w(t),!n.random.chance(this.config.chance))return null;const e=$(t,i,this.config.length);if(e===n.xy.NO_DIRECTION)return null;if(!i[e])return null;const s=this.config.width.value(),o=Z(e,this.config.length),r=i[e];return 1==s?this.dig(t,e,r,o):this.digWide(t,e,r,o,s)}_digLine(t,i,e,s){let o=i[0],r=i[1];const n=this.config.tile;for(let i=0;i<s;i++)t.setTile(o,r,n),o+=e[0],r+=e[1];return o-=e[0],r-=e[1],[o,r]}dig(t,i,e,s){const o=j[i],[r,n]=this._digLine(t,e,o,s),h=new P(e,i,s);return h.doors=J(t,r,n,i,this.config.obliqueChance),h}digWide(t,i,e,s,o){const r=n.xy.DIRS[i],h=[e[0]-r[1],e[1]-r[0]],a=[e[0]+r[1],e[1]+r[0]];this._digLine(t,e,r,s);let l=1,c=e[0],g=e[1];l<o&&Q(t,h,r)&&(this._digLine(t,h,r,s),c=Math.min(h[0],c),g=Math.min(h[1],g),++l),l<o&&Q(t,a,r)&&(this._digLine(t,a,r,s),c=Math.min(a[0],c),g=Math.min(a[1],g),++l);const f=new P([c,g],i,s,o);return f.doors=[],f.doors[i]=[e[0]+s*r[0],e[1]+s*r[1]],f.width=o,f}}function it(t,i,e){return new tt(t).create(i,e)}var et={};function st(t,i){return et[t]=i,i}st("DEFAULT",new tt({chance:15}));var ot={__proto__:null,isDoorLoc:Q,pickWidth:function(t={}){return n.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let i=t.width;if("number"==typeof i)return i;i=Array.isArray(i)?n.random.weighted(i)+1:"string"==typeof i?n.range.make(i).value():Number.parseInt(n.random.weighted(i));return i}(t),1,3)},pickLength:Z,pickHallDirection:$,pickHallExits:J,HallDigger:tt,dig:it,halls:et,install:st};class rt{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:d,wreathChance:50,wreathSize:1,tile:u},Object.assign(this.options,t)}create(t){let i,e,s,o,r,h,a,l,c,g,f,_=0;h=this.options.height||15,a=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,f=this.options.canDisrupt||!1;const I=!!n.random.chance(this.options.wreathChance),E=this.options.wreathTile||d,p=this.options.wreathSize||1,m=this.options.tile||u,T=n.grid.alloc(t.width,t.height,0);let R=0;for(;R<g&&_<g;){const u=Math.round((a-l)*(g-R)/g)+l,d=Math.round((h-l)*(g-R)/g)+l,B=new n.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:u,maxHeight:d,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(T.width,T.height,((t,i)=>T[t][i]=1));let O=!1;for(s=0;s<c&&!O;s++)if(o=n.random.range(1-B.x,T.width-B.width-B.x-2),r=n.random.range(1-B.y,T.height-B.height-B.y-2),f||!this.isDisruptedBy(t,T,-o,-r)){for(O=!0,i=0;i<B.width;i++)for(e=0;e<B.height;e++)if(T[i+B.x][e+B.y]){const s=i+B.x+o,h=e+B.y+r;t.setTile(s,h,m),I&&n.xy.forCircle(s,h,p,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,E)}))}break}O?++_:++R}return n.grid.free(T),_}isDisruptedBy(t,i,e=0,s=0){const o=n.grid.alloc(t.width,t.height);let r=!1;n.xy.forRect(t.width,t.height,((n,h)=>{const a=n+e,l=h+s;i.get(a,l)?t.isStairs(n,h)&&(r=!0):t.isPassable(n,h)&&(o[n][h]=1)}));let h=!0;for(let t=0;t<o.width&&!r;++t)for(let i=0;i<o.height&&!r;++i)1==o[t][i]&&(h?(o.floodFill(t,i,1,2),h=!1):r=!0);return n.grid.free(o),r}}var nt={__proto__:null,Lakes:rt};class ht{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let i,e,s,o,r,h,a,c=0;const g=this.options.maxLength,f=this.options.minDistance,u=n.grid.alloc(t.width,t.height),d=n.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];d.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION));const E=n.random.sequence(t.width*t.height);for(s=0;s<E.length;s++)if(h=Math.floor(E[s]/t.height),a=E[s]%t.height,t.isPassable(h,a)&&!t.isAnyLiquid(h,a))for(r=0;r<=1;r++){const s=I[r];if(i=h+s[0],e=a+s[1],o=g,t.isAnyLiquid(i,e))for(o=0;o<g&&(i+=s[0],e+=s[1],t.isAnyLiquid(i,e));++o);if(t.isPassable(i,e)&&o<g&&(n.path.calculateDistances(u,i,e,d,!1),u[h][a]>f&&u[h][a]<n.path.NO_PATH)){for(;h!==i||a!==e;)this.isBridgeCandidate(t,h,a,s)?(t.setTile(h,a,_),d[h][a]=1):(t.setTile(h,a,l),d[h][a]=1),h+=s[0],a+=s[1];++c;break}}return n.grid.free(u),n.grid.free(d),c}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyLiquid(i,e)&&(!!t.isAnyLiquid(i+s[1],e+s[0])&&!!t.isAnyLiquid(i-s[1],e-s[0]))}}var at={__proto__:null,Bridges:ht};class lt{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:I,downTile:E,wall:p},Object.assign(this.options,t)}create(t){let i=!1!==this.options.up,e=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),o={};let r=null,h=null;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let i=this.options.start;i=!0===i?n.random.matchingLoc(t.width,t.height,a):n.random.matchingLocNear(n.xy.x(i),n.xy.y(i),a),o.start=i}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;r=n.random.matchingLocNear(n.xy.x(t),n.xy.y(t),a);const i=this.options.down;h=n.random.matchingLocNear(n.xy.x(i),n.xy.y(i),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const i=this.options.up;r=n.random.matchingLocNear(n.xy.x(i),n.xy.y(i),a),e&&(h=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,r[0],r[1])<s)&&a(t,i))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;h=n.random.matchingLocNear(n.xy.x(e),n.xy.y(e),a),i&&(r=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,h[0],h[1])<s)&&a(t,i))))}else i?(r=n.random.matchingLoc(t.width,t.height,a),e&&(h=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,r[0],r[1])<s)&&a(t,i))))):e&&(h=n.random.matchingLoc(t.width,t.height,a));return r&&(o.up=r.slice(),this.setupStairs(t,r[0],r[1],this.options.upTile),"up"===this.options.start&&(o.start=o.up)),h&&(o.down=h.slice(),this.setupStairs(t,h[0],h[1],this.options.downTile),"down"===this.options.start&&(o.start=o.down)),r||h?o:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,i,e){let s=0;if(!this.hasXY(t,i,e)||!t.isDiggable(i,e))return!1;for(let o=0;o<4;++o){const r=n.xy.DIRS[o];if(!this.hasXY(t,i+r[0],e+r[1]))return!1;if(!this.hasXY(t,i-r[0],e-r[1]))return!1;if(t.isFloor(i+r[0],e+r[1])){if(s+=1,!t.isDiggable(i-r[0]+r[1],e-r[1]+r[0]))return!1;if(!t.isDiggable(i-r[0]-r[1],e-r[1]-r[0]))return!1}else if(!t.isDiggable(i+r[0],e+r[1]))return!1}return 1==s}setupStairs(t,i,e,s){const o=n.random.sequence(4);let r=null;for(let s=0;s<o.length;++s){r=n.xy.DIRS[s];const o=i+r[0],h=e+r[1];if(t.isFloor(o,h)&&t.isDiggable(i-r[0],e-r[1]))break;r=null}r||n.utils.ERROR("No stair direction found!"),t.setTile(i,e,s);const h=n.xy.CLOCK_DIRS.findIndex((t=>t[0]==r[0]&&t[1]==r[1])),a=this.options.wall;for(let s=0;s<n.xy.CLOCK_DIRS.length;++s){const o=s?s-1:7,r=(s+1)%8;if(s==h||o==h||r==h)continue;const l=n.xy.CLOCK_DIRS[s];t.setTile(i+l[0],e+l[1],a)}return!0}}var ct={__proto__:null,Stairs:lt};class gt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},Object.assign(this.options,t)}create(t){let i,e,s,o,r,h,a,g,f;const u=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,_=n.grid.alloc(t.width,t.height),I=n.grid.alloc(t.width,t.height),E=[[1,0],[0,1]];function p(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function m(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}M(t,I);let T=0;const R=n.random.sequence(t.width*t.height);for(r=0;r<R.length;r++)if(g=Math.floor(R[r]/t.height),f=R[r]%t.height,!t.isSet(g,f))for(a=0;a<=1;a++){let r=E[a];if(p(g,f,r)){if(h=d,t.hasXY(g+r[0],f+r[1])&&t.isPassable(g+r[0],f+r[1])){if(!t.hasXY(g-r[0],f-r[1])||t.isDoor(g-r[0],f-r[1]))continue}else{if(!t.hasXY(g-r[0],f-r[1])||!t.isPassable(g-r[0],f-r[1]))continue;if(!t.hasXY(g+r[0],f+r[1])||t.isDoor(g+r[0],f+r[1]))continue;r=r.map((t=>-1*t))}for(i=g+r[0],e=f+r[1],s=g,o=f,h=0;h<d&&(s-=r[0],o-=r[1],!m(s,o,r));++h);if(h<d&&(n.path.calculateDistances(_,i,e,I,!1),_[s][o]>u&&_[s][o]<3e4)){for(;s!==i||o!==e;)t.isNothing(s,o)&&(t.setTile(s,o,l),I[s][o]=1),s+=r[0],o+=r[1];const h=n.random.chance(this.options.doorChance)?c:l;t.setTile(g,f,h),++T;break}}}return n.grid.free(_),n.grid.free(I),T}}var ft={__proto__:null,LoopDigger:gt,digLoops:function(t,i={}){return new gt(i).create(t)}};class ut{constructor(t={}){var i,e;this.seed=0,this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.seed=t.seed||0,n.object.setOptions(this.rooms,t.rooms),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),n.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),n.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),t.loops=t.loops||{},t.loops.doorChance=null!==(i=t.loops.doorChance)&&void 0!==i?i:null===(e=t.doors)||void 0===e?void 0:e.chance,n.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),n.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:(!0===t.bridges&&(t.bridges={}),n.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:(!0===t.stairs&&(t.stairs={}),n.object.setOptions(this.stairs,t.stairs)),this.startLoc=t.startLoc||[-1,-1],this.endLoc=t.endLoc||[-1,-1]}_makeSite(t,i){return new T(t,i)}create(...t){if(1==t.length&&t[0]instanceof h.map.Map){const i=t[0];this.site=new B(i)}if(t.length>1){const i=t[0],e=t[1];this.site=new T(i,e)}const i=this._create(this.site);if(t.length>1){const i=t[0],e=t[1],s=t[2];n.xy.forRect(i,e,((t,i)=>{const e=this.site.getTileIndex(t,i);e&&s(t,i,e)}))}return this.site.free(),i}_create(t){this.startLoc[0]<0&&this.startLoc[0]<0&&(this.startLoc[0]=Math.floor(t.width/2),this.startLoc[1]=t.height-2),this.start(t);let i=20;for(;--i&&!this.addFirstRoom(t););if(!i)throw new Error("Failed to place first room!");let e=0;for(;e<20;)this.addRoom(t)?e=0:++e;return this.loops&&this.addLoops(t,this.loops),this.lakes&&this.addLakes(t,this.lakes),this.bridges&&this.addBridges(t,this.bridges),this.stairs&&this.addStairs(t,this.stairs),this.finish(t),!0}start(t){this.seed&&n.random.seed(this.seed),t.clear(),this.seq=n.random.sequence(t.width*t.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof x)return t;if("string"==typeof t){const i=k[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new v(t)}addFirstRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return e&&!this._attachRoomAtLoc(t,i,e,this.startLoc)&&(e=null),i.free(),e}addRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(this.halls.chance){let t=it(this.halls,i,e.doors);t&&(e.hall=t)}return e&&!this._attachRoom(t,i,e)&&(e=null),i.free(),e}_attachRoom(t,i,e){const s=e.hall?e.hall.doors:e.doors;for(let o=0;o<this.seq.length;o++){const r=Math.floor(this.seq[o]/t.height),h=this.seq[o]%t.height;if(!t.isNothing(r,h))continue;const a=L(t,r,h);if(a!=n.xy.NO_DIRECTION){const o=(a+2)%4,n=s[o];if(!n)continue;const l=r-n[0],c=h-n[1];if(-1!=n[0]&&this._roomFitsAt(t,i,l,c))return N(t,i,l,c),this._attachDoor(t,e,r,h,o),e.translate(l,c),!0}}return!1}_attachRoomAtLoc(t,i,e,s){const[o,r]=s,h=e.hall?e.hall.doors:e.doors,a=n.random.sequence(4);for(let s of a){const n=h[(s+2)%4];if(!n||-1==n[0])continue;const a=o-n[0],l=r-n[1];if(this._roomFitsAt(t,i,a,l))return N(t,i,a,l),e.translate(a,l),!0}return!1}_roomFitsAt(t,i,e,s){let o,r,n,h,a,l;for(o=0;o<i.width;o++)for(r=0;r<i.height;r++)if(i.isSet(o,r))for(n=o+e,h=r+s,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||!t.isNothing(a,l))return!1;return!0}_attachDoor(t,i,e,s,o){const r=this.doors;let h=!1;r.chance&&n.random.chance(r.chance)&&(h=!0);const a=h?r.tile||c:l;if(t.setTile(e,s,a),i.hall&&i.hall.width>1&&i.hall.dir===o)if(o===n.xy.UP||o===n.xy.DOWN){let i=!0,o=1;for(;i;)i=!1,t.isNothing(e-o,s)&&t.isSet(e-o,s-1)&&t.isSet(e-o,s+1)&&(t.setTile(e-o,s,a),i=!0),t.isNothing(e+o,s)&&t.isSet(e+o,s-1)&&t.isSet(e+o,s+1)&&(t.setTile(e+o,s,a),i=!0),++o}else{let i=!0,o=1;for(;i;)i=!1,t.isNothing(e,s-o)&&t.isSet(e-1,s-o)&&t.isSet(e+1,s-o)&&(t.setTile(e,s-o,a),i=!0),t.isNothing(e,s+o)&&t.isSet(e-1,s+o)&&t.isSet(e+1,s+o)&&(t.setTile(e,s+o,a),i=!0),++o}}addLoops(t,i){return new gt(i).create(t)}addLakes(t,i){return new rt(i).create(t)}addBridges(t,i){return new ht(i).create(t)}addStairs(t,i){return new lt(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let i,e,s,o,r,h;do{for(h=!1,i=0;i<t.width-1;i++)for(e=0;e<t.height-1;e++)for(s=0;s<=1;s++)!t.blocksMove(i+s,e)&&t.blocksMove(i+(1-s),e)&&t.blocksDiagonal(i+(1-s),e)&&t.blocksMove(i+s,e+1)&&t.blocksDiagonal(i+s,e+1)&&!t.blocksMove(i+(1-s),e+1)&&(n.random.chance(50)?(o=i+(1-s),r=e):(o=i+s,r=e+1),h=!0,t.setTile(o,r,l))}while(1==h)}_finishDoors(t){n.xy.forRect(t.width,t.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.blocksPathing(i+1,e)?1:0)+(t.blocksPathing(i-1,e)?1:0)+(t.blocksPathing(i,e+1)?1:0)+(t.blocksPathing(i,e-1)?1:0)>=3)&&t.setTile(i,e,l)}))}_finishWalls(t){const i=this.boundary?p:f;n.xy.forRect(t.width,t.height,((e,s)=>{t.isNothing(e,s)&&(t.isBoundaryXY(e,s)?t.setTile(e,s,i):t.setTile(e,s,f))}))}}const dt=n.flag.fl;var _t;!function(t){t[t.BP_ROOM=dt(0)]="BP_ROOM",t[t.BP_VESTIBULE=dt(1)]="BP_VESTIBULE",t[t.BP_REWARD=dt(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=dt(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=dt(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=dt(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=dt(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=dt(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=dt(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=dt(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=dt(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=dt(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=dt(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=dt(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=dt(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=dt(15)]="BP_NOT_IN_HALLWAY"}(_t||(_t={}));class It{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=n.frequency.make(t.frequency||100),t.size){if(this.size=n.range.make(t.size),this.size.lo>this.size.hi)throw new Error("Blueprint size must be small to large.")}else this.size=n.range.make([1,1]);if(t.flags&&(this.flags=n.flag.from(_t,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new Lt(t)))),this.flags&_t.BP_ADOPT_ITEM&&!this.steps.some((t=>t.flags&Ot.BF_ADOPT_ITEM)))throw new Error("Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.")}getChance(t,i){return i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t))))?0:this.frequency(t)}get isRoom(){return!!(this.flags&_t.BP_ROOM)}get isReward(){return!!(this.flags&_t.BP_REWARD)}get isVestiblue(){return!!(this.flags&_t.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&_t.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&_t.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&_t.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&_t.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&_t.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&_t.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&_t.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&_t.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&_t.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&_t.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&_t.BP_NO_INTERIOR_FLAG)}qualifies(t,i){return!(this.frequency(i)<=0||~this.flags&t||this.flags&_t.BP_ADOPT_ITEM&~t||this.flags&_t.BP_VESTIBULE&~t)}pickLocation(t){return function(t,i){if(i.isRoom){const e=n.random.matchingLoc(t.width,t.height,((e,s)=>t.hasCellFlag(e,s,h.flags.Cell.IS_GATE_SITE)&&i.size.contains(t.getChokeCount(e,s))));return!e||e[0]<0||e[1]<0?(console.log("Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint."),!1):e}if(i.isVestiblue)return console.log("ERROR: Attempted to build a vestiblue without a location being provided."),!1;const e=n.random.matchingLoc(t.width,t.height,((e,s)=>{if(!t.isPassable(e,s))return!1;if(i.flags&_t.BP_NOT_IN_HALLWAY){return n.xy.arcCount(e,s,((i,e)=>t.isPassable(i,e)))<=1}return!0}));return!(!e||e[0]<0||e[1]<0)&&e}(t,this)}computeInterior(t){return function(t,i){let e,s=i.isRoom?10:20;const o=t.interior,r=t.site;do{if(e=!1,--s<=0)return!1;if(o.fill(0),i.isRoom)e=!pt(t,t.originX,t.originY);else if(i.isVestiblue){if(!Et(t,i))return console.log(`ERROR: Attempted to build vestibule ${i.id}: not enough room.`),!1}else{let s=n.grid.alloc(o.width,o.height);y(r,s,t.originX,t.originY,i.size.hi);const a=n.random.sequence(r.width*r.height);let l=0,c=i.size.value();for(let t=0;t<1e3&&l<c;t++)for(let i=0;i<a.length&&l<c;i++){const n=Math.floor(a[i]/r.height),g=a[i]%r.height;s[n][g]==t&&(o[n][g]=1,l++,(r.isOccupied(n,g)||r.hasCellFlag(n,g,h.flags.Cell.IS_IN_MACHINE))&&(e=!0,l=c))}l<c?(e=!0,console.debug("- too small")):i.treatAsBlocking&&S(r,o,{machine:r.machineCount})?(console.debug(" - disconnected"),e=!0):i.requireBlocking&&A(r,o)<100&&(console.debug(" - not disconnected enough"),e=!0),n.grid.free(s)}}while(e);return!0}(t,this)}prepareInterior(t){return function(t,i){const e=t.interior,s=t.site;i.maximizeInterior?mt(t,1):i.openInterior&&mt(t,4);i.purgeInterior&&e.forEach(((t,i,e)=>{t&&s.setTile(i,e,l)}));i.purgeBlockers&&e.forEach(((t,i,e)=>{t&&s.blocksPathing(i,e)&&s.setTile(i,e,l)}));i.purgeLiquids&&e.forEach(((t,i,e)=>{t&&s.isAnyLiquid(i,e)&&s.setTile(i,e,l)}));i.surroundWithWalls&&e.forEach(((t,i,o)=>{t&&!s.hasCellFlag(i,o,h.flags.Cell.IS_GATE_SITE)&&n.xy.eachNeighbor(i,o,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.isWall(t,i)||s.hasCellFlag(t,i,h.flags.Cell.IS_GATE_SITE)||s.hasCellFlag(t,i,h.flags.Cell.IS_IN_MACHINE)||s.blocksPathing(t,i)&&s.setTile(t,i,f))}),!1)}));i.makeImpregnable&&e.forEach(((t,i,o)=>{t&&!s.hasCellFlag(i,o,h.flags.Cell.IS_GATE_SITE)&&(s.setCellFlag(i,o,h.flags.Cell.IMPREGNABLE),n.xy.eachNeighbor(i,o,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.hasCellFlag(t,i,h.flags.Cell.IS_GATE_SITE)||s.setCellFlag(t,i,h.flags.Cell.IMPREGNABLE))}),!1))}));const o=t.machineNumber;e.forEach(((t,e,r)=>{t&&(i.flags&_t.BP_NO_INTERIOR_FLAG||s.setMachine(e,r,o,i.isRoom),s.isSecretDoor(e,r)&&s.setTile(e,r,c))}))}(t,this)}pickComponents(){const t=[Ot.BF_ALTERNATIVE,Ot.BF_ALTERNATIVE_2],i=new Array(this.steps.length).fill(!0);for(let e=0;e<=1;e++){let s=0;for(let o=0;o<i.length;o++)this.steps[o].flags&t[e]&&(i[o]=!1,s++);if(s>0){let o=n.random.range(1,s);for(let s=0;s<i.length;s++)if(this.steps[s].flags&t[e]){if(1==o){i[s]=!0;break}o--}}}return this.steps.filter(((t,e)=>i[e]))}}function Et(t,i){let e=!0;const s=t.site,o=t.interior;o.fill(0);const r=s.getChokeCount(t.originX,t.originY),h=[-1,-1];let a=r;n.xy.eachNeighbor(t.originX,t.originY,((t,i)=>{const e=s.getChokeCount(t,i);e!=r&&(e>1e4||e<0||(h[0]=t,h[1]=i,a=e))}),!0);const l=a-r;if(i.size.contains(l)){const t=o.floodFill(h[0],h[1],((t,i,o)=>(s.isOccupied(i,o)&&(e=!1),s.getChokeCount(i,o)===a)),1);if(e&&i.size.contains(t))return!0}let c=0;const g=i.size.value(),f=n.grid.alloc(s.width,s.height);y(s,f,t.originX,t.originY,i.size.hi);const u=n.random.sequence(s.width*s.height);e=!0;for(let t=0;t<1e3&&c<g;t++)for(let i=0;i<u.length&&c<g;++i){const n=Math.floor(u[i]/s.height),h=u[i]%s.height;f[n][h]==t&&(s.isOccupied(n,h)&&(e=!1,c=g),s.getChokeCount(n,h)<=r||(o[n][h]=1,c+=1))}return i.treatAsBlocking&&S(s,o,{machine:s.machineCount})?(e=!1,console.debug("- blocks")):i.requireBlocking&&A(s,o)<100&&(e=!1,console.debug("- does not block")),n.grid.free(f),e}function pt(t,i,e){let s=!0;const o=t.interior,r=t.site;o[i][e]=1;const a=r.getChokeCount(i,e);for(let l=0;l<4&&s;l++){const c=i+n.xy.DIRS[l][0],g=e+n.xy.DIRS[l][1];if(r.hasXY(c,g)&&!o[c][g]){if(r.isOccupied(c,g)||r.hasCellFlag(c,g,h.flags.Cell.IS_IN_MACHINE)&&!r.hasCellFlag(c,g,h.flags.Cell.IS_GATE_SITE))return!1;r.getChokeCount(c,g)<=a&&!r.hasCellFlag(c,g,h.flags.Cell.IS_IN_MACHINE)&&(s=pt(t,c,g))}}return s}function mt(t,i=1){let e;const s=t.interior,o=t.site;do{e=!1,s.forEach(((t,r,a)=>{if(o.hasCellFlag(r,a,h.flags.Cell.IS_IN_MACHINE))return;if(!o.blocksPathing(r,a))return;let c=0;n.xy.eachNeighbor(r,a,((t,i)=>{s.hasXY(t,i)&&s[t][i]&&!o.blocksPathing(t,i)&&++c}),!1),c<i||(c=0,n.xy.eachNeighbor(r,a,((t,i)=>{s.hasXY(t,i)&&(s[t][i]||o.isWall(t,i)&&!o.hasCellFlag(t,i,h.flags.Cell.IS_IN_MACHINE)||++c)}),!1),c||(e=!0,s[r][a]=1,o.blocksPathing(r,a)&&o.setTile(r,a,l),n.xy.eachNeighbor(r,a,((t,i)=>{s.hasXY(t,i)&&(o.isSet(t,i)||o.setTile(t,i,f))}))))}))}while(e)}const Tt={};function Rt(t,i){const e=Object.values(Tt).filter((e=>e.qualifies(t,i)));return n.random.item(e)}const Bt=n.flag.fl;var Ot;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=Bt(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=Bt(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=Bt(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=Bt(4)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=Bt(5)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=Bt(6)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=Bt(7)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=Bt(8)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=Bt(9)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=Bt(10)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=Bt(11)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=Bt(12)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=Bt(13)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=Bt(14)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=Bt(15)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=Bt(16)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=Bt(17)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=Bt(18)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=Bt(19)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=Bt(20)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=Bt(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=Bt(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=Bt(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=Bt(24)]="BF_IMPREGNABLE",t[t.BF_NOT_IN_HALLWAY=Bt(27)]="BF_NOT_IN_HALLWAY",t[t.BF_NOT_ON_LEVEL_PERIMETER=Bt(28)]="BF_NOT_ON_LEVEL_PERIMETER",t[t.BF_SKELETON_KEY=Bt(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=Bt(30)]="BF_KEY_DISPOSABLE"}(Ot||(Ot={}));class Lt{constructor(t={}){var i;if(this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.id="n/a",this.tile=null!==(i=t.tile)&&void 0!==i?i:-1,t.flags&&(this.flags=n.flag.from(Ot,t.flags)),t.pad&&(this.pad=t.pad),this.count=n.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.effect&&(this.effect=h.effect.from(t.effect)),this.item&&this.flags&Ot.BF_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BF_ADOPT_ITEM.")}get repeatUntilNoProgress(){return!!(this.flags&Ot.BF_REPEAT_UNTIL_NO_PROGRESS)}get generateEverywhere(){return!!(this.flags&Ot.BF_EVERYWHERE&~Ot.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&Ot.BF_BUILD_AT_ORIGIN)}cellIsCandidate(t,i,e,s,o){return St(t,i,this,e,s,o)}distanceBound(t){return Nt(t,this)}updateViewMap(t){wt(t,this)}build(t,i,e){return yt(t,i,this,e)}}function wt(t,i){if(i.flags&(Ot.BF_IN_VIEW_OF_ORIGIN|Ot.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const e=t.site;if(i.flags&Ot.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new n.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}else{new n.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i)||e.blocksVision(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}t.viewMap[t.originX][t.originY]=1}}function Nt(t,i){const e=[0,1e4];return i.flags&Ot.BF_NEAR_ORIGIN&&(e[1]=t.distance25),i.flags&Ot.BF_FAR_FROM_ORIGIN&&(e[0]=t.distance75),e}function Mt(t,i,e,s,o){let r=0;return t.update(((t,n,h)=>St(i,e,s,n,h,o)?(r++,1):0)),r}function St(t,i,e,s,o,r){const a=t.site;if(e.flags&Ot.BF_NOT_IN_HALLWAY&&n.xy.arcCount(s,o,((t,i)=>a.hasXY(t,i)&&a.isPassable(t,i)))>1)return!1;if(e.flags&Ot.BF_NOT_ON_LEVEL_PERIMETER&&(0==s||s==a.width-1||0==o||o==a.height-1))return!1;if(e.flags&Ot.BF_BUILD_AT_ORIGIN)return s==t.originX&&o==t.originY;if(i.isRoom&&s==t.originX&&o==t.originY)return!1;if(t.occupied[s][o])return!1;if(e.flags&(Ot.BF_IN_VIEW_OF_ORIGIN|Ot.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][o])return!1;let l=1e4;if(a.isWall(s,o)?n.xy.eachNeighbor(s,o,((i,e)=>{t.distanceMap.hasXY(i,e)&&!a.blocksPathing(i,e)&&l>t.distanceMap[i][e]+1&&(l=t.distanceMap[i][e]+1)}),!0):l=t.distanceMap[s][o],l>r[1]||l<r[0])return!1;if(e.flags&Ot.BF_BUILD_IN_WALLS){const i=a.getMachine(s,o);if(!t.interior[s][o]&&(!i||i==t.machineNumber)&&a.isWall(s,o)){let i=!1;return n.xy.eachNeighbor(s,o,((s,o)=>{a.hasXY(s,o)&&(t.interior[s][o]&&(s!=t.originX||o!=t.originY)||e.flags&Ot.BF_BUILD_ANYWHERE_ON_LEVEL&&!a.blocksPathing(s,o)&&!a.getMachine(s,o))&&(i=!0)})),i}return!1}return!a.isWall(s,o)&&(e.flags&Ot.BF_BUILD_ANYWHERE_ON_LEVEL?!(e.item&&a.blocksItems(s,o)||a.hasCellFlag(s,o,h.flags.Cell.IS_CHOKEPOINT|h.flags.Cell.IS_IN_LOOP|h.flags.Cell.IS_IN_MACHINE)):!!t.interior[s][o])}function At(t,i,e,s,o){let r=0;for(let n=i-o+1;n<=i+o-1;n++)for(let i=e-o+1;i<=e+o-1;i++)t.site.hasXY(n,i)&&(s[n][i]&&(s[n][i]=0,++r),t.occupied[n][i]=1);return r}function yt(t,i,e,s){let o=0,r=0;const a=t.site,l=n.grid.alloc(a.width,a.height),c=Nt(t,e);e.updateViewMap(t);let g=Mt(l,t,i,e,c);if(e.generateEverywhere||(o=e.count.value()),!g||g<e.count.lo)return console.log(" - Only %s qualifying tiles - want at least %s.",g,e.count.lo),!1;let f=0,u=0,d=!0,_=!1;do{if(d=!0,e.buildAtOrigin?(f=t.originX,u=t.originY):[f,u]=n.random.matchingLoc(l.width,l.height,((t,i)=>l[t][i]>0)),l[f][u]=0,g--,e.effect&&(d=a.fireEffect(e.effect,f,u),_=d),d&&-1!==e.tile){const t=h.tile.get(e.tile);if(!(e.flags&Ot.BF_PERMIT_BLOCKING)&&(t.blocksMove()||e.flags&Ot.BF_TREAT_AS_BLOCKING)){const t=n.grid.alloc(a.width,a.height);t[f][u]=1,d=!S(a,t,{machine:a.machineCount}),n.grid.free(t)}d&&(d=a.setTile(f,u,t),_=_||d)}if(d&&e.item){const i=a.makeRandomItem(e.item);i||(d=!1),e.flags&Ot.BF_ITEM_IS_KEY&&(i.key=h.entity.makeKeyInfo(f,u,!!(e.flags&Ot.BF_KEY_DISPOSABLE))),e.flags&Ot.BF_OUTSOURCE_ITEM_TO_MACHINE?(d=t.buildRandom(_t.BP_ADOPT_ITEM,-1,-1,i),d&&(_=!0)):(d=a.addItem(f,u,i),_=_||d)}else if(d&&e.flags&Ot.BF_ADOPT_ITEM){if(!s)throw new Error("Failed to build blueprint because there is no adopted item.");if(e.flags&Ot.BF_TREAT_AS_BLOCKING){const t=n.grid.alloc(a.width,a.height);t[f][u]=1,d=!S(a,t),n.grid.free(t)}d&&(d=a.addItem(f,u,s),d?_=!0:console.log("- failed to add item",f,u))}d&&_&&(g-=At(t,f,u,l,e.pad),r++,i.flags&_t.BP_NO_INTERIOR_FLAG||a.setMachine(f,u,t.machineNumber,i.isRoom),e.flags&Ot.BF_IMPREGNABLE&&a.setCellFlag(f,u,h.flags.Cell.IMPREGNABLE))}while(g>0&&(e.generateEverywhere||r<o||e.flags&Ot.BF_REPEAT_UNTIL_NO_PROGRESS));if(d&&e.flags&Ot.BF_BUILD_VESTIBULE){if(d=t.buildRandom(_t.BP_VESTIBULE,t.originX,t.originY),!d)return!1;++r}return d=r>0,n.grid.free(l),d}var bt={__proto__:null,get Flags(){return _t},Blueprint:It,install:function(t,i){return i instanceof It||(i=new It(i)),Tt[t]=i,i.id=t,i},random:Rt,blueprints:Tt,get StepFlags(){return Ot},BuildStep:Lt,updateViewMap:wt,calcDistanceBound:Nt,markCandidates:Mt,cellIsCandidate:St,makePersonalSpace:At,buildStep:yt,Builder:class{constructor(t,i){this.map=t,this.spawnedItems=[],this.spawnedHordes=[],this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.depth=0,this.site=new B(t),this.interior=n.grid.alloc(t.width,t.height),this.occupied=n.grid.alloc(t.width,t.height),this.viewMap=n.grid.alloc(t.width,t.height),this.distanceMap=n.grid.alloc(t.width,t.height),this.depth=i}free(){n.grid.free(this.interior),n.grid.free(this.occupied),n.grid.free(this.viewMap),n.grid.free(this.distanceMap)}buildRandom(t=_t.BP_ROOM,i=-1,e=-1,s=null){let o=[];for(;o.length<10;){const r=Rt(t,this.depth);if(!r)return!1;if(o.push(r.id),this.build(r,i,e,s))return!0}return!1}build(t,i=-1,e=-1,s=null){let o=10;if(this.site.analyze(),i>=0&&e>=0)return this._build(t,i,e,s);for(;o--;){const i=t.pickLocation(this.site);if(i&&this._build(t,i[0],i[1],s))return!0}return!1}_build(t,i,e,s=null){if(this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=i,this.originY=e,!t.computeInterior(this))return!1;const o=this.site.backup();this.machineNumber=this.site.nextMachineId(),t.prepareInterior(this),this.calcDistances(t.size.hi);const r=t.pickComponents();for(let i=0;i<r.length;i++){if(!r[i].build(this,t,s))return this.site.restore(o),!1}return t.noInteriorFlag&&b(this.site,this.machineNumber),!0}calcDistances(t){this.distanceMap.fill(0),y(this.site,this.distanceMap,this.originX,this.originY,t);let i=0;const e=new Array(100).fill(0);this.interior.forEach(((t,s,o)=>{if(!t)return;const r=this.distanceMap[s][o];r<100&&(e[r]++,i++)}));let s=Math.round(i/4),o=Math.round(3*i/4);for(let t=0;t<100;t++){if(s<=e[t]){s=t;break}s-=e[t]}for(let t=0;t<100;t++){if(o<=e[t]){o=t;break}o-=e[t]}this.distance25=s,this.distance75=o}}};t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],n.object.setOptions(this.config,t),this.config.seed&&n.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=n.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const i=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let e=0;e<this.config.levels;++e){const e=n.random.matchingLoc(this.config.width,this.config.height,((e,s)=>n.xy.distanceBetween(t[0],t[1],e,s)>i));this.stairLocs.push([[t[0],t[1]],[e[0],e[1]]]),t=e}}getLevel(t,i){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);n.random.seed(this.seeds[t]);const[e,s]=this.stairLocs[t],o=Object.assign({},this.config.stairs);this.config.goesUp?(o.down=e,o.up=s,0==t&&this.config.startTile&&(o.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.upTile=this.config.endTile)):(o.down=s,o.up=e,0==t&&this.config.startTile&&(o.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.downTile=this.config.endTile));const r=Object.assign({},this.config.rooms);0===t&&r.entrance&&(r.first=r.entrance);const h={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:r,stairs:o,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,h,i)}makeLevel(t,i,e){const s=new ut(i),o=s.create(this.config.width,this.config.height,e);return n.xy.equalsXY(s.endLoc,i.endLoc)&&n.xy.equalsXY(s.startLoc,i.startLoc)||(this.stairLocs[t]=[s.startLoc,s.endLoc]),o}},t.Hall=P,t.Level=ut,t.Room=D,t.blueprint=bt,t.bridge=at,t.hall=ot,t.lake=nt,t.loop=ft,t.room=z,t.site=F,t.stairs=ct,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWU,t.GWM)}(this,(function(t,i,e){"use strict";function s(t){if(t&&t.__esModule)return t;var i=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(i,e,s.get?s:{enumerable:!0,get:function(){return t[e]}})}})),i.default=t,Object.freeze(i)}var n=s(i),o=s(e);const r=n.xy.DIRS;function a(t,i,e){let s,o,a,l,h,c;for(o=n.xy.NO_DIRECTION,s=0;s<4;s++)if(a=i+r[s][0],l=e+r[s][1],h=i-r[s][0],c=e-r[s][1],t.hasXY(h,c)&&t.hasXY(a,l)&&t.isFloor(h,c)){if(o!=n.xy.NO_DIRECTION)return n.xy.NO_DIRECTION;o=s}return o}function l(t){let i,e,s,o,r,l,h;const c=[[],[],[],[]],g=t.height,u=t.width;for(i=0;i<u;i++)for(e=0;e<g;e++)if(t.isDiggable(i,e)&&(l=a(t,i,e),l!=n.xy.NO_DIRECTION)){for(o=i+n.xy.DIRS[l][0],r=e+n.xy.DIRS[l][1],h=!1,s=0;s<10&&t.hasXY(o,r)&&!h;s++)t.isSet(o,r)&&(h=!0),o+=n.xy.DIRS[l][0],r+=n.xy.DIRS[l][1];h||c[l].push([i,e])}let d=[];for(l=0;l<4;l++){const t=n.rng.random.item(c[l])||[-1,-1];d[l]=[t[0],t[1]]}return d}function h(t,i,e=0,s=0){n.xy.forRect(t.width,t.height,((n,o)=>{const r=n-e,a=o-s,l=i.getTileIndex(r,a);l&&t.setTile(n,o,l)}))}function c(t,i){i.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION))}function g(t,i,e,s={}){var o,r,a;if(null!==(o=s.offsetX)&&void 0!==o||(s.offsetX=0),null!==(r=s.offsetY)&&void 0!==r||(s.offsetY=0),null!==(a=s.machine)&&void 0!==a||(s.machine=0),n.xy.arcCount(i,e,((i,e)=>t.isPassable(i,e)))<=1)return!1;const l=n.grid.alloc(t.width,t.height);l[i][e]=1;const h=u(t,l,s);return n.grid.free(l),h}function u(t,i,e={}){var s,o,r;null!==(s=e.offsetX)&&void 0!==s||(e.offsetX=0),null!==(o=e.offsetY)&&void 0!==o||(e.offsetY=0),null!==(r=e.machine)&&void 0!==r||(e.machine=0);const a=n.grid.alloc(t.width,t.height);let l=!1;n.xy.forRect(t.width,t.height,((s,n)=>{const o=s+e.offsetX,r=n+e.offsetY;i.get(o,r)?t.isStairs(s,n)&&(l=!0):!t.isPassable(s,n)||0!=t.getMachine(s,n)&&t.getMachine(s,n)!=e.machine||(a[s][n]=1)}));let h=!0;for(let t=0;t<a.width&&!l;++t)for(let i=0;i<a.height&&!l;++i)1==a[t][i]&&(h?(a.floodFill(t,i,1,2),h=!1):l=!0);return n.grid.free(a),l}function d(t,i,e=0,s=0){const o=n.grid.alloc(t.width,t.height);let r=0;if(n.xy.forRect(t.width,t.height,((n,a)=>{const l=n+e,h=a+s;i.get(l,h)?t.isStairs(n,a)&&(r=t.width*t.height):t.isPassable(n,a)&&(o[n][a]=1)})),r)return r;let a=!0,l=2,h=t.width*t.height;for(let t=0;t<o.width;++t)for(let i=0;i<o.height;++i)if(1==o[t][i]){const e=o.floodFill(t,i,1,l++);h=Math.min(h,e),a?a=!1:r=h}return n.grid.free(o),r}function f(t,i,e,s,o){const r=n.grid.alloc(t.width,t.height);c(t,r),n.path.calculateDistances(i,e,s,r,!1,o+1),n.grid.free(r)}function _(t,i){for(let e=0;e<t.width;e++)for(let s=0;s<t.height;s++)t.getMachine(e,s)!=i||t.hasCellFlag(e,s,o.flags.Cell.IS_WIRED|o.flags.Cell.IS_CIRCUIT_BREAKER)||t.setMachine(e,s,0)}var p,I;const m=o.tile.get("NULL").index,E=o.tile.get("FLOOR").index,B=o.tile.get("DOOR").index,w=null!==(I=null===(p=o.tile.get("DOOR_SECRET"))||void 0===p?void 0:p.index)&&void 0!==I?I:-1,S=o.tile.get("WALL").index,T=o.tile.get("LAKE").index,O=o.tile.get("SHALLOW").index,R=o.tile.get("BRIDGE").index,y=o.tile.get("UP_STAIRS").index,b=o.tile.get("DOWN_STAIRS").index,A=o.tile.get("IMPREGNABLE").index,L={[m]:"NULL",[E]:"FLOOR",[B]:"DOOR",[S]:"WALL",[A]:"IMPREGNABLE",[T]:"LAKE",[O]:"SHALLOW",[R]:"BRIDGE",[y]:"UP_STAIRS",[b]:"DOWN_STAIRS"};class N{constructor(t,i){this.seed=0,this.tiles=n.grid.alloc(t,i),this.doors=n.grid.alloc(t,i)}free(){n.grid.free(this.tiles),n.grid.free(this.doors)}clear(){this.tiles.fill(0),this.doors.fill(0)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return this.tiles.get(t,i)===m}isDiggable(t,i){return this.tiles.get(t,i)===m}isFloor(t,i){return this.tiles.get(t,i)==E}isDoor(t,i){return this.tiles.get(t,i)===B}isSecretDoor(t,i){return this.tiles.get(t,i)===w}isBridge(t,i){return this.tiles.get(t,i)===R}isWall(t,i){const e=this.tiles.get(t,i);return e===S||e===A}blocksMove(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)}blocksDiagonal(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksPathing(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)||this.isStairs(t,i)}blocksVision(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksItems(t,i){return this.blocksPathing(t,i)||this.blocksPathing(t,i)}blocksEffects(t,i){return this.isWall(t,i)}isStairs(t,i){const e=this.tiles.get(t,i);return e===y||e===b}isDeep(t,i){return this.tiles.get(t,i)===T}isShallow(t,i){return this.tiles.get(t,i)===O}isAnyLiquid(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTileIndex(t,i){return this.tiles.get(t,i)||0}setTile(t,i,e){if(e instanceof o.tile.Tile&&(e=e.index),"string"==typeof e){const t=o.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return!!this.tiles.hasXY(t,i)&&(this.tiles[t][i]=e,!0)}hasTile(t,i,e){if(e instanceof o.tile.Tile&&(e=e.index),"string"==typeof e){const t=o.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return this.tiles.hasXY(t,i)&&this.tiles[t][i]==e}getMachine(t,i){return 0}updateDoorDirs(){this.doors.update(((t,i,e)=>a(this,i,e)))}getDoorDir(t,i){return this.doors[t][i]}}const M=o.flags.Cell;class F{constructor(t){this.machineCount=0,this.needsAnalysis=!0,this.map=t,this.doors=n.grid.alloc(t.width,t.height)}get seed(){return this.map.seed}set seed(t){this.map.seed=t}get width(){return this.map.width}get height(){return this.map.height}hasXY(t,i){return this.map.hasXY(t,i)}isBoundaryXY(t,i){return this.map.isBoundaryXY(t,i)}hasCellFlag(t,i,e){return this.map.cellInfo(t,i).hasCellFlag(e)}setCellFlag(t,i,e){this.needsAnalysis=!0,this.map.cell(t,i).setCellFlag(e)}clearCellFlag(t,i,e){this.needsAnalysis=!0,this.map.cell(t,i).clearCellFlag(e)}hasTile(t,i,e){return this.map.cellInfo(t,i).hasTile(e)}setTile(t,i,e,s){return this.needsAnalysis=!0,this.map.setTile(t,i,e,s)}getTileIndex(t,i){if(!this.hasXY(t,i))return 0;return this.map.cell(t,i).highestPriorityTile().index}clear(){this.needsAnalysis=!0,this.map.cells.forEach((t=>t.clear()))}hasItem(t,i){return this.map.cellInfo(t,i).hasItem()}makeRandomItem(t){return o.item.makeRandom(t)}addItem(t,i,e){return this.needsAnalysis=!0,this.map.forceItem(t,i,e)}hasActor(t,i){return this.map.hasActor(t,i)}blocksMove(t,i){return this.map.cellInfo(t,i).blocksMove()}blocksVision(t,i){return this.map.cellInfo(t,i).blocksVision()}blocksDiagonal(t,i){return this.map.cellInfo(t,i).hasEntityFlag(o.flags.Entity.L_BLOCKS_DIAGONAL)}blocksPathing(t,i){const e=this.map.cellInfo(t,i);return e.hasEntityFlag(o.flags.Entity.L_BLOCKS_MOVE)||e.hasTileFlag(o.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,i){return this.map.cellInfo(t,i).hasEntityFlag(o.flags.Entity.L_BLOCKS_ITEMS)}blocksEffects(t,i){return this.map.cellInfo(t,i).hasEntityFlag(o.flags.Entity.L_BLOCKS_EFFECTS)}isWall(t,i){return this.map.cellInfo(t,i).isWall()}isStairs(t,i){return this.map.cellInfo(t,i).isStairs()}isSet(t,i){return this.hasXY(t,i)&&!this.map.cell(t,i).isEmpty()}isDiggable(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.isEmpty()||!!e.isWall()}isNothing(t,i){return this.hasXY(t,i)&&this.map.cell(t,i).isEmpty()}isFloor(t,i){return this.isPassable(t,i)}isBridge(t,i){return this.map.cellInfo(t,i).hasTileFlag(o.tile.flags.Tile.T_BRIDGE)}isDoor(t,i){return this.map.cellInfo(t,i).hasTileFlag(o.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,i){return this.map.cellInfo(t,i).hasEntityFlag(o.flags.Entity.L_SECRETLY_PASSABLE)}isDeep(t,i){return this.map.cellInfo(t,i).hasTileFlag(o.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.depthTile(o.flags.Depth.LIQUID)&&!e.hasTileFlag(o.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return e.hasDepthTile(o.flags.Depth.LIQUID)||e.hasTileFlag(o.tile.flags.Tile.T_IS_DEEP_LIQUID)}isOccupied(t,i){return this.hasItem(t,i)||this.hasActor(t,i)}isPassable(t,i){const e=this.map.cellInfo(t,i);return!(e.blocksMove()||e.blocksPathing())}backup(){const t=new F(this.map.clone());return t.machineCount=this.machineCount,t.needsAnalysis=this.needsAnalysis,t}restore(t){this.map.copy(t.map),this.machineCount=t.machineCount,this.needsAnalysis=t.needsAnalysis}free(){n.grid.free(this.doors)}getChokeCount(t,i){return this.map.cell(t,i).chokeCount}setChokeCount(t,i,e){this.map.cell(t,i).chokeCount=e}analyze(){this.needsAnalysis&&o.map.analyze(this.map),this.needsAnalysis=!1}buildEffect(t,i,e){return this.needsAnalysis=!0,o.effect.fireSync(t,this.map,i,e)}nextMachineId(){return++this.machineCount}getMachine(t,i){return this.map.cell(t,i).machineId}setMachine(t,i,e,s=!0){this.needsAnalysis=!0,this.map.cell(t,i).machineId=e,0==e?this.map.clearCellFlag(t,i,M.IS_IN_MACHINE):this.map.setCellFlag(t,i,s?M.IS_IN_ROOM_MACHINE:M.IS_IN_AREA_MACHINE)}updateDoorDirs(){this.doors.update(((t,i,e)=>a(this,i,e)))}getDoorDir(t,i){return this.doors[t][i]}}var D=Object.freeze({__proto__:null,NOTHING:m,FLOOR:E,DOOR:B,SECRET_DOOR:w,WALL:S,DEEP:T,SHALLOW:O,BRIDGE:R,UP_STAIRS:y,DOWN_STAIRS:b,IMPREGNABLE:A,TILEMAP:L,GridSite:N,MapSite:F,directionOfDoorSite:a,chooseRandomDoorSites:l,copySite:h,fillCostGrid:c,siteDisruptedByXY:g,siteDisruptedBy:u,siteDisruptedSize:d,computeDistanceMap:f,clearInteriorFlag:_});class C extends n.xy.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[]}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}function P(t,i,e,s=1){const o=n.xy.DIRS[i],r=Math.min(t[0],t[0]+o[0]*(e-1)),a=Math.min(t[1],t[1]+o[1]*(e-1)),l=Math.abs(o[0]*e)||s,h=Math.abs(o[1]*e)||s;return new C(r,a,l,h)}class x extends n.xy.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}function k(t,i={}){return t=t||{},i=i||{},Object.entries(i).forEach((([i,e])=>{let s=t[i];if("tile"===i)return void(void 0===s&&(t[i]=e));if(!0===e){if(!s)throw new Error("Missing required config for room digger: "+i)}else s=("number"==typeof e||Array.isArray(e),s||e);const o=n.range.make(s);t[i]=o})),t}class v{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=k(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=l(t))),i}}var Y={};class X extends v{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,i={}){const e=t.choices||i.choices;if(Array.isArray(e))this.randomRoom=n.rng.random.item.bind(n.rng.random,e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=n.rng.random.weighted.bind(n.rng.random,e)}}carve(t){let i=this.randomRoom();const e=Y[i];return e||n.ERROR("Missing room digger choice: "+i),e.create(t)}}class G extends v{constructor(t={}){super(t,{width:12,height:8})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||E,o=n.grid.alloc(t.width,t.height,0),r=Math.floor(.5*i),a=i,l=Math.floor(.5*e),h=e,c=new n.blob.Blob({rounds:5,minWidth:r,minHeight:l,maxWidth:a,maxHeight:h,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(o.width,o.height,((t,i)=>o[t][i]=1)),g=Math.floor((t.width-c.width)/2),u=g-c.x,d=Math.floor((t.height-c.height)/2),f=d-c.y;return o.forEach(((i,e,n)=>{i&&t.setTile(e+u,n+f,s)})),n.grid.free(o),new x(g,d,c.width,c.height)}}class W extends v{constructor(t={}){super(t,{width:20,height:10})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||E,o=Math.floor(.4*i),r=e,a=i,l=Math.floor(.5*e),h=Math.floor(t.width/2-o/2-1),c=t.height-r-2,g=Math.floor(t.width/2-a/2-1),u=t.height-l-2;n.xy.forRect(h,c,o,r,((i,e)=>t.setTile(i,e,s))),n.xy.forRect(g,u,a,l,((i,e)=>t.setTile(i,e,s)));const d=new x(Math.min(h,g),Math.min(c,u),Math.max(o,a),Math.max(r,l));return d.doors[n.xy.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class U extends v{constructor(t={}){super(t,{width:12,height:20})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||E,o=i,r=Math.max(3,Math.floor(i*n.rng.random.range(25,75)/100)),a=Math.max(3,Math.floor(e*n.rng.random.range(25,75)/100)),l=e,h=Math.floor((t.width-o)/2),c=h+n.rng.random.range(2,Math.max(2,o-r-2)),g=Math.floor((t.height-l)/2),u=g+n.rng.random.range(2,Math.max(2,l-a-2));return n.xy.forRect(h,u,o,a,((i,e)=>t.setTile(i,e,s))),n.xy.forRect(c,g,r,l,((i,e)=>t.setTile(i,e,s))),new x(h,g,Math.max(o,r),Math.max(a,l))}}class $ extends v{constructor(t={}){super(t,{width:7,height:7})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||E;let o=Math.max(3,Math.floor(i*n.rng.random.range(25,50)/100)),r=Math.max(3,Math.floor(e*n.rng.random.range(25,50)/100));const a=Math.floor((t.width-i)/2),l=Math.floor((t.height-r)/2);n.xy.forRect(a,l,i,r,((i,e)=>t.setTile(i,e,s)));const h=Math.floor((t.width-o)/2),c=Math.floor((t.height-e)/2);return n.xy.forRect(h,c,o,e,((i,e)=>t.setTile(i,e,s))),new x(Math.min(a,h),Math.min(l,c),Math.max(i,o),Math.max(e,r))}}class H extends v{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||E,o=Math.floor((t.width-i)/2),r=Math.floor((t.height-e)/2);return n.xy.forRect(o,r,i,e,((i,e)=>t.setTile(i,e,s))),new x(o,r,i,e)}}class z extends v{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const i=this.options.radius.value(),e=this.options.tile||E,s=Math.floor(t.width/2),o=Math.floor(t.height/2);return i>1&&n.xy.forCircle(s,o,i,((i,s)=>t.setTile(i,s,e))),new x(s-i,o-i,2*i+1,2*i+1)}}class V extends v{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const i=this.options.radius.value(),e=this.options.ringMinWidth.value(),s=this.options.holeMinSize.value(),o=this.options.tile||E,r=Math.floor(t.width/2),a=Math.floor(t.height/2);return n.xy.forCircle(r,a,i,((i,e)=>t.setTile(i,e,o))),i>e+s&&n.rng.random.chance(this.options.holeChance.value())&&n.xy.forCircle(r,a,n.rng.random.range(s,i-s),((i,e)=>t.setTile(i,e,0))),new x(r-i,a-i,2*i+1,2*i+1)}}class q extends v{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let i,e,s,o=this.options.count.value();const r=this.options.width.value(),a=this.options.height.value(),l=this.options.tile||E,h=Math.floor(t.width/2)-Math.floor(r/2),c=Math.floor(t.width/2)+Math.floor(r/2),g=Math.floor(t.height/2)-Math.floor(a/2),u=Math.floor(t.height/2)+Math.floor(a/2);let d=Math.floor(t.width/2),f=d,_=Math.floor(t.height/2),p=_;for(n.xy.forCircle(d,_,2,((i,e)=>t.setTile(i,e,l))),d-=2,f+=2,_-=2,p+=2,i=0;i<o;)if(e=n.rng.random.range(h,c),s=n.rng.random.range(g,u),t.isSet(e,s)){if(e-2<h)continue;if(e+2>c)continue;if(s-2<g)continue;if(s+2>u)continue;d=Math.min(e-2,d),f=Math.max(e+2,f),_=Math.min(s-2,_),p=Math.max(s+2,p),n.xy.forCircle(e,s,2,((i,e)=>t.setTile(i,e,l))),i++}return new x(d,_,f-d+1,p-_+1)}}function K(t,i){return Y[t]=i,i}K("DEFAULT",new H);var j=Object.freeze({__proto__:null,checkConfig:k,RoomDigger:v,rooms:Y,ChoiceRoom:X,choiceRoom:function(t,i){return new X(t).create(i)},Cavern:G,cavern:function(t,i){return new G(t).create(i)},BrogueEntrance:W,brogueEntrance:function(t,i){return new W(t).create(i)},Cross:U,cross:function(t,i){return new U(t).create(i)},SymmetricalCross:$,symmetricalCross:function(t,i){return new $(t).create(i)},Rectangular:H,rectangular:function(t,i){return new H(t).create(i)},Circular:z,circular:function(t,i){return new z(t).create(i)},BrogueDonut:V,brogueDonut:function(t,i){return new V(t).create(i)},ChunkyRoom:q,chunkyRoom:function(t,i){return new q(t).create(i)},install:K});const Q=n.xy.DIRS;function Z(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function J(t,i){return t==n.xy.UP||t==n.xy.DOWN?i[1].value():i[0].value()}function tt(t,i,e){let s=n.xy.NO_DIRECTION;if(s==n.xy.NO_DIRECTION){const o=n.rng.random.sequence(4);for(let r=0;r<4;r++){s=o[r];const a=e[(r+1)%2].hi,l=i[s];if(l&&-1!=l[0]&&-1!=l[1]){const i=l[0]+Math.floor(Q[s][0]*a),e=l[1]+Math.floor(Q[s][1]*a);if(t.hasXY(i,e))break}s=n.xy.NO_DIRECTION}}return s}function it(t,i,e,s,o){let r,a;const l=n.rng.random.chance(o),h=[];for(let n=0;n<4;n++)r=i+Q[n][0],a=e+Q[n][1],n!=s&&!l||!t.hasXY(r,a)||t.isSet(r,a)||(h[n]=[r,a]);return h}class et{constructor(t={}){this.config={width:n.range.make(1),length:[n.range.make("2-15"),n.range.make("2-9")],tile:E,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=n.range.make(t.width)),t.length&&"number"==typeof t.length){const i=n.range.make(t.length);this.config.length=[i,i]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,i=[]){if(i=i||l(t),!n.rng.random.chance(this.config.chance))return null;const e=tt(t,i,this.config.length);if(e===n.xy.NO_DIRECTION)return null;if(!i[e])return null;const s=this.config.width.value(),o=J(e,this.config.length),r=i[e];return 1==s?this.dig(t,e,r,o):this.digWide(t,e,r,o,s)}_digLine(t,i,e,s){let n=i[0],o=i[1];const r=this.config.tile;for(let i=0;i<s;i++)t.setTile(n,o,r),n+=e[0],o+=e[1];return n-=e[0],o-=e[1],[n,o]}dig(t,i,e,s){const n=Q[i],[o,r]=this._digLine(t,e,n,s),a=P(e,i,s);return a.doors=it(t,o,r,i,this.config.obliqueChance),a}digWide(t,i,e,s,o){const r=n.xy.DIRS[i],a=[e[0]-r[1],e[1]-r[0]],l=[e[0]+r[1],e[1]+r[0]];this._digLine(t,e,r,s);let h=1,c=e[0],g=e[1];h<o&&Z(t,a,r)&&(this._digLine(t,a,r,s),c=Math.min(a[0],c),g=Math.min(a[1],g),++h),h<o&&Z(t,l,r)&&(this._digLine(t,l,r,s),c=Math.min(l[0],c),g=Math.min(l[1],g),++h);const u=P([c,g],i,s,o);return u.doors=[],u.doors[i]=[e[0]+s*r[0],e[1]+s*r[1]],u}}function st(t,i,e){return new et(t).create(i,e)}var nt={};function ot(t,i){return nt[t]=i,i}ot("DEFAULT",new et({chance:15}));var rt=Object.freeze({__proto__:null,isDoorLoc:Z,pickWidth:function(t){return"number"==typeof t&&(t={width:t}),t.width=t.width||1,n.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t)return 1;if("number"==typeof t)return t;if(Array.isArray(t))t=n.rng.random.weighted(t)+1;else if("string"==typeof t)t=n.range.make(t).value();else if(t instanceof n.range.Range)t=t.value();else{const i=t;t=Number.parseInt(n.rng.random.weighted(i))}return t}(t.width),1,3)},pickLength:J,pickHallDirection:tt,pickHallExits:it,HallDigger:et,dig:st,halls:nt,install:ot});class at{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:O,wreathChance:50,wreathSize:1,tile:T},Object.assign(this.options,t)}create(t){let i,e,s,o,r,a,l,h,c,g,u,d=0;a=this.options.height||15,l=this.options.width||30,h=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,u=this.options.canDisrupt||!1;const f=!!n.rng.random.chance(this.options.wreathChance),_=this.options.wreathTile||O,p=this.options.wreathSize||1,I=this.options.tile||T,m=n.grid.alloc(t.width,t.height,0);let E=0;for(;E<g&&d<g;){const B=Math.round((l-h)*(g-E)/g)+h,w=Math.round((a-h)*(g-E)/g)+h,S=new n.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:B,maxHeight:w,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(m.width,m.height,((t,i)=>m[t][i]=1));let T=!1;for(s=0;s<c&&!T;s++)if(o=n.rng.random.range(1-S.x,m.width-S.width-S.x-2),r=n.rng.random.range(1-S.y,m.height-S.height-S.y-2),u||!this.isDisruptedBy(t,m,-o,-r)){for(T=!0,i=0;i<S.width;i++)for(e=0;e<S.height;e++)if(m[i+S.x][e+S.y]){const s=i+S.x+o,a=e+S.y+r;t.setTile(s,a,I),f&&n.xy.forCircle(s,a,p,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,_)}))}break}T?++d:++E}return n.grid.free(m),d}isDisruptedBy(t,i,e=0,s=0){const o=n.grid.alloc(t.width,t.height);let r=!1;n.xy.forRect(t.width,t.height,((n,a)=>{const l=n+e,h=a+s;i.get(l,h)?t.isStairs(n,a)&&(r=!0):t.isPassable(n,a)&&(o[n][a]=1)}));let a=!0;for(let t=0;t<o.width&&!r;++t)for(let i=0;i<o.height&&!r;++i)1==o[t][i]&&(a?(o.floodFill(t,i,1,2),a=!1):r=!0);return n.grid.free(o),r}}var lt=Object.freeze({__proto__:null,Lakes:at});class ht{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let i,e,s,o,r,a,l,h=0;const c=this.options.maxLength,g=this.options.minDistance,u=n.grid.alloc(t.width,t.height),d=n.grid.alloc(t.width,t.height),f=[[1,0],[0,1]];d.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION));const _=n.rng.random.sequence(t.width*t.height);for(s=0;s<_.length;s++)if(a=Math.floor(_[s]/t.height),l=_[s]%t.height,t.isPassable(a,l)&&!t.isAnyLiquid(a,l))for(r=0;r<=1;r++){const s=f[r];if(i=a+s[0],e=l+s[1],o=c,t.isAnyLiquid(i,e))for(o=0;o<c&&(i+=s[0],e+=s[1],t.isAnyLiquid(i,e));++o);if(t.isPassable(i,e)&&o<c&&(n.path.calculateDistances(u,i,e,d,!1),u[a][l]>g&&u[a][l]<n.path.NO_PATH)){for(;a!==i||l!==e;)this.isBridgeCandidate(t,a,l,s)?(t.setTile(a,l,R),d[a][l]=1):(t.setTile(a,l,E),d[a][l]=1),a+=s[0],l+=s[1];++h;break}}return n.grid.free(u),n.grid.free(d),h}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyLiquid(i,e)&&(!!t.isAnyLiquid(i+s[1],e+s[0])&&!!t.isAnyLiquid(i-s[1],e-s[0]))}}var ct=Object.freeze({__proto__:null,Bridges:ht});class gt{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:y,downTile:b,wall:A},Object.assign(this.options,t)}create(t){let i=!1!==this.options.up,e=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),o={};let r=null,a=null;const l=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let i=this.options.start;i=!0===i?n.rng.random.matchingLoc(t.width,t.height,l):n.rng.random.matchingLocNear(n.xy.x(i),n.xy.y(i),l),o.start=i}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;r=n.rng.random.matchingLocNear(n.xy.x(t),n.xy.y(t),l);const i=this.options.down;a=n.rng.random.matchingLocNear(n.xy.x(i),n.xy.y(i),l)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const i=this.options.up;r=n.rng.random.matchingLocNear(n.xy.x(i),n.xy.y(i),l),e&&(a=n.rng.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,r[0],r[1])<s)&&l(t,i))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;a=n.rng.random.matchingLocNear(n.xy.x(e),n.xy.y(e),l),i&&(r=n.rng.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,a[0],a[1])<s)&&l(t,i))))}else i?(r=n.rng.random.matchingLoc(t.width,t.height,l),e&&(a=n.rng.random.matchingLoc(t.width,t.height,((t,i)=>!(n.xy.distanceBetween(t,i,r[0],r[1])<s)&&l(t,i))))):e&&(a=n.rng.random.matchingLoc(t.width,t.height,l));return r&&(o.up=r.slice(),this.setupStairs(t,r[0],r[1],this.options.upTile),"up"===this.options.start&&(o.start=o.up)),a&&(o.down=a.slice(),this.setupStairs(t,a[0],a[1],this.options.downTile),"down"===this.options.start&&(o.start=o.down)),r||a?o:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,i,e){let s=0;if(!this.hasXY(t,i,e)||!t.isDiggable(i,e))return!1;for(let o=0;o<4;++o){const r=n.xy.DIRS[o];if(!this.hasXY(t,i+r[0],e+r[1]))return!1;if(!this.hasXY(t,i-r[0],e-r[1]))return!1;if(t.isFloor(i+r[0],e+r[1])){if(s+=1,!t.isDiggable(i-r[0]+r[1],e-r[1]+r[0]))return!1;if(!t.isDiggable(i-r[0]-r[1],e-r[1]-r[0]))return!1}else if(!t.isDiggable(i+r[0],e+r[1]))return!1}return 1==s}setupStairs(t,i,e,s){const o=n.rng.random.sequence(4);let r=null;for(let s=0;s<o.length;++s){r=n.xy.DIRS[s];const o=i+r[0],a=e+r[1];if(t.isFloor(o,a)&&t.isDiggable(i-r[0],e-r[1]))break;r=null}r||n.ERROR("No stair direction found!"),t.setTile(i,e,s);const a=n.xy.CLOCK_DIRS.findIndex((t=>t[0]==r[0]&&t[1]==r[1])),l=this.options.wall;for(let s=0;s<n.xy.CLOCK_DIRS.length;++s){const o=s?s-1:7,r=(s+1)%8;if(s==a||o==a||r==a)continue;const h=n.xy.CLOCK_DIRS[s];t.setTile(i+h[0],e+h[1],l)}return!0}}var ut=Object.freeze({__proto__:null,Stairs:gt});class dt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},Object.assign(this.options,t)}create(t){let i,e,s,o,r,a,l,h,g;const u=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,f=n.grid.alloc(t.width,t.height),_=n.grid.alloc(t.width,t.height),p=[[1,0],[0,1]];function I(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function m(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}c(t,_);let w=0;const S=n.rng.random.sequence(t.width*t.height);for(r=0;r<S.length;r++)if(h=Math.floor(S[r]/t.height),g=S[r]%t.height,!t.isSet(h,g))for(l=0;l<=1;l++){let r=p[l];if(I(h,g,r)){if(a=d,t.hasXY(h+r[0],g+r[1])&&t.isPassable(h+r[0],g+r[1])){if(!t.hasXY(h-r[0],g-r[1])||t.isDoor(h-r[0],g-r[1]))continue}else{if(!t.hasXY(h-r[0],g-r[1])||!t.isPassable(h-r[0],g-r[1]))continue;if(!t.hasXY(h+r[0],g+r[1])||t.isDoor(h+r[0],g+r[1]))continue;r=r.map((t=>-1*t))}for(i=h+r[0],e=g+r[1],s=h,o=g,a=0;a<d&&(s-=r[0],o-=r[1],!m(s,o,r));++a);if(a<d&&(n.path.calculateDistances(f,i,e,_,!1),f[s][o]>u&&f[s][o]<3e4)){for(;s!==i||o!==e;)t.isNothing(s,o)&&(t.setTile(s,o,E),_[s][o]=1),s+=r[0],o+=r[1];const a=n.rng.random.chance(this.options.doorChance)?B:E;t.setTile(h,g,a),++w;break}}}return n.grid.free(f),n.grid.free(_),w}}var ft=Object.freeze({__proto__:null,LoopDigger:dt,digLoops:function(t,i={}){return new dt(i).create(t)}});class _t{constructor(t={}){var i,e;this.seed=0,this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.seed=t.seed||n.rng.random.number(),n.object.setOptions(this.rooms,t.rooms),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),n.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),n.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),t.loops=t.loops||{},t.loops.doorChance=null!==(i=t.loops.doorChance)&&void 0!==i?i:null===(e=t.doors)||void 0===e?void 0:e.chance,n.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),n.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:(!0===t.bridges&&(t.bridges={}),n.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:(!0===t.stairs&&(t.stairs={}),n.object.setOptions(this.stairs,t.stairs)),this.startLoc=t.startLoc||[-1,-1],this.endLoc=t.endLoc||[-1,-1]}_makeSite(t,i){return new N(t,i)}create(...t){if(1==t.length&&t[0]instanceof o.map.Map){const i=t[0];this.site=new F(i)}if(t.length>1){const i=t[0],e=t[1];this.site=new N(i,e)}const i=this._create(this.site);if(t.length>1){const i=t[0],e=t[1],s=t[2];n.xy.forRect(i,e,((t,i)=>{const e=this.site.getTileIndex(t,i);e&&s(t,i,e)}))}return this.site.free(),i}_create(t){this.startLoc[0]<0&&this.startLoc[0]<0&&(this.startLoc[0]=Math.floor(t.width/2),this.startLoc[1]=t.height-2),this.start(t);let i=20;for(;--i&&!this.addFirstRoom(t););if(!i)throw new Error("Failed to place first room!");t.updateDoorDirs();let e=0;for(;e<20;)this.addRoom(t)?(e=0,t.updateDoorDirs(),n.rng.random.shuffle(this.seq)):++e;return this.loops&&this.addLoops(t,this.loops),this.lakes&&this.addLakes(t,this.lakes),this.bridges&&this.addBridges(t,this.bridges),this.stairs&&this.addStairs(t,this.stairs),this.finish(t),!0}start(t){this.seed&&(n.rng.random.seed(this.seed),t.seed=this.seed),t.clear(),this.seq=n.rng.random.sequence(t.width*t.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof v)return t;if("string"==typeof t){const i=Y[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new X(t)}addFirstRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return e&&!this._attachRoomAtLoc(t,i,e,this.startLoc)&&(e=null),i.free(),e}addRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(this.halls.chance){let t=st(this.halls,i,e.doors);t&&(e.hall=t)}return e&&!this._attachRoom(t,i,e)&&(e=null),i.free(),e}_attachRoom(t,i,e){const s=e.hall?e.hall.doors:e.doors;let o=0;const r=this.seq.length;for(o=0;o<r;o++){const r=Math.floor(this.seq[o]/t.height),a=this.seq[o]%t.height,l=t.getDoorDir(r,a);if(l!=n.xy.NO_DIRECTION){const n=(l+2)%4,o=s[n];if(!o)continue;const c=r-o[0],g=a-o[1];if(-1!=o[0]&&this._roomFitsAt(t,i,e,c,g))return h(t,i,c,g),this._attachDoor(t,e,r,a,n),e.translate(c,g),!0}}return!1}_attachRoomAtLoc(t,i,e,s){const[o,r]=s,a=e.hall?e.hall.doors:e.doors,l=n.rng.random.sequence(4);for(let s of l){const n=a[(s+2)%4];if(!n||-1==n[0])continue;const l=o-n[0],c=r-n[1];if(this._roomFitsAt(t,i,e,l,c))return h(t,i,l,c),e.translate(l,c),!0}return!1}_roomFitsAt(t,i,e,s,n){let o,r,a,l,h,c;const g=e.hall||e,u=Math.min(e.left,g.left),d=Math.min(e.top,g.top),f=Math.max(e.right,g.right),_=Math.max(e.bottom,g.bottom);for(o=u;o<=f;o++)for(r=d;r<=_;r++)if(i.isSet(o,r)){if(a=o+s,l=r+n,!t.hasXY(a,l)||t.isBoundaryXY(a,l))return!1;for(h=a-1;h<=a+1;h++)for(c=l-1;c<=l+1;c++)if(!t.isNothing(h,c))return!1}return!0}_attachDoor(t,i,e,s,o){const r=this.doors;let a=!1;r.chance&&n.rng.random.chance(r.chance)&&(a=!0);const l=a?r.tile||B:E;if(t.setTile(e,s,l),i.hall&&1!=i.hall.width&&1!=i.hall.height)if(o===n.xy.UP||o===n.xy.DOWN){let i=!0,n=1;for(;i;)i=!1,t.isNothing(e-n,s)&&t.isSet(e-n,s-1)&&t.isSet(e-n,s+1)&&(t.setTile(e-n,s,l),i=!0),t.isNothing(e+n,s)&&t.isSet(e+n,s-1)&&t.isSet(e+n,s+1)&&(t.setTile(e+n,s,l),i=!0),++n}else{let i=!0,n=1;for(;i;)i=!1,t.isNothing(e,s-n)&&t.isSet(e-1,s-n)&&t.isSet(e+1,s-n)&&(t.setTile(e,s-n,l),i=!0),t.isNothing(e,s+n)&&t.isSet(e-1,s+n)&&t.isSet(e+1,s+n)&&(t.setTile(e,s+n,l),i=!0),++n}}addLoops(t,i){return new dt(i).create(t)}addLakes(t,i){return new at(i).create(t)}addBridges(t,i){return new ht(i).create(t)}addStairs(t,i){return new gt(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let i,e,s,o,r,a;do{for(a=!1,i=0;i<t.width-1;i++)for(e=0;e<t.height-1;e++)for(s=0;s<=1;s++)!t.blocksMove(i+s,e)&&t.blocksMove(i+(1-s),e)&&t.blocksDiagonal(i+(1-s),e)&&t.blocksMove(i+s,e+1)&&t.blocksDiagonal(i+s,e+1)&&!t.blocksMove(i+(1-s),e+1)&&(n.rng.random.chance(50)?(o=i+(1-s),r=e):(o=i+s,r=e+1),a=!0,t.setTile(o,r,E))}while(1==a)}_finishDoors(t){n.xy.forRect(t.width,t.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.blocksPathing(i+1,e)?1:0)+(t.blocksPathing(i-1,e)?1:0)+(t.blocksPathing(i,e+1)?1:0)+(t.blocksPathing(i,e-1)?1:0)>=3)&&t.setTile(i,e,E)}))}_finishWalls(t){const i=this.boundary?A:S;n.xy.forRect(t.width,t.height,((e,s)=>{t.isNothing(e,s)&&(t.isBoundaryXY(e,s)?t.setTile(e,s,i):t.setTile(e,s,S))}))}}class pt{constructor(t,i){this.map=t,this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.depth=0,this.site=new F(t),this.interior=n.grid.alloc(t.width,t.height),this.occupied=n.grid.alloc(t.width,t.height),this.viewMap=n.grid.alloc(t.width,t.height),this.distanceMap=n.grid.alloc(t.width,t.height),this.candidates=n.grid.alloc(t.width,t.height),this.depth=i}free(){n.grid.free(this.interior),n.grid.free(this.occupied),n.grid.free(this.viewMap),n.grid.free(this.distanceMap),n.grid.free(this.candidates)}reset(t,i){this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=t,this.originY=i,this.distance25=0,this.distance75=0}calcDistances(t){this.distanceMap.fill(0),f(this.site,this.distanceMap,this.originX,this.originY,t);let i=0;const e=new Array(100).fill(0);this.interior.forEach(((t,s,n)=>{if(!t)return;const o=this.distanceMap[s][n];o<100&&(e[o]++,i++)}));let s=Math.round(i/4),n=Math.round(3*i/4);for(let t=0;t<100;t++){if(s<=e[t]){s=t;break}s-=e[t]}for(let t=0;t<100;t++){if(n<=e[t]){n=t;break}n-=e[t]}this.distance25=s,this.distance75=n}}class It{async onError(){}async onBlueprintPick(){}async onBlueprintCandidates(){}async onBlueprintStart(){}async onBlueprintInterior(){}async onBlueprintFail(){}async onBlueprintSuccess(){}async onStepStart(){}async onStepCandidates(){}async onStepInstanceSuccess(){}async onStepInstanceFail(){}async onStepSuccess(){}async onStepFail(){}}const mt=n.flag.fl;var Et;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=mt(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=mt(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=mt(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=mt(4)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=mt(5)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=mt(6)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=mt(7)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=mt(8)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=mt(9)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=mt(10)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=mt(11)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=mt(12)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=mt(13)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=mt(14)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=mt(15)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=mt(16)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=mt(17)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=mt(18)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=mt(19)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=mt(20)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=mt(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=mt(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=mt(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=mt(24)]="BF_IMPREGNABLE",t[t.BF_NOT_IN_HALLWAY=mt(27)]="BF_NOT_IN_HALLWAY",t[t.BF_ALLOW_BOUNDARY=mt(28)]="BF_ALLOW_BOUNDARY",t[t.BF_SKELETON_KEY=mt(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=mt(30)]="BF_KEY_DISPOSABLE"}(Et||(Et={}));class Bt{constructor(t={}){var i;if(this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.id="n/a",this.tile=null!==(i=t.tile)&&void 0!==i?i:-1,t.flags&&(this.flags=n.flag.from(Et,t.flags)),t.pad&&(this.pad=t.pad),this.count=n.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.effect&&(this.effect=o.effect.from(t.effect)),this.item&&this.flags&Et.BF_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BF_ADOPT_ITEM.");if(this.buildAtOrigin&&this.count.hi>1)throw new Error("Cannot have count > 1 for step with BF_BUILD_AT_ORIGIN.")}get allowBoundary(){return!!(this.flags&Et.BF_ALLOW_BOUNDARY)}get notInHallway(){return!!(this.flags&Et.BF_NOT_IN_HALLWAY)}get buildInWalls(){return!!(this.flags&Et.BF_BUILD_IN_WALLS)}get buildAnywhere(){return!!(this.flags&Et.BF_BUILD_ANYWHERE_ON_LEVEL)}get repeatUntilNoProgress(){return!!(this.flags&Et.BF_REPEAT_UNTIL_NO_PROGRESS)}get permitBlocking(){return!!(this.flags&Et.BF_PERMIT_BLOCKING)}get treatAsBlocking(){return!!(this.flags&Et.BF_TREAT_AS_BLOCKING)}get adoptItem(){return!!(this.flags&Et.BF_ADOPT_ITEM)}get itemIsKey(){return!!(this.flags&Et.BF_ITEM_IS_KEY)}get keyIsDisposable(){return!!(this.flags&Et.BF_KEY_DISPOSABLE)}get outsourceItem(){return!!(this.flags&Et.BF_OUTSOURCE_ITEM_TO_MACHINE)}get impregnable(){return!!(this.flags&Et.BF_IMPREGNABLE)}get buildVestibule(){return!!(this.flags&Et.BF_BUILD_VESTIBULE)}get generateEverywhere(){return!!(this.flags&Et.BF_EVERYWHERE&~Et.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&Et.BF_BUILD_AT_ORIGIN)}get buildsInstances(){return!!(this.effect||-1!=this.tile||this.item||this.horde||this.adoptItem)}markCandidates(t,i,e,s=[0,1e4]){wt(t,this);let n=0;return e.update(((e,o,r)=>Tt(t,i,this,o,r,s)?(n++,1):0)),n}}function wt(t,i){if(i.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const e=t.site;if(i.flags&Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new n.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}else{new n.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i)||e.blocksVision(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}t.viewMap[t.originX][t.originY]=1}}function St(t,i){const e=[0,1e4];return i.flags&Et.BF_NEAR_ORIGIN&&(e[1]=t.distance25),i.flags&Et.BF_FAR_FROM_ORIGIN&&(e[0]=t.distance75),e}function Tt(t,i,e,s,r,a){const l=t.site;if(e.notInHallway&&n.xy.arcCount(s,r,((t,i)=>l.hasXY(t,i)&&l.isPassable(t,i)))>1)return!1;if((0==s||s==l.width-1||0==r||r==l.height-1)&&!e.allowBoundary)return!1;if(e.buildAtOrigin)return s==t.originX&&r==t.originY;if(i.isRoom&&s==t.originX&&r==t.originY)return!1;if(t.occupied[s][r])return!1;if(e.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][r])return!1;let h=1e4;if(l.isWall(s,r)?n.xy.eachNeighbor(s,r,((i,e)=>{t.distanceMap.hasXY(i,e)&&!l.blocksPathing(i,e)&&h>t.distanceMap[i][e]+1&&(h=t.distanceMap[i][e]+1)}),!0):h=t.distanceMap[s][r],h>a[1]||h<a[0])return!1;if(e.buildInWalls){const i=l.getMachine(s,r);if(!t.interior[s][r]&&(!i||i==t.machineNumber)&&l.isWall(s,r)){let i=!1;return n.xy.eachNeighbor(s,r,((s,n)=>{l.hasXY(s,n)&&(t.interior[s][n]||e.buildAnywhere)&&(!e.buildAnywhere||l.blocksPathing(s,n)||l.getMachine(s,n)||s==t.originX&&n==t.originY||(i=!0))}),!0),i}return!1}return!l.isWall(s,r)&&(e.buildAnywhere?!(e.item&&l.blocksItems(s,r)||l.hasCellFlag(s,r,o.flags.Cell.IS_CHOKEPOINT|o.flags.Cell.IS_IN_LOOP|o.flags.Cell.IS_IN_MACHINE)):!!t.interior[s][r])}function Ot(t,i,e,s,n){let o=0;for(let r=i-n+1;r<=i+n-1;r++)for(let i=e-n+1;i<=e+n-1;i++)t.site.hasXY(r,i)&&(s[r][i]&&(s[r][i]=0,++o),t.occupied[r][i]=1);return o}const Rt=n.flag.fl;var yt;!function(t){t[t.BP_ROOM=Rt(0)]="BP_ROOM",t[t.BP_VESTIBULE=Rt(1)]="BP_VESTIBULE",t[t.BP_REWARD=Rt(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=Rt(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=Rt(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=Rt(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=Rt(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=Rt(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=Rt(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=Rt(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=Rt(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=Rt(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=Rt(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=Rt(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=Rt(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=Rt(15)]="BP_NOT_IN_HALLWAY"}(yt||(yt={}));class bt{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=n.frequency.make(t.frequency||100),t.size?(this.size=n.range.make(t.size),this.size.lo<=0&&(this.size.lo=1),this.size.hi<this.size.lo&&(this.size.hi=this.size.lo)):this.size=n.range.make([1,1]),t.flags&&(this.flags=n.flag.from(yt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new Bt(t)))),this.flags&yt.BP_ADOPT_ITEM&&!this.steps.some((t=>t.flags&Et.BF_ADOPT_ITEM)))throw new Error("Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.")}get isRoom(){return!!(this.flags&yt.BP_ROOM)}get isReward(){return!!(this.flags&yt.BP_REWARD)}get isVestiblue(){return!!(this.flags&yt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&yt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&yt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&yt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&yt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&yt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&yt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&yt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&yt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&yt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&yt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&yt.BP_NO_INTERIOR_FLAG)}get notInHallway(){return!!(this.flags&yt.BP_NOT_IN_HALLWAY)}qualifies(t,i){return!(i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t)))))&&!(~this.flags&t||this.flags&yt.BP_ADOPT_ITEM&~t||this.flags&yt.BP_VESTIBULE&~t)}pickComponents(){const t=[Et.BF_ALTERNATIVE,Et.BF_ALTERNATIVE_2],i=new Array(this.steps.length).fill(!0);for(let e=0;e<=1;e++){let s=0;for(let n=0;n<i.length;n++)this.steps[n].flags&t[e]&&(i[n]=!1,s++);if(s>0){let o=n.rng.random.range(1,s);for(let s=0;s<i.length;s++)if(this.steps[s].flags&t[e]){if(1==o){i[s]=!0;break}o--}}}return this.steps.filter(((t,e)=>i[e]))}fillInterior(t){const i=t.interior,e=t.site;if(i.fill(0),this.isRoom)return Lt(t,t.originX,t.originY);if(this.isVestiblue)return function(t,i){let e=!0;const s=t.site,o=t.interior;if(o.fill(0),1==i.size.hi)return o[t.originX][t.originY]=1,1;const r=s.getChokeCount(t.originX,t.originY);if(r>1e4)return 0;const a=[-1,-1];let l=r;n.xy.eachNeighbor(t.originX,t.originY,((t,i)=>{const e=s.getChokeCount(t,i);e!=r&&(e>1e4||e<0||(a[0]=t,a[1]=i,l=e))}),!0);const h=l-r;if(i.size.contains(h)){const t=o.floodFill(a[0],a[1],((t,i,n)=>(s.isOccupied(i,n)&&(e=!1),s.getChokeCount(i,n)===l)),1);if(e&&i.size.contains(t))return h}let c=0;const g=i.size.value(),u=t.distanceMap;f(s,u,t.originX,t.originY,i.size.hi);const d=n.rng.random.sequence(s.width*s.height);e=!0;for(let t=0;t<1e3&&c<g;t++)for(let i=0;i<d.length&&c<g;++i){const n=Math.floor(d[i]/s.height),a=d[i]%s.height;u[n][a]==t&&(s.isOccupied(n,a)&&(e=!1,c=g),s.getChokeCount(n,a)<=r||(o[n][a]=1,c+=1))}return c}(t,this);{let s=t.distanceMap;f(e,s,t.originX,t.originY,this.size.hi);const r=n.rng.random.sequence(e.width*e.height);let a=0,l=this.size.value();for(let t=0;t<1e3&&a<l;t++)for(let n=0;n<r.length&&a<l;n++){const l=Math.floor(r[n]/e.height),h=r[n]%e.height;if(s[l][h]==t&&(i[l][h]=1,a++,e.isOccupied(l,h)||e.hasCellFlag(l,h,o.flags.Cell.IS_IN_MACHINE)))return 0}return a}}}function At(t,i){const e=t.site,s=t.candidates,o=n.rng.random.matchingLoc(e.width,e.height,((t,i)=>1==s[t][i]));return!o||o[0]<0||o[1]<0?null:o}function Lt(t,i,e){const s=t.interior,r=t.site;let a=1;s[i][e]=1;const l=r.getChokeCount(i,e);for(let h=0;h<4;h++){const c=i+n.xy.DIRS[h][0],g=e+n.xy.DIRS[h][1];if(r.hasXY(c,g)&&!s[c][g]){if(r.isOccupied(c,g)||r.hasCellFlag(c,g,o.flags.Cell.IS_IN_MACHINE)&&!r.hasCellFlag(c,g,o.flags.Cell.IS_GATE_SITE))return 0;if(r.getChokeCount(c,g)<=l&&!r.hasCellFlag(c,g,o.flags.Cell.IS_IN_MACHINE)){let i=Lt(t,c,g);if(i<=0)return 0;a+=i}}}return a}function Nt(t,i=1){let e;const s=t.interior,r=t.site;do{e=!1,s.forEach(((t,a,l)=>{if(r.hasCellFlag(a,l,o.flags.Cell.IS_IN_MACHINE))return;if(!r.blocksPathing(a,l))return;let h=0;n.xy.eachNeighbor(a,l,((t,i)=>{s.hasXY(t,i)&&s[t][i]&&!r.blocksPathing(t,i)&&++h}),!1),h<i||(h=0,n.xy.eachNeighbor(a,l,((t,i)=>{s.hasXY(t,i)&&(s[t][i]||r.isWall(t,i)&&!r.hasCellFlag(t,i,o.flags.Cell.IS_IN_MACHINE)||++h)}),!1),h||(e=!0,s[a][l]=1,r.blocksPathing(a,l)&&r.setTile(a,l,E),n.xy.eachNeighbor(a,l,((t,i)=>{s.hasXY(t,i)&&(r.isSet(t,i)||r.setTile(t,i,S))}))))}))}while(e)}const Mt={};class Ft{async onError(t,i){console.log(`onBuildError - error: ${i}`)}async onBlueprintPick(t,i,e,s){console.log(`onBlueprintPick - ${i.id}, depth = ${s}, matchingFlags = ${n.flag.toString(yt,e)}`)}async onBlueprintCandidates(t,i){const e=`onBlueprintCandidates - ${i.id}`;console.group(e),t.candidates.dump(),console.groupEnd()}async onBlueprintStart(t,i){console.log(`onBlueprintStart - ${i.id} @ ${t.originX},${t.originY} : stepCount: ${i.steps.length}, size: [${i.size.toString()}], flags: ${n.flag.toString(yt,i.flags)}`)}async onBlueprintInterior(t,i){console.log(`onBlueprintInterior - ${i.id}`),t.interior.dump()}async onBlueprintFail(t,i,e){console.log(`onBlueprintFail - ${i.id} @ ${t.originX},${t.originY} : error: ${e}`)}async onBlueprintSuccess(t,i){console.log(`onBlueprintSuccess - ${i.id} @ ${t.originX},${t.originY}`)}async onStepStart(t,i,e){console.log(`onStepStart - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${n.flag.toString(Et,e.flags)}`)}async onStepCandidates(t,i,e,s,n){const o=s.count((t=>1==t));console.log(`onStepCandidates - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : wantCount: ${n}, have: ${o}`),s.dump()}async onStepInstanceSuccess(t,i,e,s,n){console.log(`onStepInstance @ ${s},${n}`)}async onStepInstanceFail(t,i,e,s,n,o){console.log(`onStepInstanceFail @ ${s},${n} - error: ${o}`)}async onStepSuccess(t,i,e){console.log(`onStepSuccess - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${n.flag.toString(Et,e.flags)}`)}async onStepFail(t,i,e,s){console.log(`onStepFail - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : error : ${s}`)}}var Dt=Object.freeze({__proto__:null,get Flags(){return yt},Blueprint:bt,install:function(t,i){return i instanceof bt||(i=new bt(i)),Mt[t]=i,i.id=t,i},random:function(t,i){const e=Object.values(Mt).filter((e=>e.qualifies(t)&&e.frequency(i)));return n.rng.random.item(e)},blueprints:Mt,BuildData:pt,NullLogger:It,get StepFlags(){return Et},BuildStep:Bt,updateViewMap:wt,calcDistanceBound:St,cellIsCandidate:Tt,makePersonalSpace:Ot,Builder:class{constructor(t,i={}){this.data=new pt(t,i.depth||1),i.blueprints?(Array.isArray(i.blueprints)||(i.blueprints=Object.values(i.blueprints)),this.blueprints=i.blueprints.map((t=>{return(i=t)instanceof bt?i:Mt[i];var i}))):this.blueprints=Object.values(Mt),!0===i.log?this.log=new Ft:this.log=i.log||new It}_pickRandom(t){const i=this.blueprints.map((i=>i.qualifies(t)?i.frequency(this.data.depth):0)),e=n.rng.random.weighted(i);return this.blueprints[e]||null}async buildRandom(t=yt.BP_ROOM,i=-1,e=-1,s=null){const o=this.data;o.site.analyze();let r=0;for(;r<10;){const a=this._pickRandom(t);if(!a)return await this.log.onError(o,`Failed to find matching blueprint: requiredMachineFlags : ${n.flag.toString(yt,t)}, depth: ${o.depth}`),!1;if(await this.log.onBlueprintPick(o,a,t,o.depth),await this._buildAt(a,i,e,s))return!0;++r}return!1}async build(t,i=-1,e=-1,s=null){const n=this.data;if("string"==typeof t){const i=t;if(!(t=Mt[i]))throw new Error("Failed to find blueprint - "+i)}return n.site.analyze(),await this._buildAt(t,i,e,s)}async _buildAt(t,i=-1,e=-1,s=null){const n=this.data;if(i>=0&&e>=0)return await this._build(t,i,e,s);let o=await this._markCandidates(t);if(!o)return!1;let r=20;for(;o--&&r--;){const i=At(n)||!1;if(i&&await this._build(t,i[0],i[1],s))return!0}return await this.log.onBlueprintFail(n,t,"No suitable locations found to build blueprint."),!1}async _build(t,i,e,s=null){const r=this.data;if(r.reset(i,e),await this.log.onBlueprintStart(r,t,s),!await this._computeInterior(t))return!1;const a=r.site.backup();r.machineNumber=r.site.nextMachineId(),function(t,i){const e=t.interior,s=t.site;i.maximizeInterior?Nt(t,1):i.openInterior&&Nt(t,4),i.purgeInterior&&e.forEach(((t,i,e)=>{t&&s.setTile(i,e,E)})),i.purgeBlockers&&e.forEach(((t,i,e)=>{t&&s.blocksPathing(i,e)&&s.setTile(i,e,E)})),i.purgeLiquids&&e.forEach(((t,i,e)=>{t&&s.isAnyLiquid(i,e)&&s.setTile(i,e,E)})),i.surroundWithWalls&&e.forEach(((t,i,r)=>{t&&!s.hasCellFlag(i,r,o.flags.Cell.IS_GATE_SITE)&&n.xy.eachNeighbor(i,r,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.isWall(t,i)||s.hasCellFlag(t,i,o.flags.Cell.IS_GATE_SITE)||s.hasCellFlag(t,i,o.flags.Cell.IS_IN_MACHINE)||s.blocksPathing(t,i)&&s.setTile(t,i,S))}),!1)})),i.makeImpregnable&&e.forEach(((t,i,r)=>{t&&!s.hasCellFlag(i,r,o.flags.Cell.IS_GATE_SITE)&&(s.setCellFlag(i,r,o.flags.Cell.IMPREGNABLE),n.xy.eachNeighbor(i,r,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.hasCellFlag(t,i,o.flags.Cell.IS_GATE_SITE)||s.setCellFlag(t,i,o.flags.Cell.IMPREGNABLE))}),!1))}));const r=t.machineNumber;e.forEach(((t,e,n)=>{t&&(i.flags&yt.BP_NO_INTERIOR_FLAG||s.setMachine(e,n,r,i.isRoom),s.isSecretDoor(e,n)&&s.setTile(e,n,B))}))}(r,t),r.calcDistances(t.size.hi);const l=t.pickComponents();for(let i=0;i<l.length;i++){const e=l[i];if(!await this._buildStep(t,e,s))return r.site.restore(a),await this.log.onBlueprintFail(r,t,`Failed to build step ${i+1}.`),!1}return t.noInteriorFlag&&_(r.site,r.machineNumber),await this.log.onBlueprintSuccess(r,t),!0}async _markCandidates(t){const i=this.data,e=function(t,i){const e=t.site,s=t.candidates;if(s.fill(0),i.isRoom)s.update(((t,s,n)=>e.hasCellFlag(s,n,o.flags.Cell.IS_GATE_SITE)&&i.size.contains(e.getChokeCount(s,n))?1:0));else{if(i.isVestiblue)throw new Error("ERROR: Attempted to build a vestiblue without a location being provided.");s.update(((t,s,o)=>e.isPassable(s,o)?i.notInHallway?n.xy.arcCount(s,o,((t,i)=>e.isPassable(t,i)))<=1?1:0:1:0))}return s.count((t=>1==t))}(i,t);return e<=0?(await this.log.onBlueprintFail(i,t,"No suitable candidate locations found."),0):(await this.log.onBlueprintCandidates(i,t),e)}async _computeInterior(t){let i=null;const e=this.data;let s=t.fillInterior(e);return s?t.size.contains(s)?t.treatAsBlocking&&u(e.site,e.interior,{machine:e.site.machineCount})?i="Interior blocks map.":t.requireBlocking&&d(e.site,e.interior)<100&&(i="Interior does not block enough cells."):i=`Interior wrong size - have: ${s}, want: ${t.size.toString()}`:i="Interior error.",i?(await this.log.onBlueprintFail(e,t,i),!1):(await this.log.onBlueprintInterior(e,t),!0)}async _buildStep(t,i,e){let s=0,o=0;const r=this.data,a=r.site;await this.log.onStepStart(r,t,i,e);const l=St(r,i);let h=0;if(i.buildVestibule){if(!await this.buildRandom(yt.BP_VESTIBULE,r.originX,r.originY))return await this.log.onStepFail(r,t,i,"Failed to build vestibule"),!1}if(!i.buildsInstances)return!0;const c=n.grid.alloc(a.width,a.height);if(i.buildAtOrigin)c[r.originX][r.originY]=1,h=1,s=1;else if(h=i.markCandidates(r,t,c,l),s=i.generateEverywhere?h:i.count.value(),await this.log.onStepCandidates(r,t,i,c,s),!h||h<i.count.lo)return await this.log.onStepFail(r,t,i,`Blueprint ${t.id}, step ${t.steps.indexOf(i)} - Only ${h} qualifying tiles - want ${i.count.toString()}.`),!1;let g=0,u=0,d=!0;for(;h>0&&(i.generateEverywhere||o<s||i.repeatUntilNoProgress);)d=!0,i.buildAtOrigin?(g=r.originX,u=r.originY):[g,u]=n.rng.random.matchingLoc(c.width,c.height,((t,i)=>c[t][i]>0)),c[g][u]=0,h--,d=await this._buildStepInstance(t,i,g,u,e),d&&(h-=Ot(r,g,u,c,i.pad),o++);return n.grid.free(c),i.count.contains(o)||i.generateEverywhere||i.repeatUntilNoProgress||(d=!1,await this.log.onStepFail(r,t,i,`Failed to build enough instances - want: ${i.count.toString()}, built: ${o}`)),d&&await this.log.onStepSuccess(r,t,i),d}async _buildStepInstance(t,i,e,s,n=null){let r=!0,a=!0;const l=this.data,h=l.site;if(r&&i.treatAsBlocking&&g(h,e,s)&&(await this.log.onStepInstanceFail(l,t,i,e,s,"instance blocks map"),r=!1),r&&i.effect&&(r=h.buildEffect(i.effect,e,s),a=r,r||this.log.onStepInstanceFail(l,t,i,e,s,"Failed to build effect - "+JSON.stringify(i.effect))),r&&-1!==i.tile){const n=o.tile.get(i.tile);i.permitBlocking||!n.blocksMove()||i.treatAsBlocking||g(h,e,s,{machine:h.machineCount})&&(await this.log.onStepInstanceFail(l,t,i,e,s,"tile blocks site"),r=!1),r&&(r=h.setTile(e,s,n),a=a||r,r||await this.log.onStepInstanceFail(l,t,i,e,s,"failed to set tile - "+n.id))}if(r&&i.item){const n=h.makeRandomItem(i.item);n?(i.itemIsKey&&(n.key=o.entity.makeKeyInfo(e,s,!!i.keyIsDisposable)),i.outsourceItem?(r=await this.buildRandom(yt.BP_ADOPT_ITEM,-1,-1,n),r?a=!0:await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to build machine to adopt item - "+n.kind.id)):(r=h.addItem(e,s,n),a=a||r,r||await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to add item to site - "+n.kind.id))):(r=!1,await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to make random item - "+JSON.stringify(i.item)))}else if(r&&i.adoptItem){if(!n)throw new Error("Failed to build blueprint because there is no adopted item.");r&&(r=h.addItem(e,s,n),r?a=!0:await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to add adopted item to site - "+n.kind.id))}return r&&a&&(t.noInteriorFlag||h.setMachine(e,s,l.machineNumber,t.isRoom),i.impregnable&&h.setCellFlag(e,s,o.flags.Cell.IMPREGNABLE),await this.log.onStepInstanceSuccess(l,t,i,e,s)),r&&a}},ConsoleLogger:Ft});t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],n.object.setOptions(this.config,t),this.config.seed&&n.rng.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=n.rng.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const i=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let e=0;e<this.config.levels;++e){const e=n.rng.random.matchingLoc(this.config.width,this.config.height,((e,s)=>n.xy.distanceBetween(t[0],t[1],e,s)>i));this.stairLocs.push([[t[0],t[1]],[e[0],e[1]]]),t=e}}getLevel(t,i){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);n.rng.random.seed(this.seeds[t]);const[e,s]=this.stairLocs[t],o=Object.assign({},this.config.stairs);this.config.goesUp?(o.down=e,o.up=s,0==t&&this.config.startTile&&(o.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.upTile=this.config.endTile)):(o.down=s,o.up=e,0==t&&this.config.startTile&&(o.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.downTile=this.config.endTile));const r=Object.assign({},this.config.rooms);0===t&&r.entrance&&(r.first=r.entrance);const a={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:r,stairs:o,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,a,i)}makeLevel(t,i,e){const s=new _t(i),o=s.create(this.config.width,this.config.height,e);return n.xy.equalsXY(s.endLoc,i.endLoc)&&n.xy.equalsXY(s.startLoc,i.startLoc)||(this.stairLocs[t]=[s.startLoc,s.endLoc]),o}},t.Hall=C,t.Level=_t,t.Room=x,t.blueprint=Dt,t.bridge=ct,t.hall=rt,t.lake=lt,t.loop=ft,t.makeHall=P,t.room=j,t.site=D,t.stairs=ut,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

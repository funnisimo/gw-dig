!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWU,t.GWM)}(this,(function(t,e,i){"use strict";function s(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var s=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,s.get?s:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var o=s(e),r=s(i);const n=o.xy.DIRS;function a(t,e,i){let s,r,a,h,l,c;for(r=o.xy.NO_DIRECTION,s=0;s<4;s++)if(a=e+n[s][0],h=i+n[s][1],l=e-n[s][0],c=i-n[s][1],t.hasXY(l,c)&&t.hasXY(a,h)&&t.isFloor(l,c)){if(r!=o.xy.NO_DIRECTION)return o.xy.NO_DIRECTION;r=s}return r}function h(t){let e,i,s,r,n,h,l;const c=[[],[],[],[]],g=t.height,f=t.width;for(e=0;e<f;e++)for(i=0;i<g;i++)if(t.isDiggable(e,i)&&(h=a(t,e,i),h!=o.xy.NO_DIRECTION)){for(r=e+o.xy.DIRS[h][0],n=i+o.xy.DIRS[h][1],l=!1,s=0;s<10&&t.hasXY(r,n)&&!l;s++)t.isSet(r,n)&&(l=!0),r+=o.xy.DIRS[h][0],n+=o.xy.DIRS[h][1];l||c[h].push([e,i])}let d=[];for(h=0;h<4;h++){const t=o.random.item(c[h])||[-1,-1];d[h]=[t[0],t[1]]}return d}function l(t,e,i=0,s=0){o.xy.forRect(t.width,t.height,((o,r)=>{const n=o-i,a=r-s,h=e.getTileIndex(n,a);h&&t.setTile(o,r,h)}))}function c(t,e){e.update(((e,i,s)=>t.isPassable(i,s)?1:o.path.OBSTRUCTION))}function g(t,e,i,s={}){var r,n,a;if(null!==(r=s.offsetX)&&void 0!==r||(s.offsetX=0),null!==(n=s.offsetY)&&void 0!==n||(s.offsetY=0),null!==(a=s.machine)&&void 0!==a||(s.machine=0),o.xy.arcCount(e,i,((e,i)=>t.isPassable(e,i)))<=1)return!1;const h=o.grid.alloc(t.width,t.height);h[e][i]=1;const l=f(t,h,s);return o.grid.free(h),l}function f(t,e,i={}){var s,r,n;null!==(s=i.offsetX)&&void 0!==s||(i.offsetX=0),null!==(r=i.offsetY)&&void 0!==r||(i.offsetY=0),null!==(n=i.machine)&&void 0!==n||(i.machine=0);const a=o.grid.alloc(t.width,t.height);let h=!1;o.xy.forRect(t.width,t.height,((s,o)=>{const r=s+i.offsetX,n=o+i.offsetY;e.get(r,n)?t.isStairs(s,o)&&(h=!0):!t.isPassable(s,o)||0!=t.getMachine(s,o)&&t.getMachine(s,o)!=i.machine||(a[s][o]=1)}));let l=!0;for(let t=0;t<a.width&&!h;++t)for(let e=0;e<a.height&&!h;++e)1==a[t][e]&&(l?(a.floodFill(t,e,1,2),l=!1):h=!0);return o.grid.free(a),h}function d(t,e,i=0,s=0){const r=o.grid.alloc(t.width,t.height);let n=0;if(o.xy.forRect(t.width,t.height,((o,a)=>{const h=o+i,l=a+s;e.get(h,l)?t.isStairs(o,a)&&(n=t.width*t.height):t.isPassable(o,a)&&(r[o][a]=1)})),n)return n;let a=!0,h=2,l=t.width*t.height;for(let t=0;t<r.width;++t)for(let e=0;e<r.height;++e)if(1==r[t][e]){const i=r.floodFill(t,e,1,h++);l=Math.min(l,i),a?a=!1:n=l}return o.grid.free(r),n}function u(t,e,i,s,r){const n=o.grid.alloc(t.width,t.height);c(t,n),o.path.calculateDistances(e,i,s,n,!1,r+1),o.grid.free(n)}function _(t,e){for(let i=0;i<t.width;i++)for(let s=0;s<t.height;s++)t.getMachine(i,s)!=e||t.hasCellFlag(i,s,r.flags.Cell.IS_WIRED|r.flags.Cell.IS_CIRCUIT_BREAKER)||t.setMachine(i,s,0)}var I,m;const p=r.tile.get("NULL").index,E=r.tile.get("FLOOR").index,T=r.tile.get("DOOR").index,R=null!==(m=null===(I=r.tile.get("DOOR_SECRET"))||void 0===I?void 0:I.index)&&void 0!==m?m:-1,B=r.tile.get("WALL").index,O=r.tile.get("LAKE").index,w=r.tile.get("SHALLOW").index,L=r.tile.get("BRIDGE").index,N=r.tile.get("UP_STAIRS").index,A=r.tile.get("DOWN_STAIRS").index,M=r.tile.get("IMPREGNABLE").index,y={[p]:"NULL",[E]:"FLOOR",[T]:"DOOR",[B]:"WALL",[M]:"IMPREGNABLE",[O]:"LAKE",[w]:"SHALLOW",[L]:"BRIDGE",[N]:"UP_STAIRS",[A]:"DOWN_STAIRS"};class b{constructor(t,e){this.seed=0,this.tiles=o.grid.alloc(t,e),this.doors=o.grid.alloc(t,e)}free(){o.grid.free(this.tiles),o.grid.free(this.doors)}clear(){this.tiles.fill(0),this.doors.fill(0)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,e){return this.tiles.hasXY(t,e)}isBoundaryXY(t,e){return this.tiles.isBoundaryXY(t,e)}isPassable(t,e){return this.isFloor(t,e)||this.isDoor(t,e)||this.isBridge(t,e)||this.isStairs(t,e)||this.isShallow(t,e)}isNothing(t,e){return this.tiles.get(t,e)===p}isDiggable(t,e){return this.tiles.get(t,e)===p}isFloor(t,e){return this.tiles.get(t,e)==E}isDoor(t,e){return this.tiles.get(t,e)===T}isSecretDoor(t,e){return this.tiles.get(t,e)===R}isBridge(t,e){return this.tiles.get(t,e)===L}isWall(t,e){const i=this.tiles.get(t,e);return i===B||i===M}blocksMove(t,e){return this.isNothing(t,e)||this.isWall(t,e)||this.isDeep(t,e)}blocksDiagonal(t,e){return this.isNothing(t,e)||this.isWall(t,e)}blocksPathing(t,e){return this.isNothing(t,e)||this.isWall(t,e)||this.isDeep(t,e)||this.isStairs(t,e)}blocksVision(t,e){return this.isNothing(t,e)||this.isWall(t,e)}blocksItems(t,e){return this.blocksPathing(t,e)||this.blocksPathing(t,e)}blocksEffects(t,e){return this.isWall(t,e)}isStairs(t,e){const i=this.tiles.get(t,e);return i===N||i===A}isDeep(t,e){return this.tiles.get(t,e)===O}isShallow(t,e){return this.tiles.get(t,e)===w}isAnyLiquid(t,e){return this.isDeep(t,e)||this.isShallow(t,e)}isSet(t,e){return(this.tiles.get(t,e)||0)>0}getTileIndex(t,e){return this.tiles.get(t,e)||0}setTile(t,e,i){if(i instanceof r.tile.Tile&&(i=i.index),"string"==typeof i){const t=r.tile.tiles[i];if(!t)throw new Error("Failed to find tie: "+i);i=t.index}return!!this.tiles.hasXY(t,e)&&(this.tiles[t][e]=i,!0)}hasTile(t,e,i){if(i instanceof r.tile.Tile&&(i=i.index),"string"==typeof i){const t=r.tile.tiles[i];if(!t)throw new Error("Failed to find tie: "+i);i=t.index}return this.tiles.hasXY(t,e)&&this.tiles[t][e]==i}getMachine(t,e){return 0}updateDoorDirs(){this.doors.update(((t,e,i)=>a(this,e,i)))}getDoorDir(t,e){return this.doors[t][e]}}const S=r.flags.Cell;class D{constructor(t){this.machineCount=0,this.needsAnalysis=!0,this.map=t,this.doors=o.grid.alloc(t.width,t.height)}get seed(){return this.map.seed}set seed(t){this.map.seed=t}get width(){return this.map.width}get height(){return this.map.height}hasXY(t,e){return this.map.hasXY(t,e)}isBoundaryXY(t,e){return this.map.isBoundaryXY(t,e)}hasCellFlag(t,e,i){return this.map.cellInfo(t,e).hasCellFlag(i)}setCellFlag(t,e,i){this.needsAnalysis=!0,this.map.cell(t,e).setCellFlag(i)}clearCellFlag(t,e,i){this.needsAnalysis=!0,this.map.cell(t,e).clearCellFlag(i)}hasTile(t,e,i){return this.map.cellInfo(t,e).hasTile(i)}setTile(t,e,i,s){return this.needsAnalysis=!0,this.map.setTile(t,e,i,s)}getTileIndex(t,e){if(!this.hasXY(t,e))return 0;return this.map.cell(t,e).highestPriorityTile().index}clear(){this.needsAnalysis=!0,this.map.cells.forEach((t=>t.clear()))}hasItem(t,e){return this.map.cellInfo(t,e).hasItem()}makeRandomItem(t){return r.item.makeRandom(t)}addItem(t,e,i){return this.needsAnalysis=!0,this.map.forceItem(t,e,i)}hasActor(t,e){return this.map.hasActor(t,e)}blocksMove(t,e){return this.map.cellInfo(t,e).blocksMove()}blocksVision(t,e){return this.map.cellInfo(t,e).blocksVision()}blocksDiagonal(t,e){return this.map.cellInfo(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_DIAGONAL)}blocksPathing(t,e){const i=this.map.cellInfo(t,e);return i.hasEntityFlag(r.flags.Entity.L_BLOCKS_MOVE)||i.hasTileFlag(r.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,e){return this.map.cellInfo(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_ITEMS)}blocksEffects(t,e){return this.map.cellInfo(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_EFFECTS)}isWall(t,e){return this.map.cellInfo(t,e).isWall()}isStairs(t,e){return this.map.cellInfo(t,e).isStairs()}isSet(t,e){return this.hasXY(t,e)&&!this.map.cell(t,e).isEmpty()}isDiggable(t,e){if(!this.hasXY(t,e))return!1;const i=this.map.cell(t,e);return!!i.isEmpty()||!!i.isWall()}isNothing(t,e){return this.hasXY(t,e)&&this.map.cell(t,e).isEmpty()}isFloor(t,e){return this.isPassable(t,e)}isBridge(t,e){return this.map.cellInfo(t,e).hasTileFlag(r.tile.flags.Tile.T_BRIDGE)}isDoor(t,e){return this.map.cellInfo(t,e).hasTileFlag(r.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,e){return this.map.cellInfo(t,e).hasEntityFlag(r.flags.Entity.L_SECRETLY_PASSABLE)}isDeep(t,e){return this.map.cellInfo(t,e).hasTileFlag(r.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,e){if(!this.hasXY(t,e))return!1;const i=this.map.cell(t,e);return!!i.depthTile(r.flags.Depth.LIQUID)&&!i.hasTileFlag(r.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,e){if(!this.hasXY(t,e))return!1;const i=this.map.cell(t,e);return i.hasDepthTile(r.flags.Depth.LIQUID)||i.hasTileFlag(r.tile.flags.Tile.T_IS_DEEP_LIQUID)}isOccupied(t,e){return this.hasItem(t,e)||this.hasActor(t,e)}isPassable(t,e){const i=this.map.cellInfo(t,e);return!(i.blocksMove()||i.blocksPathing())}backup(){const t=new D(this.map.clone());return t.machineCount=this.machineCount,t.needsAnalysis=this.needsAnalysis,t}restore(t){this.map.copy(t.map),this.machineCount=t.machineCount,this.needsAnalysis=t.needsAnalysis}free(){o.grid.free(this.doors)}getChokeCount(t,e){return this.map.cell(t,e).chokeCount}setChokeCount(t,e,i){this.map.cell(t,e).chokeCount=i}analyze(){this.needsAnalysis&&r.map.analyze(this.map),this.needsAnalysis=!1}fireEffect(t,e,i){return this.needsAnalysis=!0,r.effect.fireSync(t,this.map,e,i)}nextMachineId(){return++this.machineCount}getMachine(t,e){return this.map.cell(t,e).machineId}setMachine(t,e,i,s=!0){this.needsAnalysis=!0,this.map.cell(t,e).machineId=i,0==i?this.map.clearCellFlag(t,e,S.IS_IN_MACHINE):this.map.setCellFlag(t,e,s?S.IS_IN_ROOM_MACHINE:S.IS_IN_AREA_MACHINE)}updateDoorDirs(){this.doors.update(((t,e,i)=>a(this,e,i)))}getDoorDir(t,e){return this.doors[t][e]}}var F=Object.freeze({__proto__:null,NOTHING:p,FLOOR:E,DOOR:T,SECRET_DOOR:R,WALL:B,DEEP:O,SHALLOW:w,BRIDGE:L,UP_STAIRS:N,DOWN_STAIRS:A,IMPREGNABLE:M,TILEMAP:y,GridSite:b,MapSite:D,directionOfDoorSite:a,chooseRandomDoorSites:h,copySite:l,fillCostGrid:c,siteDisruptedByXY:g,siteDisruptedBy:f,siteDisruptedSize:d,computeDistanceMap:u,clearInteriorFlag:_});class P extends o.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[]}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))}))}}function C(t,e,i,s=1){const r=o.xy.DIRS[e],n=Math.min(t[0],t[0]+r[0]*(i-1)),a=Math.min(t[1],t[1]+r[1]*(i-1)),h=Math.abs(r[0]*i)||s,l=Math.abs(r[1]*i)||s;return new P(n,a,h,l)}class x extends o.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))})),this.hall&&this.hall.translate(t,e)}}function k(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,i])=>{let s=t[e];if("tile"===e)return void(void 0===s&&(t[e]=i));if(!0===i){if(!s)throw new Error("Missing required config for room digger: "+e)}else s=("number"==typeof i||Array.isArray(i),s||i);const r=o.range.make(s);t[e]=r})),t}class v{constructor(t,e={}){this.options={},this.doors=[],this._setOptions(t,e)}_setOptions(t,e={}){this.options=k(t,e)}create(t){const e=this.carve(t);return e&&(e.doors&&0!=e.doors.length&&!e.doors.every((t=>!t||-1==t[0]))||(e.doors=h(t))),e}}var Y={};class G extends v{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const i=t.choices||e.choices;if(Array.isArray(i))this.randomRoom=o.random.item.bind(o.random,i);else{if("object"!=typeof i)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=o.random.weighted.bind(o.random,i)}}carve(t){let e=this.randomRoom();const i=Y[e];return i||o.utils.ERROR("Missing room digger choice: "+e),i.create(t)}}class X extends v{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(),i=this.options.height.value(),s=this.options.tile||E,r=o.grid.alloc(t.width,t.height,0),n=Math.floor(.5*e),a=e,h=Math.floor(.5*i),l=i,c=new o.blob.Blob({rounds:5,minWidth:n,minHeight:h,maxWidth:a,maxHeight:l,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(r.width,r.height,((t,e)=>r[t][e]=1)),g=Math.floor((t.width-c.width)/2),f=g-c.x,d=Math.floor((t.height-c.height)/2),u=d-c.y;return r.forEach(((e,i,o)=>{e&&t.setTile(i+f,o+u,s)})),o.grid.free(r),new x(g,d,c.width,c.height)}}class W extends v{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(),i=this.options.height.value(),s=this.options.tile||E,r=Math.floor(.4*e),n=i,a=e,h=Math.floor(.5*i),l=Math.floor(t.width/2-r/2-1),c=t.height-n-2,g=Math.floor(t.width/2-a/2-1),f=t.height-h-2;o.xy.forRect(l,c,r,n,((e,i)=>t.setTile(e,i,s))),o.xy.forRect(g,f,a,h,((e,i)=>t.setTile(e,i,s)));const d=new x(Math.min(l,g),Math.min(c,f),Math.max(r,a),Math.max(n,h));return d.doors[o.xy.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class U extends v{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(),i=this.options.height.value(),s=this.options.tile||E,r=e,n=Math.max(3,Math.floor(e*o.random.range(25,75)/100)),a=Math.max(3,Math.floor(i*o.random.range(25,75)/100)),h=i,l=Math.floor((t.width-r)/2),c=l+o.random.range(2,Math.max(2,r-n-2)),g=Math.floor((t.height-h)/2),f=g+o.random.range(2,Math.max(2,h-a-2));return o.xy.forRect(l,f,r,a,((e,i)=>t.setTile(e,i,s))),o.xy.forRect(c,g,n,h,((e,i)=>t.setTile(e,i,s))),new x(l,g,Math.max(r,n),Math.max(a,h))}}class H extends v{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(),i=this.options.height.value(),s=this.options.tile||E;let r=Math.max(3,Math.floor(e*o.random.range(25,50)/100)),n=Math.max(3,Math.floor(i*o.random.range(25,50)/100));const a=Math.floor((t.width-e)/2),h=Math.floor((t.height-n)/2);o.xy.forRect(a,h,e,n,((e,i)=>t.setTile(e,i,s)));const l=Math.floor((t.width-r)/2),c=Math.floor((t.height-i)/2);return o.xy.forRect(l,c,r,i,((e,i)=>t.setTile(e,i,s))),new x(Math.min(a,l),Math.min(h,c),Math.max(e,r),Math.max(i,n))}}class V extends v{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(),i=this.options.height.value(),s=this.options.tile||E,r=Math.floor((t.width-e)/2),n=Math.floor((t.height-i)/2);return o.xy.forRect(r,n,e,i,((e,i)=>t.setTile(e,i,s))),new x(r,n,e,i)}}class K extends v{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(),i=this.options.tile||E,s=Math.floor(t.width/2),r=Math.floor(t.height/2);return e>1&&o.xy.forCircle(s,r,e,((e,s)=>t.setTile(e,s,i))),new x(s-e,r-e,2*e+1,2*e+1)}}class q extends v{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(),i=this.options.ringMinWidth.value(),s=this.options.holeMinSize.value(),r=this.options.tile||E,n=Math.floor(t.width/2),a=Math.floor(t.height/2);return o.xy.forCircle(n,a,e,((e,i)=>t.setTile(e,i,r))),e>i+s&&o.random.chance(this.options.holeChance.value())&&o.xy.forCircle(n,a,o.random.range(s,e-s),((e,i)=>t.setTile(e,i,0))),new x(n-e,a-e,2*e+1,2*e+1)}}class z extends v{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,i,s,r=this.options.count.value();const n=this.options.width.value(),a=this.options.height.value(),h=this.options.tile||E,l=Math.floor(t.width/2)-Math.floor(n/2),c=Math.floor(t.width/2)+Math.floor(n/2),g=Math.floor(t.height/2)-Math.floor(a/2),f=Math.floor(t.height/2)+Math.floor(a/2);let d=Math.floor(t.width/2),u=d,_=Math.floor(t.height/2),I=_;for(o.xy.forCircle(d,_,2,((e,i)=>t.setTile(e,i,h))),d-=2,u+=2,_-=2,I+=2,e=0;e<r;)if(i=o.random.range(l,c),s=o.random.range(g,f),t.isSet(i,s)){if(i-2<l)continue;if(i+2>c)continue;if(s-2<g)continue;if(s+2>f)continue;d=Math.min(i-2,d),u=Math.max(i+2,u),_=Math.min(s-2,_),I=Math.max(s+2,I),o.xy.forCircle(i,s,2,((e,i)=>t.setTile(e,i,h))),e++}return new x(d,_,u-d+1,I-_+1)}}function j(t,e){return Y[t]=e,e}j("DEFAULT",new V);var Q=Object.freeze({__proto__:null,checkConfig:k,RoomDigger:v,rooms:Y,ChoiceRoom:G,choiceRoom:function(t,e){return new G(t).create(e)},Cavern:X,cavern:function(t,e){return new X(t).create(e)},BrogueEntrance:W,brogueEntrance:function(t,e){return new W(t).create(e)},Cross:U,cross:function(t,e){return new U(t).create(e)},SymmetricalCross:H,symmetricalCross:function(t,e){return new H(t).create(e)},Rectangular:V,rectangular:function(t,e){return new V(t).create(e)},Circular:K,circular:function(t,e){return new K(t).create(e)},BrogueDonut:q,brogueDonut:function(t,e){return new q(t).create(e)},ChunkyRoom:z,chunkyRoom:function(t,e){return new z(t).create(e)},install:j});const Z=o.xy.DIRS;function $(t,e,i){if(!t.hasXY(e[0],e[1]))return!1;if(!t.isDiggable(e[0],e[1]))return!1;const s=[e[0]-i[0],e[1]-i[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function J(t,e){return t==o.xy.UP||t==o.xy.DOWN?e[1].value():e[0].value()}function tt(t,e,i){let s=o.xy.NO_DIRECTION;if(s==o.xy.NO_DIRECTION){const r=o.random.sequence(4);for(let n=0;n<4;n++){s=r[n];const a=i[(n+1)%2].hi,h=e[s];if(h&&-1!=h[0]&&-1!=h[1]){const e=h[0]+Math.floor(Z[s][0]*a),i=h[1]+Math.floor(Z[s][1]*a);if(t.hasXY(e,i))break}s=o.xy.NO_DIRECTION}}return s}function et(t,e,i,s,r){let n,a;const h=o.random.chance(r),l=[];for(let o=0;o<4;o++)n=e+Z[o][0],a=i+Z[o][1],o!=s&&!h||!t.hasXY(n,a)||t.isSet(n,a)||(l[o]=[n,a]);return l}class it{constructor(t={}){this.config={width:o.range.make(1),length:[o.range.make("2-15"),o.range.make("2-9")],tile:E,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=o.range.make(t.width)),t.length&&"number"==typeof t.length){const e=o.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,e=[]){if(e=e||h(t),!o.random.chance(this.config.chance))return null;const i=tt(t,e,this.config.length);if(i===o.xy.NO_DIRECTION)return null;if(!e[i])return null;const s=this.config.width.value(),r=J(i,this.config.length),n=e[i];return 1==s?this.dig(t,i,n,r):this.digWide(t,i,n,r,s)}_digLine(t,e,i,s){let o=e[0],r=e[1];const n=this.config.tile;for(let e=0;e<s;e++)t.setTile(o,r,n),o+=i[0],r+=i[1];return o-=i[0],r-=i[1],[o,r]}dig(t,e,i,s){const o=Z[e],[r,n]=this._digLine(t,i,o,s),a=C(i,e,s);return a.doors=et(t,r,n,e,this.config.obliqueChance),a}digWide(t,e,i,s,r){const n=o.xy.DIRS[e],a=[i[0]-n[1],i[1]-n[0]],h=[i[0]+n[1],i[1]+n[0]];this._digLine(t,i,n,s);let l=1,c=i[0],g=i[1];l<r&&$(t,a,n)&&(this._digLine(t,a,n,s),c=Math.min(a[0],c),g=Math.min(a[1],g),++l),l<r&&$(t,h,n)&&(this._digLine(t,h,n,s),c=Math.min(h[0],c),g=Math.min(h[1],g),++l);const f=C([c,g],e,s,r);return f.doors=[],f.doors[e]=[i[0]+s*n[0],i[1]+s*n[1]],f}}function st(t,e,i){return new it(t).create(e,i)}var ot={};function rt(t,e){return ot[t]=e,e}rt("DEFAULT",new it({chance:15}));var nt=Object.freeze({__proto__:null,isDoorLoc:$,pickWidth:function(t={}){return o.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let e=t.width;if("number"==typeof e)return e;e=Array.isArray(e)?o.random.weighted(e)+1:"string"==typeof e?o.range.make(e).value():Number.parseInt(o.random.weighted(e));return e}(t),1,3)},pickLength:J,pickHallDirection:tt,pickHallExits:et,HallDigger:it,dig:st,halls:ot,install:rt});class at{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:w,wreathChance:50,wreathSize:1,tile:O},Object.assign(this.options,t)}create(t){let e,i,s,r,n,a,h,l,c,g,f,d=0;a=this.options.height||15,h=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,f=this.options.canDisrupt||!1;const u=!!o.random.chance(this.options.wreathChance),_=this.options.wreathTile||w,I=this.options.wreathSize||1,m=this.options.tile||O,p=o.grid.alloc(t.width,t.height,0);let E=0;for(;E<g&&d<g;){const T=Math.round((h-l)*(g-E)/g)+l,R=Math.round((a-l)*(g-E)/g)+l,B=new o.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:T,maxHeight:R,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(p.width,p.height,((t,e)=>p[t][e]=1));let O=!1;for(s=0;s<c&&!O;s++)if(r=o.random.range(1-B.x,p.width-B.width-B.x-2),n=o.random.range(1-B.y,p.height-B.height-B.y-2),f||!this.isDisruptedBy(t,p,-r,-n)){for(O=!0,e=0;e<B.width;e++)for(i=0;i<B.height;i++)if(p[e+B.x][i+B.y]){const s=e+B.x+r,a=i+B.y+n;t.setTile(s,a,m),u&&o.xy.forCircle(s,a,I,((e,i)=>{t.isPassable(e,i)&&t.setTile(e,i,_)}))}break}O?++d:++E}return o.grid.free(p),d}isDisruptedBy(t,e,i=0,s=0){const r=o.grid.alloc(t.width,t.height);let n=!1;o.xy.forRect(t.width,t.height,((o,a)=>{const h=o+i,l=a+s;e.get(h,l)?t.isStairs(o,a)&&(n=!0):t.isPassable(o,a)&&(r[o][a]=1)}));let a=!0;for(let t=0;t<r.width&&!n;++t)for(let e=0;e<r.height&&!n;++e)1==r[t][e]&&(a?(r.floodFill(t,e,1,2),a=!1):n=!0);return o.grid.free(r),n}}var ht=Object.freeze({__proto__:null,Lakes:at});class lt{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let e,i,s,r,n,a,h,l=0;const c=this.options.maxLength,g=this.options.minDistance,f=o.grid.alloc(t.width,t.height),d=o.grid.alloc(t.width,t.height),u=[[1,0],[0,1]];d.update(((e,i,s)=>t.isPassable(i,s)?1:o.path.OBSTRUCTION));const _=o.random.sequence(t.width*t.height);for(s=0;s<_.length;s++)if(a=Math.floor(_[s]/t.height),h=_[s]%t.height,t.isPassable(a,h)&&!t.isAnyLiquid(a,h))for(n=0;n<=1;n++){const s=u[n];if(e=a+s[0],i=h+s[1],r=c,t.isAnyLiquid(e,i))for(r=0;r<c&&(e+=s[0],i+=s[1],t.isAnyLiquid(e,i));++r);if(t.isPassable(e,i)&&r<c&&(o.path.calculateDistances(f,e,i,d,!1),f[a][h]>g&&f[a][h]<o.path.NO_PATH)){for(;a!==e||h!==i;)this.isBridgeCandidate(t,a,h,s)?(t.setTile(a,h,L),d[a][h]=1):(t.setTile(a,h,E),d[a][h]=1),a+=s[0],h+=s[1];++l;break}}return o.grid.free(f),o.grid.free(d),l}isBridgeCandidate(t,e,i,s){return!!t.isBridge(e,i)||!!t.isAnyLiquid(e,i)&&(!!t.isAnyLiquid(e+s[1],i+s[0])&&!!t.isAnyLiquid(e-s[1],i-s[0]))}}var ct=Object.freeze({__proto__:null,Bridges:lt});class gt{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:N,downTile:A,wall:M},Object.assign(this.options,t)}create(t){let e=!1!==this.options.up,i=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),r={};let n=null,a=null;const h=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?o.random.matchingLoc(t.width,t.height,h):o.random.matchingLocNear(o.xy.x(e),o.xy.y(e),h),r.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;n=o.random.matchingLocNear(o.xy.x(t),o.xy.y(t),h);const e=this.options.down;a=o.random.matchingLocNear(o.xy.x(e),o.xy.y(e),h)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;n=o.random.matchingLocNear(o.xy.x(e),o.xy.y(e),h),i&&(a=o.random.matchingLoc(t.width,t.height,((t,e)=>!(o.xy.distanceBetween(t,e,n[0],n[1])<s)&&h(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const i=this.options.down;a=o.random.matchingLocNear(o.xy.x(i),o.xy.y(i),h),e&&(n=o.random.matchingLoc(t.width,t.height,((t,e)=>!(o.xy.distanceBetween(t,e,a[0],a[1])<s)&&h(t,e))))}else e?(n=o.random.matchingLoc(t.width,t.height,h),i&&(a=o.random.matchingLoc(t.width,t.height,((t,e)=>!(o.xy.distanceBetween(t,e,n[0],n[1])<s)&&h(t,e))))):i&&(a=o.random.matchingLoc(t.width,t.height,h));return n&&(r.up=n.slice(),this.setupStairs(t,n[0],n[1],this.options.upTile),"up"===this.options.start&&(r.start=r.up)),a&&(r.down=a.slice(),this.setupStairs(t,a[0],a[1],this.options.downTile),"down"===this.options.start&&(r.start=r.down)),n||a?r:null}hasXY(t,e,i){return!(e<0||i<0)&&!(e>=t.width||i>=t.height)}isStairXY(t,e,i){let s=0;if(!this.hasXY(t,e,i)||!t.isDiggable(e,i))return!1;for(let r=0;r<4;++r){const n=o.xy.DIRS[r];if(!this.hasXY(t,e+n[0],i+n[1]))return!1;if(!this.hasXY(t,e-n[0],i-n[1]))return!1;if(t.isFloor(e+n[0],i+n[1])){if(s+=1,!t.isDiggable(e-n[0]+n[1],i-n[1]+n[0]))return!1;if(!t.isDiggable(e-n[0]-n[1],i-n[1]-n[0]))return!1}else if(!t.isDiggable(e+n[0],i+n[1]))return!1}return 1==s}setupStairs(t,e,i,s){const r=o.random.sequence(4);let n=null;for(let s=0;s<r.length;++s){n=o.xy.DIRS[s];const r=e+n[0],a=i+n[1];if(t.isFloor(r,a)&&t.isDiggable(e-n[0],i-n[1]))break;n=null}n||o.utils.ERROR("No stair direction found!"),t.setTile(e,i,s);const a=o.xy.CLOCK_DIRS.findIndex((t=>t[0]==n[0]&&t[1]==n[1])),h=this.options.wall;for(let s=0;s<o.xy.CLOCK_DIRS.length;++s){const r=s?s-1:7,n=(s+1)%8;if(s==a||r==a||n==a)continue;const l=o.xy.CLOCK_DIRS[s];t.setTile(e+l[0],i+l[1],h)}return!0}}var ft=Object.freeze({__proto__:null,Stairs:gt});class dt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},Object.assign(this.options,t)}create(t){let e,i,s,r,n,a,h,l,g;const f=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,u=o.grid.alloc(t.width,t.height),_=o.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];function m(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!t.isSet(e,i)&&(!t.isSet(e+s[1],i+s[0])&&!t.isSet(e-s[1],i-s[0])))))}function p(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!!t.isSet(e,i)||(!!t.isSet(e+s[1],i+s[0])||!!t.isSet(e-s[1],i-s[0])))))}c(t,_);let R=0;const B=o.random.sequence(t.width*t.height);for(n=0;n<B.length;n++)if(l=Math.floor(B[n]/t.height),g=B[n]%t.height,!t.isSet(l,g))for(h=0;h<=1;h++){let n=I[h];if(m(l,g,n)){if(a=d,t.hasXY(l+n[0],g+n[1])&&t.isPassable(l+n[0],g+n[1])){if(!t.hasXY(l-n[0],g-n[1])||t.isDoor(l-n[0],g-n[1]))continue}else{if(!t.hasXY(l-n[0],g-n[1])||!t.isPassable(l-n[0],g-n[1]))continue;if(!t.hasXY(l+n[0],g+n[1])||t.isDoor(l+n[0],g+n[1]))continue;n=n.map((t=>-1*t))}for(e=l+n[0],i=g+n[1],s=l,r=g,a=0;a<d&&(s-=n[0],r-=n[1],!p(s,r,n));++a);if(a<d&&(o.path.calculateDistances(u,e,i,_,!1),u[s][r]>f&&u[s][r]<3e4)){for(;s!==e||r!==i;)t.isNothing(s,r)&&(t.setTile(s,r,E),_[s][r]=1),s+=n[0],r+=n[1];const a=o.random.chance(this.options.doorChance)?T:E;t.setTile(l,g,a),++R;break}}}return o.grid.free(u),o.grid.free(_),R}}var ut=Object.freeze({__proto__:null,LoopDigger:dt,digLoops:function(t,e={}){return new dt(e).create(t)}});class _t{constructor(t={}){var e,i;this.seed=0,this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.seed=t.seed||o.random.number(),o.object.setOptions(this.rooms,t.rooms),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),o.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),o.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),t.loops=t.loops||{},t.loops.doorChance=null!==(e=t.loops.doorChance)&&void 0!==e?e:null===(i=t.doors)||void 0===i?void 0:i.chance,o.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),o.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:(!0===t.bridges&&(t.bridges={}),o.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:(!0===t.stairs&&(t.stairs={}),o.object.setOptions(this.stairs,t.stairs)),this.startLoc=t.startLoc||[-1,-1],this.endLoc=t.endLoc||[-1,-1]}_makeSite(t,e){return new b(t,e)}create(...t){if(1==t.length&&t[0]instanceof r.map.Map){const e=t[0];this.site=new D(e)}if(t.length>1){const e=t[0],i=t[1];this.site=new b(e,i)}const e=this._create(this.site);if(t.length>1){const e=t[0],i=t[1],s=t[2];o.xy.forRect(e,i,((t,e)=>{const i=this.site.getTileIndex(t,e);i&&s(t,e,i)}))}return this.site.free(),e}_create(t){this.startLoc[0]<0&&this.startLoc[0]<0&&(this.startLoc[0]=Math.floor(t.width/2),this.startLoc[1]=t.height-2),this.start(t);let e=20;for(;--e&&!this.addFirstRoom(t););if(!e)throw new Error("Failed to place first room!");t.updateDoorDirs();let i=0;for(;i<20;)this.addRoom(t)?(i=0,t.updateDoorDirs(),o.random.shuffle(this.seq)):++i;return this.loops&&this.addLoops(t,this.loops),this.lakes&&this.addLakes(t,this.lakes),this.bridges&&this.addBridges(t,this.bridges),this.stairs&&this.addStairs(t,this.stairs),this.finish(t),!0}start(t){this.seed&&(o.random.seed(this.seed),t.seed=this.seed),t.clear(),this.seq=o.random.sequence(t.width*t.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof v)return t;if("string"==typeof t){const e=Y[t];if(!e)throw new Error("Failed to find digger - "+t);return e}return new G(t)}addFirstRoom(t){const e=this._makeSite(t.width,t.height);let i=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(e);return i&&!this._attachRoomAtLoc(t,e,i,this.startLoc)&&(i=null),e.free(),i}addRoom(t){const e=this._makeSite(t.width,t.height);let i=this.getDigger(this.rooms.digger||"DEFAULT").create(e);if(this.halls.chance){let t=st(this.halls,e,i.doors);t&&(i.hall=t)}return i&&!this._attachRoom(t,e,i)&&(i=null),e.free(),i}_attachRoom(t,e,i){const s=i.hall?i.hall.doors:i.doors;let r=0;const n=this.seq.length;for(r=0;r<n;r++){const n=Math.floor(this.seq[r]/t.height),a=this.seq[r]%t.height,h=t.getDoorDir(n,a);if(h!=o.xy.NO_DIRECTION){const o=(h+2)%4,r=s[o];if(!r)continue;const c=n-r[0],g=a-r[1];if(-1!=r[0]&&this._roomFitsAt(t,e,i,c,g))return l(t,e,c,g),this._attachDoor(t,i,n,a,o),i.translate(c,g),!0}}return!1}_attachRoomAtLoc(t,e,i,s){const[r,n]=s,a=i.hall?i.hall.doors:i.doors,h=o.random.sequence(4);for(let s of h){const o=a[(s+2)%4];if(!o||-1==o[0])continue;const h=r-o[0],c=n-o[1];if(this._roomFitsAt(t,e,i,h,c))return l(t,e,h,c),i.translate(h,c),!0}return!1}_roomFitsAt(t,e,i,s,o){let r,n,a,h,l,c;const g=i.hall||i,f=Math.min(i.left,g.left),d=Math.min(i.top,g.top),u=Math.max(i.right,g.right),_=Math.max(i.bottom,g.bottom);for(r=f;r<=u;r++)for(n=d;n<=_;n++)if(e.isSet(r,n)){if(a=r+s,h=n+o,!t.hasXY(a,h)||t.isBoundaryXY(a,h))return!1;for(l=a-1;l<=a+1;l++)for(c=h-1;c<=h+1;c++)if(!t.isNothing(l,c))return!1}return!0}_attachDoor(t,e,i,s,r){const n=this.doors;let a=!1;n.chance&&o.random.chance(n.chance)&&(a=!0);const h=a?n.tile||T:E;if(t.setTile(i,s,h),e.hall&&1!=e.hall.width&&1!=e.hall.height)if(r===o.xy.UP||r===o.xy.DOWN){let e=!0,o=1;for(;e;)e=!1,t.isNothing(i-o,s)&&t.isSet(i-o,s-1)&&t.isSet(i-o,s+1)&&(t.setTile(i-o,s,h),e=!0),t.isNothing(i+o,s)&&t.isSet(i+o,s-1)&&t.isSet(i+o,s+1)&&(t.setTile(i+o,s,h),e=!0),++o}else{let e=!0,o=1;for(;e;)e=!1,t.isNothing(i,s-o)&&t.isSet(i-1,s-o)&&t.isSet(i+1,s-o)&&(t.setTile(i,s-o,h),e=!0),t.isNothing(i,s+o)&&t.isSet(i-1,s+o)&&t.isSet(i+1,s+o)&&(t.setTile(i,s+o,h),e=!0),++o}}addLoops(t,e){return new dt(e).create(t)}addLakes(t,e){return new at(e).create(t)}addBridges(t,e){return new lt(e).create(t)}addStairs(t,e){return new gt(e).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let e,i,s,r,n,a;do{for(a=!1,e=0;e<t.width-1;e++)for(i=0;i<t.height-1;i++)for(s=0;s<=1;s++)!t.blocksMove(e+s,i)&&t.blocksMove(e+(1-s),i)&&t.blocksDiagonal(e+(1-s),i)&&t.blocksMove(e+s,i+1)&&t.blocksDiagonal(e+s,i+1)&&!t.blocksMove(e+(1-s),i+1)&&(o.random.chance(50)?(r=e+(1-s),n=i):(r=e+s,n=i+1),a=!0,t.setTile(r,n,E))}while(1==a)}_finishDoors(t){o.xy.forRect(t.width,t.height,((e,i)=>{t.isBoundaryXY(e,i)||t.isDoor(e,i)&&((t.isFloor(e+1,i)||t.isFloor(e-1,i))&&(t.isFloor(e,i+1)||t.isFloor(e,i-1))||(t.blocksPathing(e+1,i)?1:0)+(t.blocksPathing(e-1,i)?1:0)+(t.blocksPathing(e,i+1)?1:0)+(t.blocksPathing(e,i-1)?1:0)>=3)&&t.setTile(e,i,E)}))}_finishWalls(t){const e=this.boundary?M:B;o.xy.forRect(t.width,t.height,((i,s)=>{t.isNothing(i,s)&&(t.isBoundaryXY(i,s)?t.setTile(i,s,e):t.setTile(i,s,B))}))}}const It=o.flag.fl;var mt;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=It(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=It(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=It(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=It(4)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=It(5)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=It(6)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=It(7)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=It(8)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=It(9)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=It(10)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=It(11)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=It(12)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=It(13)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=It(14)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=It(15)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=It(16)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=It(17)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=It(18)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=It(19)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=It(20)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=It(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=It(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=It(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=It(24)]="BF_IMPREGNABLE",t[t.BF_NOT_IN_HALLWAY=It(27)]="BF_NOT_IN_HALLWAY",t[t.BF_NOT_ON_LEVEL_PERIMETER=It(28)]="BF_NOT_ON_LEVEL_PERIMETER",t[t.BF_SKELETON_KEY=It(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=It(30)]="BF_KEY_DISPOSABLE"}(mt||(mt={}));class pt{constructor(t={}){var e;if(this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.id="n/a",this.tile=null!==(e=t.tile)&&void 0!==e?e:-1,t.flags&&(this.flags=o.flag.from(mt,t.flags)),t.pad&&(this.pad=t.pad),this.count=o.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.effect&&(this.effect=r.effect.from(t.effect)),this.item&&this.flags&mt.BF_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BF_ADOPT_ITEM.")}get repeatUntilNoProgress(){return!!(this.flags&mt.BF_REPEAT_UNTIL_NO_PROGRESS)}get permitBlocking(){return!!(this.flags&mt.BF_PERMIT_BLOCKING)}get treatAsBlocking(){return!!(this.flags&mt.BF_TREAT_AS_BLOCKING)}get adoptItem(){return!!(this.flags&mt.BF_ADOPT_ITEM)}get itemIsKey(){return!!(this.flags&mt.BF_ITEM_IS_KEY)}get keyIsDisposable(){return!!(this.flags&mt.BF_KEY_DISPOSABLE)}get outsourceItem(){return!!(this.flags&mt.BF_OUTSOURCE_ITEM_TO_MACHINE)}get impregnable(){return!!(this.flags&mt.BF_IMPREGNABLE)}get buildVestibule(){return!!(this.flags&mt.BF_BUILD_VESTIBULE)}get generateEverywhere(){return!!(this.flags&mt.BF_EVERYWHERE&~mt.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&mt.BF_BUILD_AT_ORIGIN)}}function Et(t,e){if(e.flags&(mt.BF_IN_VIEW_OF_ORIGIN|mt.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const i=t.site;if(e.flags&mt.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new o.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap[e][i]=1}))}else{new o.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e)||i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap[e][i]=1}))}t.viewMap[t.originX][t.originY]=1}}function Tt(t,e){const i=[0,1e4];return e.flags&mt.BF_NEAR_ORIGIN&&(i[1]=t.distance25),e.flags&mt.BF_FAR_FROM_ORIGIN&&(i[0]=t.distance75),i}function Rt(t,e,i,s,o){let r=0;return t.update(((t,n,a)=>Bt(e,i,s,n,a,o)?(r++,1):0)),r}function Bt(t,e,i,s,n,a){const h=t.site;if(i.flags&mt.BF_NOT_IN_HALLWAY&&o.xy.arcCount(s,n,((t,e)=>h.hasXY(t,e)&&h.isPassable(t,e)))>1)return!1;if(i.flags&mt.BF_NOT_ON_LEVEL_PERIMETER&&(0==s||s==h.width-1||0==n||n==h.height-1))return!1;if(i.flags&mt.BF_BUILD_AT_ORIGIN)return s==t.originX&&n==t.originY;if(e.isRoom&&s==t.originX&&n==t.originY)return!1;if(t.occupied[s][n])return!1;if(i.flags&(mt.BF_IN_VIEW_OF_ORIGIN|mt.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][n])return!1;let l=1e4;if(h.isWall(s,n)?o.xy.eachNeighbor(s,n,((e,i)=>{t.distanceMap.hasXY(e,i)&&!h.blocksPathing(e,i)&&l>t.distanceMap[e][i]+1&&(l=t.distanceMap[e][i]+1)}),!0):l=t.distanceMap[s][n],l>a[1]||l<a[0])return!1;if(i.flags&mt.BF_BUILD_IN_WALLS){const e=h.getMachine(s,n);if(!t.interior[s][n]&&(!e||e==t.machineNumber)&&h.isWall(s,n)){let e=!1;return o.xy.eachNeighbor(s,n,((s,o)=>{h.hasXY(s,o)&&(t.interior[s][o]&&(s!=t.originX||o!=t.originY)||i.flags&mt.BF_BUILD_ANYWHERE_ON_LEVEL&&!h.blocksPathing(s,o)&&!h.getMachine(s,o))&&(e=!0)})),e}return!1}return!h.isWall(s,n)&&(i.flags&mt.BF_BUILD_ANYWHERE_ON_LEVEL?!(i.item&&h.blocksItems(s,n)||h.hasCellFlag(s,n,r.flags.Cell.IS_CHOKEPOINT|r.flags.Cell.IS_IN_LOOP|r.flags.Cell.IS_IN_MACHINE)):!!t.interior[s][n])}function Ot(t,e,i,s,o){let r=0;for(let n=e-o+1;n<=e+o-1;n++)for(let e=i-o+1;e<=i+o-1;e++)t.site.hasXY(n,e)&&(s[n][e]&&(s[n][e]=0,++r),t.occupied[n][e]=1);return r}const wt=o.flag.fl;var Lt;!function(t){t[t.BP_ROOM=wt(0)]="BP_ROOM",t[t.BP_VESTIBULE=wt(1)]="BP_VESTIBULE",t[t.BP_REWARD=wt(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=wt(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=wt(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=wt(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=wt(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=wt(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=wt(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=wt(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=wt(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=wt(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=wt(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=wt(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=wt(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=wt(15)]="BP_NOT_IN_HALLWAY"}(Lt||(Lt={}));class Nt{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=o.frequency.make(t.frequency||100),t.size){if(this.size=o.range.make(t.size),this.size.lo>this.size.hi)throw new Error("Blueprint size must be small to large.")}else this.size=o.range.make([1,1]);if(t.flags&&(this.flags=o.flag.from(Lt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new pt(t)))),this.flags&Lt.BP_ADOPT_ITEM&&!this.steps.some((t=>t.flags&mt.BF_ADOPT_ITEM)))throw new Error("Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.")}getChance(t,e){return e&&e.length&&("string"==typeof e&&(e=e.split(/[,|]/).map((t=>t.trim()))),!e.every((t=>this.tags.includes(t))))?0:this.frequency(t)}get isRoom(){return!!(this.flags&Lt.BP_ROOM)}get isReward(){return!!(this.flags&Lt.BP_REWARD)}get isVestiblue(){return!!(this.flags&Lt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&Lt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&Lt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&Lt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&Lt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&Lt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&Lt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&Lt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&Lt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&Lt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&Lt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&Lt.BP_NO_INTERIOR_FLAG)}qualifies(t,e){return!(this.frequency(e)<=0||~this.flags&t||this.flags&Lt.BP_ADOPT_ITEM&~t||this.flags&Lt.BP_VESTIBULE&~t)}pickLocation(t){return At(t,this)}pickComponents(){const t=[mt.BF_ALTERNATIVE,mt.BF_ALTERNATIVE_2],e=new Array(this.steps.length).fill(!0);for(let i=0;i<=1;i++){let s=0;for(let o=0;o<e.length;o++)this.steps[o].flags&t[i]&&(e[o]=!1,s++);if(s>0){let r=o.random.range(1,s);for(let s=0;s<e.length;s++)if(this.steps[s].flags&t[i]){if(1==r){e[s]=!0;break}r--}}}return this.steps.filter(((t,i)=>e[i]))}}function At(t,e){if(e.isRoom){const i=o.random.matchingLoc(t.width,t.height,((i,s)=>t.hasCellFlag(i,s,r.flags.Cell.IS_GATE_SITE)&&e.size.contains(t.getChokeCount(i,s))));return!i||i[0]<0||i[1]<0?(console.log("Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint."),!1):i}if(e.isVestiblue)return console.log("ERROR: Attempted to build a vestiblue without a location being provided."),!1;const i=o.random.matchingLoc(t.width,t.height,((i,s)=>{if(!t.isPassable(i,s))return!1;if(e.flags&Lt.BP_NOT_IN_HALLWAY){return o.xy.arcCount(i,s,((e,i)=>t.isPassable(e,i)))<=1}return!0}));return!(!i||i[0]<0||i[1]<0)&&i}function Mt(t,e){let i=!0;const s=t.site,r=t.interior;r.fill(0);const n=s.getChokeCount(t.originX,t.originY),a=[-1,-1];let h=n;o.xy.eachNeighbor(t.originX,t.originY,((t,e)=>{const i=s.getChokeCount(t,e);i!=n&&(i>1e4||i<0||(a[0]=t,a[1]=e,h=i))}),!0);const l=h-n;if(e.size.contains(l)){const t=r.floodFill(a[0],a[1],((t,e,o)=>(s.isOccupied(e,o)&&(i=!1),s.getChokeCount(e,o)===h)),1);if(i&&e.size.contains(t))return!0}let c=0;const g=e.size.value(),_=o.grid.alloc(s.width,s.height);u(s,_,t.originX,t.originY,e.size.hi);const I=o.random.sequence(s.width*s.height);i=!0;for(let t=0;t<1e3&&c<g;t++)for(let e=0;e<I.length&&c<g;++e){const o=Math.floor(I[e]/s.height),a=I[e]%s.height;_[o][a]==t&&(s.isOccupied(o,a)&&(i=!1,c=g),s.getChokeCount(o,a)<=n||(r[o][a]=1,c+=1))}return e.treatAsBlocking&&f(s,r,{machine:s.machineCount})?(i=!1,console.debug("- blocks")):e.requireBlocking&&d(s,r)<100&&(i=!1,console.debug("- does not block")),o.grid.free(_),i}function yt(t,e,i){let s=!0;const n=t.interior,a=t.site;n[e][i]=1;const h=a.getChokeCount(e,i);for(let l=0;l<4&&s;l++){const c=e+o.xy.DIRS[l][0],g=i+o.xy.DIRS[l][1];if(a.hasXY(c,g)&&!n[c][g]){if(a.isOccupied(c,g)||a.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)&&!a.hasCellFlag(c,g,r.flags.Cell.IS_GATE_SITE))return!1;a.getChokeCount(c,g)<=h&&!a.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)&&(s=yt(t,c,g))}}return s}function bt(t,e=1){let i;const s=t.interior,n=t.site;do{i=!1,s.forEach(((t,a,h)=>{if(n.hasCellFlag(a,h,r.flags.Cell.IS_IN_MACHINE))return;if(!n.blocksPathing(a,h))return;let l=0;o.xy.eachNeighbor(a,h,((t,e)=>{s.hasXY(t,e)&&s[t][e]&&!n.blocksPathing(t,e)&&++l}),!1),l<e||(l=0,o.xy.eachNeighbor(a,h,((t,e)=>{s.hasXY(t,e)&&(s[t][e]||n.isWall(t,e)&&!n.hasCellFlag(t,e,r.flags.Cell.IS_IN_MACHINE)||++l)}),!1),l||(i=!0,s[a][h]=1,n.blocksPathing(a,h)&&n.setTile(a,h,E),o.xy.eachNeighbor(a,h,((t,e)=>{s.hasXY(t,e)&&(n.isSet(t,e)||n.setTile(t,e,B))}))))}))}while(i)}const St={};function Dt(t,e){const i=Object.values(St).filter((i=>i.qualifies(t,e)));return o.random.item(i)}class Ft{constructor(t,e){this.map=t,this.spawnedItems=[],this.spawnedHordes=[],this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.depth=0,this.site=new D(t),this.interior=o.grid.alloc(t.width,t.height),this.occupied=o.grid.alloc(t.width,t.height),this.viewMap=o.grid.alloc(t.width,t.height),this.distanceMap=o.grid.alloc(t.width,t.height),this.depth=e}free(){o.grid.free(this.interior),o.grid.free(this.occupied),o.grid.free(this.viewMap),o.grid.free(this.distanceMap)}reset(t,e){this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=t,this.originY=e}calcDistances(t){this.distanceMap.fill(0),u(this.site,this.distanceMap,this.originX,this.originY,t);let e=0;const i=new Array(100).fill(0);this.interior.forEach(((t,s,o)=>{if(!t)return;const r=this.distanceMap[s][o];r<100&&(i[r]++,e++)}));let s=Math.round(e/4),o=Math.round(3*e/4);for(let t=0;t<100;t++){if(s<=i[t]){s=t;break}s-=i[t]}for(let t=0;t<100;t++){if(o<=i[t]){o=t;break}o-=i[t]}this.distance25=s,this.distance75=o}}var Pt=Object.freeze({__proto__:null,get Flags(){return Lt},Blueprint:Nt,install:function(t,e){return e instanceof Nt||(e=new Nt(e)),St[t]=e,e.id=t,e},random:Dt,blueprints:St,get StepFlags(){return mt},BuildStep:pt,updateViewMap:Et,calcDistanceBound:Tt,markCandidates:Rt,cellIsCandidate:Bt,makePersonalSpace:Ot,BuildData:Ft,Builder:class{constructor(t,e){this.data=new Ft(t,e)}async buildRandom(t=Lt.BP_ROOM,e=-1,i=-1,s=null){this.data.site.analyze();let o=[];for(;o.length<10;){const r=Dt(t,this.data.depth);if(!r)return!1;if(o.push(r.id),await this._buildAt(r,e,i,s))return!0}return!1}async build(t,e=-1,i=-1,s=null){if("string"==typeof t){const e=t;if(!(t=St[e]))throw new Error("Failed to find blueprint - "+e)}return this.data.site.analyze(),this._buildAt(t,e,i,s)}async _buildAt(t,e=-1,i=-1,s=null){if(e>=0&&i>=0)return await this._build(t,e,i,s);let o=10;for(;o--;){const e=await this.pickLocation(t);if(e&&await this._build(t,e[0],e[1],s))return!0}return!1}async _build(t,e,i,s=null){const n=this.data;if(n.reset(e,i),!await this.computeInterior(t))return!1;const a=n.site.backup();n.machineNumber=n.site.nextMachineId(),function(t,e){const i=t.interior,s=t.site;e.maximizeInterior?bt(t,1):e.openInterior&&bt(t,4),e.purgeInterior&&i.forEach(((t,e,i)=>{t&&s.setTile(e,i,E)})),e.purgeBlockers&&i.forEach(((t,e,i)=>{t&&s.blocksPathing(e,i)&&s.setTile(e,i,E)})),e.purgeLiquids&&i.forEach(((t,e,i)=>{t&&s.isAnyLiquid(e,i)&&s.setTile(e,i,E)})),e.surroundWithWalls&&i.forEach(((t,e,n)=>{t&&!s.hasCellFlag(e,n,r.flags.Cell.IS_GATE_SITE)&&o.xy.eachNeighbor(e,n,((t,e)=>{i.hasXY(t,e)&&(i[t][e]||s.isWall(t,e)||s.hasCellFlag(t,e,r.flags.Cell.IS_GATE_SITE)||s.hasCellFlag(t,e,r.flags.Cell.IS_IN_MACHINE)||s.blocksPathing(t,e)&&s.setTile(t,e,B))}),!1)})),e.makeImpregnable&&i.forEach(((t,e,n)=>{t&&!s.hasCellFlag(e,n,r.flags.Cell.IS_GATE_SITE)&&(s.setCellFlag(e,n,r.flags.Cell.IMPREGNABLE),o.xy.eachNeighbor(e,n,((t,e)=>{i.hasXY(t,e)&&(i[t][e]||s.hasCellFlag(t,e,r.flags.Cell.IS_GATE_SITE)||s.setCellFlag(t,e,r.flags.Cell.IMPREGNABLE))}),!1))}));const n=t.machineNumber;i.forEach(((t,i,o)=>{t&&(e.flags&Lt.BP_NO_INTERIOR_FLAG||s.setMachine(i,o,n,e.isRoom),s.isSecretDoor(i,o)&&s.setTile(i,o,T))}))}(n,t),this.data.calcDistances(t.size.hi);const h=t.pickComponents();for(let e=0;e<h.length;e++){const i=h[e];if(!await this.buildComponent(t,i,s))return n.site.restore(a),!1}return t.noInteriorFlag&&_(n.site,this.data.machineNumber),!0}async pickLocation(t){return At(this.data.site,t)}async computeInterior(t){return function(t,e){let i,s=e.isRoom?10:20;const n=t.interior,a=t.site;do{if(i=!1,--s<=0)return!1;if(n.fill(0),e.isRoom)i=!yt(t,t.originX,t.originY);else if(e.isVestiblue){if(!Mt(t,e))return console.log(`ERROR: Attempted to build vestibule ${e.id}: not enough room.`),!1}else{let s=o.grid.alloc(n.width,n.height);u(a,s,t.originX,t.originY,e.size.hi);const h=o.random.sequence(a.width*a.height);let l=0,c=e.size.value();for(let t=0;t<1e3&&l<c;t++)for(let e=0;e<h.length&&l<c;e++){const o=Math.floor(h[e]/a.height),g=h[e]%a.height;s[o][g]==t&&(n[o][g]=1,l++,(a.isOccupied(o,g)||a.hasCellFlag(o,g,r.flags.Cell.IS_IN_MACHINE))&&(i=!0,l=c))}l<c?(i=!0,console.debug("- too small")):e.treatAsBlocking&&f(a,n,{machine:a.machineCount})?(console.debug(" - disconnected"),i=!0):e.requireBlocking&&d(a,n)<100&&(console.debug(" - not disconnected enough"),i=!0),o.grid.free(s)}}while(i);return!0}(this.data,t)}async buildComponent(t,e,i){let s=0,n=0;const a=this.data,h=a.site,l=o.grid.alloc(h.width,h.height),c=Tt(a,e);Et(a,e);let f=Rt(l,a,t,e,c);if(e.generateEverywhere||(s=e.count.value()),!f||f<e.count.lo)return!1;let d=0,u=0,_=!0,I=!1;do{if(_=!0,e.buildAtOrigin?(d=a.originX,u=a.originY):[d,u]=o.random.matchingLoc(l.width,l.height,((t,e)=>l[t][e]>0)),l[d][u]=0,f--,e.effect&&(_=h.fireEffect(e.effect,d,u),I=_),_&&-1!==e.tile){const t=r.tile.get(e.tile);e.permitBlocking||!t.blocksMove()&&!e.treatAsBlocking||(_=!g(h,d,u,{machine:h.machineCount})),_&&(_=h.setTile(d,u,t),I=I||_)}if(_&&e.item){const t=h.makeRandomItem(e.item);t||(_=!1),e.itemIsKey&&(t.key=r.entity.makeKeyInfo(d,u,!!e.keyIsDisposable)),e.outsourceItem?(_=await this.buildRandom(Lt.BP_ADOPT_ITEM,-1,-1,t),_&&(I=!0)):(_=h.addItem(d,u,t),I=I||_)}else if(_&&e.adoptItem){if(!i)throw new Error("Failed to build blueprint because there is no adopted item.");e.treatAsBlocking&&(_=!g(h,d,u)),_&&(_=h.addItem(d,u,i),_?I=!0:console.log("- failed to add item",d,u))}_&&I&&(f-=Ot(a,d,u,l,e.pad),n++,t.noInteriorFlag||h.setMachine(d,u,a.machineNumber,t.isRoom),e.impregnable&&h.setCellFlag(d,u,r.flags.Cell.IMPREGNABLE))}while(f>0&&(e.generateEverywhere||n<s||e.repeatUntilNoProgress));if(_&&e.buildVestibule){if(_=await this.buildRandom(Lt.BP_VESTIBULE,a.originX,a.originY),!_)return!1;++n}return _=n>0,o.grid.free(l),_}}});t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],o.object.setOptions(this.config,t),this.config.seed&&o.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=o.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const e=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let i=0;i<this.config.levels;++i){const i=o.random.matchingLoc(this.config.width,this.config.height,((i,s)=>o.xy.distanceBetween(t[0],t[1],i,s)>e));this.stairLocs.push([[t[0],t[1]],[i[0],i[1]]]),t=i}}getLevel(t,e){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);o.random.seed(this.seeds[t]);const[i,s]=this.stairLocs[t],r=Object.assign({},this.config.stairs);this.config.goesUp?(r.down=i,r.up=s,0==t&&this.config.startTile&&(r.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.upTile=this.config.endTile)):(r.down=s,r.up=i,0==t&&this.config.startTile&&(r.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.downTile=this.config.endTile));const n=Object.assign({},this.config.rooms);0===t&&n.entrance&&(n.first=n.entrance);const a={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:n,stairs:r,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,a,e)}makeLevel(t,e,i){const s=new _t(e),r=s.create(this.config.width,this.config.height,i);return o.xy.equalsXY(s.endLoc,e.endLoc)&&o.xy.equalsXY(s.startLoc,e.startLoc)||(this.stairLocs[t]=[s.startLoc,s.endLoc]),r}},t.Hall=P,t.Level=_t,t.Room=x,t.blueprint=Pt,t.bridge=ct,t.hall=nt,t.lake=ht,t.loop=ut,t.makeHall=C,t.room=Q,t.site=F,t.stairs=ft,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

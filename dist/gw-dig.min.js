!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";class s{constructor(t,s,e,o=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const r=i.utils.DIRS[s];this.length=e,this.width=o,s===i.utils.UP||s===i.utils.DOWN?(this.x2=this.x+(o-1),this.y2=this.y+(e-1)*r[1]):(this.x2=this.x+(e-1)*r[0],this.y2=this.y+(o-1)),this.dir=s}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((s=>{s&&(s[0]<0||s[1]<0||(s[0]+=t,s[1]+=i))}))}}class e extends i.utils.Bounds{constructor(t,i,s,e){super(t,i,s,e),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((s=>{s&&(s[0]<0||s[1]<0||(s[0]+=t,s[1]+=i))})),this.hall&&this.hall.translate(t,i)}}const o=i.utils.DIRS;function r(t,s,e){let r,n,h,a,l,c;for(n=i.utils.NO_DIRECTION,r=0;r<4;r++)if(h=s+o[r][0],a=e+o[r][1],l=s-o[r][0],c=e-o[r][1],t.hasXY(l,c)&&t.hasXY(h,a)&&t.isFloor(l,c)){if(n!=i.utils.NO_DIRECTION)return i.utils.NO_DIRECTION;n=r}return n}function n(t){let s,e,o,n,h,a,l;const c=[[],[],[],[]],u=t.height,g=t.width;for(s=0;s<g;s++)for(e=0;e<u;e++)if(t.isDiggable(s,e)&&(a=r(t,s,e),a!=i.utils.NO_DIRECTION)){for(n=s+i.utils.DIRS[a][0],h=e+i.utils.DIRS[a][1],l=!1,o=0;o<10&&t.hasXY(n,h)&&!l;o++)t.isSet(n,h)&&(l=!0),n+=i.utils.DIRS[a][0],h+=i.utils.DIRS[a][1];l||c[a].push([s,e])}let f=[];for(a=0;a<4;a++){const t=i.random.item(c[a])||[-1,-1];f[a]=[t[0],t[1]]}return f}function h(t,s,e=0,o=0){i.utils.forRect(t.width,t.height,((i,r)=>{const n=i-e,h=r-o,a=s.getTile(n,h);a&&t.setTile(i,r,a)}))}var a={__proto__:null,directionOfDoorSite:r,chooseRandomDoorSites:n,copySite:h};const l={0:"NULL",1:"FLOOR",2:"DOOR",3:"WALL",8:"IMPREGNABLE",4:"LAKE",5:"SHALLOW",6:"BRIDGE",7:"UP_STAIRS",17:"DOWN_STAIRS"},c=[];function u(t){c.length=t;for(let i=0;i<t;++i)c[i]=i;i.random.shuffle(c)}function g(t,s){s.update(((s,e,o)=>t.isPassable(e,o)?1:i.path.OBSTRUCTION))}const f=i.flag.fl;var d;!function(t){t[t.IS_IN_LOOP=f(0)]="IS_IN_LOOP",t[t.IS_CHOKEPOINT=f(1)]="IS_CHOKEPOINT",t[t.IS_GATE_SITE=f(2)]="IS_GATE_SITE",t[t.IS_IN_ROOM_MACHINE=f(3)]="IS_IN_ROOM_MACHINE",t[t.IS_IN_AREA_MACHINE=f(4)]="IS_IN_AREA_MACHINE",t[t.IMPREGNABLE=f(5)]="IMPREGNABLE",t[t.IS_IN_MACHINE=t.IS_IN_ROOM_MACHINE|t.IS_IN_AREA_MACHINE]="IS_IN_MACHINE"}(d||(d={}));class _{constructor(t,s){this.tiles=i.grid.alloc(t,s),this.flags=i.grid.alloc(t,s),this.choke=i.grid.alloc(t,s)}free(){i.grid.free(this.tiles),i.grid.free(this.flags),i.grid.free(this.choke)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return 0===this.tiles.get(t,i)}isDiggable(t,i){return 0===this.tiles.get(t,i)}isFloor(t,i){return 1==this.tiles.get(t,i)}isDoor(t,i){return 2===this.tiles.get(t,i)}isBridge(t,i){return 6===this.tiles.get(t,i)}isWall(t,i){const s=this.tiles.get(t,i);return 3===s||8===s}isObstruction(t,i){return this.isNothing(t,i)||this.isWall(t,i)}isStairs(t,i){const s=this.tiles.get(t,i);return 7===s||17===s}isDeep(t,i){return 4===this.tiles.get(t,i)}isShallow(t,i){return 5===this.tiles.get(t,i)}isAnyWater(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTile(t,i){return this.tiles.get(t,i)||0}setTile(t,i,s){this.tiles.hasXY(t,i)&&(this.tiles[t][i]=s)}hasSiteFlag(t,i,s){return!!((this.flags.get(t,i)||0)&s)}setSiteFlag(t,i,s){const e=(this.flags.get(t,i)||0)|s;this.flags.set(t,i,e)}clearSiteFlag(t,i,s){const e=(this.flags.get(t,i)||0)&~s;this.flags.set(t,i,e)}getChokeCount(t,i){return this.choke.get(t,i)||0}setChokeCount(t,i,s){this.choke.set(t,i,s)}}var p={__proto__:null,NOTHING:0,FLOOR:1,DOOR:2,WALL:3,DEEP:4,SHALLOW:5,BRIDGE:6,UP_STAIRS:7,DOWN_STAIRS:17,IMPREGNABLE:8,TILEMAP:l,SEQ:c,initSeqence:u,fillCostGrid:g,get Flags(){return d},GridSite:_};function m(t,s={}){return t=t||{},s=s||{},Object.entries(s).forEach((([s,e])=>{let o=t[s];if("tile"===s)return void(void 0===o&&(t[s]=e));if(!0===e){if(!o)throw new Error("Missing required config for room digger: "+s)}else o=("number"==typeof e||Array.isArray(e),o||e);const r=i.range.make(o);t[s]=r})),t}class I{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=m(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=n(t))),i}}var w={};class S extends I{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,s={}){const e=t.choices||s.choices;if(Array.isArray(e))this.randomRoom=i.random.item.bind(i.random,e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=i.random.weighted.bind(i.random,e)}}carve(t){let s=this.randomRoom();const e=w[s];return e||i.utils.ERROR("Missing room digger choice: "+s),e.create(t)}}class O extends I{constructor(t={}){super(t,{width:12,height:8})}carve(t){const s=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,n=i.grid.alloc(t.width,t.height,0),h=Math.floor(.5*s),a=s,l=Math.floor(.5*o),c=o,u=new i.blob.Blob({rounds:5,minWidth:h,minHeight:l,maxWidth:a,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(n.width,n.height,((t,i)=>n[t][i]=1)),g=Math.floor((t.width-u.width)/2),f=g-u.x,d=Math.floor((t.height-u.height)/2),_=d-u.y;return n.forEach(((i,s,e)=>{i&&t.setTile(s+f,e+_,r)})),i.grid.free(n),new e(g,d,u.width,u.height)}}class R extends I{constructor(t={}){super(t,{width:20,height:10})}carve(t){const s=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,n=Math.floor(.4*s),h=o,a=s,l=Math.floor(.5*o),c=Math.floor(t.width/2-n/2-1),u=t.height-h-2,g=Math.floor(t.width/2-a/2-1),f=t.height-l-2;i.utils.forRect(c,u,n,h,((i,s)=>t.setTile(i,s,r))),i.utils.forRect(g,f,a,l,((i,s)=>t.setTile(i,s,r)));const d=new e(Math.min(c,g),Math.min(u,f),Math.max(n,a),Math.max(h,l));return d.doors[i.utils.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class E extends I{constructor(t={}){super(t,{width:12,height:20})}carve(t){const s=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,n=s,h=Math.max(3,Math.floor(s*i.random.range(25,75)/100)),a=Math.max(3,Math.floor(o*i.random.range(25,75)/100)),l=o,c=Math.floor((t.width-n)/2),u=c+i.random.range(2,Math.max(2,n-h-2)),g=Math.floor((t.height-l)/2),f=g+i.random.range(2,Math.max(2,l-a-2));return i.utils.forRect(c,f,n,a,((i,s)=>t.setTile(i,s,r))),i.utils.forRect(u,g,h,l,((i,s)=>t.setTile(i,s,r))),new e(c,g,Math.max(n,h),Math.max(a,l))}}class T extends I{constructor(t={}){super(t,{width:7,height:7})}carve(t){const s=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1;let n=Math.max(3,Math.floor(s*i.random.range(25,50)/100)),h=Math.max(3,Math.floor(o*i.random.range(25,50)/100));const a=Math.floor((t.width-s)/2),l=Math.floor((t.height-h)/2);i.utils.forRect(a,l,s,h,((i,s)=>t.setTile(i,s,r)));const c=Math.floor((t.width-n)/2),u=Math.floor((t.height-o)/2);return i.utils.forRect(c,u,n,o,((i,s)=>t.setTile(i,s,r))),new e(Math.min(a,c),Math.min(l,u),Math.max(s,n),Math.max(o,h))}}class L extends I{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const s=this.options.width.value(),o=this.options.height.value(),r=this.options.tile||1,n=Math.floor((t.width-s)/2),h=Math.floor((t.height-o)/2);return i.utils.forRect(n,h,s,o,((i,s)=>t.setTile(i,s,r))),new e(n,h,s,o)}}class M extends I{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const s=this.options.radius.value(),o=this.options.tile||1,r=Math.floor(t.width/2),n=Math.floor(t.height/2);return s>1&&i.utils.forCircle(r,n,s,((i,s)=>t.setTile(i,s,o))),new e(r-s,n-s,2*s+1,2*s+1)}}class N extends I{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const s=this.options.radius.value(),o=this.options.ringMinWidth.value(),r=this.options.holeMinSize.value(),n=this.options.tile||1,h=Math.floor(t.width/2),a=Math.floor(t.height/2);return i.utils.forCircle(h,a,s,((i,s)=>t.setTile(i,s,n))),s>o+r&&i.random.chance(this.options.holeChance.value())&&i.utils.forCircle(h,a,i.random.range(r,s-r),((i,s)=>t.setTile(i,s,0))),new e(h-s,a-s,2*s+1,2*s+1)}}class D extends I{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let s,o,r,n=this.options.count.value();const h=this.options.width.value(),a=this.options.height.value(),l=this.options.tile||1,c=Math.floor(t.width/2)-Math.floor(h/2),u=Math.floor(t.width/2)+Math.floor(h/2),g=Math.floor(t.height/2)-Math.floor(a/2),f=Math.floor(t.height/2)+Math.floor(a/2);let d=Math.floor(t.width/2),_=d,p=Math.floor(t.height/2),m=p;for(i.utils.forCircle(d,p,2,((i,s)=>t.setTile(i,s,l))),d-=2,_+=2,p-=2,m+=2,s=0;s<n;)if(o=i.random.range(c,u),r=i.random.range(g,f),t.isSet(o,r)){if(o-2<c)continue;if(o+2>u)continue;if(r-2<g)continue;if(r+2>f)continue;d=Math.min(o-2,d),_=Math.max(o+2,_),p=Math.min(r-2,p),m=Math.max(r+2,m),i.utils.forCircle(o,r,2,((i,s)=>t.setTile(i,s,l))),s++}return new e(d,p,_-d+1,m-p+1)}}function C(t,i){return w[t]=i,i}C("DEFAULT",new L);var P={__proto__:null,checkConfig:m,RoomDigger:I,rooms:w,ChoiceRoom:S,choiceRoom:function(t,i){return new S(t).create(i)},Cavern:O,cavern:function(t,i){return new O(t).create(i)},BrogueEntrance:R,brogueEntrance:function(t,i){return new R(t).create(i)},Cross:E,cross:function(t,i){return new E(t).create(i)},SymmetricalCross:T,symmetricalCross:function(t,i){return new T(t).create(i)},Rectangular:L,rectangular:function(t,i){return new L(t).create(i)},Circular:M,circular:function(t,i){return new M(t).create(i)},BrogueDonut:N,brogueDonut:function(t,i){return new N(t).create(i)},ChunkyRoom:D,chunkyRoom:function(t,i){return new D(t).create(i)},install:C};const b=i.utils.DIRS;function A(t,i,s){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const e=[i[0]-s[0],i[1]-s[1]];return!!t.hasXY(e[0],e[1])&&!!t.isFloor(e[0],e[1])}function y(t,s){return t==i.utils.UP||t==i.utils.DOWN?s[1].value():s[0].value()}function B(t,s,e){let o=i.utils.NO_DIRECTION;if(o==i.utils.NO_DIRECTION){const r=i.random.sequence(4);for(let n=0;n<4;n++){o=r[n];const h=e[(n+1)%2].hi,a=s[o];if(a&&-1!=a[0]&&-1!=a[1]){const i=a[0]+Math.floor(b[o][0]*h),s=a[1]+Math.floor(b[o][1]*h);if(t.hasXY(i,s))break}o=i.utils.NO_DIRECTION}}return o}function v(t,s,e,o,r){let n,h;const a=i.random.chance(r),l=[];for(let i=0;i<4;i++)n=s+b[i][0],h=e+b[i][1],i!=o&&!a||!t.hasXY(n,h)||t.isSet(n,h)||(l[i]=[n,h]);return l}class x{constructor(t={}){this.config={width:i.range.make(1),length:[i.range.make("2-15"),i.range.make("2-9")],tile:1,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=i.range.make(t.width)),t.length&&"number"==typeof t.length){const s=i.range.make(t.length);this.config.length=[s,s]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,s=[]){if(s=s||n(t),!i.random.chance(this.config.chance))return null;const e=B(t,s,this.config.length);if(e===i.utils.NO_DIRECTION)return null;if(!s[e])return null;const o=this.config.width.value(),r=y(e,this.config.length),h=s[e];return 1==o?this.dig(t,e,h,r):this.digWide(t,e,h,r,o)}_digLine(t,i,s,e){let o=i[0],r=i[1];const n=this.config.tile;for(let i=0;i<e;i++)t.setTile(o,r,n),o+=s[0],r+=s[1];return o-=s[0],r-=s[1],[o,r]}dig(t,i,e,o){const r=b[i],[n,h]=this._digLine(t,e,r,o),a=new s(e,i,o);return a.doors=v(t,n,h,i,this.config.obliqueChance),a}digWide(t,e,o,r,n){const h=i.utils.DIRS[e],a=[o[0]-h[1],o[1]-h[0]],l=[o[0]+h[1],o[1]+h[0]];this._digLine(t,o,h,r);let c=1,u=o[0],g=o[1];c<n&&A(t,a,h)&&(this._digLine(t,a,h,r),u=Math.min(a[0],u),g=Math.min(a[1],g),++c),c<n&&A(t,l,h)&&(this._digLine(t,l,h,r),u=Math.min(l[0],u),g=Math.min(l[1],g),++c);const f=new s([u,g],e,r,n);return f.doors=[],f.doors[e]=[o[0]+r*h[0],o[1]+r*h[1]],f.width=n,f}}function F(t,i,s){return new x(t).create(i,s)}var X={};function k(t,i){return X[t]=i,i}k("DEFAULT",new x({chance:15}));var Y={__proto__:null,isDoorLoc:A,pickWidth:function(t={}){return i.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let s=t.width;if("number"==typeof s)return s;s=Array.isArray(s)?i.random.weighted(s)+1:"string"==typeof s?i.range.make(s).value():Number.parseInt(i.random.weighted(s));return s}(t),1,3)},pickLength:y,pickHallDirection:B,pickHallExits:v,HallDigger:x,dig:F,halls:X,install:k};class W{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:5,wreathChance:50,wreathSize:1,tile:4},Object.assign(this.options,t)}create(t){let s,e,o,r,n,h,a,l,c,u,g,f=0;h=this.options.height||15,a=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,u=this.options.count||1,g=this.options.canDisrupt||!1;const d=!!i.random.chance(this.options.wreathChance),_=this.options.wreathTile||5,p=this.options.wreathSize||1,m=this.options.tile||4,I=i.grid.alloc(t.width,t.height,0);let w=0;for(;w<u&&f<u;){const S=Math.round((a-l)*(u-w)/u)+l,O=Math.round((h-l)*(u-w)/u)+l,R=new i.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:S,maxHeight:O,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(I.width,I.height,((t,i)=>I[t][i]=1));let E=!1;for(o=0;o<c&&!E;o++)if(r=i.random.range(1-R.x,I.width-R.width-R.x-2),n=i.random.range(1-R.y,I.height-R.height-R.y-2),g||!this.isDisruptedBy(t,I,-r,-n)){for(E=!0,s=0;s<R.width;s++)for(e=0;e<R.height;e++)if(I[s+R.x][e+R.y]){const o=s+R.x+r,h=e+R.y+n;t.setTile(o,h,m),d&&i.utils.forCircle(o,h,p,((i,s)=>{t.isPassable(i,s)&&t.setTile(i,s,_)}))}break}E?++f:++w}return i.grid.free(I),f}isDisruptedBy(t,s,e=0,o=0){const r=i.grid.alloc(t.width,t.height);let n=!1;i.utils.forRect(t.width,t.height,((i,h)=>{const a=i+e,l=h+o;s.get(a,l)?t.isStairs(i,h)&&(n=!0):t.isPassable(i,h)&&(r[i][h]=1)}));let h=!0;for(let t=0;t<r.width&&!n;++t)for(let i=0;i<r.height&&!n;++i)1==r[t][i]&&(h?(r.floodFill(t,i,1,2),h=!1):n=!0);return i.grid.free(r),n}}var G={__proto__:null,Lakes:W};class U{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let s,e,o,r,n,h,a,l=0;const c=this.options.maxLength,u=this.options.minDistance,g=i.grid.alloc(t.width,t.height),f=i.grid.alloc(t.width,t.height),d=[[1,0],[0,1]];f.update(((s,e,o)=>t.isPassable(e,o)?1:i.path.OBSTRUCTION));const _=i.random.sequence(t.width*t.height);for(o=0;o<_.length;o++)if(h=Math.floor(_[o]/t.height),a=_[o]%t.height,t.isPassable(h,a)&&!t.isAnyWater(h,a))for(n=0;n<=1;n++){const o=d[n];if(s=h+o[0],e=a+o[1],r=c,t.isAnyWater(s,e))for(r=0;r<c&&(s+=o[0],e+=o[1],t.isAnyWater(s,e));++r);if(t.isPassable(s,e)&&r<c&&(i.path.calculateDistances(g,s,e,f,!1),g[h][a]>u&&g[h][a]<i.path.NO_PATH)){for(;h!==s||a!==e;)this.isBridgeCandidate(t,h,a,o)?(t.setTile(h,a,6),f[h][a]=1):(t.setTile(h,a,1),f[h][a]=1),h+=o[0],a+=o[1];++l;break}}return i.grid.free(g),i.grid.free(f),l}isBridgeCandidate(t,i,s,e){return!!t.isBridge(i,s)||!!t.isAnyWater(i,s)&&(!!t.isAnyWater(i+e[1],s+e[0])&&!!t.isAnyWater(i-e[1],s-e[0]))}}var H={__proto__:null,Bridges:U};class K{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:7,downTile:17,wall:8},Object.assign(this.options,t)}create(t){let s=!1!==this.options.up,e=!1!==this.options.down;const o=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),r={};let n,h;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let s=this.options.start;s=!0===s?i.random.matchingXY(t.width,t.height,a):i.random.matchingXYNear(i.utils.x(s),i.utils.y(s),a),r.start=s}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;n=i.random.matchingXYNear(i.utils.x(t),i.utils.y(t),a);const s=this.options.down;h=i.random.matchingXYNear(i.utils.x(s),i.utils.y(s),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const s=this.options.up;n=i.random.matchingXYNear(i.utils.x(s),i.utils.y(s),a),e&&(h=i.random.matchingXY(t.width,t.height,((t,s)=>!(i.utils.distanceBetween(t,s,n[0],n[1])<o)&&a(t,s))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;h=i.random.matchingXYNear(i.utils.x(e),i.utils.y(e),a),s&&(n=i.random.matchingXY(t.width,t.height,((t,s)=>!(i.utils.distanceBetween(t,s,h[0],h[1])<o)&&a(t,s))))}else s?(n=i.random.matchingXY(t.width,t.height,a),e&&(h=i.random.matchingXY(t.width,t.height,((t,s)=>!(i.utils.distanceBetween(t,s,n[0],n[1])<o)&&a(t,s))))):e&&(h=i.random.matchingXY(t.width,t.height,a));return n&&(r.up=n.slice(),this.setupStairs(t,n[0],n[1],this.options.upTile),"up"===this.options.start&&(r.start=r.up)),void 0!==h&&(r.down=h.slice(),this.setupStairs(t,h[0],h[1],this.options.downTile),"down"===this.options.start&&(r.start=r.down)),n||h?r:null}hasXY(t,i,s){return!(i<0||s<0)&&!(i>=t.width||s>=t.height)}isStairXY(t,s,e){let o=0;if(!this.hasXY(t,s,e)||!t.isDiggable(s,e))return!1;for(let r=0;r<4;++r){const n=i.utils.DIRS[r];if(!this.hasXY(t,s+n[0],e+n[1]))return!1;if(!this.hasXY(t,s-n[0],e-n[1]))return!1;if(t.isFloor(s+n[0],e+n[1])){if(o+=1,!t.isDiggable(s-n[0]+n[1],e-n[1]+n[0]))return!1;if(!t.isDiggable(s-n[0]-n[1],e-n[1]-n[0]))return!1}else if(!t.isDiggable(s+n[0],e+n[1]))return!1}return 1==o}setupStairs(t,s,e,o){const r=i.random.sequence(4);let n=null;for(let o=0;o<r.length;++o){n=i.utils.DIRS[o];const r=s+n[0],h=e+n[1];if(t.isFloor(r,h)&&t.isDiggable(s-n[0],e-n[1]))break;n=null}n||i.utils.ERROR("No stair direction found!"),t.setTile(s,e,o);const h=i.utils.CLOCK_DIRS.findIndex((t=>t[0]==n[0]&&t[1]==n[1])),a=this.options.wall;for(let o=0;o<i.utils.CLOCK_DIRS.length;++o){const r=o?o-1:7,n=(o+1)%8;if(o==h||r==h||n==h)continue;const l=i.utils.CLOCK_DIRS[o];t.setTile(s+l[0],e+l[1],a)}return!0}}var z={__proto__:null,Stairs:K};class q{constructor(t={}){this.options={minDistance:100,maxLength:1},Object.assign(this.options,t)}create(t){let s,e,o,r,n,h,a,l,u;const f=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,_=i.grid.alloc(t.width,t.height),p=i.grid.alloc(t.width,t.height),m=[[1,0],[0,1]];function I(i,s,e){return!!t.hasXY(i,s)&&(!!t.hasXY(i+e[1],s+e[0])&&(!!t.hasXY(i-e[1],s-e[0])&&(!t.isSet(i,s)&&(!t.isSet(i+e[1],s+e[0])&&!t.isSet(i-e[1],s-e[0])))))}function w(i,s,e){return!!t.hasXY(i,s)&&(!!t.hasXY(i+e[1],s+e[0])&&(!!t.hasXY(i-e[1],s-e[0])&&(!!t.isSet(i,s)||(!!t.isSet(i+e[1],s+e[0])||!!t.isSet(i-e[1],s-e[0])))))}g(t,p);let S=0;for(n=0;n<c.length;n++)if(l=Math.floor(c[n]/t.height),u=c[n]%t.height,!t.isSet(l,u))for(a=0;a<=1;a++){let n=m[a];if(I(l,u,n)){if(h=d,t.hasXY(l+n[0],u+n[1])&&t.isPassable(l+n[0],u+n[1])){if(!t.hasXY(l-n[0],u-n[1])||t.isDoor(l-n[0],u-n[1]))continue}else{if(!t.hasXY(l-n[0],u-n[1])||!t.isPassable(l-n[0],u-n[1]))continue;if(!t.hasXY(l+n[0],u+n[1])||t.isDoor(l+n[0],u+n[1]))continue;n=n.map((t=>-1*t))}for(s=l+n[0],e=u+n[1],o=l,r=u,h=0;h<d&&(o-=n[0],r-=n[1],!w(o,r,n));++h);if(h<d&&(i.path.calculateDistances(_,s,e,p,!1),_[o][r]>f&&_[o][r]<3e4)){for(;o!==s||r!==e;)t.isNothing(o,r)&&(t.setTile(o,r,1),p[o][r]=1),o+=n[0],r+=n[1];t.setTile(l,u,2),++S;break}}}return i.grid.free(_),i.grid.free(p),S}}var j={__proto__:null,LoopDigger:q,digLoops:function(t,i={}){return new q(i).create(t)}};class Q{constructor(t,s,e={}){this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.height=s,this.width=t,e.seed&&i.random.seed(e.seed),i.utils.setOptions(this.rooms,e.rooms),i.utils.setOptions(this.halls,e.halls),i.utils.setOptions(this.loops,e.loops),i.utils.setOptions(this.lakes,e.lakes),i.utils.setOptions(this.bridges,e.bridges),i.utils.setOptions(this.stairs,e.stairs),i.utils.setOptions(this.doors,e.doors),this.startLoc=e.startLoc||[Math.floor(t/2),s-2],this.endLoc=e.endLoc||[-1,-1]}makeSite(t,i){return new _(t,i)}create(t){const s=this.makeSite(this.width,this.height);this.start(s);let e=20;for(;--e&&!this.addFirstRoom(s););if(!e)throw new Error("Failed to place first room!");let o=0;for(;o<20;)this.addRoom(s)?o=0:++o;return this.addLoops(s,this.loops),this.addLakes(s,this.lakes),this.addBridges(s,this.bridges),this.addStairs(s,this.stairs),this.finish(s),i.utils.forRect(this.width,this.height,((i,e)=>{const o=s.getTile(i,e);o&&t(i,e,o)})),s.free(),!0}start(t){u(this.width*this.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof I)return t;if("string"==typeof t){const i=w[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new S(t)}addFirstRoom(t){const i=this.makeSite(this.width,this.height);let s=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return s&&!this._attachRoomAtLoc(t,i,s,this.startLoc)&&(s=null),i.free(),s}addRoom(t){const i=this.makeSite(this.width,this.height);let s=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(this.halls.chance){let t=F(this.halls,i,s.doors);t&&(s.hall=t)}return s&&!this._attachRoom(t,i,s)&&(s=null),i.free(),s}_attachRoom(t,s,e){const o=e.hall?e.hall.doors:e.doors;for(let n=0;n<c.length;n++){const a=Math.floor(c[n]/this.height),l=c[n]%this.height;if(!t.isNothing(a,l))continue;const u=r(t,a,l);if(u!=i.utils.NO_DIRECTION){const i=(u+2)%4,r=o[i];if(!r)continue;const n=a-r[0],c=l-r[1];if(-1!=r[0]&&this._roomFitsAt(t,s,n,c))return h(t,s,n,c),this._attachDoor(t,e,a,l,i),e.translate(n,c),!0}}return!1}_attachRoomAtLoc(t,s,e,o){const[r,n]=o,a=e.hall?e.hall.doors:e.doors,l=i.random.sequence(4);for(let i of l){const o=a[(i+2)%4];if(!o||-1==o[0])continue;const l=r-o[0],c=n-o[1];if(this._roomFitsAt(t,s,l,c))return h(t,s,l,c),e.translate(l,c),!0}return!1}_roomFitsAt(t,i,s,e){let o,r,n,h,a,l;for(o=0;o<i.width;o++)for(r=0;r<i.height;r++)if(i.isSet(o,r))for(n=o+s,h=r+e,a=n-1;a<=n+1;a++)for(l=h-1;l<=h+1;l++)if(!t.hasXY(a,l)||t.isBoundaryXY(a,l)||!t.isNothing(a,l))return!1;return!0}_attachDoor(t,s,e,o,r){const n=this.doors;if(0===n.chance)return;const h=n.chance&&i.random.chance(n.chance)?n.tile||2:1;if(t.setTile(e,o,h),s.hall&&s.hall.width>1&&s.hall.dir===r)if(r===i.utils.UP||r===i.utils.DOWN){let i=!0,s=1;for(;i;)i=!1,t.isNothing(e-s,o)&&t.isSet(e-s,o-1)&&t.isSet(e-s,o+1)&&(t.setTile(e-s,o,h),i=!0),t.isNothing(e+s,o)&&t.isSet(e+s,o-1)&&t.isSet(e+s,o+1)&&(t.setTile(e+s,o,h),i=!0),++s}else{let i=!0,s=1;for(;i;)i=!1,t.isNothing(e,o-s)&&t.isSet(e-1,o-s)&&t.isSet(e+1,o-s)&&(t.setTile(e,o-s,h),i=!0),t.isNothing(e,o+s)&&t.isSet(e-1,o+s)&&t.isSet(e+1,o+s)&&(t.setTile(e,o+s,h),i=!0),++s}}addLoops(t,i){return new q(i).create(t)}addLakes(t,i){return new W(i).create(t)}addBridges(t,i){return new U(i).create(t)}addStairs(t,i){return new K(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let s,e,o,r,n,h;do{for(h=!1,s=0;s<this.width-1;s++)for(e=0;e<this.height-1;e++)for(o=0;o<=1;o++)t.isPassable(s+o,e)&&!t.isPassable(s+(1-o),e)&&t.isObstruction(s+(1-o),e)&&!t.isPassable(s+o,e+1)&&t.isObstruction(s+o,e+1)&&t.isPassable(s+(1-o),e+1)&&(i.random.chance(50)?(r=s+(1-o),n=e):(r=s+o,n=e+1),h=!0,t.setTile(r,n,1))}while(1==h)}_finishDoors(t){i.utils.forRect(this.width,this.height,((i,s)=>{t.isBoundaryXY(i,s)||t.isDoor(i,s)&&((t.isFloor(i+1,s)||t.isFloor(i-1,s))&&(t.isFloor(i,s+1)||t.isFloor(i,s-1))||(t.isObstruction(i+1,s)?1:0)+(t.isObstruction(i-1,s)?1:0)+(t.isObstruction(i,s+1)?1:0)+(t.isObstruction(i,s-1)?1:0)>=3)&&t.setTile(i,s,1)}))}_finishWalls(t){const s=this.boundary?8:3;i.utils.forRect(this.width,this.height,((i,e)=>{t.isNothing(i,e)&&(t.isBoundaryXY(i,e)?t.setTile(i,e,s):t.setTile(i,e,3))}))}}var V={__proto__:null,room:P,hall:Y,lake:G,bridge:H,stairs:z,utils:a,loop:j,Hall:s,Room:e,Level:Q,Dungeon:class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],i.utils.setOptions(this.config,t),this.config.seed&&i.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=i.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const s=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let e=0;e<this.config.levels;++e){const e=i.random.matchingXY(this.config.width,this.config.height,((e,o)=>i.utils.distanceBetween(t[0],t[1],e,o)>s));this.stairLocs.push([[t[0],t[1]],[e[0],e[1]]]),t=e}}getLevel(t,s){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);i.random.seed(this.seeds[t]);const[e,o]=this.stairLocs[t],r=Object.assign({},this.config.stairs);this.config.goesUp?(r.down=e,r.up=o,0==t&&this.config.startTile&&(r.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.upTile=this.config.endTile)):(r.down=o,r.up=e,0==t&&this.config.startTile&&(r.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.downTile=this.config.endTile));const n=Object.assign({},this.config.rooms);0===t&&n.entrance&&(n.first=n.entrance);const h={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:n,stairs:r,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,h,s)}makeLevel(t,s,e){const o=new Q(this.config.width,this.config.height,s),r=o.create(e);return i.utils.equalsXY(o.endLoc,s.endLoc)&&i.utils.equalsXY(o.startLoc,s.startLoc)||(this.stairLocs[t]=[o.startLoc,o.endLoc]),r}}};const Z=i.flag.fl;var J;!function(t){t[t.BP_ROOM=Z(10)]="BP_ROOM",t[t.BP_VESTIBULE=Z(1)]="BP_VESTIBULE",t[t.BP_REWARD=Z(7)]="BP_REWARD",t[t.BP_ADOPT_ITEM=Z(0)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=Z(2)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=Z(3)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=Z(4)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=Z(5)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=Z(6)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=Z(8)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=Z(9)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=Z(14)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=Z(11)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=Z(12)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=Z(13)]="BP_NO_INTERIOR_FLAG"}(J||(J={}));const $={};var tt={__proto__:null,get Flags(){return J},Blueprint:class{constructor(t={}){if(this.tags=[],this.size=[-1,-1],this.flags=0,t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=i.frequency.make(t.frequency||100),t.size){if("string"==typeof t.size){const i=t.size.split(/-/).map((t=>t.trim())).map((t=>Number.parseInt(t)));if(2!==i.length)throw new Error("Blueprint size must be of format: #-#");this.size=[i[0],i[1]]}else{if(!Array.isArray(t.size))throw new Error("size must be string or array.");if(2!==t.size.length)throw new Error("Blueprint size must be [min, max]");this.size=[t.size[0],t.size[1]]}if(this.size[0]>this.size[1])throw new Error("Blueprint size must be small to large.")}t.flags&&(this.flags=i.flag.from(J,t.flags))}getChance(t,i){return i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t))))?0:this.frequency(t)}get isRoom(){return this.flags&J.BP_ROOM}get isReward(){return this.flags&J.BP_REWARD}get isVestiblue(){return this.flags&J.BP_VESTIBULE}get adoptsItem(){return this.flags&J.BP_ADOPT_ITEM}},blueprints:$,install:function(t,i){$[t]=i}};class it{constructor(t=!1){this.withCounts=t}compute(t){const s=i.grid.alloc(t.width,t.height),e=i.grid.alloc(t.width,t.height);let o;e.update(((i,s,e)=>t.isPassable(s,e)?1:0));for(let s=1;s<e.width-1;s++)for(let r=1;r<e.height-1;r++)if(t.clearSiteFlag(s,r,d.IS_CHOKEPOINT),t.setChokeCount(s,r,3e4),e[s][r]&&!t.hasSiteFlag(s,r,d.IS_IN_LOOP)){o=0;for(let n=0;n<8;n++){const h=s+i.utils.CLOCK_DIRS[(n+7)%8][0],a=r+i.utils.CLOCK_DIRS[(n+7)%8][1],l=s+i.utils.CLOCK_DIRS[n][0],c=r+i.utils.CLOCK_DIRS[n][1];if(e.hasXY(l,c)&&e.hasXY(h,a)&&e[l][c]!=e[h][a]&&++o>2){(e[s-1][r]||e[s+1][r])&&(e[s][r-1]||e[s][r+1])||t.setSiteFlag(s,r,d.IS_CHOKEPOINT);break}}}if(this.withCounts){e.update(((i,s,e)=>i&&t.hasSiteFlag(s,e,d.IS_IN_ROOM_MACHINE)?0:i));for(let o=0;o<t.width;o++)for(let r=0;r<t.height;r++)if(e[o][r]&&t.hasSiteFlag(o,r,d.IS_CHOKEPOINT))for(let n=0;n<4;n++){const h=o+i.utils.DIRS[n][0],a=r+i.utils.DIRS[n][1];if(e.hasXY(h,a)&&e[h][a]&&!t.hasSiteFlag(h,a,d.IS_CHOKEPOINT)){s.fill(0),e[o][r]=0;let i=st(t,s,e,h,a);if(e[o][r]=1,i>=4){for(let e=0;e<s.width;e++)for(let o=0;o<s.height;o++)s[e][o]&&i<t.getChokeCount(e,o)&&(t.setChokeCount(e,o,i),t.clearSiteFlag(e,o,d.IS_GATE_SITE));i<t.getChokeCount(o,r)&&(t.setChokeCount(o,r,i),t.setSiteFlag(o,r,d.IS_GATE_SITE))}}}}i.grid.free(e),i.grid.free(s)}}function st(t,s,e,o,r){let n=2==e[o][r]?5e3:1;t.isDeep(o,r)&&(n=1e4),s[o][r]=1;for(let h=0;h<4;h++){const a=o+i.utils.DIRS[h][0],l=r+i.utils.DIRS[h][1];t.hasXY(a,l)&&e[a][l]&&!s[a][l]&&(n+=st(t,s,e,a,l))}return Math.min(n,1e4)}class et{constructor(){}compute(t){this._initGrid(t),i.utils.forRect(t.width,t.height,((i,s)=>this._checkCell(t,i,s)))}_initGrid(t){i.utils.forRect(t.width,t.height,((i,s)=>{t.isPassable(i,s)?t.setSiteFlag(i,s,d.IS_IN_LOOP):t.clearSiteFlag(i,s,d.IS_IN_LOOP)}))}_checkCell(t,s,e){let o,r,n,h,a,l,c,u;if(t.hasSiteFlag(s,e,d.IS_IN_LOOP)){for(a=0;a<8&&(r=s+i.utils.CLOCK_DIRS[a][0],n=e+i.utils.CLOCK_DIRS[a][1],!t.hasXY(r,n)||t.hasSiteFlag(r,n,d.IS_IN_LOOP));a++);if(8!=a){for(l=c=u=0,o=!1,h=a;h<a+8;h++){if(r=s+i.utils.CLOCK_DIRS[h%8][0],n=e+i.utils.CLOCK_DIRS[h%8][1],!t.hasXY(r,n))continue;if(t.hasSiteFlag(r,n,d.IS_IN_LOOP)){if(u++,!o){if(l>0)return!1;l++,o=!0}}else o&&(u>c&&(c=u),u=0,o=!1)}if(o&&u>c&&(c=u),1==l&&c<=4)for(t.clearSiteFlag(s,e,d.IS_IN_LOOP),h=0;h<8;h++){const o=s+i.utils.CLOCK_DIRS[h][0],r=e+i.utils.CLOCK_DIRS[h][1];t.hasXY(o,r)&&this._checkCell(t,o,r)}}}}_fillInnerLoopGrid(t,i){for(let s=0;s<t.width;++s)for(let e=0;e<t.height;++e)if(t.hasSiteFlag(s,e,d.IS_IN_LOOP))i[s][e]=1;else if(s>0&&e>0){const o=t.hasSiteFlag(s,e-1,d.IS_IN_LOOP),r=t.hasSiteFlag(s-1,e,d.IS_IN_LOOP);o&&r&&(i[s][e]=1)}}_update(t){const s=i.grid.alloc(t.width,t.height);let e;this._fillInnerLoopGrid(t,s);for(let o=0;o<t.width;o++)for(let r=0;r<t.height;r++)if(t.hasSiteFlag(o,r,d.IS_IN_LOOP)){e=!1;for(let n=0;n<8;n++){let h=o+i.utils.CLOCK_DIRS[n][0],a=r+i.utils.CLOCK_DIRS[n][1];if(t.hasXY(h,a)&&!s[h][a]&&!t.hasSiteFlag(h,a,d.IS_IN_LOOP)){e=!0;break}}e||(s[o][r]=1,t.clearSiteFlag(o,r,d.IS_IN_LOOP))}i.grid.free(s)}}var ot={__proto__:null,blueprint:tt,analyze:function(t){(new et).compute(t),new it(!0).compute(t)},LoopFinder:et,ChokeFinder:it,floodFillCount:st};t.build=ot,t.dig=V,t.site=p,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

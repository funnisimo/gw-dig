!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";var e,s;const r=i.tile.get("NULL").index,o=i.tile.get("FLOOR").index,l=i.tile.get("DOOR").index,n=null!==(s=null===(e=i.tile.get("DOOR_SECRET"))||void 0===e?void 0:e.index)&&void 0!==s?s:-1,h=i.tile.get("WALL").index,a=i.tile.get("LAKE").index,c=i.tile.get("SHALLOW").index,g=i.tile.get("BRIDGE").index,u=i.tile.get("UP_STAIRS").index,f=i.tile.get("DOWN_STAIRS").index,d=i.tile.get("IMPREGNABLE").index,_={[r]:"NULL",[o]:"FLOOR",[l]:"DOOR",[h]:"WALL",[d]:"IMPREGNABLE",[a]:"LAKE",[c]:"SHALLOW",[g]:"BRIDGE",[u]:"UP_STAIRS",[f]:"DOWN_STAIRS"};class I{constructor(t,e){this.tiles=i.grid.alloc(t,e)}free(){i.grid.free(this.tiles)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return this.tiles.get(t,i)===r}isDiggable(t,i){return this.tiles.get(t,i)===r}isFloor(t,i){return this.tiles.get(t,i)==o}isDoor(t,i){return this.tiles.get(t,i)===l}isSecretDoor(t,i){return this.tiles.get(t,i)===n}isBridge(t,i){return this.tiles.get(t,i)===g}isWall(t,i){const e=this.tiles.get(t,i);return e===h||e===d}blocksMove(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)}blocksDiagonal(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksPathing(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)||this.isStairs(t,i)}blocksVision(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksItems(t,i){return this.blocksPathing(t,i)||this.blocksPathing(t,i)}blocksEffects(t,i){return this.isWall(t,i)}isStairs(t,i){const e=this.tiles.get(t,i);return e===u||e===f}isDeep(t,i){return this.tiles.get(t,i)===a}isShallow(t,i){return this.tiles.get(t,i)===c}isAnyLiquid(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTileIndex(t,i){return this.tiles.get(t,i)||0}setTile(t,e,s){if("string"==typeof s){const t=i.tile.tiles[s];if(!t)throw new Error("Failed to find tie: "+s);s=t.index}return!!this.tiles.hasXY(t,e)&&(this.tiles[t][e]=s,!0)}hasTile(t,e,s){if("string"==typeof s){const t=i.tile.tiles[s];if(!t)throw new Error("Failed to find tie: "+s);s=t.index}return this.tiles.hasXY(t,e)&&this.tiles[t][e]==s}tileBlocksMove(t){return t===h||t===a||t===d||t===r}}var p={__proto__:null,NOTHING:r,FLOOR:o,DOOR:l,SECRET_DOOR:n,WALL:h,DEEP:a,SHALLOW:c,BRIDGE:g,UP_STAIRS:u,DOWN_STAIRS:f,IMPREGNABLE:d,TILEMAP:_,GridSite:I};class m{constructor(t,e,s,r=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const o=i.utils.DIRS[e];this.length=s,this.width=r,e===i.utils.UP||e===i.utils.DOWN?(this.x2=this.x+(r-1),this.y2=this.y+(s-1)*o[1]):(this.x2=this.x+(s-1)*o[0],this.y2=this.y+(r-1)),this.dir=e}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}class E extends i.utils.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}const O=i.utils.DIRS;function R(t,e,s){let r,o,l,n,h,a;for(o=i.utils.NO_DIRECTION,r=0;r<4;r++)if(l=e+O[r][0],n=s+O[r][1],h=e-O[r][0],a=s-O[r][1],t.hasXY(h,a)&&t.hasXY(l,n)&&t.isFloor(h,a)){if(o!=i.utils.NO_DIRECTION)return i.utils.NO_DIRECTION;o=r}return o}function T(t){let e,s,r,o,l,n,h;const a=[[],[],[],[]],c=t.height,g=t.width;for(e=0;e<g;e++)for(s=0;s<c;s++)if(t.isDiggable(e,s)&&(n=R(t,e,s),n!=i.utils.NO_DIRECTION)){for(o=e+i.utils.DIRS[n][0],l=s+i.utils.DIRS[n][1],h=!1,r=0;r<10&&t.hasXY(o,l)&&!h;r++)t.isSet(o,l)&&(h=!0),o+=i.utils.DIRS[n][0],l+=i.utils.DIRS[n][1];h||a[n].push([e,s])}let u=[];for(n=0;n<4;n++){const t=i.random.item(a[n])||[-1,-1];u[n]=[t[0],t[1]]}return u}function L(t,e,s=0,r=0){i.utils.forRect(t.width,t.height,((i,o)=>{const l=i-s,n=o-r,h=e.getTileIndex(l,n);h&&t.setTile(i,o,h)}))}function w(t,e){e.update(((e,s,r)=>t.isPassable(s,r)?1:i.path.OBSTRUCTION))}function S(t,e,s=0,r=0){const o=i.grid.alloc(t.width,t.height);let l=!1;i.utils.forRect(t.width,t.height,((i,n)=>{const h=i+s,a=n+r;e.get(h,a)?t.isStairs(i,n)&&(l=!0):t.isPassable(i,n)&&(o[i][n]=1)}));let n=!0;for(let t=0;t<o.width&&!l;++t)for(let i=0;i<o.height&&!l;++i)1==o[t][i]&&(n?(o.floodFill(t,i,1,2),n=!1):l=!0);return i.grid.free(o),l}function B(t,e,s=0,r=0){const o=i.grid.alloc(t.width,t.height);let l=0;if(i.utils.forRect(t.width,t.height,((i,n)=>{const h=i+s,a=n+r;e.get(h,a)?t.isStairs(i,n)&&(l=t.width*t.height):t.isPassable(i,n)&&(o[i][n]=1)})),l)return l;let n=!0,h=2,a=t.width*t.height;for(let t=0;t<o.width;++t)for(let i=0;i<o.height;++i)if(1==o[t][i]){const e=o.floodFill(t,i,1,h++);a=Math.min(a,e),n?n=!1:l=a}return i.grid.free(o),l}function N(t,e,s,r,o){const l=i.grid.alloc(t.width,t.height);w(t,l),i.path.calculateDistances(e,s,r,l,!1,o+1),i.grid.free(l)}var C={__proto__:null,directionOfDoorSite:R,chooseRandomDoorSites:T,copySite:L,fillCostGrid:w,siteDisruptedBy:S,siteDisruptedSize:B,computeDistanceMap:N};function F(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,s])=>{let r=t[e];if("tile"===e)return void(void 0===r&&(t[e]=s));if(!0===s){if(!r)throw new Error("Missing required config for room digger: "+e)}else r=("number"==typeof s||Array.isArray(s),r||s);const o=i.range.make(r);t[e]=o})),t}class M{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=F(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=T(t))),i}}var A={};class b extends M{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const s=t.choices||e.choices;if(Array.isArray(s))this.randomRoom=i.random.item.bind(i.random,s);else{if("object"!=typeof s)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=i.random.weighted.bind(i.random,s)}}carve(t){let e=this.randomRoom();const s=A[e];return s||i.utils.ERROR("Missing room digger choice: "+e),s.create(t)}}class D extends M{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),r=this.options.tile||o,l=i.grid.alloc(t.width,t.height,0),n=Math.floor(.5*e),h=e,a=Math.floor(.5*s),c=s,g=new i.blob.Blob({rounds:5,minWidth:n,minHeight:a,maxWidth:h,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(l.width,l.height,((t,i)=>l[t][i]=1)),u=Math.floor((t.width-g.width)/2),f=u-g.x,d=Math.floor((t.height-g.height)/2),_=d-g.y;return l.forEach(((i,e,s)=>{i&&t.setTile(e+f,s+_,r)})),i.grid.free(l),new E(u,d,g.width,g.height)}}class P extends M{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),r=this.options.tile||o,l=Math.floor(.4*e),n=s,h=e,a=Math.floor(.5*s),c=Math.floor(t.width/2-l/2-1),g=t.height-n-2,u=Math.floor(t.width/2-h/2-1),f=t.height-a-2;i.utils.forRect(c,g,l,n,((i,e)=>t.setTile(i,e,r))),i.utils.forRect(u,f,h,a,((i,e)=>t.setTile(i,e,r)));const d=new E(Math.min(c,u),Math.min(g,f),Math.max(l,h),Math.max(n,a));return d.doors[i.utils.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class k extends M{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),r=this.options.tile||o,l=e,n=Math.max(3,Math.floor(e*i.random.range(25,75)/100)),h=Math.max(3,Math.floor(s*i.random.range(25,75)/100)),a=s,c=Math.floor((t.width-l)/2),g=c+i.random.range(2,Math.max(2,l-n-2)),u=Math.floor((t.height-a)/2),f=u+i.random.range(2,Math.max(2,a-h-2));return i.utils.forRect(c,f,l,h,((i,e)=>t.setTile(i,e,r))),i.utils.forRect(g,u,n,a,((i,e)=>t.setTile(i,e,r))),new E(c,u,Math.max(l,n),Math.max(h,a))}}class y extends M{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),r=this.options.tile||o;let l=Math.max(3,Math.floor(e*i.random.range(25,50)/100)),n=Math.max(3,Math.floor(s*i.random.range(25,50)/100));const h=Math.floor((t.width-e)/2),a=Math.floor((t.height-n)/2);i.utils.forRect(h,a,e,n,((i,e)=>t.setTile(i,e,r)));const c=Math.floor((t.width-l)/2),g=Math.floor((t.height-s)/2);return i.utils.forRect(c,g,l,s,((i,e)=>t.setTile(i,e,r))),new E(Math.min(h,c),Math.min(a,g),Math.max(e,l),Math.max(s,n))}}class v extends M{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(),s=this.options.height.value(),r=this.options.tile||o,l=Math.floor((t.width-e)/2),n=Math.floor((t.height-s)/2);return i.utils.forRect(l,n,e,s,((i,e)=>t.setTile(i,e,r))),new E(l,n,e,s)}}class Y extends M{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(),s=this.options.tile||o,r=Math.floor(t.width/2),l=Math.floor(t.height/2);return e>1&&i.utils.forCircle(r,l,e,((i,e)=>t.setTile(i,e,s))),new E(r-e,l-e,2*e+1,2*e+1)}}class G extends M{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(),s=this.options.ringMinWidth.value(),r=this.options.holeMinSize.value(),l=this.options.tile||o,n=Math.floor(t.width/2),h=Math.floor(t.height/2);return i.utils.forCircle(n,h,e,((i,e)=>t.setTile(i,e,l))),e>s+r&&i.random.chance(this.options.holeChance.value())&&i.utils.forCircle(n,h,i.random.range(r,e-r),((i,e)=>t.setTile(i,e,0))),new E(n-e,h-e,2*e+1,2*e+1)}}class x extends M{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,s,r,l=this.options.count.value();const n=this.options.width.value(),h=this.options.height.value(),a=this.options.tile||o,c=Math.floor(t.width/2)-Math.floor(n/2),g=Math.floor(t.width/2)+Math.floor(n/2),u=Math.floor(t.height/2)-Math.floor(h/2),f=Math.floor(t.height/2)+Math.floor(h/2);let d=Math.floor(t.width/2),_=d,I=Math.floor(t.height/2),p=I;for(i.utils.forCircle(d,I,2,((i,e)=>t.setTile(i,e,a))),d-=2,_+=2,I-=2,p+=2,e=0;e<l;)if(s=i.random.range(c,g),r=i.random.range(u,f),t.isSet(s,r)){if(s-2<c)continue;if(s+2>g)continue;if(r-2<u)continue;if(r+2>f)continue;d=Math.min(s-2,d),_=Math.max(s+2,_),I=Math.min(r-2,I),p=Math.max(r+2,p),i.utils.forCircle(s,r,2,((i,e)=>t.setTile(i,e,a))),e++}return new E(d,I,_-d+1,p-I+1)}}function W(t,i){return A[t]=i,i}W("DEFAULT",new v);var X={__proto__:null,checkConfig:F,RoomDigger:M,rooms:A,ChoiceRoom:b,choiceRoom:function(t,i){return new b(t).create(i)},Cavern:D,cavern:function(t,i){return new D(t).create(i)},BrogueEntrance:P,brogueEntrance:function(t,i){return new P(t).create(i)},Cross:k,cross:function(t,i){return new k(t).create(i)},SymmetricalCross:y,symmetricalCross:function(t,i){return new y(t).create(i)},Rectangular:v,rectangular:function(t,i){return new v(t).create(i)},Circular:Y,circular:function(t,i){return new Y(t).create(i)},BrogueDonut:G,brogueDonut:function(t,i){return new G(t).create(i)},ChunkyRoom:x,chunkyRoom:function(t,i){return new x(t).create(i)},install:W};const U=i.utils.DIRS;function K(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function H(t,e){return t==i.utils.UP||t==i.utils.DOWN?e[1].value():e[0].value()}function V(t,e,s){let r=i.utils.NO_DIRECTION;if(r==i.utils.NO_DIRECTION){const o=i.random.sequence(4);for(let l=0;l<4;l++){r=o[l];const n=s[(l+1)%2].hi,h=e[r];if(h&&-1!=h[0]&&-1!=h[1]){const i=h[0]+Math.floor(U[r][0]*n),e=h[1]+Math.floor(U[r][1]*n);if(t.hasXY(i,e))break}r=i.utils.NO_DIRECTION}}return r}function q(t,e,s,r,o){let l,n;const h=i.random.chance(o),a=[];for(let i=0;i<4;i++)l=e+U[i][0],n=s+U[i][1],i!=r&&!h||!t.hasXY(l,n)||t.isSet(l,n)||(a[i]=[l,n]);return a}class z{constructor(t={}){this.config={width:i.range.make(1),length:[i.range.make("2-15"),i.range.make("2-9")],tile:o,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=i.range.make(t.width)),t.length&&"number"==typeof t.length){const e=i.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,e=[]){if(e=e||T(t),!i.random.chance(this.config.chance))return null;const s=V(t,e,this.config.length);if(s===i.utils.NO_DIRECTION)return null;if(!e[s])return null;const r=this.config.width.value(),o=H(s,this.config.length),l=e[s];return 1==r?this.dig(t,s,l,o):this.digWide(t,s,l,o,r)}_digLine(t,i,e,s){let r=i[0],o=i[1];const l=this.config.tile;for(let i=0;i<s;i++)t.setTile(r,o,l),r+=e[0],o+=e[1];return r-=e[0],o-=e[1],[r,o]}dig(t,i,e,s){const r=U[i],[o,l]=this._digLine(t,e,r,s),n=new m(e,i,s);return n.doors=q(t,o,l,i,this.config.obliqueChance),n}digWide(t,e,s,r,o){const l=i.utils.DIRS[e],n=[s[0]-l[1],s[1]-l[0]],h=[s[0]+l[1],s[1]+l[0]];this._digLine(t,s,l,r);let a=1,c=s[0],g=s[1];a<o&&K(t,n,l)&&(this._digLine(t,n,l,r),c=Math.min(n[0],c),g=Math.min(n[1],g),++a),a<o&&K(t,h,l)&&(this._digLine(t,h,l,r),c=Math.min(h[0],c),g=Math.min(h[1],g),++a);const u=new m([c,g],e,r,o);return u.doors=[],u.doors[e]=[s[0]+r*l[0],s[1]+r*l[1]],u.width=o,u}}function j(t,i,e){return new z(t).create(i,e)}var Q={};function Z(t,i){return Q[t]=i,i}Z("DEFAULT",new z({chance:15}));var $={__proto__:null,isDoorLoc:K,pickWidth:function(t={}){return i.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let e=t.width;if("number"==typeof e)return e;e=Array.isArray(e)?i.random.weighted(e)+1:"string"==typeof e?i.range.make(e).value():Number.parseInt(i.random.weighted(e));return e}(t),1,3)},pickLength:H,pickHallDirection:V,pickHallExits:q,HallDigger:z,dig:j,halls:Q,install:Z};class J{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:c,wreathChance:50,wreathSize:1,tile:a},Object.assign(this.options,t)}create(t){let e,s,r,o,l,n,h,g,u,f,d,_=0;n=this.options.height||15,h=this.options.width||30,g=this.options.minSize||5,u=this.options.tries||20,f=this.options.count||1,d=this.options.canDisrupt||!1;const I=!!i.random.chance(this.options.wreathChance),p=this.options.wreathTile||c,m=this.options.wreathSize||1,E=this.options.tile||a,O=i.grid.alloc(t.width,t.height,0);let R=0;for(;R<f&&_<f;){const a=Math.round((h-g)*(f-R)/f)+g,c=Math.round((n-g)*(f-R)/f)+g,T=new i.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:a,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(O.width,O.height,((t,i)=>O[t][i]=1));let L=!1;for(r=0;r<u&&!L;r++)if(o=i.random.range(1-T.x,O.width-T.width-T.x-2),l=i.random.range(1-T.y,O.height-T.height-T.y-2),d||!this.isDisruptedBy(t,O,-o,-l)){for(L=!0,e=0;e<T.width;e++)for(s=0;s<T.height;s++)if(O[e+T.x][s+T.y]){const r=e+T.x+o,n=s+T.y+l;t.setTile(r,n,E),I&&i.utils.forCircle(r,n,m,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,p)}))}break}L?++_:++R}return i.grid.free(O),_}isDisruptedBy(t,e,s=0,r=0){const o=i.grid.alloc(t.width,t.height);let l=!1;i.utils.forRect(t.width,t.height,((i,n)=>{const h=i+s,a=n+r;e.get(h,a)?t.isStairs(i,n)&&(l=!0):t.isPassable(i,n)&&(o[i][n]=1)}));let n=!0;for(let t=0;t<o.width&&!l;++t)for(let i=0;i<o.height&&!l;++i)1==o[t][i]&&(n?(o.floodFill(t,i,1,2),n=!1):l=!0);return i.grid.free(o),l}}var tt={__proto__:null,Lakes:J};class it{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let e,s,r,l,n,h,a,c=0;const u=this.options.maxLength,f=this.options.minDistance,d=i.grid.alloc(t.width,t.height),_=i.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];_.update(((e,s,r)=>t.isPassable(s,r)?1:i.path.OBSTRUCTION));const p=i.random.sequence(t.width*t.height);for(r=0;r<p.length;r++)if(h=Math.floor(p[r]/t.height),a=p[r]%t.height,t.isPassable(h,a)&&!t.isAnyLiquid(h,a))for(n=0;n<=1;n++){const r=I[n];if(e=h+r[0],s=a+r[1],l=u,t.isAnyLiquid(e,s))for(l=0;l<u&&(e+=r[0],s+=r[1],t.isAnyLiquid(e,s));++l);if(t.isPassable(e,s)&&l<u&&(i.path.calculateDistances(d,e,s,_,!1),d[h][a]>f&&d[h][a]<i.path.NO_PATH)){for(;h!==e||a!==s;)this.isBridgeCandidate(t,h,a,r)?(t.setTile(h,a,g),_[h][a]=1):(t.setTile(h,a,o),_[h][a]=1),h+=r[0],a+=r[1];++c;break}}return i.grid.free(d),i.grid.free(_),c}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyLiquid(i,e)&&(!!t.isAnyLiquid(i+s[1],e+s[0])&&!!t.isAnyLiquid(i-s[1],e-s[0]))}}var et={__proto__:null,Bridges:it};class st{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:u,downTile:f,wall:d},Object.assign(this.options,t)}create(t){let e=!1!==this.options.up,s=!1!==this.options.down;const r=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),o={};let l,n;const h=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?i.random.matchingLoc(t.width,t.height,h):i.random.matchingLocNear(i.utils.x(e),i.utils.y(e),h),o.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;l=i.random.matchingLocNear(i.utils.x(t),i.utils.y(t),h);const e=this.options.down;n=i.random.matchingLocNear(i.utils.x(e),i.utils.y(e),h)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;l=i.random.matchingLocNear(i.utils.x(e),i.utils.y(e),h),s&&(n=i.random.matchingLoc(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,l[0],l[1])<r)&&h(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const s=this.options.down;n=i.random.matchingLocNear(i.utils.x(s),i.utils.y(s),h),e&&(l=i.random.matchingLoc(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,n[0],n[1])<r)&&h(t,e))))}else e?(l=i.random.matchingLoc(t.width,t.height,h),s&&(n=i.random.matchingLoc(t.width,t.height,((t,e)=>!(i.utils.distanceBetween(t,e,l[0],l[1])<r)&&h(t,e))))):s&&(n=i.random.matchingLoc(t.width,t.height,h));return l&&(o.up=l.slice(),this.setupStairs(t,l[0],l[1],this.options.upTile),"up"===this.options.start&&(o.start=o.up)),void 0!==n&&(o.down=n.slice(),this.setupStairs(t,n[0],n[1],this.options.downTile),"down"===this.options.start&&(o.start=o.down)),l||n?o:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,e,s){let r=0;if(!this.hasXY(t,e,s)||!t.isDiggable(e,s))return!1;for(let o=0;o<4;++o){const l=i.utils.DIRS[o];if(!this.hasXY(t,e+l[0],s+l[1]))return!1;if(!this.hasXY(t,e-l[0],s-l[1]))return!1;if(t.isFloor(e+l[0],s+l[1])){if(r+=1,!t.isDiggable(e-l[0]+l[1],s-l[1]+l[0]))return!1;if(!t.isDiggable(e-l[0]-l[1],s-l[1]-l[0]))return!1}else if(!t.isDiggable(e+l[0],s+l[1]))return!1}return 1==r}setupStairs(t,e,s,r){const o=i.random.sequence(4);let l=null;for(let r=0;r<o.length;++r){l=i.utils.DIRS[r];const o=e+l[0],n=s+l[1];if(t.isFloor(o,n)&&t.isDiggable(e-l[0],s-l[1]))break;l=null}l||i.utils.ERROR("No stair direction found!"),t.setTile(e,s,r);const n=i.utils.CLOCK_DIRS.findIndex((t=>t[0]==l[0]&&t[1]==l[1])),h=this.options.wall;for(let r=0;r<i.utils.CLOCK_DIRS.length;++r){const o=r?r-1:7,l=(r+1)%8;if(r==n||o==n||l==n)continue;const a=i.utils.CLOCK_DIRS[r];t.setTile(e+a[0],s+a[1],h)}return!0}}var rt={__proto__:null,Stairs:st};class ot{constructor(t={}){this.options={minDistance:100,maxLength:1},Object.assign(this.options,t)}create(t){let e,s,r,n,h,a,c,g,u;const f=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,_=i.grid.alloc(t.width,t.height),I=i.grid.alloc(t.width,t.height),p=[[1,0],[0,1]];function m(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function E(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}w(t,I);let O=0;const R=i.random.sequence(t.width*t.height);for(h=0;h<R.length;h++)if(g=Math.floor(R[h]/t.height),u=R[h]%t.height,!t.isSet(g,u))for(c=0;c<=1;c++){let h=p[c];if(m(g,u,h)){if(a=d,t.hasXY(g+h[0],u+h[1])&&t.isPassable(g+h[0],u+h[1])){if(!t.hasXY(g-h[0],u-h[1])||t.isDoor(g-h[0],u-h[1]))continue}else{if(!t.hasXY(g-h[0],u-h[1])||!t.isPassable(g-h[0],u-h[1]))continue;if(!t.hasXY(g+h[0],u+h[1])||t.isDoor(g+h[0],u+h[1]))continue;h=h.map((t=>-1*t))}for(e=g+h[0],s=u+h[1],r=g,n=u,a=0;a<d&&(r-=h[0],n-=h[1],!E(r,n,h));++a);if(a<d&&(i.path.calculateDistances(_,e,s,I,!1),_[r][n]>f&&_[r][n]<3e4)){for(;r!==e||n!==s;)t.isNothing(r,n)&&(t.setTile(r,n,o),I[r][n]=1),r+=h[0],n+=h[1];t.setTile(g,u,l),++O;break}}}return i.grid.free(_),i.grid.free(I),O}}var lt={__proto__:null,LoopDigger:ot,digLoops:function(t,i={}){return new ot(i).create(t)}};class nt{constructor(t,e,s={}){this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.height=e,this.width=t,s.seed&&i.random.seed(s.seed),this.seq=i.random.sequence(t*e),i.utils.setOptions(this.rooms,s.rooms),i.utils.setOptions(this.halls,s.halls),i.utils.setOptions(this.loops,s.loops),i.utils.setOptions(this.lakes,s.lakes),i.utils.setOptions(this.bridges,s.bridges),i.utils.setOptions(this.stairs,s.stairs),i.utils.setOptions(this.doors,s.doors),this.startLoc=s.startLoc||[Math.floor(t/2),e-2],this.endLoc=s.endLoc||[-1,-1]}makeSite(t,i){return new I(t,i)}create(t){const e=this.makeSite(this.width,this.height);this.start(e);let s=20;for(;--s&&!this.addFirstRoom(e););if(!s)throw new Error("Failed to place first room!");let r=0;for(;r<20;)this.addRoom(e)?r=0:++r;return this.addLoops(e,this.loops),this.addLakes(e,this.lakes),this.addBridges(e,this.bridges),this.addStairs(e,this.stairs),this.finish(e),i.utils.forRect(this.width,this.height,((i,s)=>{const r=e.getTileIndex(i,s);r&&t(i,s,r)})),e.free(),!0}start(t){}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof M)return t;if("string"==typeof t){const i=A[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new b(t)}addFirstRoom(t){const i=this.makeSite(this.width,this.height);let e=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return e&&!this._attachRoomAtLoc(t,i,e,this.startLoc)&&(e=null),i.free(),e}addRoom(t){const i=this.makeSite(this.width,this.height);let e=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(this.halls.chance){let t=j(this.halls,i,e.doors);t&&(e.hall=t)}return e&&!this._attachRoom(t,i,e)&&(e=null),i.free(),e}_attachRoom(t,e,s){const r=s.hall?s.hall.doors:s.doors;for(let o=0;o<this.seq.length;o++){const l=Math.floor(this.seq[o]/this.height),n=this.seq[o]%this.height;if(!t.isNothing(l,n))continue;const h=R(t,l,n);if(h!=i.utils.NO_DIRECTION){const i=(h+2)%4,o=r[i];if(!o)continue;const a=l-o[0],c=n-o[1];if(-1!=o[0]&&this._roomFitsAt(t,e,a,c))return L(t,e,a,c),this._attachDoor(t,s,l,n,i),s.translate(a,c),!0}}return!1}_attachRoomAtLoc(t,e,s,r){const[o,l]=r,n=s.hall?s.hall.doors:s.doors,h=i.random.sequence(4);for(let i of h){const r=n[(i+2)%4];if(!r||-1==r[0])continue;const h=o-r[0],a=l-r[1];if(this._roomFitsAt(t,e,h,a))return L(t,e,h,a),s.translate(h,a),!0}return!1}_roomFitsAt(t,i,e,s){let r,o,l,n,h,a;for(r=0;r<i.width;r++)for(o=0;o<i.height;o++)if(i.isSet(r,o))for(l=r+e,n=o+s,h=l-1;h<=l+1;h++)for(a=n-1;a<=n+1;a++)if(!t.hasXY(h,a)||t.isBoundaryXY(h,a)||!t.isNothing(h,a))return!1;return!0}_attachDoor(t,e,s,r,n){const h=this.doors;if(0===h.chance)return;const a=h.chance&&i.random.chance(h.chance)?h.tile||l:o;if(t.setTile(s,r,a),e.hall&&e.hall.width>1&&e.hall.dir===n)if(n===i.utils.UP||n===i.utils.DOWN){let i=!0,e=1;for(;i;)i=!1,t.isNothing(s-e,r)&&t.isSet(s-e,r-1)&&t.isSet(s-e,r+1)&&(t.setTile(s-e,r,a),i=!0),t.isNothing(s+e,r)&&t.isSet(s+e,r-1)&&t.isSet(s+e,r+1)&&(t.setTile(s+e,r,a),i=!0),++e}else{let i=!0,e=1;for(;i;)i=!1,t.isNothing(s,r-e)&&t.isSet(s-1,r-e)&&t.isSet(s+1,r-e)&&(t.setTile(s,r-e,a),i=!0),t.isNothing(s,r+e)&&t.isSet(s-1,r+e)&&t.isSet(s+1,r+e)&&(t.setTile(s,r+e,a),i=!0),++e}}addLoops(t,i){return new ot(i).create(t)}addLakes(t,i){return new J(i).create(t)}addBridges(t,i){return new it(i).create(t)}addStairs(t,i){return new st(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let e,s,r,l,n,h;do{for(h=!1,e=0;e<this.width-1;e++)for(s=0;s<this.height-1;s++)for(r=0;r<=1;r++)!t.blocksMove(e+r,s)&&t.blocksMove(e+(1-r),s)&&t.blocksDiagonal(e+(1-r),s)&&t.blocksMove(e+r,s+1)&&t.blocksDiagonal(e+r,s+1)&&!t.blocksMove(e+(1-r),s+1)&&(i.random.chance(50)?(l=e+(1-r),n=s):(l=e+r,n=s+1),h=!0,t.setTile(l,n,o))}while(1==h)}_finishDoors(t){i.utils.forRect(this.width,this.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.blocksPathing(i+1,e)?1:0)+(t.blocksPathing(i-1,e)?1:0)+(t.blocksPathing(i,e+1)?1:0)+(t.blocksPathing(i,e-1)?1:0)>=3)&&t.setTile(i,e,o)}))}_finishWalls(t){const e=this.boundary?d:h;i.utils.forRect(this.width,this.height,((i,s)=>{t.isNothing(i,s)&&(t.isBoundaryXY(i,s)?t.setTile(i,s,e):t.setTile(i,s,h))}))}}var ht={__proto__:null,site:p,room:X,hall:$,lake:tt,bridge:et,stairs:rt,utils:C,loop:lt,Hall:m,Room:E,Level:nt,Dungeon:class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],i.utils.setOptions(this.config,t),this.config.seed&&i.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=i.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const e=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let s=0;s<this.config.levels;++s){const s=i.random.matchingLoc(this.config.width,this.config.height,((s,r)=>i.utils.distanceBetween(t[0],t[1],s,r)>e));this.stairLocs.push([[t[0],t[1]],[s[0],s[1]]]),t=s}}getLevel(t,e){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);i.random.seed(this.seeds[t]);const[s,r]=this.stairLocs[t],o=Object.assign({},this.config.stairs);this.config.goesUp?(o.down=s,o.up=r,0==t&&this.config.startTile&&(o.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.upTile=this.config.endTile)):(o.down=r,o.up=s,0==t&&this.config.startTile&&(o.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(o.downTile=this.config.endTile));const l=Object.assign({},this.config.rooms);0===t&&l.entrance&&(l.first=l.entrance);const n={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:l,stairs:o,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,n,e)}makeLevel(t,e,s){const r=new nt(this.config.width,this.config.height,e),o=r.create(s);return i.utils.equalsXY(r.endLoc,e.endLoc)&&i.utils.equalsXY(r.startLoc,e.startLoc)||(this.stairLocs[t]=[r.startLoc,r.endLoc]),o}}};class at{constructor(t){if(this.info=t,!t.tile)throw new Error('Invalid effect - requires "tile".')}get abortIfBlocks(){return!!(this.info.flags&i.effect.Flags.E_ABORT_IF_BLOCKS_MAP)}spawn(t,e,s){const r=i.grid.alloc(s.width,s.height),o=this.fill(t,e,s,r);return(!this.abortIfBlocks||!S(s,r))&&(this.spawnTiles(s,r),i.grid.free(r),o)}compute(t,e,s){const r=this.info.tile;let o=r.grow,l=r.decrement;if(!s(t,e))return 0;let n=[[t+1,e],[t-1,e],[t,e+1],[t,e-1]],h=[];const a=new Set([`${t},${e}`]);let c=1;for(;n.length&&o>0;){for([h,n]=[n,h];h.length;){let[t,e]=h.pop();i.random.chance(o)&&s(t,e)&&(c++,i.utils.eachNeighbor(t,e,((t,i)=>{const e=t+","+i;a.has(e)||(a.add(e),n.push([t,i]))}),!0))}o-=l}return c}fill(t,i,e,s){return this.compute(t,i,((r,o)=>!!this.cellIsOk(e,r,o,r==t&&o==i)&&(s[r][o]=1,!0)))}cellIsOk(t,e,s,r){if(!t.hasXY(e,s))return!1;if(t.blocksEffects(e,s)&&!this.info.tile.matchTile&&!r)return!1;if(this.info.flags&i.effect.Flags.E_BUILD_IN_WALLS){if(!t.isWall(e,s))return!1}else if(this.info.flags&i.effect.Flags.E_MUST_TOUCH_WALLS){let r=!1;if(i.utils.eachNeighbor(e,s,((i,e)=>{t.isWall(i,e)&&(r=!0)}),!0),!r)return!1}else if(this.info.flags&i.effect.Flags.E_NO_TOUCH_WALLS){let r=!0;if(t.isWall(e,s))return!1;if(i.utils.eachNeighbor(e,s,((i,e)=>{t.isWall(i,e)&&(r=!1)}),!0),!r)return!1}return!(this.info.tile.matchTile&&!r&&!t.hasTile(e,s,this.info.tile.matchTile))}spawnTiles(t,e){var s;let r=!1;const o={superpriority:!!(this.info.flags&i.effect.Flags.E_SUPERPRIORITY),blockedByOtherLayers:!!(this.info.flags&i.effect.Flags.E_BLOCKED_BY_OTHER_LAYERS),blockedByActors:!!(this.info.flags&i.effect.Flags.E_BLOCKED_BY_ACTORS),blockedByItems:!!(this.info.flags&i.effect.Flags.E_BLOCKED_BY_ITEMS),volume:null===(s=this.info.tile)||void 0===s?void 0:s.volume};return e.forEach(((i,s,l)=>{i&&(e[s][l]=0,t.setTile(s,l,this.info.tile,o)&&(e[s][l]=1,r=!0))})),r}}const ct=i.flag.fl;var gt;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=ct(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=ct(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=ct(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=ct(6)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=ct(8)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=ct(9)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=ct(10)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=ct(11)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=ct(25)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=ct(26)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=ct(12)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=ct(13)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=ct(14)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=ct(19)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=ct(0)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=ct(5)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=ct(4)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=ct(15)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=ct(16)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=ct(17)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=ct(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=ct(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=ct(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=ct(24)]="BF_IMPREGNABLE",t[t.BF_NOT_IN_HALLWAY=ct(27)]="BF_NOT_IN_HALLWAY",t[t.BF_NOT_ON_LEVEL_PERIMETER=ct(28)]="BF_NOT_ON_LEVEL_PERIMETER",t[t.BF_SKELETON_KEY=ct(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=ct(30)]="BF_KEY_DISPOSABLE"}(gt||(gt={}));class ut{constructor(t={}){if(this.tile=0,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.spawn=null,t.tile)if("string"==typeof t.tile){const e=i.tile.tiles[t.tile];if(!e)throw new Error("Failed to find tile: "+t.tile);this.tile=e.index}else this.tile=t.tile;t.flags&&(this.flags=i.flag.from(gt,t.flags)),t.pad&&(this.pad=t.pad),this.count=i.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.spawn&&(this.spawn=i.effect.from(t.spawn))}cellIsCandidate(t,e,s,r,o){const l=t.site;if(this.flags&gt.BF_NOT_IN_HALLWAY&&i.utils.arcCount(s,r,((t,i)=>l.hasXY(t,i)&&l.isPassable(t,i)))>1)return!1;if(this.flags&gt.BF_NOT_ON_LEVEL_PERIMETER&&(0==s||s==l.width-1||0==r||r==l.height-1))return!1;if(this.flags&gt.BF_BUILD_AT_ORIGIN)return s==t.originX&&r==t.originY;if(e.isRoom&&s==t.originX&&r==t.originY)return!1;if(t.occupied[s][r])return!1;if(this.flags&(gt.BF_IN_VIEW_OF_ORIGIN|gt.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][r])return!1;let n=1e4;if(l.isWall(s,r)?i.utils.eachNeighbor(s,r,((i,e)=>{t.distanceMap.hasXY(i,e)&&!l.blocksPathing(i,e)&&n>t.distanceMap[i][e]+1&&(n=t.distanceMap[i][e]+1)}),!0):n=t.distanceMap[s][r],n>o[1]||n<o[0])return!1;if(this.flags&gt.BF_BUILD_IN_WALLS){const e=l.getMachine(s,r);if(!t.interior[s][r]&&(!e||e==t.machineNumber)&&l.isWall(s,r)){let e=!1;return i.utils.eachNeighbor(s,r,((i,s)=>{l.hasXY(i,s)&&(t.interior[i][s]&&(i!=t.originX||s!=t.originY)||this.flags&gt.BF_BUILD_ANYWHERE_ON_LEVEL&&!l.blocksPathing(i,s)&&!l.getMachine(i,s))&&(e=!0)})),e}return!1}return!l.isWall(s,r)&&(this.flags&gt.BF_BUILD_ANYWHERE_ON_LEVEL?!(this.item&&l.blocksItems(s,r)||l.hasCellFlag(s,r,i.map.flags.Cell.IS_CHOKEPOINT|i.map.flags.Cell.IS_IN_LOOP|i.map.flags.Cell.IS_IN_MACHINE)):!!t.interior[s][r])}makePersonalSpace(t,i,e,s){const r=this.pad;let o=0;for(let l=i-r+1;l<=i+r-1;l++)for(let i=e-r+1;i<=e+r-1;i++)t.site.hasXY(l,i)&&(s[l][i]&&(s[l][i]=0,++o),t.occupied[l][i]=1);return o}get generateEverywhere(){return!!(this.flags&gt.BF_EVERYWHERE&~gt.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&gt.BF_BUILD_AT_ORIGIN)}distanceBound(t){const i=[0,1e4];return this.flags&gt.BF_NEAR_ORIGIN&&(i[1]=t.distance25),this.flags&gt.BF_FAR_FROM_ORIGIN&&(i[0]=t.distance75),i}updateViewMap(t){if(this.flags&(gt.BF_IN_VIEW_OF_ORIGIN|gt.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const e=t.site;if(this.flags&gt.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new i.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}else{new i.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i)||e.blocksVision(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}t.viewMap[t.originX][t.originY]=1}}markCandidates(t,i,e,s){let r=0;return t.update(((t,o,l)=>this.cellIsCandidate(i,e,o,l,s)?(r++,1):0)),r}build(t,e){let s=0,r=0;const o=t.site,l=i.grid.alloc(o.width,o.height),n=this.distanceBound(t);this.updateViewMap(t);do{let h=this.markCandidates(l,t,e,n);if(this.generateEverywhere||(s=this.count.value()),!h||h<this.count.lo)return console.warn("Only %s qualifying tiles - want at least %s.",h,this.count.lo),0;let a=0,c=0;for(r=0;(this.generateEverywhere||r<s)&&h>0;){this.buildAtOrigin?(a=t.originX,c=t.originY):[a,c]=i.random.matchingLoc(l.width,l.height,(t=>t>0)),l[a][c]=0,h--;let s=!0,n=!0;if(this.spawn){s=new at(this.spawn).spawn(a,c,o)>0}if(s&&this.tile){let t=this.tile;if("string"==typeof t&&(t=i.tile.get(t).index),t){if(!(this.flags&gt.BF_PERMIT_BLOCKING)&&(o.tileBlocksMove(t)||this.flags&gt.BF_TREAT_AS_BLOCKING)){const t=i.grid.alloc(o.width,o.height);t[a][c]=1,n=!S(o,t),i.grid.free(t)}}else n=!1,console.error("placing invalid tile",this.tile,a,c);n&&o.setTile(a,c,t)}s&&n&&(h-=this.makePersonalSpace(t,a,c,l),r++),s&&n&&(e.flags&dt.BP_NO_INTERIOR_FLAG||o.setMachine(a,c,t.machineNumber,e.isRoom),this.flags&gt.BF_IMPREGNABLE&&o.setCellFlag(a,c,i.map.flags.Cell.IMPREGNABLE))}}while(this.flags&gt.BF_REPEAT_UNTIL_NO_PROGRESS&&r<=this.count.lo);return i.grid.free(l),r}}const ft=i.flag.fl;var dt;!function(t){t[t.BP_ROOM=ft(10)]="BP_ROOM",t[t.BP_VESTIBULE=ft(1)]="BP_VESTIBULE",t[t.BP_REWARD=ft(7)]="BP_REWARD",t[t.BP_ADOPT_ITEM=ft(0)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=ft(2)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=ft(3)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=ft(4)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=ft(5)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=ft(6)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=ft(8)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=ft(9)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=ft(14)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=ft(11)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=ft(12)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=ft(13)]="BP_NO_INTERIOR_FLAG"}(dt||(dt={}));class _t{constructor(t={}){if(this.tags=[],this.size=[-1,-1],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=i.frequency.make(t.frequency||100),t.size){if("string"==typeof t.size){const i=t.size.split(/-/).map((t=>t.trim())).map((t=>Number.parseInt(t)));if(2!==i.length)throw new Error("Blueprint size must be of format: #-#");this.size=[i[0],i[1]]}else{if(!Array.isArray(t.size))throw new Error("size must be string or array.");if(2!==t.size.length)throw new Error("Blueprint size must be [min, max]");this.size=[t.size[0],t.size[1]]}if(this.size[0]>this.size[1])throw new Error("Blueprint size must be small to large.")}t.flags&&(this.flags=i.flag.from(dt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new ut(t))))}getChance(t,i){return i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t))))?0:this.frequency(t)}get isRoom(){return!!(this.flags&dt.BP_ROOM)}get isReward(){return!!(this.flags&dt.BP_REWARD)}get isVestiblue(){return!!(this.flags&dt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&dt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&dt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&dt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&dt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&dt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&dt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&dt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&dt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&dt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&dt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&dt.BP_NO_INTERIOR_FLAG)}qualifies(t,i){return!(this.frequency(i)<=0||~this.flags&t||this.flags&dt.BP_ADOPT_ITEM&~t||this.flags&dt.BP_VESTIBULE&~t)}pickLocation(t){if(this.isRoom){const e=i.random.matchingLoc(t.width,t.height,((e,s)=>t.hasCellFlag(e,s,i.map.flags.Cell.IS_GATE_SITE)));return!e||e[0]<0||e[1]<0?(console.log("Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint."),!1):e}if(this.isVestiblue)return console.log("ERROR: Attempted to build a vestiblue without a location being provided."),!1;const e=i.random.matchingLoc(t.width,t.height,((i,e)=>t.isPassable(i,e)));return!(!e||e[0]<0||e[1]<0)&&e}computeInterior(t){let e,s=this.isRoom?10:20;const r=t.interior,o=t.site;do{if(e=!1,--s<=0)return console.log("Failed to build a machine; failed repeatedly to find a suitable blueprint location."),!1;if(r.fill(0),this.isRoom)e=!this.addTileToInteriorAndIterate(t,t.originX,t.originY);else if(this.isVestiblue){if(!this.computeInteriorForVestibuleMachine(t))return console.error("ERROR: Attempted to build a door machine from blueprint: not enough room."),!1}else{let s=i.grid.alloc(r.width,r.height);N(o,s,t.originX,t.originY,this.size[1]);const l=i.random.sequence(o.width*o.height);let n=0,h=i.random.range(this.size[0],this.size[1]);for(let t=0;t<1e3&&n<h;t++)for(let a=0;a<l.length&&n<h;a++){const c=Math.floor(l[a]/o.height),g=l[a]%o.height;s[c][g]==t&&(r[c][g]=1,n++,(o.isOccupied(c,g)||o.hasCellFlag(c,g,i.map.flags.Cell.IS_IN_MACHINE))&&(e=!0,n=h))}n<h?(e=!0,console.log("too small")):this.treatAsBlocking&&S(o,r)?(console.log("disconnected"),e=!0):this.requireBlocking&&B(o,r)<100&&(console.log("not disconnected enough"),e=!0),i.grid.free(s)}}while(e);return console.log(e,s),!0}addTileToInteriorAndIterate(t,e,s){let r=!0;const o=t.interior,l=t.site;o[e][s]=1;const n=l.getChokeCount(e,s);for(let h=0;h<4&&r;h++){const a=e+i.utils.DIRS[h][0],c=s+i.utils.DIRS[h][1];if(l.hasXY(a,c)&&!o[a][c]){if(l.isOccupied(a,c)||l.hasCellFlag(a,c,i.map.flags.Cell.IS_IN_MACHINE)&&!l.hasCellFlag(a,c,i.map.flags.Cell.IS_GATE_SITE))return!1;l.getChokeCount(a,c)<=n&&!l.hasCellFlag(a,c,i.map.flags.Cell.IS_IN_MACHINE)&&(r=this.addTileToInteriorAndIterate(t,a,c))}}return r}computeInteriorForVestibuleMachine(t){let e=!0;const s=t.interior,r=t.site;s.fill(0);let o=0;const l=i.random.range(this.size[0],this.size[1]),n=i.grid.alloc(r.width,r.height);N(r,n,t.originX,t.originY,this.size[1]);const h=i.random.sequence(r.width*r.height);for(let t=0;t<1e3&&o<l;t++)for(let i=0;i<h.length&&o<l;++i){const a=Math.floor(h[i]/r.height),c=h[i]%r.height;n[a][c]==t&&(r.isOccupied(a,c)&&(e=!1,o=l),s[a][c]=1,o+=1)}return(this.treatAsBlocking&&S(r,s)||this.requireBlocking&&B(r,s)<100)&&(e=!1),i.grid.free(n),e}prepareInteriorWithMachineFlags(t){const e=t.interior,s=t.site;this.maximizeInterior?this.expandMachineInterior(t,1):this.openInterior&&this.expandMachineInterior(t,4),this.purgeInterior&&e.forEach(((t,i,e)=>{t&&s.setTile(i,e,o)})),this.purgeBlockers&&e.forEach(((t,i,e)=>{t&&s.blocksPathing(i,e)&&s.setTile(i,e,o)})),this.purgeLiquids&&e.forEach(((t,i,e)=>{t&&s.isAnyLiquid(i,e)&&s.setTile(i,e,o)})),this.surroundWithWalls&&e.forEach(((t,r,o)=>{t&&!s.hasCellFlag(r,o,i.map.flags.Cell.IS_GATE_SITE)&&i.utils.eachNeighbor(r,o,((t,r)=>{e.hasXY(t,r)&&(e[t][r]||s.isWall(t,r)||s.hasCellFlag(t,r,i.map.flags.Cell.IS_GATE_SITE)||s.hasCellFlag(t,r,i.map.flags.Cell.IS_IN_MACHINE)||s.blocksPathing(t,r)&&s.setTile(t,r,h))}),!1)})),this.makeImpregnable&&e.forEach(((t,r,o)=>{t&&!s.hasCellFlag(r,o,i.map.flags.Cell.IS_GATE_SITE)&&(s.setCellFlag(r,o,i.map.flags.Cell.IMPREGNABLE),i.utils.eachNeighbor(r,o,((t,r)=>{e.hasXY(t,r)&&(e[t][r]||s.hasCellFlag(t,r,i.map.flags.Cell.IS_GATE_SITE)||s.setCellFlag(t,r,i.map.flags.Cell.IMPREGNABLE))}),!1))}));const r=t.machineNumber;e.forEach(((t,i,e)=>{t&&(s.setMachine(i,e,r,this.isRoom),s.isSecretDoor(i,e)&&s.setTile(i,e,l))}))}expandMachineInterior(t,e=1){let s;const r=t.interior,l=t.site;do{s=!1,r.forEach(((t,n,a)=>{if(l.hasCellFlag(n,a,i.map.flags.Cell.IS_IN_MACHINE))return;if(!l.blocksPathing(n,a))return;let c=0;i.utils.eachNeighbor(n,a,((t,i)=>{r.hasXY(t,i)&&r[t][i]&&!l.blocksPathing(t,i)&&++c}),!1),c<e||(c=0,i.utils.eachNeighbor(n,a,((t,e)=>{r.hasXY(t,e)&&(r[t][e]||l.isWall(t,e)&&!l.hasCellFlag(t,e,i.map.flags.Cell.IS_IN_MACHINE)||++c)}),!1),c||(s=!0,r[n][a]=1,l.blocksPathing(n,a)&&l.setTile(n,a,o),i.utils.eachNeighbor(n,a,((t,i)=>{r.hasXY(t,i)&&(l.isSet(t,i)||l.setTile(t,i,h))}))))}))}while(s)}calcDistances(t){t.distanceMap.fill(0),N(t.site,t.distanceMap,t.originX,t.originY,this.size[1]);let i=0;const e=new Array(100).fill(0);t.interior.forEach(((s,r,o)=>{if(!s)return;const l=t.distanceMap[r][o];l<100&&(e[l]++,i++)}));let s=Math.round(i/4),r=Math.round(3*i/4);for(let t=0;t<100;t++){if(s<=e[t]){s=t;break}s-=e[t]}for(let t=0;t<100;t++){if(r<=e[t]){r=t;break}r-=e[t]}t.distance25=s,t.distance75=r}pickComponents(){const t=[gt.BF_ALTERNATIVE,gt.BF_ALTERNATIVE_2],e=new Array(this.steps.length).fill(!0);for(let s=0;s<=1;s++){let r=0;for(let i=0;i<e.length;i++)this.steps[i].flags&t[s]&&(e[i]=!1,r++);if(r>0){let o=i.random.range(1,r);for(let i=0;i<e.length;i++)if(this.steps[i].flags&t[s]){if(1==o){e[i]=!0;break}o--}}}return this.steps.filter(((t,i)=>e[i]))}clearInteriorFlag(t){t.interior.forEach(((e,s,r)=>{e&&(t.site.hasCellFlag(s,r,i.map.flags.Cell.IS_WIRED|i.map.flags.Cell.IS_CIRCUIT_BREAKER)||t.site.setMachine(s,r,0))}))}}const It={};function pt(t,i){return i instanceof _t||(i=new _t(i)),It[t]=i,i.id=t,i}function mt(t,e){const s=Object.values(It).filter((i=>i.qualifies(t,e)));return i.random.item(s)}var Et={__proto__:null,get Flags(){return dt},Blueprint:_t,blueprints:It,install:pt,random:mt};class Ot{constructor(t=!1){this.withCounts=t}compute(t){const e=i.grid.alloc(t.width,t.height),s=i.grid.alloc(t.width,t.height);let r;s.update(((i,e,s)=>t.isPassable(e,s)?1:0));for(let e=1;e<s.width-1;e++)for(let o=1;o<s.height-1;o++)if(t.clearCellFlag(e,o,i.map.flags.Cell.IS_CHOKEPOINT),t.setChokeCount(e,o,3e4),s[e][o]&&!t.hasCellFlag(e,o,i.map.flags.Cell.IS_IN_LOOP)){r=0;for(let l=0;l<8;l++){const n=e+i.utils.CLOCK_DIRS[(l+7)%8][0],h=o+i.utils.CLOCK_DIRS[(l+7)%8][1],a=e+i.utils.CLOCK_DIRS[l][0],c=o+i.utils.CLOCK_DIRS[l][1];if(s.hasXY(a,c)&&s.hasXY(n,h)&&s[a][c]!=s[n][h]&&++r>2){(s[e-1][o]||s[e+1][o])&&(s[e][o-1]||s[e][o+1])||t.setCellFlag(e,o,i.map.flags.Cell.IS_CHOKEPOINT);break}}}if(this.withCounts){s.update(((e,s,r)=>e&&t.hasCellFlag(s,r,i.map.flags.Cell.IS_IN_ROOM_MACHINE)?0:e));for(let r=0;r<t.width;r++)for(let o=0;o<t.height;o++)if(s[r][o]&&t.hasCellFlag(r,o,i.map.flags.Cell.IS_CHOKEPOINT))for(let l=0;l<4;l++){const n=r+i.utils.DIRS[l][0],h=o+i.utils.DIRS[l][1];if(s.hasXY(n,h)&&s[n][h]&&!t.hasCellFlag(n,h,i.map.flags.Cell.IS_CHOKEPOINT)){e.fill(0),s[r][o]=0;let l=Rt(t,e,s,n,h);if(s[r][o]=1,l>=4){for(let s=0;s<e.width;s++)for(let r=0;r<e.height;r++)e[s][r]&&l<t.getChokeCount(s,r)&&(t.setChokeCount(s,r,l),t.clearCellFlag(s,r,i.map.flags.Cell.IS_GATE_SITE));l<t.getChokeCount(r,o)&&(t.setChokeCount(r,o,l),t.setCellFlag(r,o,i.map.flags.Cell.IS_GATE_SITE))}}}}i.grid.free(s),i.grid.free(e)}}function Rt(t,e,s,r,o){let l=2==s[r][o]?5e3:1;t.isDeep(r,o)&&(l=1e4),e[r][o]=1;for(let n=0;n<4;n++){const h=r+i.utils.DIRS[n][0],a=o+i.utils.DIRS[n][1];t.hasXY(h,a)&&s[h][a]&&!e[h][a]&&(l+=Rt(t,e,s,h,a))}return Math.min(l,1e4)}class Tt{constructor(){}compute(t){this._initGrid(t),i.utils.forRect(t.width,t.height,((i,e)=>this._checkCell(t,i,e)))}_initGrid(t){i.utils.forRect(t.width,t.height,((e,s)=>{t.isPassable(e,s)?t.setCellFlag(e,s,i.map.flags.Cell.IS_IN_LOOP):t.clearCellFlag(e,s,i.map.flags.Cell.IS_IN_LOOP)}))}_checkCell(t,e,s){let r,o,l,n,h,a,c,g;if(t.hasCellFlag(e,s,i.map.flags.Cell.IS_IN_LOOP)){for(h=0;h<8&&(o=e+i.utils.CLOCK_DIRS[h][0],l=s+i.utils.CLOCK_DIRS[h][1],!t.hasXY(o,l)||t.hasCellFlag(o,l,i.map.flags.Cell.IS_IN_LOOP));h++);if(8!=h){for(a=c=g=0,r=!1,n=h;n<h+8;n++){if(o=e+i.utils.CLOCK_DIRS[n%8][0],l=s+i.utils.CLOCK_DIRS[n%8][1],!t.hasXY(o,l))continue;if(t.hasCellFlag(o,l,i.map.flags.Cell.IS_IN_LOOP)){if(g++,!r){if(a>0)return!1;a++,r=!0}}else r&&(g>c&&(c=g),g=0,r=!1)}if(r&&g>c&&(c=g),1==a&&c<=4)for(t.clearCellFlag(e,s,i.map.flags.Cell.IS_IN_LOOP),n=0;n<8;n++){const r=e+i.utils.CLOCK_DIRS[n][0],o=s+i.utils.CLOCK_DIRS[n][1];t.hasXY(r,o)&&this._checkCell(t,r,o)}}}}_fillInnerLoopGrid(t,e){for(let s=0;s<t.width;++s)for(let r=0;r<t.height;++r)if(t.hasCellFlag(s,r,i.map.flags.Cell.IS_IN_LOOP))e[s][r]=1;else if(s>0&&r>0){const o=t.hasCellFlag(s,r-1,i.map.flags.Cell.IS_IN_LOOP),l=t.hasCellFlag(s-1,r,i.map.flags.Cell.IS_IN_LOOP);o&&l&&(e[s][r]=1)}}_update(t){const e=i.grid.alloc(t.width,t.height);let s;this._fillInnerLoopGrid(t,e);for(let r=0;r<t.width;r++)for(let o=0;o<t.height;o++)if(t.hasCellFlag(r,o,i.map.flags.Cell.IS_IN_LOOP)){s=!1;for(let l=0;l<8;l++){let n=r+i.utils.CLOCK_DIRS[l][0],h=o+i.utils.CLOCK_DIRS[l][1];if(t.hasXY(n,h)&&!e[n][h]&&!t.hasCellFlag(n,h,i.map.flags.Cell.IS_IN_LOOP)){s=!0;break}}s||(e[r][o]=1,t.clearCellFlag(r,o,i.map.flags.Cell.IS_IN_LOOP))}i.grid.free(e)}}const Lt=i.map.flags.Cell;class wt{constructor(t,e){this.machineCount=0,this.map=new i.map.Map(t,e),this.machineId=new i.grid.NumGrid(t,e)}hasCellFlag(t,i,e){return this.map.hasCellFlag(t,i,e)}setCellFlag(t,i,e){this.map.setCellFlag(t,i,e)}clearCellFlag(t,i,e){this.map.clearCellFlag(t,i,e)}free(){}hasXY(t,i){return this.map.hasXY(t,i)}isBoundaryXY(t,i){return this.map.isBoundaryXY(t,i)}isSet(t,i){return this.map.hasXY(t,i)&&!this.map.cell(t,i).isEmpty()}isDiggable(t,i){if(!this.map.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.isEmpty()||!!e.isWall()}isNothing(t,i){return this.map.hasXY(t,i)&&this.map.cell(t,i).isEmpty()}isPassable(t,i){return this.map.isPassable(t,i)}isFloor(t,i){return this.map.isPassable(t,i)}isBridge(t,e){return this.map.hasTileFlag(t,e,i.tile.flags.Tile.T_BRIDGE)}isDoor(t,e){return this.map.hasTileFlag(t,e,i.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,e){return this.map.hasObjectFlag(t,e,i.gameObject.flags.GameObject.L_SECRETLY_PASSABLE)}blocksMove(t,i){return this.map.blocksMove(t,i)}blocksDiagonal(t,e){return this.map.hasObjectFlag(t,e,i.gameObject.flags.GameObject.L_BLOCKS_DIAGONAL)}blocksPathing(t,e){return this.map.hasObjectFlag(t,e,i.gameObject.flags.GameObject.L_BLOCKS_MOVE)||this.map.hasTileFlag(t,e,i.tile.flags.Tile.T_PATHING_BLOCKER)}blocksVision(t,i){return this.map.blocksVision(t,i)}blocksItems(t,e){return this.map.hasObjectFlag(t,e,i.gameObject.flags.GameObject.L_BLOCKS_ITEMS)}blocksEffects(t,e){return this.map.hasObjectFlag(t,e,i.gameObject.flags.GameObject.L_BLOCKS_EFFECTS)}isWall(t,i){return this.map.isWall(t,i)}isStairs(t,i){return this.map.isStairs(t,i)}isDeep(t,e){return this.map.hasTileFlag(t,e,i.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,e){if(!this.hasXY(t,e))return!1;const s=this.map.cell(t,e);return s.depthTile(i.gameObject.flags.Depth.LIQUID)&&!s.hasTileFlag(i.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,e){if(!this.hasXY(t,e))return!1;const s=this.map.cell(t,e);return s.hasDepthTile(i.gameObject.flags.Depth.LIQUID)||s.hasTileFlag(i.tile.flags.Tile.T_IS_DEEP_LIQUID)}hasTile(t,i,e){return this.map.hasTile(t,i,e)}getTileIndex(t,i){if(!this.map.hasXY(t,i))return 0;return this.map.cell(t,i).highestPriorityTile().index}tileBlocksMove(t){return i.tile.get(t).blocksMove()}get width(){return this.map.width}get height(){return this.map.height}backup(){const t=new wt(this.width,this.height);return t.map.copy(this.map),t.machineId.copy(this.machineId),t.machineCount=this.machineCount,t}restore(t){this.map.copy(t.map),this.machineId.copy(t.machineId),this.machineCount=t.machineCount}getChokeCount(t,i){return this.map.cell(t,i).chokeCount}setChokeCount(t,i,e){this.map.cell(t,i).chokeCount=e}isOccupied(t,i){return this.hasItem(t,i)||this.hasActor(t,i)}hasItem(t,i){return this.map.hasItem(t,i)}hasActor(t,i){return this.map.hasActor(t,i)}setTile(t,i,e,s){return this.map.setTile(t,i,e,s)}nextMachineId(){return++this.machineCount}getMachine(t,i){return this.machineId[t][i]}setMachine(t,i,e,s=!0){this.machineId[t][i]=e,0==e?this.clearCellFlag(t,i,Lt.IS_IN_MACHINE):this.setCellFlag(t,i,s?Lt.IS_IN_ROOM_MACHINE:Lt.IS_IN_AREA_MACHINE)}}var St={__proto__:null,MapSite:wt};var Bt={__proto__:null,blueprint:Et,site:St,analyze:{ChokeFinder:Ot,LoopFinder:Tt},analyzeSite:function(t){(new Tt).compute(t),new Ot(!0).compute(t)},get Flags(){return dt},Blueprint:_t,blueprints:It,install:pt,random:mt,get StepFlags(){return gt},BuildStep:ut,Builder:class{constructor(t,e){this.site=t,this.depth=e,this.spawnedItems=[],this.spawnedHordes=[],this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.interior=i.grid.alloc(t.width,t.height),this.occupied=i.grid.alloc(t.width,t.height),this.viewMap=i.grid.alloc(t.width,t.height),this.distanceMap=i.grid.alloc(t.width,t.height)}free(){i.grid.free(this.interior),i.grid.free(this.occupied),i.grid.free(this.viewMap),i.grid.free(this.distanceMap)}buildRandom(t=dt.BP_ROOM){let e=10;for(;e--;){const i=mt(t,this.depth);if(i&&this.buildBlueprint(i))return!0}return console.log("Failed to find blueprint matching flags: "+i.flag.toString(dt,t)),!1}buildBlueprint(t){let i=10;for(;i--;){const i=t.pickLocation(this.site);if(i&&this.build(t,i[0],i[1]))return!0}return console.log("Failed to build blueprint."),!1}build(t,i,e){if(this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=i,this.originY=e,!t.computeInterior(this))return!1;const s=this.site.backup();this.machineNumber=this.site.nextMachineId(),t.prepareInteriorWithMachineFlags(this),t.calcDistances(this);const r=t.pickComponents();for(let i=0;i<r.length;i++){const e=r[i];console.log("BUILD COMPONENT",e);if(e.build(this,t)<e.count.lo&&!(e.flags&gt.BF_REPEAT_UNTIL_NO_PROGRESS))return console.log("Failed to place blueprint because of feature; needed more instances."),this.site.restore(s),!1}return t.noInteriorFlag&&t.clearInteriorFlag(this),!0}}};t.build=Bt,t.dig=ht,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

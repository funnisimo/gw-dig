!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-map"),require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-map","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWM,t.GWU)}(this,(function(t,i,e){"use strict";function s(t){if(t&&t.__esModule)return t;var i=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(i,e,s.get?s:{enumerable:!0,get:function(){return t[e]}})}})),i.default=t,Object.freeze(i)}var n,o,r=s(i),a=s(e);const l=r.tile.get("NULL").index,h=r.tile.get("FLOOR").index,c=r.tile.get("DOOR").index,g=null!==(o=null===(n=r.tile.get("DOOR_SECRET"))||void 0===n?void 0:n.index)&&void 0!==o?o:-1,d=r.tile.get("WALL").index,u=r.tile.get("LAKE").index,f=r.tile.get("SHALLOW").index,p=r.tile.get("BRIDGE").index,_=r.tile.get("UP_STAIRS").index,I=r.tile.get("DOWN_STAIRS").index,m=r.tile.get("IMPREGNABLE").index,E={[l]:"NULL",[h]:"FLOOR",[c]:"DOOR",[d]:"WALL",[m]:"IMPREGNABLE",[u]:"LAKE",[f]:"SHALLOW",[p]:"BRIDGE",[_]:"UP_STAIRS",[I]:"DOWN_STAIRS"},w=a.xy.DIRS;function S(t,i,e){let s,n,o,r,l,h;for(n=a.xy.NO_DIRECTION,s=0;s<4;s++)if(o=i+w[s][0],r=e+w[s][1],l=i-w[s][0],h=e-w[s][1],t.hasXY(l,h)&&t.hasXY(o,r)&&t.isFloor(l,h)){if(n!=a.xy.NO_DIRECTION)return a.xy.NO_DIRECTION;n=s}return n}function B(t){let i,e,s,n,o,r,l;const h=[[],[],[],[]],c=t.height,g=t.width;for(i=0;i<g;i++)for(e=0;e<c;e++)if(t.isDiggable(i,e)&&(r=S(t,i,e),r!=a.xy.NO_DIRECTION)){for(n=i+a.xy.DIRS[r][0],o=e+a.xy.DIRS[r][1],l=!1,s=0;s<10&&t.hasXY(n,o)&&!l;s++)t.isSet(n,o)&&(l=!0),n+=a.xy.DIRS[r][0],o+=a.xy.DIRS[r][1];l||h[r].push([i,e])}let d=[];for(r=0;r<4;r++){const i=t.rng.item(h[r])||[-1,-1];d[r]=[i[0],i[1]]}return d}function y(t,i,e=0,s=0){a.xy.forRect(t.width,t.height,((n,o)=>{const r=n-e,a=o-s,l=i.getTileIndex(r,a);l&&t.setTile(n,o,l)}))}function R(t,i){i.update(((i,e,s)=>t.isPassable(e,s)?1:a.path.OBSTRUCTION))}function O(t,i,e,s={}){var n,o,r;if(null!==(n=s.offsetX)&&void 0!==n||(s.offsetX=0),null!==(o=s.offsetY)&&void 0!==o||(s.offsetY=0),null!==(r=s.machine)&&void 0!==r||(s.machine=0),a.xy.arcCount(i,e,((i,e)=>t.isPassable(i,e)))<=1)return!1;const l=a.grid.alloc(t.width,t.height);l[i][e]=1;const h=T(t,l,s);return a.grid.free(l),h}function T(t,i,e={}){var s,n,o;null!==(s=e.offsetX)&&void 0!==s||(e.offsetX=0),null!==(n=e.offsetY)&&void 0!==n||(e.offsetY=0),null!==(o=e.machine)&&void 0!==o||(e.machine=0);const r=a.grid.alloc(t.width,t.height);let l=!1;if(a.xy.forRect(t.width,t.height,((s,n)=>{const o=s+e.offsetX,a=n+e.offsetY;i.get(o,a)?t.isStairs(s,n)&&(l=!0):!t.isPassable(s,n)||0!=t.getMachine(s,n)&&t.getMachine(s,n)!=e.machine||(r[s][n]=1)})),e.updateWalkable&&!e.updateWalkable(r))return!0;let h=!0;for(let t=0;t<r.width&&!l;++t)for(let i=0;i<r.height&&!l;++i)1==r[t][i]&&(h?(r.floodFill(t,i,1,2),h=!1):l=!0);return a.grid.free(r),l}function A(t,i,e=0,s=0){const n=a.grid.alloc(t.width,t.height);let o=0;if(a.xy.forRect(t.width,t.height,((r,a)=>{const l=r+e,h=a+s;i.get(l,h)?t.isStairs(r,a)&&(o=t.width*t.height):t.isPassable(r,a)&&(n[r][a]=1)})),o)return o;let r=!0,l=2,h=t.width*t.height;for(let t=0;t<n.width;++t)for(let i=0;i<n.height;++i)if(1==n[t][i]){const e=n.floodFill(t,i,1,l++);h=Math.min(h,e),r?r=!1:o=h}return a.grid.free(n),o}function b(t,i,e,s,n){const o=a.grid.alloc(t.width,t.height);R(t,o),a.path.calculateDistances(i,e,s,o,!1,n+1),a.grid.free(o)}function L(t,i){for(let e=0;e<t.width;e++)for(let s=0;s<t.height;s++)t.getMachine(e,s)!=i||t.hasCellFlag(e,s,r.flags.Cell.IS_WIRED|r.flags.Cell.IS_CIRCUIT_BREAKER)||t.setMachine(e,s,0)}class N{constructor(t,i){this.rng=a.rng.random,this.tiles=a.grid.alloc(t,i),this.doors=a.grid.alloc(t,i)}free(){a.grid.free(this.tiles),a.grid.free(this.doors)}clear(){this.tiles.fill(0),this.doors.fill(0)}dump(){this.tiles.dump()}drawInto(t){t.blackOut(),this.tiles.forEach(((i,e,s)=>{const n=r.tile.get(i);t.drawSprite(e,s,n.sprite)}))}setSeed(t){this.rng.seed(t)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return this.tiles.get(t,i)===l}isDiggable(t,i){return this.tiles.get(t,i)===l}isFloor(t,i){return this.tiles.get(t,i)==h}isDoor(t,i){return this.tiles.get(t,i)===c}isSecretDoor(t,i){return this.tiles.get(t,i)===g}isBridge(t,i){return this.tiles.get(t,i)===p}isWall(t,i){const e=this.tiles.get(t,i);return e===d||e===m}blocksMove(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)}blocksDiagonal(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksPathing(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)||this.isStairs(t,i)}blocksVision(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksItems(t,i){return this.blocksPathing(t,i)||this.blocksPathing(t,i)}blocksEffects(t,i){return this.isWall(t,i)}isStairs(t,i){const e=this.tiles.get(t,i);return e===_||e===I}isDeep(t,i){return this.tiles.get(t,i)===u}isShallow(t,i){return this.tiles.get(t,i)===f}isAnyLiquid(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTileIndex(t,i){return this.tiles.get(t,i)||0}setTile(t,i,e){if(e instanceof r.tile.Tile&&(e=e.index),"string"==typeof e){const t=r.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return!!this.tiles.hasXY(t,i)&&(this.tiles[t][i]=e,!0)}hasTile(t,i,e){if(e instanceof r.tile.Tile&&(e=e.index),"string"==typeof e){const t=r.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return this.tiles.hasXY(t,i)&&this.tiles[t][i]==e}getMachine(t,i){return 0}updateDoorDirs(){this.doors.update(((t,i,e)=>S(this,i,e)))}getDoorDir(t,i){return this.doors[t][i]}}const F=r.flags.Cell;class M{constructor(t,i){this.machineCount=0,this.needsAnalysis=!0,this.isUsed=!1,this.site=t,this.snapshot=i,this.machineCount=this.site.machineCount,this.needsAnalysis=this.site.needsAnalysis,this.isUsed=!0}restore(){this.site.snapshots.revertMapTo(this.snapshot),this.site.machineCount=this.machineCount,this.site.needsAnalysis=this.needsAnalysis,this.cancel()}cancel(){this.site.snapshots.release(this.snapshot)}}class D{constructor(t){this.machineCount=0,this.needsAnalysis=!0,this.map=t,this.doors=a.grid.alloc(t.width,t.height),this.snapshots=new r.map.SnapshotManager(t)}get rng(){return this.map.rng}setSeed(t){this.map.seed=t}get width(){return this.map.width}get height(){return this.map.height}dump(){this.map.dump()}drawInto(t){this.map.drawInto(t)}hasXY(t,i){return this.map.hasXY(t,i)}isBoundaryXY(t,i){return this.map.isBoundaryXY(t,i)}hasCellFlag(t,i,e){return this.map.cellInfo(t,i).hasCellFlag(e)}setCellFlag(t,i,e){this.needsAnalysis=!0,this.map.cell(t,i).setCellFlag(e)}clearCellFlag(t,i,e){this.needsAnalysis=!0,this.map.cell(t,i).clearCellFlag(e)}hasTile(t,i,e){return this.map.cellInfo(t,i).hasTile(e)}setTile(t,i,e,s){return this.needsAnalysis=!0,this.map.setTile(t,i,e,s)}getTileIndex(t,i){if(!this.hasXY(t,i))return 0;return this.map.cell(t,i).highestPriorityTile().index}clear(){this.needsAnalysis=!0,this.map.cells.forEach((t=>t.clear()))}hasItem(t,i){return this.map.cellInfo(t,i).hasItem()}makeRandomItem(t){return"string"==typeof t&&(t={tags:t}),t.rng=this.rng,r.item.makeRandom(t)}addItem(t,i,e){return this.needsAnalysis=!0,this.map.forceItem(t,i,e)}hasActor(t,i){return this.map.hasActor(t,i)}blocksMove(t,i){return this.map.cellInfo(t,i).blocksMove()}blocksVision(t,i){return this.map.cellInfo(t,i).blocksVision()}blocksDiagonal(t,i){return this.map.cellInfo(t,i).hasEntityFlag(r.flags.Entity.L_BLOCKS_DIAGONAL)}blocksPathing(t,i){const e=this.map.cellInfo(t,i);return e.hasEntityFlag(r.flags.Entity.L_BLOCKS_MOVE)||e.hasTileFlag(r.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,i){return this.map.cellInfo(t,i).hasEntityFlag(r.flags.Entity.L_BLOCKS_ITEMS)}blocksEffects(t,i){return this.map.cellInfo(t,i).hasEntityFlag(r.flags.Entity.L_BLOCKS_EFFECTS)}isWall(t,i){return this.map.cellInfo(t,i).isWall()}isStairs(t,i){return this.map.cellInfo(t,i).isStairs()}isSet(t,i){return this.hasXY(t,i)&&!this.map.cell(t,i).isEmpty()}isDiggable(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.isEmpty()||!!e.isWall()}isNothing(t,i){return this.hasXY(t,i)&&this.map.cell(t,i).isEmpty()}isFloor(t,i){return this.isPassable(t,i)}isBridge(t,i){return this.map.cellInfo(t,i).hasTileFlag(r.tile.flags.Tile.T_BRIDGE)}isDoor(t,i){return this.map.cellInfo(t,i).hasTileFlag(r.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,i){return this.map.cellInfo(t,i).hasEntityFlag(r.flags.Entity.L_SECRETLY_PASSABLE)}isDeep(t,i){return this.map.cellInfo(t,i).hasTileFlag(r.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.depthTile(r.flags.Depth.LIQUID)&&!e.hasTileFlag(r.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return e.hasDepthTile(r.flags.Depth.LIQUID)||e.hasTileFlag(r.tile.flags.Tile.T_IS_DEEP_LIQUID)}isOccupied(t,i){return this.hasItem(t,i)||this.hasActor(t,i)}isPassable(t,i){const e=this.map.cellInfo(t,i);return!(e.blocksMove()||e.blocksPathing())}snapshot(){return new M(this,this.snapshots.takeNew())}free(){a.grid.free(this.doors)}getChokeCount(t,i){return this.map.cell(t,i).chokeCount}setChokeCount(t,i,e){this.map.cell(t,i).chokeCount=e}analyze(){this.needsAnalysis&&r.map.analyze(this.map),this.needsAnalysis=!1}buildEffect(t,i,e){return this.needsAnalysis=!0,r.effect.fireSync(t,this.map,i,e,{rng:this.rng})}nextMachineId(){return++this.machineCount}getMachine(t,i){return this.map.cell(t,i).machineId}setMachine(t,i,e,s=!0){this.needsAnalysis=!0,this.map.cell(t,i).machineId=e,0==e?this.map.clearCellFlag(t,i,F.IS_IN_MACHINE):this.map.setCellFlag(t,i,s?F.IS_IN_ROOM_MACHINE:F.IS_IN_AREA_MACHINE)}updateDoorDirs(){this.doors.update(((t,i,e)=>S(this,i,e)))}getDoorDir(t,i){return this.doors[t][i]}}var C=Object.freeze({__proto__:null,NOTHING:l,FLOOR:h,DOOR:c,SECRET_DOOR:g,WALL:d,DEEP:u,SHALLOW:f,BRIDGE:p,UP_STAIRS:_,DOWN_STAIRS:I,IMPREGNABLE:m,TILEMAP:E,directionOfDoorSite:S,chooseRandomDoorSites:B,copySite:y,fillCostGrid:R,siteDisruptedByXY:O,siteDisruptedBy:T,siteDisruptedSize:A,computeDistanceMap:b,clearInteriorFlag:L,GridSite:N,MapSnapshot:M,MapSite:D});class P extends a.xy.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[]}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}function x(t,i,e,s=1){const n=a.xy.DIRS[i],o=Math.min(t[0],t[0]+n[0]*(e-1)),r=Math.min(t[1],t[1]+n[1]*(e-1)),l=Math.abs(n[0]*e)||s,h=Math.abs(n[1]*e)||s;return new P(o,r,l,h)}class k extends a.xy.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}function v(t,i={}){return t=t||{},i=i||{},Object.entries(i).forEach((([i,e])=>{let s=t[i];if("tile"===i)return void(void 0===s&&(t[i]=e));if(!0===e){if(!s)throw new Error("Missing required config for room digger: "+i)}else s=("number"==typeof e||Array.isArray(e),s||e);const n=a.range.make(s);t[i]=n})),t}class Y{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=v(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=B(t))),i}}var X={};class G extends Y{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,i={}){const e=t.choices||i.choices;if(Array.isArray(e))this.randomRoom=t=>t.item(e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=t=>t.weighted(e)}}carve(t){let i=this.randomRoom(t.rng);const e=X[i];return e||a.ERROR("Missing room digger choice: "+i),e.create(t)}}class W extends Y{constructor(t={}){super(t,{width:12,height:8})}carve(t){const i=this.options.width.value(t.rng),e=this.options.height.value(t.rng),s=this.options.tile||h,n=a.grid.alloc(t.width,t.height,0),o=Math.floor(.5*i),r=i,l=Math.floor(.5*e),c=e,g=new a.blob.Blob({rng:t.rng,rounds:5,minWidth:o,minHeight:l,maxWidth:r,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(n.width,n.height,((t,i)=>n[t][i]=1)),d=Math.floor((t.width-g.width)/2),u=d-g.x,f=Math.floor((t.height-g.height)/2),p=f-g.y;return n.forEach(((i,e,n)=>{i&&t.setTile(e+u,n+p,s)})),a.grid.free(n),new k(d,f,g.width,g.height)}}class U extends Y{constructor(t={}){super(t,{width:20,height:10})}carve(t){const i=this.options.width.value(t.rng),e=this.options.height.value(t.rng),s=this.options.tile||h,n=Math.floor(.4*i),o=e,r=i,l=Math.floor(.5*e),c=Math.floor(t.width/2-n/2-1),g=t.height-o-2,d=Math.floor(t.width/2-r/2-1),u=t.height-l-2;a.xy.forRect(c,g,n,o,((i,e)=>t.setTile(i,e,s))),a.xy.forRect(d,u,r,l,((i,e)=>t.setTile(i,e,s)));const f=new k(Math.min(c,d),Math.min(g,u),Math.max(n,r),Math.max(o,l));return f.doors[a.xy.DOWN]=[Math.floor(t.width/2),t.height-2],f}}class $ extends Y{constructor(t={}){super(t,{width:12,height:20})}carve(t){const i=this.options.width.value(t.rng),e=this.options.height.value(t.rng),s=this.options.tile||h,n=i,o=Math.max(3,Math.floor(i*t.rng.range(25,75)/100)),r=Math.max(3,Math.floor(e*t.rng.range(25,75)/100)),l=e,c=Math.floor((t.width-n)/2),g=c+t.rng.range(2,Math.max(2,n-o-2)),d=Math.floor((t.height-l)/2),u=d+t.rng.range(2,Math.max(2,l-r-2));return a.xy.forRect(c,u,n,r,((i,e)=>t.setTile(i,e,s))),a.xy.forRect(g,d,o,l,((i,e)=>t.setTile(i,e,s))),new k(c,d,Math.max(n,o),Math.max(r,l))}}class H extends Y{constructor(t={}){super(t,{width:7,height:7})}carve(t){const i=this.options.width.value(t.rng),e=this.options.height.value(t.rng),s=this.options.tile||h;let n=Math.max(3,Math.floor(i*t.rng.range(25,50)/100)),o=Math.max(3,Math.floor(e*t.rng.range(25,50)/100));const r=Math.floor((t.width-i)/2),l=Math.floor((t.height-o)/2);a.xy.forRect(r,l,i,o,((i,e)=>t.setTile(i,e,s)));const c=Math.floor((t.width-n)/2),g=Math.floor((t.height-e)/2);return a.xy.forRect(c,g,n,e,((i,e)=>t.setTile(i,e,s))),new k(Math.min(r,c),Math.min(l,g),Math.max(i,n),Math.max(e,o))}}class K extends Y{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const i=this.options.width.value(t.rng),e=this.options.height.value(t.rng),s=this.options.tile||h,n=Math.floor((t.width-i)/2),o=Math.floor((t.height-e)/2);return a.xy.forRect(n,o,i,e,((i,e)=>t.setTile(i,e,s))),new k(n,o,i,e)}}class z extends Y{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const i=this.options.radius.value(t.rng),e=this.options.tile||h,s=Math.floor(t.width/2),n=Math.floor(t.height/2);return i>1&&a.xy.forCircle(s,n,i,((i,s)=>t.setTile(i,s,e))),new k(s-i,n-i,2*i+1,2*i+1)}}class V extends Y{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const i=this.options.radius.value(t.rng),e=this.options.ringMinWidth.value(t.rng),s=this.options.holeMinSize.value(t.rng),n=this.options.tile||h,o=Math.floor(t.width/2),r=Math.floor(t.height/2);return a.xy.forCircle(o,r,i,((i,e)=>t.setTile(i,e,n))),i>e+s&&t.rng.chance(this.options.holeChance.value(t.rng))&&a.xy.forCircle(o,r,t.rng.range(s,i-s),((i,e)=>t.setTile(i,e,0))),new k(o-i,r-i,2*i+1,2*i+1)}}class q extends Y{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let i,e,s,n=this.options.count.value(t.rng);const o=this.options.width.value(t.rng),r=this.options.height.value(t.rng),l=this.options.tile||h,c=Math.floor(t.width/2)-Math.floor(o/2),g=Math.floor(t.width/2)+Math.floor(o/2),d=Math.floor(t.height/2)-Math.floor(r/2),u=Math.floor(t.height/2)+Math.floor(r/2);let f=Math.floor(t.width/2),p=f,_=Math.floor(t.height/2),I=_;for(a.xy.forCircle(f,_,2,((i,e)=>t.setTile(i,e,l))),f-=2,p+=2,_-=2,I+=2,i=0;i<n;)if(e=t.rng.range(c,g),s=t.rng.range(d,u),t.isSet(e,s)){if(e-2<c)continue;if(e+2>g)continue;if(s-2<d)continue;if(s+2>u)continue;f=Math.min(e-2,f),p=Math.max(e+2,p),_=Math.min(s-2,_),I=Math.max(s+2,I),a.xy.forCircle(e,s,2,((i,e)=>t.setTile(i,e,l))),i++}return new k(f,_,p-f+1,I-_+1)}}function j(t,i){return X[t]=i,i}j("DEFAULT",new K);var Q=Object.freeze({__proto__:null,checkConfig:v,RoomDigger:Y,rooms:X,ChoiceRoom:G,choiceRoom:function(t,i){return new G(t).create(i)},Cavern:W,cavern:function(t,i){return new W(t).create(i)},BrogueEntrance:U,brogueEntrance:function(t,i){return new U(t).create(i)},Cross:$,cross:function(t,i){return new $(t).create(i)},SymmetricalCross:H,symmetricalCross:function(t,i){return new H(t).create(i)},Rectangular:K,rectangular:function(t,i){return new K(t).create(i)},Circular:z,circular:function(t,i){return new z(t).create(i)},BrogueDonut:V,brogueDonut:function(t,i){return new V(t).create(i)},ChunkyRoom:q,chunkyRoom:function(t,i){return new q(t).create(i)},install:j});const Z=a.xy.DIRS;function J(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function tt(t,i){return a.clamp(function(t,i){if(!t)return 1;if("number"==typeof t)return t;if(i=null!=i?i:a.rng.random,Array.isArray(t))t=i.weighted(t)+1;else if("string"==typeof t)t=a.range.make(t).value(i);else if(t instanceof a.range.Range)t=t.value(i);else{const e=t;t=Number.parseInt(i.weighted(e))}return t}(t,i),1,3)}function it(t,i,e){return t==a.xy.UP||t==a.xy.DOWN?i[1].value(e):i[0].value(e)}function et(t,i,e){let s=a.xy.NO_DIRECTION;if(s==a.xy.NO_DIRECTION){const n=t.rng.sequence(4);for(let o=0;o<4;o++){s=n[o];const r=e[(o+1)%2].hi,l=i[s];if(l&&-1!=l[0]&&-1!=l[1]){const i=l[0]+Math.floor(Z[s][0]*r),e=l[1]+Math.floor(Z[s][1]*r);if(t.hasXY(i,e))break}s=a.xy.NO_DIRECTION}}return s}function st(t,i,e,s,n){let o,r;const a=t.rng.chance(n),l=[];for(let n=0;n<4;n++)o=i+Z[n][0],r=e+Z[n][1],n!=s&&!a||!t.hasXY(o,r)||t.isSet(o,r)||(l[n]=[o,r]);return l}class nt{constructor(t={}){this.config={width:1,length:[a.range.make("2-15"),a.range.make("2-9")],tile:h,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=t.width),t.length&&"number"==typeof t.length){const i=a.range.make(t.length);this.config.length=[i,i]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,i=[]){if(i=i||B(t),!t.rng.chance(this.config.chance))return null;const e=et(t,i,this.config.length);if(e===a.xy.NO_DIRECTION)return null;if(!i[e])return null;const s=tt(this.config.width,t.rng),n=it(e,this.config.length,t.rng),o=i[e];return 1==s?this.dig(t,e,o,n):this.digWide(t,e,o,n,s)}_digLine(t,i,e,s){let n=i[0],o=i[1];const r=this.config.tile;for(let i=0;i<s;i++)t.setTile(n,o,r),n+=e[0],o+=e[1];return n-=e[0],o-=e[1],[n,o]}dig(t,i,e,s){const n=Z[i],[o,r]=this._digLine(t,e,n,s),a=x(e,i,s);return a.doors=st(t,o,r,i,this.config.obliqueChance),a}digWide(t,i,e,s,n){const o=a.xy.DIRS[i],r=[e[0]-o[1],e[1]-o[0]],l=[e[0]+o[1],e[1]+o[0]];this._digLine(t,e,o,s);let h=1,c=e[0],g=e[1];h<n&&J(t,r,o)&&(this._digLine(t,r,o,s),c=Math.min(r[0],c),g=Math.min(r[1],g),++h),h<n&&J(t,l,o)&&(this._digLine(t,l,o,s),c=Math.min(l[0],c),g=Math.min(l[1],g),++h);const d=x([c,g],i,s,n);return d.doors=[],d.doors[i]=[e[0]+s*o[0],e[1]+s*o[1]],d}}function ot(t,i,e){return new nt(t).create(i,e)}var rt={};function at(t,i){return rt[t]=i,i}at("DEFAULT",new nt({chance:15}));var lt=Object.freeze({__proto__:null,isDoorLoc:J,pickWidth:tt,pickLength:it,pickHallDirection:et,pickHallExits:st,HallDigger:nt,dig:ot,halls:rt,install:at});class ht{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:f,wreathChance:50,wreathSize:1,tile:u},Object.assign(this.options,t)}create(t){let i,e,s,n,o,r,l,h,c,g,d,p=0;r=this.options.height||15,l=this.options.width||30,h=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,d=this.options.canDisrupt||!1;const _=!!t.rng.chance(this.options.wreathChance),I=this.options.wreathTile||f,m=this.options.wreathSize||1,E=this.options.tile||u,w=a.grid.alloc(t.width,t.height,0);let S=0;for(;S<g&&p<g;){const u=Math.round((l-h)*(g-S)/g)+h,f=Math.round((r-h)*(g-S)/g)+h,B=new a.blob.Blob({rng:t.rng,rounds:5,minWidth:4,minHeight:4,maxWidth:u,maxHeight:f,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(w.width,w.height,((t,i)=>w[t][i]=1));let y=!1;for(s=0;s<c&&!y;s++)if(n=t.rng.range(1-B.x,w.width-B.width-B.x-2),o=t.rng.range(1-B.y,w.height-B.height-B.y-2),d||!this.isDisruptedBy(t,w,-n,-o)){for(y=!0,i=0;i<B.width;i++)for(e=0;e<B.height;e++)if(w[i+B.x][e+B.y]){const s=i+B.x+n,r=e+B.y+o;t.setTile(s,r,E),_&&a.xy.forCircle(s,r,m,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,I)}))}break}y?++p:++S}return a.grid.free(w),p}isDisruptedBy(t,i,e=0,s=0){const n=a.grid.alloc(t.width,t.height);let o=!1;a.xy.forRect(t.width,t.height,((r,a)=>{const l=r+e,h=a+s;i.get(l,h)?t.isStairs(r,a)&&(o=!0):t.isPassable(r,a)&&(n[r][a]=1)}));let r=!0;for(let t=0;t<n.width&&!o;++t)for(let i=0;i<n.height&&!o;++i)1==n[t][i]&&(r?(n.floodFill(t,i,1,2),r=!1):o=!0);return a.grid.free(n),o}}var ct=Object.freeze({__proto__:null,Lakes:ht});class gt{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let i,e,s,n,o,r,l,c=0;const g=this.options.maxLength,d=this.options.minDistance,u=a.grid.alloc(t.width,t.height),f=a.grid.alloc(t.width,t.height),_=[[1,0],[0,1]];f.update(((i,e,s)=>t.isPassable(e,s)?1:a.path.OBSTRUCTION));const I=t.rng.sequence(t.width*t.height);for(s=0;s<I.length;s++)if(r=Math.floor(I[s]/t.height),l=I[s]%t.height,t.isPassable(r,l)&&!t.isAnyLiquid(r,l))for(o=0;o<=1;o++){const s=_[o];if(i=r+s[0],e=l+s[1],n=g,t.isAnyLiquid(i,e))for(n=0;n<g&&(i+=s[0],e+=s[1],t.isAnyLiquid(i,e));++n);if(t.isPassable(i,e)&&n<g&&(a.path.calculateDistances(u,i,e,f,!1),u[r][l]>d&&u[r][l]<a.path.NO_PATH)){for(;r!==i||l!==e;)this.isBridgeCandidate(t,r,l,s)?(t.setTile(r,l,p),f[r][l]=1):(t.setTile(r,l,h),f[r][l]=1),r+=s[0],l+=s[1];++c;break}}return a.grid.free(u),a.grid.free(f),c}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyLiquid(i,e)&&(!!t.isAnyLiquid(i+s[1],e+s[0])&&!!t.isAnyLiquid(i-s[1],e-s[0]))}}var dt=Object.freeze({__proto__:null,Bridges:gt});class ut{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:_,downTile:I,wall:m},Object.assign(this.options,t)}create(t){let i=!1!==this.options.up,e=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),n={};let o=null,r=null;const l=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let i=this.options.start;i=!0===i?t.rng.matchingLoc(t.width,t.height,l):t.rng.matchingLocNear(a.xy.x(i),a.xy.y(i),l),n.start=i}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const i=this.options.up;o=t.rng.matchingLocNear(a.xy.x(i),a.xy.y(i),l);const e=this.options.down;r=t.rng.matchingLocNear(a.xy.x(e),a.xy.y(e),l)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const i=this.options.up;o=t.rng.matchingLocNear(a.xy.x(i),a.xy.y(i),l),e&&(r=t.rng.matchingLoc(t.width,t.height,((t,i)=>!(a.xy.distanceBetween(t,i,o[0],o[1])<s)&&l(t,i))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;r=t.rng.matchingLocNear(a.xy.x(e),a.xy.y(e),l),i&&(o=t.rng.matchingLoc(t.width,t.height,((t,i)=>!(a.xy.distanceBetween(t,i,r[0],r[1])<s)&&l(t,i))))}else i?(o=t.rng.matchingLoc(t.width,t.height,l),e&&(r=t.rng.matchingLoc(t.width,t.height,((t,i)=>!(a.xy.distanceBetween(t,i,o[0],o[1])<s)&&l(t,i))))):e&&(r=t.rng.matchingLoc(t.width,t.height,l));return o&&(n.up=o.slice(),this.setupStairs(t,o[0],o[1],this.options.upTile),"up"===this.options.start&&(n.start=n.up)),r&&(n.down=r.slice(),this.setupStairs(t,r[0],r[1],this.options.downTile),"down"===this.options.start&&(n.start=n.down)),o||r?n:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,i,e){let s=0;if(!this.hasXY(t,i,e)||!t.isDiggable(i,e))return!1;for(let n=0;n<4;++n){const o=a.xy.DIRS[n];if(!this.hasXY(t,i+o[0],e+o[1]))return!1;if(!this.hasXY(t,i-o[0],e-o[1]))return!1;if(t.isFloor(i+o[0],e+o[1])){if(s+=1,!t.isDiggable(i-o[0]+o[1],e-o[1]+o[0]))return!1;if(!t.isDiggable(i-o[0]-o[1],e-o[1]-o[0]))return!1}else if(!t.isDiggable(i+o[0],e+o[1]))return!1}return 1==s}setupStairs(t,i,e,s){const n=t.rng.sequence(4);let o=null;for(let s=0;s<n.length;++s){o=a.xy.DIRS[s];const n=i+o[0],r=e+o[1];if(t.isFloor(n,r)&&t.isDiggable(i-o[0],e-o[1]))break;o=null}o||a.ERROR("No stair direction found!"),t.setTile(i,e,s);const r=a.xy.CLOCK_DIRS.findIndex((t=>t[0]==o[0]&&t[1]==o[1])),l=this.options.wall;for(let s=0;s<a.xy.CLOCK_DIRS.length;++s){const n=s?s-1:7,o=(s+1)%8;if(s==r||n==r||o==r)continue;const h=a.xy.CLOCK_DIRS[s];t.setTile(i+h[0],e+h[1],l)}return!0}}var ft=Object.freeze({__proto__:null,Stairs:ut});class pt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},Object.assign(this.options,t)}create(t){let i,e,s,n,o,r,l,g,d;const u=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),f=this.options.maxLength,p=a.grid.alloc(t.width,t.height),_=a.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];function m(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function E(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}R(t,_);let w=0;const S=t.rng.sequence(t.width*t.height);for(o=0;o<S.length;o++)if(g=Math.floor(S[o]/t.height),d=S[o]%t.height,!t.isSet(g,d))for(l=0;l<=1;l++){let o=I[l];if(m(g,d,o)){if(r=f,t.hasXY(g+o[0],d+o[1])&&t.isPassable(g+o[0],d+o[1])){if(!t.hasXY(g-o[0],d-o[1])||t.isDoor(g-o[0],d-o[1]))continue}else{if(!t.hasXY(g-o[0],d-o[1])||!t.isPassable(g-o[0],d-o[1]))continue;if(!t.hasXY(g+o[0],d+o[1])||t.isDoor(g+o[0],d+o[1]))continue;o=o.map((t=>-1*t))}for(i=g+o[0],e=d+o[1],s=g,n=d,r=0;r<f&&(s-=o[0],n-=o[1],!E(s,n,o));++r);if(r<f&&(a.path.calculateDistances(p,i,e,_,!1),p[s][n]>u&&p[s][n]<3e4)){for(;s!==i||n!==e;)t.isNothing(s,n)&&(t.setTile(s,n,h),_[s][n]=1),s+=o[0],n+=o[1];const r=t.rng.chance(this.options.doorChance)?c:h;t.setTile(g,d,r),++w;break}}}return a.grid.free(p),a.grid.free(_),w}}var _t=Object.freeze({__proto__:null,LoopDigger:pt,digLoops:function(t,i={}){return new pt(i).create(t)}});class It{async onDigFirstRoom(){}async onRoomCandidate(){}async onRoomFailed(){}async onRoomSuccess(){}async onLoopsAdded(){}async onLakesAdded(){}async onBridgesAdded(){}async onStairsAdded(){}async onBuildError(){}async onBlueprintPick(){}async onBlueprintCandidates(){}async onBlueprintStart(){}async onBlueprintInterior(){}async onBlueprintFail(){}async onBlueprintSuccess(){}async onStepStart(){}async onStepCandidates(){}async onStepInstanceSuccess(){}async onStepInstanceFail(){}async onStepSuccess(){}async onStepFail(){}}const mt=a.flag.fl;var Et;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=mt(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=mt(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=mt(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=mt(4)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=mt(5)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=mt(6)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=mt(7)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=mt(8)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=mt(9)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=mt(10)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=mt(11)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=mt(12)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=mt(13)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=mt(14)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=mt(15)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=mt(16)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=mt(17)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=mt(18)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=mt(19)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=mt(20)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=mt(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=mt(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=mt(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=mt(24)]="BF_IMPREGNABLE",t[t.BF_NO_BLOCK_ORIGIN=mt(25)]="BF_NO_BLOCK_ORIGIN",t[t.BF_NOT_IN_HALLWAY=mt(27)]="BF_NOT_IN_HALLWAY",t[t.BF_ALLOW_BOUNDARY=mt(28)]="BF_ALLOW_BOUNDARY",t[t.BF_SKELETON_KEY=mt(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=mt(30)]="BF_KEY_DISPOSABLE"}(Et||(Et={}));class wt{constructor(t={}){var i;if(this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.id="n/a",this.tile=null!==(i=t.tile)&&void 0!==i?i:-1,t.flags&&(this.flags=a.flag.from(Et,t.flags)),t.pad&&(this.pad=t.pad),this.count=a.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.effect&&(this.effect=r.effect.from(t.effect)),this.item&&this.flags&Et.BF_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BF_ADOPT_ITEM.");if(this.buildAtOrigin&&this.count.hi>1)throw new Error("Cannot have count > 1 for step with BF_BUILD_AT_ORIGIN.");if(this.buildAtOrigin&&this.repeatUntilNoProgress)throw new Error("Cannot have BF_BUILD_AT_ORIGIN and BF_REPEAT_UNTIL_NO_PROGRESS together in a build step.")}get allowBoundary(){return!!(this.flags&Et.BF_ALLOW_BOUNDARY)}get notInHallway(){return!!(this.flags&Et.BF_NOT_IN_HALLWAY)}get buildInWalls(){return!!(this.flags&Et.BF_BUILD_IN_WALLS)}get buildAnywhere(){return!!(this.flags&Et.BF_BUILD_ANYWHERE_ON_LEVEL)}get repeatUntilNoProgress(){return!!(this.flags&Et.BF_REPEAT_UNTIL_NO_PROGRESS)}get permitBlocking(){return!!(this.flags&Et.BF_PERMIT_BLOCKING)}get treatAsBlocking(){return!!(this.flags&(Et.BF_TREAT_AS_BLOCKING|Et.BF_NO_BLOCK_ORIGIN))}get noBlockOrigin(){return!!(this.flags&Et.BF_NO_BLOCK_ORIGIN)}get adoptItem(){return!!(this.flags&Et.BF_ADOPT_ITEM)}get itemIsKey(){return!!(this.flags&Et.BF_ITEM_IS_KEY)}get keyIsDisposable(){return!!(this.flags&Et.BF_KEY_DISPOSABLE)}get outsourceItem(){return!!(this.flags&Et.BF_OUTSOURCE_ITEM_TO_MACHINE)}get impregnable(){return!!(this.flags&Et.BF_IMPREGNABLE)}get buildVestibule(){return!!(this.flags&Et.BF_BUILD_VESTIBULE)}get generateEverywhere(){return!!(this.flags&Et.BF_EVERYWHERE&~Et.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&Et.BF_BUILD_AT_ORIGIN)}get buildsInstances(){return!!(this.effect||-1!=this.tile||this.item||this.horde||this.adoptItem)}markCandidates(t,i,e,s=[0,1e4]){St(t,this);let n=0;return e.update(((e,o,r)=>yt(t,i,this,o,r,s)?(n++,1):0)),n}}function St(t,i){if(i.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const e=t.site;if(i.flags&Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new a.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}else{new a.fov.FOV({isBlocked:(t,i)=>e.blocksPathing(t,i)||e.blocksVision(t,i),hasXY:(t,i)=>e.hasXY(t,i)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}t.viewMap[t.originX][t.originY]=1}}function Bt(t,i){const e=[0,1e4];return i.flags&Et.BF_NEAR_ORIGIN&&(e[1]=t.distance25),i.flags&Et.BF_FAR_FROM_ORIGIN&&(e[0]=t.distance75),e}function yt(t,i,e,s,n,o){const l=t.site;if(e.notInHallway&&a.xy.arcCount(s,n,((t,i)=>l.hasXY(t,i)&&l.isPassable(t,i)))>1)return!1;if((0==s||s==l.width-1||0==n||n==l.height-1)&&!e.allowBoundary)return!1;if(e.buildAtOrigin)return s==t.originX&&n==t.originY;if(i.isRoom&&s==t.originX&&n==t.originY)return!1;if(t.occupied[s][n])return!1;if(e.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][n])return!1;let h=1e4;if(l.isWall(s,n)?a.xy.eachNeighbor(s,n,((i,e)=>{t.distanceMap.hasXY(i,e)&&!l.blocksPathing(i,e)&&h>t.distanceMap[i][e]+1&&(h=t.distanceMap[i][e]+1)}),!0):h=t.distanceMap[s][n],h>o[1]||h<o[0])return!1;if(e.buildInWalls){const i=l.getMachine(s,n);if(!t.interior[s][n]&&(!i||i==t.machineNumber)&&l.isWall(s,n)){let i=!1;return a.xy.eachNeighbor(s,n,((s,n)=>{l.hasXY(s,n)&&(t.interior[s][n]||e.buildAnywhere)&&(!e.buildAnywhere||l.blocksPathing(s,n)||l.getMachine(s,n)||s==t.originX&&n==t.originY||(i=!0))}),!0),i}return!1}return!l.isWall(s,n)&&(e.buildAnywhere?!(e.item&&l.blocksItems(s,n)||l.hasCellFlag(s,n,r.flags.Cell.IS_CHOKEPOINT|r.flags.Cell.IS_IN_LOOP|r.flags.Cell.IS_IN_MACHINE)):!!t.interior[s][n])}function Rt(t,i,e,s,n){let o=0;for(let r=i-n+1;r<=i+n-1;r++)for(let i=e-n+1;i<=e+n-1;i++)t.site.hasXY(r,i)&&(s[r][i]&&(s[r][i]=0,++o),t.occupied[r][i]=1);return o}const Ot=a.flag.fl;var Tt;!function(t){t[t.BP_ROOM=Ot(0)]="BP_ROOM",t[t.BP_VESTIBULE=Ot(1)]="BP_VESTIBULE",t[t.BP_REWARD=Ot(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=Ot(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=Ot(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=Ot(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=Ot(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=Ot(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=Ot(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=Ot(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=Ot(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=Ot(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=Ot(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=Ot(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=Ot(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=Ot(15)]="BP_NOT_IN_HALLWAY"}(Tt||(Tt={}));class At{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=a.frequency.make(t.frequency||100),t.size?(this.size=a.range.make(t.size),this.size.lo<=0&&(this.size.lo=1),this.size.hi<this.size.lo&&(this.size.hi=this.size.lo)):this.size=a.range.make([1,1]),t.flags&&(this.flags=a.flag.from(Tt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new wt(t)))),this.flags&Tt.BP_ADOPT_ITEM&&!this.steps.some((t=>t.flags&Et.BF_ADOPT_ITEM)))throw new Error("Blueprint wants to BP_ADOPT_ITEM, but has no steps with BF_ADOPT_ITEM.");t.id&&(this.id=t.id)}get isRoom(){return!!(this.flags&Tt.BP_ROOM)}get isReward(){return!!(this.flags&Tt.BP_REWARD)}get isVestiblue(){return!!(this.flags&Tt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&Tt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&Tt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&Tt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&Tt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&Tt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&Tt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&Tt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&Tt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&Tt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&Tt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&Tt.BP_NO_INTERIOR_FLAG)}get notInHallway(){return!!(this.flags&Tt.BP_NOT_IN_HALLWAY)}qualifies(t,i){return!(i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t)))))&&!(~this.flags&t||this.flags&Tt.BP_ADOPT_ITEM&~t||this.flags&Tt.BP_VESTIBULE&~t)}pickComponents(t){const i=[Et.BF_ALTERNATIVE,Et.BF_ALTERNATIVE_2],e=new Array(this.steps.length).fill(!0);for(let s=0;s<=1;s++){let n=0;for(let t=0;t<e.length;t++)this.steps[t].flags&i[s]&&(e[t]=!1,n++);if(n>0){let o=t.range(1,n);for(let t=0;t<e.length;t++)if(this.steps[t].flags&i[s]){if(1==o){e[t]=!0;break}o--}}}return this.steps.filter(((t,i)=>e[i]))}fillInterior(t){const i=t.interior,e=t.site;if(i.fill(0),this.isRoom)return Lt(t,t.originX,t.originY);if(this.isVestiblue)return function(t,i){let e=!0;const s=t.site,n=t.interior;if(n.fill(0),1==i.size.hi)return n[t.originX][t.originY]=1,1;const o=s.getChokeCount(t.originX,t.originY);if(o>1e4)return 0;const r=[-1,-1];let l=o;a.xy.eachNeighbor(t.originX,t.originY,((t,i)=>{const e=s.getChokeCount(t,i);e!=o&&(e>1e4||e<0||(r[0]=t,r[1]=i,l=e))}),!0);const h=l-o;if(i.size.contains(h)){const t=n.floodFill(r[0],r[1],((t,i,n)=>(s.isOccupied(i,n)&&(e=!1),s.getChokeCount(i,n)===l)),1);if(e&&i.size.contains(t))return h}let c=0;const g=i.size.value(s.rng),d=t.distanceMap;b(s,d,t.originX,t.originY,i.size.hi);const u=s.rng.sequence(s.width*s.height);e=!0;for(let t=0;t<1e3&&c<g;t++)for(let i=0;i<u.length&&c<g;++i){const r=Math.floor(u[i]/s.height),a=u[i]%s.height;d[r][a]==t&&(s.isOccupied(r,a)&&(e=!1,c=g),s.getChokeCount(r,a)<=o||(n[r][a]=1,c+=1))}return c}(t,this);{let s=t.distanceMap;b(e,s,t.originX,t.originY,this.size.hi);const n=e.rng.sequence(e.width*e.height);let o=0,a=this.size.value();for(let t=0;t<1e3&&o<a;t++)for(let l=0;l<n.length&&o<a;l++){const a=Math.floor(n[l]/e.height),h=n[l]%e.height;if(s[a][h]==t&&(i[a][h]=1,o++,e.isOccupied(a,h)||e.hasCellFlag(a,h,r.flags.Cell.IS_IN_MACHINE)))return 0}return o}}}function bt(t,i){const e=t.site,s=t.candidates,n=e.rng.matchingLoc(e.width,e.height,((t,i)=>1==s[t][i]));return!n||n[0]<0||n[1]<0?null:n}function Lt(t,i,e){const s=t.interior,n=t.site;let o=1;s[i][e]=1;const l=n.getChokeCount(i,e);for(let h=0;h<4;h++){const c=i+a.xy.DIRS[h][0],g=e+a.xy.DIRS[h][1];if(n.hasXY(c,g)&&!s[c][g]){if(n.isOccupied(c,g)||n.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)&&!n.hasCellFlag(c,g,r.flags.Cell.IS_GATE_SITE))return 0;if(n.getChokeCount(c,g)<=l&&!n.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)){let i=Lt(t,c,g);if(i<=0)return 0;o+=i}}}return o}function Nt(t,i=1){let e;const s=t.interior,n=t.site;do{e=!1,s.forEach(((t,o,l)=>{if(n.hasCellFlag(o,l,r.flags.Cell.IS_IN_MACHINE))return;if(!n.blocksPathing(o,l))return;let c=0;a.xy.eachNeighbor(o,l,((t,i)=>{s.hasXY(t,i)&&s[t][i]&&!n.blocksPathing(t,i)&&++c}),!1),c<i||(c=0,a.xy.eachNeighbor(o,l,((t,i)=>{s.hasXY(t,i)&&(s[t][i]||n.isWall(t,i)&&!n.hasCellFlag(t,i,r.flags.Cell.IS_IN_MACHINE)||++c)}),!1),c||(e=!0,s[o][l]=1,n.blocksPathing(o,l)&&n.setTile(o,l,h),a.xy.eachNeighbor(o,l,((t,i)=>{s.hasXY(t,i)&&(n.isSet(t,i)||n.setTile(t,i,d))}))))}))}while(e)}const Ft={};class Mt{async onDigFirstRoom(t){console.group("dig first room"),t.dump(),console.groupEnd()}async onRoomCandidate(t,i){console.group("room candidate: "+t.toString()),i.dump(),console.groupEnd()}async onRoomFailed(t,i,e,s){console.log("Room Failed - ",s)}async onRoomSuccess(t,i){console.group("Added Room - "+i.toString()),t.dump(),console.groupEnd()}async onLoopsAdded(t){console.log("loops added")}async onLakesAdded(t){console.log("lakes added")}async onBridgesAdded(t){console.log("bridges added")}async onStairsAdded(t){console.log("stairs added")}async onBuildError(t,i){console.log(`onBuildError - error: ${i}`)}async onBlueprintPick(t,i,e,s){console.log(`onBlueprintPick - ${i.id}, depth = ${s}, matchingFlags = ${a.flag.toString(Tt,e)}`)}async onBlueprintCandidates(t,i){const e=`onBlueprintCandidates - ${i.id}`;console.group(e),t.candidates.dump(),console.groupEnd()}async onBlueprintStart(t,i){console.group(`onBlueprintStart - ${i.id} @ ${t.originX},${t.originY} : stepCount: ${i.steps.length}, size: [${i.size.toString()}], flags: ${a.flag.toString(Tt,i.flags)}`)}async onBlueprintInterior(t,i){console.group(`onBlueprintInterior - ${i.id}`),t.interior.dump(),console.groupEnd()}async onBlueprintFail(t,i,e){console.log(`onBlueprintFail - ${i.id} @ ${t.originX},${t.originY} : error: ${e}`),console.groupEnd()}async onBlueprintSuccess(t,i){console.log(`onBlueprintSuccess - ${i.id} @ ${t.originX},${t.originY}`),console.groupEnd()}async onStepStart(t,i,e){console.group(`onStepStart - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${a.flag.toString(Et,e.flags)}`)}async onStepCandidates(t,i,e,s,n){const o=s.count((t=>1==t));console.log(`onStepCandidates - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : wantCount: ${n}, have: ${o}`),s.dump()}async onStepInstanceSuccess(t,i,e,s,n){console.log(`onStepInstance @ ${s},${n}`)}async onStepInstanceFail(t,i,e,s,n,o){console.log(`onStepInstanceFail @ ${s},${n} - error: ${o}`)}async onStepSuccess(t,i,e){console.log(`onStepSuccess - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${a.flag.toString(Et,e.flags)}`),console.groupEnd()}async onStepFail(t,i,e,s){console.log(`onStepFail - ${i.id}[${i.steps.indexOf(e)+1}/${i.steps.length}] @ ${t.originX},${t.originY} : error : ${s}`),console.groupEnd()}}class Dt{constructor(t={}){var i,e;this.seed=0,this.rooms={fails:20},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.seed=t.seed||0,a.object.setOptions(this.rooms,t.rooms),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),a.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),a.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),t.loops=t.loops||{},t.loops.doorChance=null!==(i=t.loops.doorChance)&&void 0!==i?i:null===(e=t.doors)||void 0===e?void 0:e.chance,a.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),a.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:(!0===t.bridges&&(t.bridges={}),a.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:(!0===t.stairs&&(t.stairs={}),a.object.setOptions(this.stairs,t.stairs)),this.startLoc=t.startLoc||[-1,-1],this.endLoc=t.endLoc||[-1,-1],!0===t.log?this.log=new Mt:t.log?this.log=t.log:this.log=new It}_makeRoomSite(t,i){const e=new N(t,i);return e.rng=this.site.rng,e}async create(...t){if(1==t.length&&t[0]instanceof r.map.Map){const i=t[0];this.site=new D(i)}if(t.length>1){const i=t[0],e=t[1];this.site=new N(i,e)}const i=await this._create(this.site);if(t.length>1){const i=t[0],e=t[1],s=t[2];a.xy.forRect(i,e,((t,i)=>{const e=this.site.getTileIndex(t,i);e&&s(t,i,e)}))}return this.site.free(),i}async _create(t){this.startLoc[0]<0&&this.startLoc[0]<0&&(this.startLoc[0]=Math.floor(t.width/2),this.startLoc[1]=t.height-2),this.start(t);let i=20;for(;--i&&!await this.addFirstRoom(t););if(!i)throw new Error("Failed to place first room!");t.updateDoorDirs(),await this.log.onDigFirstRoom(t);let e=0,s=1;const n=this.rooms.fails||20;for(;e<n;)if(await this.addRoom(t)){if(e=0,t.updateDoorDirs(),t.rng.shuffle(this.seq),this.rooms.count&&++s>=this.rooms.count)break}else++e;return this.loops&&(this.addLoops(t,this.loops),await this.log.onLoopsAdded(t)),this.lakes&&(this.addLakes(t,this.lakes),await this.log.onLakesAdded(t)),this.bridges&&(this.addBridges(t,this.bridges),await this.log.onBridgesAdded(t)),this.stairs&&(this.addStairs(t,this.stairs),await this.log.onStairsAdded(t)),this.finish(t),!0}start(t){const i=this.seed||a.rng.random.number();t.setSeed(i),t.clear(),this.seq=t.rng.sequence(t.width*t.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof Y)return t;if("string"==typeof t){const i=X[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new G(t)}async addFirstRoom(t){const i=this._makeRoomSite(t.width,t.height);let e=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return e&&!await this._attachRoomAtLoc(t,i,e,this.startLoc)&&(e=null),i.free(),e}async addRoom(t){const i=this._makeRoomSite(t.width,t.height);let e=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(e&&this.halls.chance){let t=ot(this.halls,i,e.doors);t&&(e.hall=t)}return e&&(await this.log.onRoomCandidate(e,i),this._attachRoom(t,i,e)?await this.log.onRoomSuccess(t,e):(await this.log.onRoomFailed(t,e,i,"Did not fit."),e=null)),i.free(),e}_attachRoom(t,i,e){const s=e.hall?e.hall.doors:e.doors;let n=0;const o=this.seq.length;for(n=0;n<o;n++){const o=Math.floor(this.seq[n]/t.height),r=this.seq[n]%t.height,l=t.getDoorDir(o,r);if(l!=a.xy.NO_DIRECTION){const n=(l+2)%4,a=s[n];if(!a)continue;const h=o-a[0],c=r-a[1];if(-1!=a[0]&&this._roomFitsAt(t,i,e,h,c))return y(t,i,h,c),this._attachDoor(t,e,o,r,n),e.translate(h,c),!0}}return!1}async _attachRoomAtLoc(t,i,e,s){const[n,o]=s,r=e.hall?e.hall.doors:e.doors,a=t.rng.sequence(4);for(let s of a){const a=r[(s+2)%4];if(!a||-1==a[0])continue;const l=n-a[0],h=o-a[1];if(this._roomFitsAt(t,i,e,l,h))return y(t,i,l,h),e.translate(l,h),!0}return!1}_roomFitsAt(t,i,e,s,n){let o,r,a,l,h,c;const g=e.hall||e,d=Math.min(e.left,g.left),u=Math.min(e.top,g.top),f=Math.max(e.right,g.right),p=Math.max(e.bottom,g.bottom);for(o=d;o<=f;o++)for(r=u;r<=p;r++)if(i.isSet(o,r)){if(a=o+s,l=r+n,!t.hasXY(a,l)||t.isBoundaryXY(a,l))return!1;for(h=a-1;h<=a+1;h++)for(c=l-1;c<=l+1;c++)if(!t.isNothing(h,c))return!1}return!0}_attachDoor(t,i,e,s,n){const o=this.doors;let r=!1;o.chance&&t.rng.chance(o.chance)&&(r=!0);const l=r?o.tile||c:h;if(t.setTile(e,s,l),i.hall&&1!=i.hall.width&&1!=i.hall.height)if(n===a.xy.UP||n===a.xy.DOWN){let i=!0,n=1;for(;i;)i=!1,t.isNothing(e-n,s)&&t.isSet(e-n,s-1)&&t.isSet(e-n,s+1)&&(t.setTile(e-n,s,l),i=!0),t.isNothing(e+n,s)&&t.isSet(e+n,s-1)&&t.isSet(e+n,s+1)&&(t.setTile(e+n,s,l),i=!0),++n}else{let i=!0,n=1;for(;i;)i=!1,t.isNothing(e,s-n)&&t.isSet(e-1,s-n)&&t.isSet(e+1,s-n)&&(t.setTile(e,s-n,l),i=!0),t.isNothing(e,s+n)&&t.isSet(e-1,s+n)&&t.isSet(e+1,s+n)&&(t.setTile(e,s+n,l),i=!0),++n}}addLoops(t,i){return new pt(i).create(t)}addLakes(t,i){return new ht(i).create(t)}addBridges(t,i){return new gt(i).create(t)}addStairs(t,i){return new ut(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let i,e,s,n,o,r;do{for(r=!1,i=0;i<t.width-1;i++)for(e=0;e<t.height-1;e++)for(s=0;s<=1;s++)!t.blocksMove(i+s,e)&&t.blocksMove(i+(1-s),e)&&t.blocksDiagonal(i+(1-s),e)&&t.blocksMove(i+s,e+1)&&t.blocksDiagonal(i+s,e+1)&&!t.blocksMove(i+(1-s),e+1)&&(t.rng.chance(50)?(n=i+(1-s),o=e):(n=i+s,o=e+1),r=!0,t.setTile(n,o,h))}while(1==r)}_finishDoors(t){a.xy.forRect(t.width,t.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.blocksPathing(i+1,e)?1:0)+(t.blocksPathing(i-1,e)?1:0)+(t.blocksPathing(i,e+1)?1:0)+(t.blocksPathing(i,e-1)?1:0)>=3)&&t.setTile(i,e,h)}))}_finishWalls(t){const i=this.boundary?m:d;a.xy.forRect(t.width,t.height,((e,s)=>{t.isNothing(e,s)&&(t.isBoundaryXY(e,s)?t.setTile(e,s,i):t.setTile(e,s,d))}))}}class Ct{constructor(t,i={}){this.map=t,this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.depth=0,this.seed=0,this.site=new D(t),this.interior=a.grid.alloc(t.width,t.height),this.occupied=a.grid.alloc(t.width,t.height),this.viewMap=a.grid.alloc(t.width,t.height),this.distanceMap=a.grid.alloc(t.width,t.height),this.candidates=a.grid.alloc(t.width,t.height),this.depth=i.depth||1,this.seed=i.seed||0}free(){a.grid.free(this.interior),a.grid.free(this.occupied),a.grid.free(this.viewMap),a.grid.free(this.distanceMap),a.grid.free(this.candidates)}reset(t,i){this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=t,this.originY=i,this.distance25=0,this.distance75=0,this.seed&&this.site.setSeed(this.seed)}calcDistances(t){this.distanceMap.fill(0),b(this.site,this.distanceMap,this.originX,this.originY,t);let i=0;const e=new Array(100).fill(0);this.interior.forEach(((t,s,n)=>{if(!t)return;const o=this.distanceMap[s][n];o<100&&(e[o]++,i++)}));let s=Math.round(i/4),n=Math.round(3*i/4);for(let t=0;t<100;t++){if(s<=e[t]){s=t;break}s-=e[t]}for(let t=0;t<100;t++){if(n<=e[t]){n=t;break}n-=e[t]}this.distance25=s,this.distance75=n}}var Pt=Object.freeze({__proto__:null,get Flags(){return Tt},Blueprint:At,install:function(t,i){return i instanceof At||(i=new At(i)),Ft[t]=i,i.id=t,i},random:function(t,i,e){const s=Object.values(Ft).filter((e=>e.qualifies(t)&&e.frequency(i)));return(e=e||a.rng.random).item(s)},blueprints:Ft,make:function(t){return new At(t)},BuildData:Ct,get StepFlags(){return Et},BuildStep:wt,updateViewMap:St,calcDistanceBound:Bt,cellIsCandidate:yt,makePersonalSpace:Rt,Builder:class{constructor(t,i={}){this.blueprints=null,this.data=new Ct(t,i),i.blueprints&&(Array.isArray(i.blueprints)||(i.blueprints=Object.values(i.blueprints)),this.blueprints=i.blueprints.map((t=>{return(i=t)instanceof At?i:Ft[i];var i}))),!0===i.log?this.log=new Mt:this.log=i.log||new It}_pickRandom(t){const i=this.blueprints||Object.values(Ft),e=i.map((i=>i.qualifies(t)?i.frequency(this.data.depth):0));return i[this.data.map.rng.weighted(e)]||null}async buildRandom(t=Tt.BP_ROOM,i=-1,e=-1,s=null){const n=this.data;n.site.analyze();let o=0;for(;o<10;){const r=this._pickRandom(t);if(!r)return await this.log.onBuildError(n,`Failed to find matching blueprint: requiredMachineFlags : ${a.flag.toString(Tt,t)}, depth: ${n.depth}`),!1;if(await this.log.onBlueprintPick(n,r,t,n.depth),await this._buildAt(r,i,e,s))return!0;++o}return!1}async build(t,i=-1,e=-1,s=null){const n=this.data;if("string"==typeof t){const i=t;if(!(t=Ft[i]))throw new Error("Failed to find blueprint - "+i)}return n.site.analyze(),await this._buildAt(t,i,e,s)}async _buildAt(t,i=-1,e=-1,s=null){const n=this.data;if(i>=0&&e>=0)return await this._build(t,i,e,s);let o=await this._markCandidates(t);if(!o)return!1;let r=20;for(;o--&&r--;){const i=bt(n)||!1;if(i&&await this._build(t,i[0],i[1],s))return!0}return await this.log.onBlueprintFail(n,t,"No suitable locations found to build blueprint."),!1}async _build(t,i,e,s=null){const n=this.data;if(n.reset(i,e),await this.log.onBlueprintStart(n,t,s),!await this._computeInterior(t))return!1;const o=n.site.snapshot();n.machineNumber=n.site.nextMachineId(),function(t,i){const e=t.interior,s=t.site;i.maximizeInterior?Nt(t,1):i.openInterior&&Nt(t,4),i.purgeInterior&&e.forEach(((t,i,e)=>{t&&s.setTile(i,e,h)})),i.purgeBlockers&&e.forEach(((t,i,e)=>{t&&s.blocksPathing(i,e)&&s.setTile(i,e,h)})),i.purgeLiquids&&e.forEach(((t,i,e)=>{t&&s.isAnyLiquid(i,e)&&s.setTile(i,e,h)})),i.surroundWithWalls&&e.forEach(((t,i,n)=>{t&&!s.hasCellFlag(i,n,r.flags.Cell.IS_GATE_SITE)&&a.xy.eachNeighbor(i,n,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.isWall(t,i)||s.hasCellFlag(t,i,r.flags.Cell.IS_GATE_SITE)||s.hasCellFlag(t,i,r.flags.Cell.IS_IN_MACHINE)||s.blocksPathing(t,i)&&s.setTile(t,i,d))}),!1)})),i.makeImpregnable&&e.forEach(((t,i,n)=>{t&&!s.hasCellFlag(i,n,r.flags.Cell.IS_GATE_SITE)&&(s.setCellFlag(i,n,r.flags.Cell.IMPREGNABLE),a.xy.eachNeighbor(i,n,((t,i)=>{e.hasXY(t,i)&&(e[t][i]||s.hasCellFlag(t,i,r.flags.Cell.IS_GATE_SITE)||s.setCellFlag(t,i,r.flags.Cell.IMPREGNABLE))}),!1))}));const n=t.machineNumber;e.forEach(((t,e,o)=>{t&&(i.flags&Tt.BP_NO_INTERIOR_FLAG||s.setMachine(e,o,n,i.isRoom),s.isSecretDoor(e,o)&&s.setTile(e,o,c))}))}(n,t),n.calcDistances(t.size.hi);const l=t.pickComponents(n.site.rng);for(let i=0;i<l.length;i++){const e=l[i];if(!await this._buildStep(t,e,s))return await this.log.onBlueprintFail(n,t,`Failed to build step ${i+1}.`),o.restore(),!1}return t.noInteriorFlag&&L(n.site,n.machineNumber),await this.log.onBlueprintSuccess(n,t),o.cancel(),!0}async _markCandidates(t){const i=this.data,e=function(t,i){const e=t.site,s=t.candidates;if(s.fill(0),i.isRoom)s.update(((t,s,n)=>e.hasCellFlag(s,n,r.flags.Cell.IS_GATE_SITE)&&i.size.contains(e.getChokeCount(s,n))?1:0));else{if(i.isVestiblue)throw new Error("ERROR: Attempted to build a vestiblue without a location being provided.");s.update(((t,s,n)=>e.isPassable(s,n)?i.notInHallway?a.xy.arcCount(s,n,((t,i)=>e.isPassable(t,i)))<=1?1:0:1:0))}return s.count((t=>1==t))}(i,t);return e<=0?(await this.log.onBlueprintFail(i,t,"No suitable candidate locations found."),0):(await this.log.onBlueprintCandidates(i,t),e)}async _computeInterior(t){let i=null;const e=this.data;let s=t.fillInterior(e);return s?t.size.contains(s)?t.treatAsBlocking&&T(e.site,e.interior,{machine:e.site.machineCount})?i="Interior blocks map.":t.requireBlocking&&A(e.site,e.interior)<100&&(i="Interior does not block enough cells."):i=`Interior wrong size - have: ${s}, want: ${t.size.toString()}`:i="Interior error.",i?(await this.log.onBlueprintFail(e,t,i),!1):(await this.log.onBlueprintInterior(e,t),!0)}async _buildStep(t,i,e){let s=0,n=0;const o=this.data,r=o.site;await this.log.onStepStart(o,t,i,e);const l=Bt(o,i);let h=0;if(i.buildVestibule){if(!await this.buildRandom(Tt.BP_VESTIBULE,o.originX,o.originY))return await this.log.onStepFail(o,t,i,"Failed to build vestibule"),!1}if(!i.buildsInstances)return await this.log.onStepSuccess(o,t,i),!0;const c=a.grid.alloc(r.width,r.height);let g=!1;do{if(g=!1,i.buildAtOrigin)c[o.originX][o.originY]=1,h=1,s=1;else if(h=i.markCandidates(o,t,c,l),s=i.generateEverywhere||i.repeatUntilNoProgress?h:i.count.value(r.rng),await this.log.onStepCandidates(o,t,i,c,s),!h||h<i.count.lo)return await this.log.onStepFail(o,t,i,`Blueprint ${t.id}, step ${t.steps.indexOf(i)} - Only ${h} qualifying tiles - want ${i.count.toString()}.`),!1;let a=0,d=0;for(;h>0&&n<s;){i.buildAtOrigin?(a=o.originX,d=o.originY):[a,d]=this.data.map.rng.matchingLoc(c.width,c.height,((t,i)=>c[t][i]>0)),c[a][d]=0,h--;const s=o.site.snapshot();await this._buildStepInstance(t,i,a,d,e)?(h-=Rt(o,a,d,c,i.pad),n++,g=!0,s.cancel()):s.restore()}}while(g&&i.repeatUntilNoProgress);return a.grid.free(c),i.count.contains(n)||i.generateEverywhere||i.repeatUntilNoProgress?(await this.log.onStepSuccess(o,t,i),!0):(await this.log.onStepFail(o,t,i,`Failed to build enough instances - want: ${i.count.toString()}, built: ${n}`),!1)}async _buildStepInstance(t,i,e,s,n=null){let o=!0,a=!0;const l=this.data,h=l.site;if(o&&i.treatAsBlocking){const n={machine:h.machineCount};i.noBlockOrigin&&(n.updateWalkable=t=>(t[l.originX][l.originY]=1,!0)),O(h,e,s,n)&&(await this.log.onStepInstanceFail(l,t,i,e,s,"instance blocks map"),o=!1)}if(o&&i.effect&&(o=h.buildEffect(i.effect,e,s),a=o,o||this.log.onStepInstanceFail(l,t,i,e,s,"Failed to build effect - "+JSON.stringify(i.effect))),o&&-1!==i.tile){const n=r.tile.get(i.tile);i.permitBlocking||!n.blocksMove()||i.treatAsBlocking||O(h,e,s,{machine:h.machineCount})&&(await this.log.onStepInstanceFail(l,t,i,e,s,"tile blocks site"),o=!1),o&&(o=h.setTile(e,s,n),a=a||o,o||await this.log.onStepInstanceFail(l,t,i,e,s,"failed to set tile - "+n.id))}if(o&&i.item){const n=h.makeRandomItem(i.item);n?(i.itemIsKey&&(n.key=r.entity.makeKeyInfo(e,s,!!i.keyIsDisposable)),i.outsourceItem?(o=await this.buildRandom(Tt.BP_ADOPT_ITEM,-1,-1,n),o?a=!0:await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to build machine to adopt item - "+n.kind.id)):(o=h.addItem(e,s,n),a=a||o,o||await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to add item to site - "+n.kind.id))):(o=!1,await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to make random item - "+JSON.stringify(i.item)))}else if(o&&i.adoptItem){if(!n)throw new Error("Failed to build blueprint because there is no adopted item.");o&&(o=h.addItem(e,s,n),o?a=!0:await this.log.onStepInstanceFail(l,t,i,e,s,"Failed to add adopted item to site - "+n.kind.id))}return o&&a&&(t.noInteriorFlag||h.setMachine(e,s,l.machineNumber,t.isRoom),i.impregnable&&h.setCellFlag(e,s,r.flags.Cell.IMPREGNABLE),await this.log.onStepInstanceSuccess(l,t,i,e,s)),o&&a}}});var xt=Object.freeze({__proto__:null,NullLogger:It,ConsoleLogger:Mt,Visualizer:class{constructor(t,i){this.dest=t instanceof a.canvas.Canvas?t.buffer:t,this.io=i||a.loop}async onDigFirstRoom(t){t.drawInto(this.dest),this.dest.drawText(0,0,"First Room","yellow"),this.dest.render(),await this.io.nextKeyPress()}async onRoomCandidate(t,i){i.drawInto(this.dest),this.dest.drawText(0,0,"Room Candidate","yellow"),t.doors&&t.doors.forEach((t=>{!t||t[0]<0||this.dest.drawSprite(t[0],t[1],r.tile.tiles.DOOR.sprite)})),t.hall&&t.hall.doors&&t.hall.doors.forEach((t=>{!t||t[0]<0||this.dest.drawSprite(t[0],t[1],r.tile.tiles.DOOR.sprite)})),this.dest.render(),await this.io.nextKeyPress()}async onRoomFailed(t,i,e,s){this.dest.drawText(0,0,s,"red"),this.dest.render(),await this.io.nextKeyPress()}async onRoomSuccess(t,i){t.drawInto(this.dest),this.dest.drawText(0,0,"Room: "+i.toString(),"yellow"),this.dest.render(),await this.io.nextKeyPress()}async onLoopsAdded(t){}async onLakesAdded(t){}async onBridgesAdded(t){}async onStairsAdded(t){}async onBuildError(t,i){}async onBlueprintPick(t,i,e,s){}async onBlueprintCandidates(t,i){}async onBlueprintStart(t,i,e){}async onBlueprintInterior(t,i){}async onBlueprintFail(t,i,e){}async onBlueprintSuccess(t,i){}async onStepStart(t,i,e,s){}async onStepCandidates(t,i,e,s,n){}async onStepInstanceSuccess(t,i,e,s,n){}async onStepInstanceFail(t,i,e,s,n,o){}async onStepSuccess(t,i,e){}async onStepFail(t,i,e,s){}}});t.Digger=Dt,t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],a.object.setOptions(this.config,t),this.config.seed&&a.rng.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=a.rng.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const i=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let e=0;e<this.config.levels;++e){const e=a.rng.random.matchingLoc(this.config.width,this.config.height,((e,s)=>a.xy.distanceBetween(t[0],t[1],e,s)>i));this.stairLocs.push([[t[0],t[1]],[e[0],e[1]]]),t=e}}async getLevel(t,i){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);const[e,s]=this.stairLocs[t],n=Object.assign({},this.config.stairs);this.config.goesUp?(n.down=e,n.up=s,0==t&&this.config.startTile&&(n.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.upTile=this.config.endTile)):(n.down=s,n.up=e,0==t&&this.config.startTile&&(n.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.downTile=this.config.endTile));const o=Object.assign({},this.config.rooms);0===t&&o.entrance&&(o.first=o.entrance);const r={seed:this.seeds[t],loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:o,stairs:n,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,r,i)}async makeLevel(t,i,e){const s=new Dt(i),n=await s.create(this.config.width,this.config.height,e);return a.xy.equalsXY(s.endLoc,i.endLoc)&&a.xy.equalsXY(s.startLoc,i.startLoc)||(this.stairLocs[t]=[s.startLoc,s.endLoc]),n}},t.Hall=P,t.Room=k,t.blueprint=Pt,t.bridge=dt,t.hall=lt,t.lake=ct,t.log=xt,t.loop=_t,t.makeHall=x,t.room=Q,t.site=C,t.stairs=ft,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GW=t.GW||{},t.GW)}(this,(function(t,i){"use strict";class o{constructor(t,o,e,r){this.width=1,this.x=t[0],this.y=t[1];const h=i.utils.DIRS[o];this.x2=this.x+e*h[0],this.y2=this.y+e*h[1],this.dir=o,this.length=e,this.doors=r}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((o=>{o[0]<0||o[1]<0||(o[0]+=t,o[1]+=i)}))}}class e{constructor(t,i,o,e,r){this.doors=[],this.hall=null,this.digger=t,this.x=i,this.y=o,this.width=e,this.height=r}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((o=>{o[0]<0||o[1]<0||(o[0]+=t,o[1]+=i)})),this.hall&&this.hall.translate(t,i)}}var r={};function h(t,o){return o=o||{},(t=t||{}).width&&t.height||i.utils.ERROR("All diggers require config to include width and height."),Object.entries(o).forEach((([o,e])=>{const r=t[o];if(!0===e)"number"!=typeof r&&i.utils.ERROR("Invalid configuration for digger: "+o+" expected number received "+typeof r);else if("number"==typeof e){"number"!=typeof t[o]&&(t[o]=e)}else if(Array.isArray(e))if("number"==typeof r)t[o]=new Array(e.length).fill(r);else if(Array.isArray(r)){if(e.length>r.length)for(let t=r.length;t<e.length;++t)r[t]=e[t]}else i.utils.WARN("Received unexpected config for digger : "+o+" expected array, received "+typeof r+", using defaults."),t[o]=e.slice();else i.utils.WARN("Unexpected digger configuration parameter: ",o,""+e)})),t}const n=i.utils.DIRS;var l;function a(t,o,e,r={}){const h=e.hall?e.hall.doors:e.doors;for(let n=0;n<l.length;n++){const a=Math.floor(l[n]/t.height),s=l[n]%t.height;if(0!=t.get(a,s))continue;const c=i.grid.directionOfDoorSite(t,a,s,1);if(c!=i.utils.NO_DIRECTION){const n=(c+2)%4,l=a-h[n][0],d=s-h[n][1];if(-1!=h[n][0]&&f(t,o,l,d))return i.grid.offsetZip(t,o,l,d,((i,o,e,h)=>{t[e][h]=r.tile||1})),(r.door||!1!==r.placeDoor)&&(t[a][s]=r.door||2),e.translate(l,d),!0}}return!1}function f(t,i,o,e){let r,h,n,l,a,f;for(r=0;r<i.width;r++)for(h=0;h<i.height;h++)if(i[r][h])for(n=r+o,l=h+e,a=n-1;a<=n+1;a++)for(f=l-1;f<=l+1;f++)if(!t.hasXY(a,f)||t.isBoundaryXY(a,f)||0!==t.get(a,f))return!1;return!0}function s(t,o,e,r,h={}){const n=i.random.sequence(o.length);for(let i=0;i<n.length;i++){const l=n[i];return c(t,o[l][0],o[l][1],e,r,h)}return!1}function c(t,o,e,r,h,n={}){const l=h.hall?h.hall.doors:h.doors,a=i.random.sequence(4);for(let s of a){const a=(s+2)%4;if(-1!=l[a][0]&&f(t,r,o-l[a][0],e-l[a][1])){const f=o-l[a][0],s=e-l[a][1];return i.grid.offsetZip(t,r,f,s,((i,o,e,r)=>{t[e][r]=n.tile||1})),(n.door||!1!==n.placeDoor)&&(t[o][e]=n.door||2),h.translate(f,s),!0}}return!1}function d(t){let o,e,r,h,l,a,f;const s=i.grid.alloc(t.width,t.height);for(s.copy(t),o=0;o<s.width;o++)for(e=0;e<s.height;e++)if(!s[o][e]&&(a=i.grid.directionOfDoorSite(s,o,e,1),a!=i.utils.NO_DIRECTION)){for(h=o+n[a][0],l=e+n[a][1],f=!1,r=0;r<10&&s.hasXY(h,l)&&!f;r++)s[h][l]&&(f=!0),h+=n[a][0],l+=n[a][1];f||(s[o][e]=a+200)}let c=[];for(a=0;a<4;a++){const t=s.randomMatchingLoc(a+200)||[-1,-1];c[a]=[t[0],t[1]]}return i.grid.free(s),c}function g(t,e,r){let h,l,a,f,s,c,d;const g=(r=r||{}).tile||1,u=i.utils.firstOpt("horizontalHallLength",r,[9,15]),m=i.utils.firstOpt("verticalHallLength",r,[2,9]),M=i.utils.firstOpt("obliqueChance",r,15),w=e.doors;if(c=r.dir,void 0===c){const o=i.random.sequence(4);for(h=0;h<4&&(c=o[h],-1==w[c][0]||-1==w[c][1]||!t.hasXY(w[c][0]+Math.floor(n[c][0]*u[1]),w[c][1]+Math.floor(n[c][1]*m[1])));h++);if(4==h)return null}let y=0;y=c==i.utils.UP||c==i.utils.DOWN?i.random.range(m[0],m[1]):i.random.range(u[0],u[1]),l=w[c][0],a=w[c][1];const R=[l-n[c][0],a-n[c][1]];let p=0;for(p=0;p<y&&t.hasXY(l,a);p++)t[l][a]=g,l+=n[c][0],a+=n[c][1];if(p<2)return null;l=i.utils.clamp(l-n[c][0],0,t.width-1),a=i.utils.clamp(a-n[c][1],0,t.height-1);const x=i.random.chance(M),O=[[-1,-1],[-1,-1],[-1,-1],[-1,-1]];for(d=0;d<4;d++)f=l+n[d][0],s=a+n[d][1],d!=c&&!x||!t.hasXY(f,s)||t[f][s]?(O[d][0]=-1,O[d][1]=-1):(O[d][0]=f,O[d][1]=s);return new o(R,c,p,O)}function u(t,i,o){const e=t.get(i,o);return 1===e||2===e||5===e}function m(t,i,o){const e=t.get(i,o);return 0===e||3===e}function M(t){let o,e,r,h,n,l;do{for(l=!1,o=0;o<t.width-1;o++)for(e=0;e<t.height-1;e++)for(r=0;r<=1;r++)u(t,o+r,e)&&!u(t,o+(1-r),e)&&m(t,o+(1-r),e)&&!u(t,o+r,e+1)&&m(t,o+r,e+1)&&u(t,o+(1-r),e+1)&&(i.random.chance(50)?(h=o+(1-r),n=e):(h=o+r,n=e+1),l=!0,t[h][n]=1)}while(1==l)}function w(t){t.forEach(((i,o,e)=>{t.isBoundaryXY(o,e)||2==i&&(1!=t.get(o+1,e)&&1!=t.get(o-1,e)||1!=t.get(o,e+1)&&1!=t.get(o,e-1)?(1!==t.get(o+1,e)?1:0)+(1!==t.get(o-1,e)?1:0)+(1!==t.get(o,e+1)?1:0)+(1!==t.get(o,e-1)?1:0)>=3&&(t[o][e]=1):t[o][e]=1)}))}function y(t){t.forEach(((i,o,e)=>{0==i&&(t[o][e]=3)}))}var R={__proto__:null,start:function(t){l=i.random.sequence(t.width*t.height),t.fill(0)},finish:function(t){M(t),y(t),w(t)},dig:function(t,o={}){"string"==typeof o&&(o={digger:o});const e=o.digger||o.id||"SMALL",h=r[e];h||i.utils.ERROR("Failed to find digger: "+e);let n=o.locs||o.loc||null;if(n&&Array.isArray(n))n&&n.length&&2==n.length&&"number"==typeof n[0]?n=[n]:0==n.length&&(n=null);else if(n=null,0===t.count(1)){n=[[Math.floor(t.width/2),t.height-2]]}const l=Object.assign({},h,o),f=i.grid.alloc(t.width,t.height),c=l.hallChance||l.hallway||0;let u,m=!1,M=l.tries||10;for(;--M>=0&&!m;){f.fill(0),u=h.fn(l,f);const o=i.random.chance(c);u.doors=d(f),o&&(u.hall=g(f,u,l)),m=n?s(t,n,f,u,l):a(t,f,u,l)}return i.grid.free(f),u&&m?u:null},attachRoom:a,roomFitsAt:f,fitRoomAtMapLoc:function(t,o,e,r,h={}){for(let n=0;n<l.length;n++){const a=Math.floor(l[n]/t.height),s=l[n]%t.height;if(e[a][s])continue;if(i.grid.directionOfDoorSite(e,a,s,1)!=i.utils.NO_DIRECTION){const n=o[0]-a,l=o[1]-s;if(f(t,e,n,l))return i.grid.offsetZip(t,e,n,l,((i,o,e,r)=>{t[e][r]=h.tile||1})),(h.door||!1!==h.placeDoor)&&(t[o[0]][o[1]]=h.door||2),r.translate(n,l),!0}}return!1},chooseRandomDoorSites:d,attachHallway:g,isPassable:u,isObstruction:m,removeDiagonalOpenings:M,finishDoors:w,finishWalls:y,NOTHING:0,FLOOR:1,DOOR:2,WALL:3,LAKE:4,BRIDGE:5,Hall:o,Room:e,diggers:r,install:function(t,i,o){return(o=i(o||{})).fn=i,o.id=t,r[t]=o,o},checkConfig:h,cavern:function(t,o){if(t=h(t,{width:12,height:8}),!o)return t;let r,n,l;l=i.grid.alloc(o.width,o.height,0);const a=Math.floor(.5*t.width),f=t.width,s=Math.floor(.5*t.height),c=t.height;o.fill(0);const d=l.fillBlob(5,a,s,f,c,55,"ffffffttt","ffffttttt");return r=Math.floor((o.width-d.width)/2),n=Math.floor((o.height-d.height)/2),i.grid.offsetZip(o,l,r-d.x,n-d.y,1),i.grid.free(l),new e(t.id,r,n,d.width,d.height)},choiceRoom:function(t,o){let e,h;t=t||{},Array.isArray(t.choices)?e=t.choices:"object"==typeof t.choices?e=Object.keys(t.choices):i.utils.ERROR("Expected choices to be either array of choices or map { digger: weight }");for(let t of e)r[t]||i.utils.ERROR("Missing digger choice: "+t);if(!o)return t;h=Array.isArray(t.choices)?i.random.item(t.choices):i.random.weighted(t.choices);const n=r[h];let l=n;return t.opts&&(l=Object.assign({},n,t.opts)),n.fn(l,o)},entranceRoom:function(t,i){if(t=h(t,{width:20,height:10}),!i)return t;const o=Math.floor(.4*t.width),r=t.height,n=t.width,l=Math.floor(.5*t.height),a=Math.floor(i.width/2-o/2-1),f=i.height-r-2,s=Math.floor(i.width/2-n/2-1),c=i.height-l-2;return i.fill(0),i.fillRect(a,f,o,r,1),i.fillRect(s,c,n,l,1),new e(t.id,Math.min(a,s),Math.min(f,c),Math.max(o,n),Math.max(r,l))},crossRoom:function(t,o){if(t=h(t,{width:12,height:20}),!o)return t;const r=Math.max(2,Math.floor(t.width*i.random.range(15,60)/100)),n=Math.max(2,Math.floor(t.width*i.random.range(20,100)/100)),l=Math.max(2,Math.floor(t.height*i.random.range(50,100)/100)),a=Math.max(2,Math.floor(t.height*i.random.range(25,75)/100)),f=i.random.range(Math.max(0,Math.floor(o.width/2)-(r-1)),Math.min(o.width,Math.floor(o.width/2))),s=f+Math.floor(r/2)+i.random.range(0,2)+i.random.range(0,2)-3-Math.floor(n/2),c=Math.floor(o.height/2-l),d=Math.floor(o.height/2-a-(i.random.range(0,2)+i.random.range(0,1)));return o.fill(0),o.fillRect(f-5,c+5,r,l,1),o.fillRect(s-5,d+5,n,a,1),new e(t.id,Math.min(f,s)-5,Math.min(c,d)-5,Math.max(r,n),Math.max(l,a))},symmetricalCrossRoom:function(t,o){if(t=h(t,{width:8,height:5}),!o)return t;let r=Math.floor(t.width*i.random.range(50,100)/100),n=Math.floor(t.height*i.random.range(75,100)/100),l=Math.max(2,Math.floor(t.width*i.random.range(25,50)/100));n%2==0&&l>2&&(l-=1);let a=Math.max(2,Math.floor(t.height*i.random.range(25,50)/100));r%2==0&&a>2&&(a-=1),o.fill(0);const f=Math.floor((o.width-r)/2),s=Math.floor((o.height-a)/2);o.fillRect(f,s,r,a,1);const c=Math.floor((o.width-l)/2),d=Math.floor((o.height-n)/2);return o.fillRect(c,d,l,n,1),new e(t.id,Math.min(f,c),Math.min(s,d),Math.max(r,l),Math.max(n,a))},rectangularRoom:function(t,o){if(t=h(t,{width:6,height:4,minPct:50}),!o)return t;const r=Math.floor(t.width*i.random.range(t.minPct,100)/100),n=Math.floor(t.height*i.random.range(t.minPct,100)/100);o.fill(0);const l=Math.floor((o.width-r)/2),a=Math.floor((o.height-n)/2);return o.fillRect(l,a,r,n,1),new e(t.id,l,a,r,n)},circularRoom:function(t,o){if(t=h(t,{width:6,height:6}),!o)return t;const r=Math.floor((Math.min(t.width,t.height)-1)*i.random.range(75,100)/200);o.fill(0);const n=Math.floor(o.width/2),l=Math.floor(o.height/2);return r>1&&o.fillCircle(n,l,r,1),new e(t.id,n,l,2*r,2*r)},brogueDonut:function(t,o){if(t=h(t,{width:10,height:10,altChance:5,ringMinWidth:3,holeMinSize:3,holeChance:50}),!o)return t;const r=Math.floor(Math.min(t.width,t.height)*i.random.range(75,100)/100);o.fill(0);const n=Math.floor(o.width/2),l=Math.floor(o.height/2);return o.fillCircle(n,l,r,1),r>t.ringMinWidth+t.holeMinSize&&i.random.chance(t.holeChance)&&o.fillCircle(n,l,i.random.range(t.holeMinSize,r-t.holeMinSize),0),new e(t.id,n,l,2*r,2*r)},chunkyRoom:function(t,o){if(t=h(t,{count:8}),!o)return t;let r,n,l,a,f,s,c,d=Math.floor(t.count*i.random.range(25,100)/100);for(a=Math.floor(o.width/2)-Math.floor(t.width/2),f=Math.floor(o.width/2)+Math.floor(t.width/2),s=Math.floor(o.height/2)-Math.floor(t.height/2),c=Math.floor(o.height/2)+Math.floor(t.height/2),o.fill(0),o.fillCircle(Math.floor(o.width/2),Math.floor(o.height/2),2,1),r=0;r<d;)if(n=i.random.range(a,f),l=i.random.range(s,c),o[n][l]){if(n-2<a)continue;if(n+2>f)continue;if(l-2<s)continue;if(l+2>c)continue;o.fillCircle(n,l,2,1),r++}return new e(t.id,a,s,f-a+1,c-s+1)}};t.dig=R,t.diggers=r,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWU,t.GWM)}(this,(function(t,i,e){"use strict";function s(t){if(t&&t.__esModule)return t;var i=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(i,e,s.get?s:{enumerable:!0,get:function(){return t[e]}})}})),i.default=t,Object.freeze(i)}var r,o,n=s(i),l=s(e);const h=l.tile.get("NULL").index,a=l.tile.get("FLOOR").index,c=l.tile.get("DOOR").index,g=null!==(o=null===(r=l.tile.get("DOOR_SECRET"))||void 0===r?void 0:r.index)&&void 0!==o?o:-1,u=l.tile.get("WALL").index,f=l.tile.get("LAKE").index,d=l.tile.get("SHALLOW").index,_=l.tile.get("BRIDGE").index,p=l.tile.get("UP_STAIRS").index,I=l.tile.get("DOWN_STAIRS").index,m=l.tile.get("IMPREGNABLE").index,E={[h]:"NULL",[a]:"FLOOR",[c]:"DOOR",[u]:"WALL",[m]:"IMPREGNABLE",[f]:"LAKE",[d]:"SHALLOW",[_]:"BRIDGE",[p]:"UP_STAIRS",[I]:"DOWN_STAIRS"};class R{constructor(t,i){this.tiles=n.grid.alloc(t,i)}free(){n.grid.free(this.tiles)}clear(){this.tiles.fill(0)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,i){return this.tiles.hasXY(t,i)}isBoundaryXY(t,i){return this.tiles.isBoundaryXY(t,i)}isPassable(t,i){return this.isFloor(t,i)||this.isDoor(t,i)||this.isBridge(t,i)||this.isStairs(t,i)||this.isShallow(t,i)}isNothing(t,i){return this.tiles.get(t,i)===h}isDiggable(t,i){return this.tiles.get(t,i)===h}isFloor(t,i){return this.tiles.get(t,i)==a}isDoor(t,i){return this.tiles.get(t,i)===c}isSecretDoor(t,i){return this.tiles.get(t,i)===g}isBridge(t,i){return this.tiles.get(t,i)===_}isWall(t,i){const e=this.tiles.get(t,i);return e===u||e===m}blocksMove(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)}blocksDiagonal(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksPathing(t,i){return this.isNothing(t,i)||this.isWall(t,i)||this.isDeep(t,i)||this.isStairs(t,i)}blocksVision(t,i){return this.isNothing(t,i)||this.isWall(t,i)}blocksItems(t,i){return this.blocksPathing(t,i)||this.blocksPathing(t,i)}blocksEffects(t,i){return this.isWall(t,i)}isStairs(t,i){const e=this.tiles.get(t,i);return e===p||e===I}isDeep(t,i){return this.tiles.get(t,i)===f}isShallow(t,i){return this.tiles.get(t,i)===d}isAnyLiquid(t,i){return this.isDeep(t,i)||this.isShallow(t,i)}isSet(t,i){return(this.tiles.get(t,i)||0)>0}getTileIndex(t,i){return this.tiles.get(t,i)||0}setTile(t,i,e){if(e instanceof l.tile.Tile&&(e=e.index),"string"==typeof e){const t=l.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return!!this.tiles.hasXY(t,i)&&(this.tiles[t][i]=e,!0)}hasTile(t,i,e){if(e instanceof l.tile.Tile&&(e=e.index),"string"==typeof e){const t=l.tile.tiles[e];if(!t)throw new Error("Failed to find tie: "+e);e=t.index}return this.tiles.hasXY(t,i)&&this.tiles[t][i]==e}getMachine(t,i){return 0}}const T=l.map.flags.Cell;class O{constructor(t){this.machineCount=0,this.map=t}get width(){return this.map.width}get height(){return this.map.height}hasXY(t,i){return this.map.hasXY(t,i)}isBoundaryXY(t,i){return this.map.isBoundaryXY(t,i)}hasCellFlag(t,i,e){return this.map.cellInfo(t,i).hasCellFlag(e)}setCellFlag(t,i,e){this.map.cell(t,i).setCellFlag(e)}clearCellFlag(t,i,e){this.map.cell(t,i).clearCellFlag(e)}hasTile(t,i,e){return this.map.cellInfo(t,i).hasTile(e)}setTile(t,i,e,s){return this.map.setTile(t,i,e,s)}getTileIndex(t,i){if(!this.hasXY(t,i))return 0;return this.map.cell(t,i).highestPriorityTile().index}clear(){this.map.cells.forEach((t=>t.clear()))}hasItem(t,i){return this.map.cellInfo(t,i).hasItem()}hasActor(t,i){return this.map.hasActor(t,i)}blocksMove(t,i){return this.map.cellInfo(t,i).blocksMove()}blocksVision(t,i){return this.map.cellInfo(t,i).blocksVision()}blocksDiagonal(t,i){return this.map.cellInfo(t,i).hasObjectFlag(l.gameObject.flags.GameObject.L_BLOCKS_DIAGONAL)}blocksPathing(t,i){const e=this.map.cellInfo(t,i);return e.hasObjectFlag(l.gameObject.flags.GameObject.L_BLOCKS_MOVE)||e.hasTileFlag(l.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,i){return this.map.cellInfo(t,i).hasObjectFlag(l.gameObject.flags.GameObject.L_BLOCKS_ITEMS)}blocksEffects(t,i){return this.map.cellInfo(t,i).hasObjectFlag(l.gameObject.flags.GameObject.L_BLOCKS_EFFECTS)}isWall(t,i){return this.map.cellInfo(t,i).isWall()}isStairs(t,i){return this.map.cellInfo(t,i).isStairs()}isSet(t,i){return this.hasXY(t,i)&&!this.map.cell(t,i).isEmpty()}isDiggable(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.isEmpty()||!!e.isWall()}isNothing(t,i){return this.hasXY(t,i)&&this.map.cell(t,i).isEmpty()}isFloor(t,i){return this.isPassable(t,i)}isBridge(t,i){return this.map.cellInfo(t,i).hasTileFlag(l.tile.flags.Tile.T_BRIDGE)}isDoor(t,i){return this.map.cellInfo(t,i).hasTileFlag(l.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,i){return this.map.cellInfo(t,i).hasObjectFlag(l.gameObject.flags.GameObject.L_SECRETLY_PASSABLE)}isDeep(t,i){return this.map.cellInfo(t,i).hasTileFlag(l.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return!!e.depthTile(l.gameObject.flags.Depth.LIQUID)&&!e.hasTileFlag(l.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,i){if(!this.hasXY(t,i))return!1;const e=this.map.cell(t,i);return e.hasDepthTile(l.gameObject.flags.Depth.LIQUID)||e.hasTileFlag(l.tile.flags.Tile.T_IS_DEEP_LIQUID)}isOccupied(t,i){return this.hasItem(t,i)||this.hasActor(t,i)}isPassable(t,i){return!this.map.cellInfo(t,i).blocksMove()}backup(){const t=new O(this.map.clone());return t.machineCount=this.machineCount,t}restore(t){this.map.copy(t.map),this.machineCount=t.machineCount}free(){}getChokeCount(t,i){return this.map.cell(t,i).chokeCount}setChokeCount(t,i,e){this.map.cell(t,i).chokeCount=e}analyze(){l.map.analyze(this.map)}fireEffect(t,i,e){return l.effect.fireSync(t,this.map,i,e)}nextMachineId(){return++this.machineCount}getMachine(t,i){return this.map.cell(t,i).machineId}setMachine(t,i,e,s=!0){this.map.cell(t,i).machineId=e,0==e?this.map.clearCellFlag(t,i,T.IS_IN_MACHINE):this.map.setCellFlag(t,i,s?T.IS_IN_ROOM_MACHINE:T.IS_IN_AREA_MACHINE)}}const B=n.utils.DIRS;function w(t,i,e){let s,r,o,l,h,a;for(r=n.utils.NO_DIRECTION,s=0;s<4;s++)if(o=i+B[s][0],l=e+B[s][1],h=i-B[s][0],a=e-B[s][1],t.hasXY(h,a)&&t.hasXY(o,l)&&t.isFloor(h,a)){if(r!=n.utils.NO_DIRECTION)return n.utils.NO_DIRECTION;r=s}return r}function L(t){let i,e,s,r,o,l,h;const a=[[],[],[],[]],c=t.height,g=t.width;for(i=0;i<g;i++)for(e=0;e<c;e++)if(t.isDiggable(i,e)&&(l=w(t,i,e),l!=n.utils.NO_DIRECTION)){for(r=i+n.utils.DIRS[l][0],o=e+n.utils.DIRS[l][1],h=!1,s=0;s<10&&t.hasXY(r,o)&&!h;s++)t.isSet(r,o)&&(h=!0),r+=n.utils.DIRS[l][0],o+=n.utils.DIRS[l][1];h||a[l].push([i,e])}let u=[];for(l=0;l<4;l++){const t=n.random.item(a[l])||[-1,-1];u[l]=[t[0],t[1]]}return u}function N(t,i,e=0,s=0){n.utils.forRect(t.width,t.height,((r,o)=>{const n=r-e,l=o-s,h=i.getTileIndex(n,l);h&&t.setTile(r,o,h)}))}function S(t,i){i.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION))}function M(t,i,e=0,s=0){const r=n.grid.alloc(t.width,t.height);let o=!1;n.utils.forRect(t.width,t.height,((n,l)=>{const h=n+e,a=l+s;i.get(h,a)?t.isStairs(n,l)&&(o=!0):t.isPassable(n,l)&&0==t.getMachine(n,l)&&(r[n][l]=1)}));let l=!0;for(let t=0;t<r.width&&!o;++t)for(let i=0;i<r.height&&!o;++i)1==r[t][i]&&(l?(r.floodFill(t,i,1,2),l=!1):o=!0);return n.grid.free(r),o}function b(t,i,e=0,s=0){const r=n.grid.alloc(t.width,t.height);let o=0;if(n.utils.forRect(t.width,t.height,((n,l)=>{const h=n+e,a=l+s;i.get(h,a)?t.isStairs(n,l)&&(o=t.width*t.height):t.isPassable(n,l)&&(r[n][l]=1)})),o)return o;let l=!0,h=2,a=t.width*t.height;for(let t=0;t<r.width;++t)for(let i=0;i<r.height;++i)if(1==r[t][i]){const e=r.floodFill(t,i,1,h++);a=Math.min(a,e),l?l=!1:o=a}return n.grid.free(r),o}function A(t,i,e,s,r){const o=n.grid.alloc(t.width,t.height);S(t,o),n.path.calculateDistances(i,e,s,o,!1,r+1),n.grid.free(o)}var F=Object.freeze({__proto__:null,NOTHING:h,FLOOR:a,DOOR:c,SECRET_DOOR:g,WALL:u,DEEP:f,SHALLOW:d,BRIDGE:_,UP_STAIRS:p,DOWN_STAIRS:I,IMPREGNABLE:m,TILEMAP:E,GridSite:R,MapSite:O,directionOfDoorSite:w,chooseRandomDoorSites:L,copySite:N,fillCostGrid:S,siteDisruptedBy:M,siteDisruptedSize:b,computeDistanceMap:A});class D{constructor(t,i,e,s=1){this.width=1,this.doors=[],this.x=t[0],this.y=t[1];const r=n.utils.DIRS[i];this.length=e,this.width=s,i===n.utils.UP||i===n.utils.DOWN?(this.x2=this.x+(s-1),this.y2=this.y+(e-1)*r[1]):(this.x2=this.x+(e-1)*r[0],this.y2=this.y+(s-1)),this.dir=i}translate(t,i){this.x+=t,this.y+=i,this.x2+=t,this.y2+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))}))}}class C extends n.utils.Bounds{constructor(t,i,e,s){super(t,i,e,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,i){this.x+=t,this.y+=i,this.doors&&this.doors.forEach((e=>{e&&(e[0]<0||e[1]<0||(e[0]+=t,e[1]+=i))})),this.hall&&this.hall.translate(t,i)}}function P(t,i={}){return t=t||{},i=i||{},Object.entries(i).forEach((([i,e])=>{let s=t[i];if("tile"===i)return void(void 0===s&&(t[i]=e));if(!0===e){if(!s)throw new Error("Missing required config for room digger: "+i)}else s=("number"==typeof e||Array.isArray(e),s||e);const r=n.range.make(s);t[i]=r})),t}class k{constructor(t,i={}){this.options={},this.doors=[],this._setOptions(t,i)}_setOptions(t,i={}){this.options=P(t,i)}create(t){const i=this.carve(t);return i&&(i.doors&&0!=i.doors.length&&!i.doors.every((t=>!t||-1==t[0]))||(i.doors=L(t))),i}}var y={};class v extends k{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,i={}){const e=t.choices||i.choices;if(Array.isArray(e))this.randomRoom=n.random.item.bind(n.random,e);else{if("object"!=typeof e)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=n.random.weighted.bind(n.random,e)}}carve(t){let i=this.randomRoom();const e=y[i];return e||n.utils.ERROR("Missing room digger choice: "+i),e.create(t)}}class G extends k{constructor(t={}){super(t,{width:12,height:8})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||a,r=n.grid.alloc(t.width,t.height,0),o=Math.floor(.5*i),l=i,h=Math.floor(.5*e),c=e,g=new n.blob.Blob({rounds:5,minWidth:o,minHeight:h,maxWidth:l,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(r.width,r.height,((t,i)=>r[t][i]=1)),u=Math.floor((t.width-g.width)/2),f=u-g.x,d=Math.floor((t.height-g.height)/2),_=d-g.y;return r.forEach(((i,e,r)=>{i&&t.setTile(e+f,r+_,s)})),n.grid.free(r),new C(u,d,g.width,g.height)}}class Y extends k{constructor(t={}){super(t,{width:20,height:10})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||a,r=Math.floor(.4*i),o=e,l=i,h=Math.floor(.5*e),c=Math.floor(t.width/2-r/2-1),g=t.height-o-2,u=Math.floor(t.width/2-l/2-1),f=t.height-h-2;n.utils.forRect(c,g,r,o,((i,e)=>t.setTile(i,e,s))),n.utils.forRect(u,f,l,h,((i,e)=>t.setTile(i,e,s)));const d=new C(Math.min(c,u),Math.min(g,f),Math.max(r,l),Math.max(o,h));return d.doors[n.utils.DOWN]=[Math.floor(t.width/2),t.height-2],d}}class x extends k{constructor(t={}){super(t,{width:12,height:20})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||a,r=i,o=Math.max(3,Math.floor(i*n.random.range(25,75)/100)),l=Math.max(3,Math.floor(e*n.random.range(25,75)/100)),h=e,c=Math.floor((t.width-r)/2),g=c+n.random.range(2,Math.max(2,r-o-2)),u=Math.floor((t.height-h)/2),f=u+n.random.range(2,Math.max(2,h-l-2));return n.utils.forRect(c,f,r,l,((i,e)=>t.setTile(i,e,s))),n.utils.forRect(g,u,o,h,((i,e)=>t.setTile(i,e,s))),new C(c,u,Math.max(r,o),Math.max(l,h))}}class U extends k{constructor(t={}){super(t,{width:7,height:7})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||a;let r=Math.max(3,Math.floor(i*n.random.range(25,50)/100)),o=Math.max(3,Math.floor(e*n.random.range(25,50)/100));const l=Math.floor((t.width-i)/2),h=Math.floor((t.height-o)/2);n.utils.forRect(l,h,i,o,((i,e)=>t.setTile(i,e,s)));const c=Math.floor((t.width-r)/2),g=Math.floor((t.height-e)/2);return n.utils.forRect(c,g,r,e,((i,e)=>t.setTile(i,e,s))),new C(Math.min(l,c),Math.min(h,g),Math.max(i,r),Math.max(e,o))}}class W extends k{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const i=this.options.width.value(),e=this.options.height.value(),s=this.options.tile||a,r=Math.floor((t.width-i)/2),o=Math.floor((t.height-e)/2);return n.utils.forRect(r,o,i,e,((i,e)=>t.setTile(i,e,s))),new C(r,o,i,e)}}class X extends k{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const i=this.options.radius.value(),e=this.options.tile||a,s=Math.floor(t.width/2),r=Math.floor(t.height/2);return i>1&&n.utils.forCircle(s,r,i,((i,s)=>t.setTile(i,s,e))),new C(s-i,r-i,2*i+1,2*i+1)}}class V extends k{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const i=this.options.radius.value(),e=this.options.ringMinWidth.value(),s=this.options.holeMinSize.value(),r=this.options.tile||a,o=Math.floor(t.width/2),l=Math.floor(t.height/2);return n.utils.forCircle(o,l,i,((i,e)=>t.setTile(i,e,r))),i>e+s&&n.random.chance(this.options.holeChance.value())&&n.utils.forCircle(o,l,n.random.range(s,i-s),((i,e)=>t.setTile(i,e,0))),new C(o-i,l-i,2*i+1,2*i+1)}}class H extends k{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let i,e,s,r=this.options.count.value();const o=this.options.width.value(),l=this.options.height.value(),h=this.options.tile||a,c=Math.floor(t.width/2)-Math.floor(o/2),g=Math.floor(t.width/2)+Math.floor(o/2),u=Math.floor(t.height/2)-Math.floor(l/2),f=Math.floor(t.height/2)+Math.floor(l/2);let d=Math.floor(t.width/2),_=d,p=Math.floor(t.height/2),I=p;for(n.utils.forCircle(d,p,2,((i,e)=>t.setTile(i,e,h))),d-=2,_+=2,p-=2,I+=2,i=0;i<r;)if(e=n.random.range(c,g),s=n.random.range(u,f),t.isSet(e,s)){if(e-2<c)continue;if(e+2>g)continue;if(s-2<u)continue;if(s+2>f)continue;d=Math.min(e-2,d),_=Math.max(e+2,_),p=Math.min(s-2,p),I=Math.max(s+2,I),n.utils.forCircle(e,s,2,((i,e)=>t.setTile(i,e,h))),i++}return new C(d,p,_-d+1,I-p+1)}}function z(t,i){return y[t]=i,i}z("DEFAULT",new W);var q=Object.freeze({__proto__:null,checkConfig:P,RoomDigger:k,rooms:y,ChoiceRoom:v,choiceRoom:function(t,i){return new v(t).create(i)},Cavern:G,cavern:function(t,i){return new G(t).create(i)},BrogueEntrance:Y,brogueEntrance:function(t,i){return new Y(t).create(i)},Cross:x,cross:function(t,i){return new x(t).create(i)},SymmetricalCross:U,symmetricalCross:function(t,i){return new U(t).create(i)},Rectangular:W,rectangular:function(t,i){return new W(t).create(i)},Circular:X,circular:function(t,i){return new X(t).create(i)},BrogueDonut:V,brogueDonut:function(t,i){return new V(t).create(i)},ChunkyRoom:H,chunkyRoom:function(t,i){return new H(t).create(i)},install:z});const j=n.utils.DIRS;function K(t,i,e){if(!t.hasXY(i[0],i[1]))return!1;if(!t.isDiggable(i[0],i[1]))return!1;const s=[i[0]-e[0],i[1]-e[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function Q(t,i){return t==n.utils.UP||t==n.utils.DOWN?i[1].value():i[0].value()}function Z(t,i,e){let s=n.utils.NO_DIRECTION;if(s==n.utils.NO_DIRECTION){const r=n.random.sequence(4);for(let o=0;o<4;o++){s=r[o];const l=e[(o+1)%2].hi,h=i[s];if(h&&-1!=h[0]&&-1!=h[1]){const i=h[0]+Math.floor(j[s][0]*l),e=h[1]+Math.floor(j[s][1]*l);if(t.hasXY(i,e))break}s=n.utils.NO_DIRECTION}}return s}function $(t,i,e,s,r){let o,l;const h=n.random.chance(r),a=[];for(let r=0;r<4;r++)o=i+j[r][0],l=e+j[r][1],r!=s&&!h||!t.hasXY(o,l)||t.isSet(o,l)||(a[r]=[o,l]);return a}class J{constructor(t={}){this.config={width:n.range.make(1),length:[n.range.make("2-15"),n.range.make("2-9")],tile:a,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=n.range.make(t.width)),t.length&&"number"==typeof t.length){const i=n.range.make(t.length);this.config.length=[i,i]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,i=[]){if(i=i||L(t),!n.random.chance(this.config.chance))return null;const e=Z(t,i,this.config.length);if(e===n.utils.NO_DIRECTION)return null;if(!i[e])return null;const s=this.config.width.value(),r=Q(e,this.config.length),o=i[e];return 1==s?this.dig(t,e,o,r):this.digWide(t,e,o,r,s)}_digLine(t,i,e,s){let r=i[0],o=i[1];const n=this.config.tile;for(let i=0;i<s;i++)t.setTile(r,o,n),r+=e[0],o+=e[1];return r-=e[0],o-=e[1],[r,o]}dig(t,i,e,s){const r=j[i],[o,n]=this._digLine(t,e,r,s),l=new D(e,i,s);return l.doors=$(t,o,n,i,this.config.obliqueChance),l}digWide(t,i,e,s,r){const o=n.utils.DIRS[i],l=[e[0]-o[1],e[1]-o[0]],h=[e[0]+o[1],e[1]+o[0]];this._digLine(t,e,o,s);let a=1,c=e[0],g=e[1];a<r&&K(t,l,o)&&(this._digLine(t,l,o,s),c=Math.min(l[0],c),g=Math.min(l[1],g),++a),a<r&&K(t,h,o)&&(this._digLine(t,h,o,s),c=Math.min(h[0],c),g=Math.min(h[1],g),++a);const u=new D([c,g],i,s,r);return u.doors=[],u.doors[i]=[e[0]+s*o[0],e[1]+s*o[1]],u.width=r,u}}function tt(t,i,e){return new J(t).create(i,e)}var it={};function et(t,i){return it[t]=i,i}et("DEFAULT",new J({chance:15}));var st=Object.freeze({__proto__:null,isDoorLoc:K,pickWidth:function(t={}){return n.utils.clamp(function(t){if(!t)return 1;if("number"==typeof t)return t;if(void 0===t.width)return 1;let i=t.width;if("number"==typeof i)return i;i=Array.isArray(i)?n.random.weighted(i)+1:"string"==typeof i?n.range.make(i).value():Number.parseInt(n.random.weighted(i));return i}(t),1,3)},pickLength:Q,pickHallDirection:Z,pickHallExits:$,HallDigger:J,dig:tt,halls:it,install:et});class rt{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:d,wreathChance:50,wreathSize:1,tile:f},Object.assign(this.options,t)}create(t){let i,e,s,r,o,l,h,a,c,g,u,_=0;l=this.options.height||15,h=this.options.width||30,a=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,u=this.options.canDisrupt||!1;const p=!!n.random.chance(this.options.wreathChance),I=this.options.wreathTile||d,m=this.options.wreathSize||1,E=this.options.tile||f,R=n.grid.alloc(t.width,t.height,0);let T=0;for(;T<g&&_<g;){const f=Math.round((h-a)*(g-T)/g)+a,d=Math.round((l-a)*(g-T)/g)+a,O=new n.blob.Blob({rounds:5,minWidth:4,minHeight:4,maxWidth:f,maxHeight:d,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(R.width,R.height,((t,i)=>R[t][i]=1));let B=!1;for(s=0;s<c&&!B;s++)if(r=n.random.range(1-O.x,R.width-O.width-O.x-2),o=n.random.range(1-O.y,R.height-O.height-O.y-2),u||!this.isDisruptedBy(t,R,-r,-o)){for(B=!0,i=0;i<O.width;i++)for(e=0;e<O.height;e++)if(R[i+O.x][e+O.y]){const s=i+O.x+r,l=e+O.y+o;t.setTile(s,l,E),p&&n.utils.forCircle(s,l,m,((i,e)=>{t.isPassable(i,e)&&t.setTile(i,e,I)}))}break}B?++_:++T}return n.grid.free(R),_}isDisruptedBy(t,i,e=0,s=0){const r=n.grid.alloc(t.width,t.height);let o=!1;n.utils.forRect(t.width,t.height,((n,l)=>{const h=n+e,a=l+s;i.get(h,a)?t.isStairs(n,l)&&(o=!0):t.isPassable(n,l)&&(r[n][l]=1)}));let l=!0;for(let t=0;t<r.width&&!o;++t)for(let i=0;i<r.height&&!o;++i)1==r[t][i]&&(l?(r.floodFill(t,i,1,2),l=!1):o=!0);return n.grid.free(r),o}}var ot=Object.freeze({__proto__:null,Lakes:rt});class nt{constructor(t={}){this.options={minDistance:20,maxLength:5},Object.assign(this.options,t)}create(t){let i,e,s,r,o,l,h,c=0;const g=this.options.maxLength,u=this.options.minDistance,f=n.grid.alloc(t.width,t.height),d=n.grid.alloc(t.width,t.height),p=[[1,0],[0,1]];d.update(((i,e,s)=>t.isPassable(e,s)?1:n.path.OBSTRUCTION));const I=n.random.sequence(t.width*t.height);for(s=0;s<I.length;s++)if(l=Math.floor(I[s]/t.height),h=I[s]%t.height,t.isPassable(l,h)&&!t.isAnyLiquid(l,h))for(o=0;o<=1;o++){const s=p[o];if(i=l+s[0],e=h+s[1],r=g,t.isAnyLiquid(i,e))for(r=0;r<g&&(i+=s[0],e+=s[1],t.isAnyLiquid(i,e));++r);if(t.isPassable(i,e)&&r<g&&(n.path.calculateDistances(f,i,e,d,!1),f[l][h]>u&&f[l][h]<n.path.NO_PATH)){for(;l!==i||h!==e;)this.isBridgeCandidate(t,l,h,s)?(t.setTile(l,h,_),d[l][h]=1):(t.setTile(l,h,a),d[l][h]=1),l+=s[0],h+=s[1];++c;break}}return n.grid.free(f),n.grid.free(d),c}isBridgeCandidate(t,i,e,s){return!!t.isBridge(i,e)||!!t.isAnyLiquid(i,e)&&(!!t.isAnyLiquid(i+s[1],e+s[0])&&!!t.isAnyLiquid(i-s[1],e-s[0]))}}var lt=Object.freeze({__proto__:null,Bridges:nt});class ht{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:p,downTile:I,wall:m},Object.assign(this.options,t)}create(t){let i=!1!==this.options.up,e=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),r={};let o=null,l=null;const h=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let i=this.options.start;i=!0===i?n.random.matchingLoc(t.width,t.height,h):n.random.matchingLocNear(n.utils.x(i),n.utils.y(i),h),r.start=i}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const t=this.options.up;o=n.random.matchingLocNear(n.utils.x(t),n.utils.y(t),h);const i=this.options.down;l=n.random.matchingLocNear(n.utils.x(i),n.utils.y(i),h)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const i=this.options.up;o=n.random.matchingLocNear(n.utils.x(i),n.utils.y(i),h),e&&(l=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.utils.distanceBetween(t,i,o[0],o[1])<s)&&h(t,i))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const e=this.options.down;l=n.random.matchingLocNear(n.utils.x(e),n.utils.y(e),h),i&&(o=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.utils.distanceBetween(t,i,l[0],l[1])<s)&&h(t,i))))}else i?(o=n.random.matchingLoc(t.width,t.height,h),e&&(l=n.random.matchingLoc(t.width,t.height,((t,i)=>!(n.utils.distanceBetween(t,i,o[0],o[1])<s)&&h(t,i))))):e&&(l=n.random.matchingLoc(t.width,t.height,h));return o&&(r.up=o.slice(),this.setupStairs(t,o[0],o[1],this.options.upTile),"up"===this.options.start&&(r.start=r.up)),l&&(r.down=l.slice(),this.setupStairs(t,l[0],l[1],this.options.downTile),"down"===this.options.start&&(r.start=r.down)),o||l?r:null}hasXY(t,i,e){return!(i<0||e<0)&&!(i>=t.width||e>=t.height)}isStairXY(t,i,e){let s=0;if(!this.hasXY(t,i,e)||!t.isDiggable(i,e))return!1;for(let r=0;r<4;++r){const o=n.utils.DIRS[r];if(!this.hasXY(t,i+o[0],e+o[1]))return!1;if(!this.hasXY(t,i-o[0],e-o[1]))return!1;if(t.isFloor(i+o[0],e+o[1])){if(s+=1,!t.isDiggable(i-o[0]+o[1],e-o[1]+o[0]))return!1;if(!t.isDiggable(i-o[0]-o[1],e-o[1]-o[0]))return!1}else if(!t.isDiggable(i+o[0],e+o[1]))return!1}return 1==s}setupStairs(t,i,e,s){const r=n.random.sequence(4);let o=null;for(let s=0;s<r.length;++s){o=n.utils.DIRS[s];const r=i+o[0],l=e+o[1];if(t.isFloor(r,l)&&t.isDiggable(i-o[0],e-o[1]))break;o=null}o||n.utils.ERROR("No stair direction found!"),t.setTile(i,e,s);const l=n.utils.CLOCK_DIRS.findIndex((t=>t[0]==o[0]&&t[1]==o[1])),h=this.options.wall;for(let s=0;s<n.utils.CLOCK_DIRS.length;++s){const r=s?s-1:7,o=(s+1)%8;if(s==l||r==l||o==l)continue;const a=n.utils.CLOCK_DIRS[s];t.setTile(i+a[0],e+a[1],h)}return!0}}var at=Object.freeze({__proto__:null,Stairs:ht});class ct{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},Object.assign(this.options,t)}create(t){let i,e,s,r,o,l,h,g,u;const f=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),d=this.options.maxLength,_=n.grid.alloc(t.width,t.height),p=n.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];function m(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!t.isSet(i,e)&&(!t.isSet(i+s[1],e+s[0])&&!t.isSet(i-s[1],e-s[0])))))}function E(i,e,s){return!!t.hasXY(i,e)&&(!!t.hasXY(i+s[1],e+s[0])&&(!!t.hasXY(i-s[1],e-s[0])&&(!!t.isSet(i,e)||(!!t.isSet(i+s[1],e+s[0])||!!t.isSet(i-s[1],e-s[0])))))}S(t,p);let R=0;const T=n.random.sequence(t.width*t.height);for(o=0;o<T.length;o++)if(g=Math.floor(T[o]/t.height),u=T[o]%t.height,!t.isSet(g,u))for(h=0;h<=1;h++){let o=I[h];if(m(g,u,o)){if(l=d,t.hasXY(g+o[0],u+o[1])&&t.isPassable(g+o[0],u+o[1])){if(!t.hasXY(g-o[0],u-o[1])||t.isDoor(g-o[0],u-o[1]))continue}else{if(!t.hasXY(g-o[0],u-o[1])||!t.isPassable(g-o[0],u-o[1]))continue;if(!t.hasXY(g+o[0],u+o[1])||t.isDoor(g+o[0],u+o[1]))continue;o=o.map((t=>-1*t))}for(i=g+o[0],e=u+o[1],s=g,r=u,l=0;l<d&&(s-=o[0],r-=o[1],!E(s,r,o));++l);if(l<d&&(n.path.calculateDistances(_,i,e,p,!1),_[s][r]>f&&_[s][r]<3e4)){for(;s!==i||r!==e;)t.isNothing(s,r)&&(t.setTile(s,r,a),p[s][r]=1),s+=o[0],r+=o[1];const l=n.random.chance(this.options.doorChance)?c:a;t.setTile(g,u,l),++R;break}}}return n.grid.free(_),n.grid.free(p),R}}var gt=Object.freeze({__proto__:null,LoopDigger:ct,digLoops:function(t,i={}){return new ct(i).create(t)}});class ut{constructor(t={}){var i,e;this.seed=0,this.rooms={},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.startLoc=[-1,-1],this.endLoc=[-1,-1],this.seed=t.seed||0,n.utils.setOptions(this.rooms,t.rooms),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),n.utils.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),n.utils.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),t.loops=t.loops||{},t.loops.doorChance=null!==(i=t.loops.doorChance)&&void 0!==i?i:null===(e=t.doors)||void 0===e?void 0:e.chance,n.utils.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),n.utils.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:(!0===t.bridges&&(t.bridges={}),n.utils.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:(!0===t.stairs&&(t.stairs={}),n.utils.setOptions(this.stairs,t.stairs)),this.startLoc=t.startLoc||[-1,-1],this.endLoc=t.endLoc||[-1,-1]}_makeSite(t,i){return new R(t,i)}create(...t){if(1==t.length&&t[0]instanceof l.map.Map){const i=t[0];this.site=new O(i)}if(t.length>1){const i=t[0],e=t[1];this.site=new R(i,e)}const i=this._create(this.site);if(t.length>1){const i=t[0],e=t[1],s=t[2];n.utils.forRect(i,e,((t,i)=>{const e=this.site.getTileIndex(t,i);e&&s(t,i,e)}))}return this.site.free(),i}_create(t){this.startLoc[0]<0&&this.startLoc[0]<0&&(this.startLoc[0]=Math.floor(t.width/2),this.startLoc[1]=t.height-2),this.start(t);let i=20;for(;--i&&!this.addFirstRoom(t););if(!i)throw new Error("Failed to place first room!");let e=0;for(;e<20;)this.addRoom(t)?e=0:++e;return this.loops&&this.addLoops(t,this.loops),this.lakes&&this.addLakes(t,this.lakes),this.bridges&&this.addBridges(t,this.bridges),this.stairs&&this.addStairs(t,this.stairs),this.finish(t),!0}start(t){this.seed&&n.random.seed(this.seed),t.clear(),this.seq=n.random.sequence(t.width*t.height)}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof k)return t;if("string"==typeof t){const i=y[t];if(!i)throw new Error("Failed to find digger - "+t);return i}return new v(t)}addFirstRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(i);return e&&!this._attachRoomAtLoc(t,i,e,this.startLoc)&&(e=null),i.free(),e}addRoom(t){const i=this._makeSite(t.width,t.height);let e=this.getDigger(this.rooms.digger||"DEFAULT").create(i);if(this.halls.chance){let t=tt(this.halls,i,e.doors);t&&(e.hall=t)}return e&&!this._attachRoom(t,i,e)&&(e=null),i.free(),e}_attachRoom(t,i,e){const s=e.hall?e.hall.doors:e.doors;for(let r=0;r<this.seq.length;r++){const o=Math.floor(this.seq[r]/t.height),l=this.seq[r]%t.height;if(!t.isNothing(o,l))continue;const h=w(t,o,l);if(h!=n.utils.NO_DIRECTION){const r=(h+2)%4,n=s[r];if(!n)continue;const a=o-n[0],c=l-n[1];if(-1!=n[0]&&this._roomFitsAt(t,i,a,c))return N(t,i,a,c),this._attachDoor(t,e,o,l,r),e.translate(a,c),!0}}return!1}_attachRoomAtLoc(t,i,e,s){const[r,o]=s,l=e.hall?e.hall.doors:e.doors,h=n.random.sequence(4);for(let s of h){const n=l[(s+2)%4];if(!n||-1==n[0])continue;const h=r-n[0],a=o-n[1];if(this._roomFitsAt(t,i,h,a))return N(t,i,h,a),e.translate(h,a),!0}return!1}_roomFitsAt(t,i,e,s){let r,o,n,l,h,a;for(r=0;r<i.width;r++)for(o=0;o<i.height;o++)if(i.isSet(r,o))for(n=r+e,l=o+s,h=n-1;h<=n+1;h++)for(a=l-1;a<=l+1;a++)if(!t.hasXY(h,a)||t.isBoundaryXY(h,a)||!t.isNothing(h,a))return!1;return!0}_attachDoor(t,i,e,s,r){const o=this.doors;let l=!1;o.chance&&n.random.chance(o.chance)&&(l=!0);const h=l?o.tile||c:a;if(t.setTile(e,s,h),i.hall&&i.hall.width>1&&i.hall.dir===r)if(r===n.utils.UP||r===n.utils.DOWN){let i=!0,r=1;for(;i;)i=!1,t.isNothing(e-r,s)&&t.isSet(e-r,s-1)&&t.isSet(e-r,s+1)&&(t.setTile(e-r,s,h),i=!0),t.isNothing(e+r,s)&&t.isSet(e+r,s-1)&&t.isSet(e+r,s+1)&&(t.setTile(e+r,s,h),i=!0),++r}else{let i=!0,r=1;for(;i;)i=!1,t.isNothing(e,s-r)&&t.isSet(e-1,s-r)&&t.isSet(e+1,s-r)&&(t.setTile(e,s-r,h),i=!0),t.isNothing(e,s+r)&&t.isSet(e-1,s+r)&&t.isSet(e+1,s+r)&&(t.setTile(e,s+r,h),i=!0),++r}}addLoops(t,i){return new ct(i).create(t)}addLakes(t,i){return new rt(i).create(t)}addBridges(t,i){return new nt(i).create(t)}addStairs(t,i){return new ht(i).create(t)}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let i,e,s,r,o,l;do{for(l=!1,i=0;i<t.width-1;i++)for(e=0;e<t.height-1;e++)for(s=0;s<=1;s++)!t.blocksMove(i+s,e)&&t.blocksMove(i+(1-s),e)&&t.blocksDiagonal(i+(1-s),e)&&t.blocksMove(i+s,e+1)&&t.blocksDiagonal(i+s,e+1)&&!t.blocksMove(i+(1-s),e+1)&&(n.random.chance(50)?(r=i+(1-s),o=e):(r=i+s,o=e+1),l=!0,t.setTile(r,o,a))}while(1==l)}_finishDoors(t){n.utils.forRect(t.width,t.height,((i,e)=>{t.isBoundaryXY(i,e)||t.isDoor(i,e)&&((t.isFloor(i+1,e)||t.isFloor(i-1,e))&&(t.isFloor(i,e+1)||t.isFloor(i,e-1))||(t.blocksPathing(i+1,e)?1:0)+(t.blocksPathing(i-1,e)?1:0)+(t.blocksPathing(i,e+1)?1:0)+(t.blocksPathing(i,e-1)?1:0)>=3)&&t.setTile(i,e,a)}))}_finishWalls(t){const i=this.boundary?m:u;n.utils.forRect(t.width,t.height,((e,s)=>{t.isNothing(e,s)&&(t.isBoundaryXY(e,s)?t.setTile(e,s,i):t.setTile(e,s,u))}))}}const ft=n.flag.fl;var dt;!function(t){t[t.BP_ROOM=ft(10)]="BP_ROOM",t[t.BP_VESTIBULE=ft(1)]="BP_VESTIBULE",t[t.BP_REWARD=ft(7)]="BP_REWARD",t[t.BP_ADOPT_ITEM=ft(0)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=ft(2)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=ft(3)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=ft(4)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=ft(5)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=ft(6)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=ft(8)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=ft(9)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=ft(14)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=ft(11)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=ft(12)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=ft(13)]="BP_NO_INTERIOR_FLAG"}(dt||(dt={}));class _t{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=n.frequency.make(t.frequency||100),t.size){if("string"==typeof t.size){const i=t.size.split(/-/).map((t=>t.trim())).map((t=>Number.parseInt(t)));if(2!==i.length)throw new Error("Blueprint size must be of format: #-#");this.size=n.range.make([i[0],i[1]])}else{if(!Array.isArray(t.size))throw new Error("size must be string or array.");if(2!==t.size.length)throw new Error("Blueprint size must be [min, max]");this.size=n.range.make([t.size[0],t.size[1]])}if(this.size.lo>this.size.hi)throw new Error("Blueprint size must be small to large.")}else this.size=n.range.make([0,999999]);t.flags&&(this.flags=n.flag.from(dt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new Rt(t))))}getChance(t,i){return i&&i.length&&("string"==typeof i&&(i=i.split(/[,|]/).map((t=>t.trim()))),!i.every((t=>this.tags.includes(t))))?0:this.frequency(t)}get isRoom(){return!!(this.flags&dt.BP_ROOM)}get isReward(){return!!(this.flags&dt.BP_REWARD)}get isVestiblue(){return!!(this.flags&dt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&dt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&dt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&dt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&dt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&dt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&dt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&dt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&dt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&dt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&dt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&dt.BP_NO_INTERIOR_FLAG)}qualifies(t,i){return!(this.frequency(i)<=0||~this.flags&t||this.flags&dt.BP_ADOPT_ITEM&~t||this.flags&dt.BP_VESTIBULE&~t)}pickLocation(t){if(this.isRoom){const i=n.random.matchingLoc(t.width,t.height,((i,e)=>t.hasCellFlag(i,e,l.map.flags.Cell.IS_GATE_SITE)&&this.size.contains(t.getChokeCount(i,e))));return!i||i[0]<0||i[1]<0?(console.log("Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint."),!1):i}if(this.isVestiblue)return console.log("ERROR: Attempted to build a vestiblue without a location being provided."),!1;const i=n.random.matchingLoc(t.width,t.height,((i,e)=>t.isPassable(i,e)));return!(!i||i[0]<0||i[1]<0)&&i}computeInterior(t){let i,e=this.isRoom?10:20;const s=t.interior,r=t.site;do{if(i=!1,--e<=0)return console.log("Failed to build a machine; failed repeatedly to find a suitable blueprint location."),!1;if(s.fill(0),this.isRoom)i=!this.addTileToInteriorAndIterate(t,t.originX,t.originY);else if(this.isVestiblue){if(!this.computeInteriorForVestibuleMachine(t))return console.error("ERROR: Attempted to build a door machine from blueprint: not enough room."),!1}else{let e=n.grid.alloc(s.width,s.height);A(r,e,t.originX,t.originY,this.size.hi);const o=n.random.sequence(r.width*r.height);let h=0,a=this.size.value();for(let t=0;t<1e3&&h<a;t++)for(let n=0;n<o.length&&h<a;n++){const c=Math.floor(o[n]/r.height),g=o[n]%r.height;e[c][g]==t&&(s[c][g]=1,h++,(r.isOccupied(c,g)||r.hasCellFlag(c,g,l.map.flags.Cell.IS_IN_MACHINE))&&(i=!0,h=a))}h<a?(i=!0,console.log("too small")):this.treatAsBlocking&&M(r,s)?(console.log("disconnected"),i=!0):this.requireBlocking&&b(r,s)<100&&(console.log("not disconnected enough"),i=!0),n.grid.free(e)}}while(i);return!0}addTileToInteriorAndIterate(t,i,e){let s=!0;const r=t.interior,o=t.site;r[i][e]=1;const h=o.getChokeCount(i,e);for(let a=0;a<4&&s;a++){const c=i+n.utils.DIRS[a][0],g=e+n.utils.DIRS[a][1];if(o.hasXY(c,g)&&!r[c][g]){if(o.isOccupied(c,g)||o.hasCellFlag(c,g,l.map.flags.Cell.IS_IN_MACHINE)&&!o.hasCellFlag(c,g,l.map.flags.Cell.IS_GATE_SITE))return!1;o.getChokeCount(c,g)<=h&&!o.hasCellFlag(c,g,l.map.flags.Cell.IS_IN_MACHINE)&&(s=this.addTileToInteriorAndIterate(t,c,g))}}return s}computeInteriorForVestibuleMachine(t){let i=!0;const e=t.interior,s=t.site;e.fill(0);let r=0;const o=this.size.value(),l=n.grid.alloc(s.width,s.height);A(s,l,t.originX,t.originY,this.size.hi);const h=s.getChokeCount(t.originX,t.originY),a=n.random.sequence(s.width*s.height);for(let t=0;t<1e3&&r<o;t++)for(let n=0;n<a.length&&r<o;++n){const c=Math.floor(a[n]/s.height),g=a[n]%s.height;l[c][g]==t&&(s.isOccupied(c,g)&&(i=!1,r=o),s.getChokeCount(c,g)<=h||(e[c][g]=1,r+=1))}return(this.treatAsBlocking&&M(s,e)||this.requireBlocking&&b(s,e)<100)&&(i=!1),n.grid.free(l),i}prepareInteriorWithMachineFlags(t){const i=t.interior,e=t.site;this.maximizeInterior?this.expandMachineInterior(t,1):this.openInterior&&this.expandMachineInterior(t,4),this.purgeInterior&&i.forEach(((t,i,s)=>{t&&e.setTile(i,s,a)})),this.purgeBlockers&&i.forEach(((t,i,s)=>{t&&e.blocksPathing(i,s)&&e.setTile(i,s,a)})),this.purgeLiquids&&i.forEach(((t,i,s)=>{t&&e.isAnyLiquid(i,s)&&e.setTile(i,s,a)})),this.surroundWithWalls&&i.forEach(((t,s,r)=>{t&&!e.hasCellFlag(s,r,l.map.flags.Cell.IS_GATE_SITE)&&n.utils.eachNeighbor(s,r,((t,s)=>{i.hasXY(t,s)&&(i[t][s]||e.isWall(t,s)||e.hasCellFlag(t,s,l.map.flags.Cell.IS_GATE_SITE)||e.hasCellFlag(t,s,l.map.flags.Cell.IS_IN_MACHINE)||e.blocksPathing(t,s)&&e.setTile(t,s,u))}),!1)})),this.makeImpregnable&&i.forEach(((t,s,r)=>{t&&!e.hasCellFlag(s,r,l.map.flags.Cell.IS_GATE_SITE)&&(e.setCellFlag(s,r,l.map.flags.Cell.IMPREGNABLE),n.utils.eachNeighbor(s,r,((t,s)=>{i.hasXY(t,s)&&(i[t][s]||e.hasCellFlag(t,s,l.map.flags.Cell.IS_GATE_SITE)||e.setCellFlag(t,s,l.map.flags.Cell.IMPREGNABLE))}),!1))}));const s=t.machineNumber;i.forEach(((t,i,r)=>{t&&(e.setMachine(i,r,s,this.isRoom),e.isSecretDoor(i,r)&&e.setTile(i,r,c))}))}expandMachineInterior(t,i=1){let e;const s=t.interior,r=t.site;do{e=!1,s.forEach(((t,o,h)=>{if(r.hasCellFlag(o,h,l.map.flags.Cell.IS_IN_MACHINE))return;if(!r.blocksPathing(o,h))return;let c=0;n.utils.eachNeighbor(o,h,((t,i)=>{s.hasXY(t,i)&&s[t][i]&&!r.blocksPathing(t,i)&&++c}),!1),c<i||(c=0,n.utils.eachNeighbor(o,h,((t,i)=>{s.hasXY(t,i)&&(s[t][i]||r.isWall(t,i)&&!r.hasCellFlag(t,i,l.map.flags.Cell.IS_IN_MACHINE)||++c)}),!1),c||(e=!0,s[o][h]=1,r.blocksPathing(o,h)&&r.setTile(o,h,a),n.utils.eachNeighbor(o,h,((t,i)=>{s.hasXY(t,i)&&(r.isSet(t,i)||r.setTile(t,i,u))}))))}))}while(e)}calcDistances(t){t.distanceMap.fill(0),A(t.site,t.distanceMap,t.originX,t.originY,this.size.hi);let i=0;const e=new Array(100).fill(0);t.interior.forEach(((s,r,o)=>{if(!s)return;const n=t.distanceMap[r][o];n<100&&(e[n]++,i++)}));let s=Math.round(i/4),r=Math.round(3*i/4);for(let t=0;t<100;t++){if(s<=e[t]){s=t;break}s-=e[t]}for(let t=0;t<100;t++){if(r<=e[t]){r=t;break}r-=e[t]}t.distance25=s,t.distance75=r}pickComponents(){const t=[Et.BF_ALTERNATIVE,Et.BF_ALTERNATIVE_2],i=new Array(this.steps.length).fill(!0);for(let e=0;e<=1;e++){let s=0;for(let r=0;r<i.length;r++)this.steps[r].flags&t[e]&&(i[r]=!1,s++);if(s>0){let r=n.random.range(1,s);for(let s=0;s<i.length;s++)if(this.steps[s].flags&t[e]){if(1==r){i[s]=!0;break}r--}}}return this.steps.filter(((t,e)=>i[e]))}clearInteriorFlag(t){t.interior.forEach(((i,e,s)=>{i&&(t.site.hasCellFlag(e,s,l.map.flags.Cell.IS_WIRED|l.map.flags.Cell.IS_CIRCUIT_BREAKER)||t.site.setMachine(e,s,0))}))}}const pt={};function It(t,i){const e=Object.values(pt).filter((e=>e.qualifies(t,i)));return n.random.item(e)}const mt=n.flag.fl;var Et;!function(t){t[t.BF_OUTSOURCE_ITEM_TO_MACHINE=mt(1)]="BF_OUTSOURCE_ITEM_TO_MACHINE",t[t.BF_BUILD_VESTIBULE=mt(2)]="BF_BUILD_VESTIBULE",t[t.BF_ADOPT_ITEM=mt(3)]="BF_ADOPT_ITEM",t[t.BF_BUILD_AT_ORIGIN=mt(6)]="BF_BUILD_AT_ORIGIN",t[t.BF_PERMIT_BLOCKING=mt(8)]="BF_PERMIT_BLOCKING",t[t.BF_TREAT_AS_BLOCKING=mt(9)]="BF_TREAT_AS_BLOCKING",t[t.BF_NEAR_ORIGIN=mt(10)]="BF_NEAR_ORIGIN",t[t.BF_FAR_FROM_ORIGIN=mt(11)]="BF_FAR_FROM_ORIGIN",t[t.BF_IN_VIEW_OF_ORIGIN=mt(25)]="BF_IN_VIEW_OF_ORIGIN",t[t.BF_IN_PASSABLE_VIEW_OF_ORIGIN=mt(26)]="BF_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BF_MONSTER_TAKE_ITEM=mt(12)]="BF_MONSTER_TAKE_ITEM",t[t.BF_MONSTER_SLEEPING=mt(13)]="BF_MONSTER_SLEEPING",t[t.BF_MONSTER_FLEEING=mt(14)]="BF_MONSTER_FLEEING",t[t.BF_MONSTERS_DORMANT=mt(19)]="BF_MONSTERS_DORMANT",t[t.BF_ITEM_IS_KEY=mt(0)]="BF_ITEM_IS_KEY",t[t.BF_ITEM_IDENTIFIED=mt(5)]="BF_ITEM_IDENTIFIED",t[t.BF_ITEM_PLAYER_AVOIDS=mt(4)]="BF_ITEM_PLAYER_AVOIDS",t[t.BF_EVERYWHERE=mt(15)]="BF_EVERYWHERE",t[t.BF_ALTERNATIVE=mt(16)]="BF_ALTERNATIVE",t[t.BF_ALTERNATIVE_2=mt(17)]="BF_ALTERNATIVE_2",t[t.BF_BUILD_IN_WALLS=mt(21)]="BF_BUILD_IN_WALLS",t[t.BF_BUILD_ANYWHERE_ON_LEVEL=mt(22)]="BF_BUILD_ANYWHERE_ON_LEVEL",t[t.BF_REPEAT_UNTIL_NO_PROGRESS=mt(23)]="BF_REPEAT_UNTIL_NO_PROGRESS",t[t.BF_IMPREGNABLE=mt(24)]="BF_IMPREGNABLE",t[t.BF_NOT_IN_HALLWAY=mt(27)]="BF_NOT_IN_HALLWAY",t[t.BF_NOT_ON_LEVEL_PERIMETER=mt(28)]="BF_NOT_ON_LEVEL_PERIMETER",t[t.BF_SKELETON_KEY=mt(29)]="BF_SKELETON_KEY",t[t.BF_KEY_DISPOSABLE=mt(30)]="BF_KEY_DISPOSABLE"}(Et||(Et={}));class Rt{constructor(t={}){var i;this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.id="n/a",this.tile=null!==(i=t.tile)&&void 0!==i?i:-1,t.flags&&(this.flags=n.flag.from(Et,t.flags)),t.pad&&(this.pad=t.pad),this.count=n.range.make(t.count||1),this.item=t.item||null,this.horde=t.horde||null,t.effect&&(this.effect=l.effect.make(t.effect))}get repeatUntilNoProgress(){return!!(this.flags&Et.BF_REPEAT_UNTIL_NO_PROGRESS)}cellIsCandidate(t,i,e,s,r){const o=t.site;if(this.flags&Et.BF_NOT_IN_HALLWAY&&n.utils.arcCount(e,s,((t,i)=>o.hasXY(t,i)&&o.isPassable(t,i)))>1)return!1;if(this.flags&Et.BF_NOT_ON_LEVEL_PERIMETER&&(0==e||e==o.width-1||0==s||s==o.height-1))return!1;if(this.flags&Et.BF_BUILD_AT_ORIGIN)return e==t.originX&&s==t.originY;if(i.isRoom&&e==t.originX&&s==t.originY)return!1;if(t.occupied[e][s])return!1;if(this.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[e][s])return!1;let h=1e4;if(o.isWall(e,s)?n.utils.eachNeighbor(e,s,((i,e)=>{t.distanceMap.hasXY(i,e)&&!o.blocksPathing(i,e)&&h>t.distanceMap[i][e]+1&&(h=t.distanceMap[i][e]+1)}),!0):h=t.distanceMap[e][s],h>r[1]||h<r[0])return!1;if(this.flags&Et.BF_BUILD_IN_WALLS){const i=o.getMachine(e,s);if(!t.interior[e][s]&&(!i||i==t.machineNumber)&&o.isWall(e,s)){let i=!1;return n.utils.eachNeighbor(e,s,((e,s)=>{o.hasXY(e,s)&&(t.interior[e][s]&&(e!=t.originX||s!=t.originY)||this.flags&Et.BF_BUILD_ANYWHERE_ON_LEVEL&&!o.blocksPathing(e,s)&&!o.getMachine(e,s))&&(i=!0)})),i}return!1}return!o.isWall(e,s)&&(this.flags&Et.BF_BUILD_ANYWHERE_ON_LEVEL?!(this.item&&o.blocksItems(e,s)||o.hasCellFlag(e,s,l.map.flags.Cell.IS_CHOKEPOINT|l.map.flags.Cell.IS_IN_LOOP|l.map.flags.Cell.IS_IN_MACHINE)):!!t.interior[e][s])}makePersonalSpace(t,i,e,s){const r=this.pad;let o=0;for(let n=i-r+1;n<=i+r-1;n++)for(let i=e-r+1;i<=e+r-1;i++)t.site.hasXY(n,i)&&(s[n][i]&&(s[n][i]=0,++o),t.occupied[n][i]=1);return o}get generateEverywhere(){return!!(this.flags&Et.BF_EVERYWHERE&~Et.BF_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&Et.BF_BUILD_AT_ORIGIN)}distanceBound(t){const i=[0,1e4];return this.flags&Et.BF_NEAR_ORIGIN&&(i[1]=t.distance25),this.flags&Et.BF_FAR_FROM_ORIGIN&&(i[0]=t.distance75),i}updateViewMap(t){if(this.flags&(Et.BF_IN_VIEW_OF_ORIGIN|Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN)){const i=t.site;if(this.flags&Et.BF_IN_PASSABLE_VIEW_OF_ORIGIN){new n.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}else{new n.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e)||i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((i,e)=>{t.viewMap[i][e]=1}))}t.viewMap[t.originX][t.originY]=1}}markCandidates(t,i,e,s){let r=0;return t.update(((t,o,n)=>this.cellIsCandidate(i,e,o,n,s)?(r++,1):0)),r}build(t,i){let e=0,s=0;const r=t.site,o=n.grid.alloc(r.width,r.height),h=this.distanceBound(t);this.updateViewMap(t);do{let a=this.markCandidates(o,t,i,h);if(this.generateEverywhere||(e=this.count.value()),!a||a<this.count.lo)return console.warn("Only %s qualifying tiles - want at least %s.",a,this.count.lo),0;let c=0,g=0;for(s=0;(this.generateEverywhere||s<e)&&a>0;){this.buildAtOrigin?(c=t.originX,g=t.originY):[c,g]=n.random.matchingLoc(o.width,o.height,((t,i)=>o[t][i]>0)),o[c][g]=0,a--;let e=!0;if(this.effect&&(e=r.fireEffect(this.effect,c,g)),e&&-1!==this.tile){const t=l.tile.get(this.tile);if(!(this.flags&Et.BF_PERMIT_BLOCKING)&&(t.blocksMove()||this.flags&Et.BF_TREAT_AS_BLOCKING)){const t=n.grid.alloc(r.width,r.height);t[c][g]=1,e=!M(r,t),n.grid.free(t)}e&&r.setTile(c,g,t)}e&&(a-=this.makePersonalSpace(t,c,g,o),s++),e&&(i.flags&dt.BP_NO_INTERIOR_FLAG||r.setMachine(c,g,t.machineNumber,i.isRoom),this.flags&Et.BF_IMPREGNABLE&&r.setCellFlag(c,g,l.map.flags.Cell.IMPREGNABLE))}}while(this.flags&Et.BF_REPEAT_UNTIL_NO_PROGRESS&&s<=this.count.lo);let a=!0;if(this.flags&(Et.BF_OUTSOURCE_ITEM_TO_MACHINE|Et.BF_BUILD_VESTIBULE)){if(this.flags&Et.BF_OUTSOURCE_ITEM_TO_MACHINE)throw new Error("OUTSOURCE_ITEM_TO_MACHINE - Not ready yet.");if(this.flags&Et.BF_BUILD_VESTIBULE&&(a=t.buildRandom(dt.BP_VESTIBULE,t.originX,t.originY)),!a)return console.log(`Depth ${t.depth}: Failed to place blueprint ${i.id} because it requires a vestibule and we couldn't place one.`),0}return n.grid.free(o),s}}var Tt=Object.freeze({__proto__:null,get StepFlags(){return Et},BuildStep:Rt,Builder:class{constructor(t,i){this.map=t,this.depth=i,this.spawnedItems=[],this.spawnedHordes=[],this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.site=new O(t),this.interior=n.grid.alloc(t.width,t.height),this.occupied=n.grid.alloc(t.width,t.height),this.viewMap=n.grid.alloc(t.width,t.height),this.distanceMap=n.grid.alloc(t.width,t.height)}free(){n.grid.free(this.interior),n.grid.free(this.occupied),n.grid.free(this.viewMap),n.grid.free(this.distanceMap)}buildRandom(t=dt.BP_ROOM,i=-1,e=-1){let s=10;for(;s--;){const s=It(t,this.depth);if(s&&this.build(s,i,e))return!0}return console.log("Failed to find blueprint matching flags: "+n.flag.toString(dt,t)),!1}build(t,i=-1,e=-1){let s=10;if(this.site.analyze(),i>=0&&e>=0)return this._build(t,i,e);for(;s--;){const i=t.pickLocation(this.site);if(i&&this._build(t,i[0],i[1]))return!0}return console.log("Failed to build blueprint."),!1}_build(t,i,e){if(this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=i,this.originY=e,!t.computeInterior(this))return!1;const s=this.site.backup();this.machineNumber=this.site.nextMachineId(),t.prepareInteriorWithMachineFlags(this),t.calcDistances(this);const r=t.pickComponents();for(let i=0;i<r.length;i++){const e=r[i],o=e.build(this,t);if(0==o||o<e.count.lo&&!e.repeatUntilNoProgress)return console.log("Failed to place blueprint because of feature; needed more instances."),this.site.restore(s),!1}return t.noInteriorFlag&&t.clearInteriorFlag(this),!0}},get Flags(){return dt},Blueprint:_t,blueprints:pt,install:function(t,i){return i instanceof _t||(i=new _t(i)),pt[t]=i,i.id=t,i},random:It});t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{count:20,digger:"DEFAULT"},halls:{},loops:{},lakes:{},bridges:{},stairs:{},boundary:!0},this.seeds=[],this.stairLocs=[],n.utils.setOptions(this.config,t),this.config.seed&&n.random.seed(this.config.seed),this.initSeeds(),this.initStairLocs()}get levels(){return this.config.levels}initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=n.random.number(2**32)}initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const i=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));for(let e=0;e<this.config.levels;++e){const e=n.random.matchingLoc(this.config.width,this.config.height,((e,s)=>n.utils.distanceBetween(t[0],t[1],e,s)>i));this.stairLocs.push([[t[0],t[1]],[e[0],e[1]]]),t=e}}getLevel(t,i){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);n.random.seed(this.seeds[t]);const[e,s]=this.stairLocs[t],r=Object.assign({},this.config.stairs);this.config.goesUp?(r.down=e,r.up=s,0==t&&this.config.startTile&&(r.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.upTile=this.config.endTile)):(r.down=s,r.up=e,0==t&&this.config.startTile&&(r.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(r.downTile=this.config.endTile));const o=Object.assign({},this.config.rooms);0===t&&o.entrance&&(o.first=o.entrance);const l={loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:o,stairs:r,boundary:this.config.boundary,width:this.config.width,height:this.config.height};return this.makeLevel(t,l,i)}makeLevel(t,i,e){const s=new ut(i),r=s.create(this.config.width,this.config.height,e);return n.utils.equalsXY(s.endLoc,i.endLoc)&&n.utils.equalsXY(s.startLoc,i.startLoc)||(this.stairLocs[t]=[s.startLoc,s.endLoc]),r}},t.Hall=D,t.Level=ut,t.Room=C,t.blueprint=Tt,t.bridge=lt,t.hall=st,t.lake=ot,t.loop=gt,t.room=q,t.site=F,t.stairs=at,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map

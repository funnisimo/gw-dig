!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-utils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWU)}(this,(function(t,e){"use strict";function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var s=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,s.get?s:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var s=i(e);class n{constructor(t=!0){var e;this.plugins=[],this.tileIds={},this.allTiles=[],t&&((e=this).tileIds.NOTHING=e.tileIds.NULL=e.install("NONE",{priority:0,ch:""}).index,e.install("FLOOR",{priority:10,ch:"."}),e.install("WALL",{blocksMove:!0,blocksVision:!0,priority:50,ch:"#"}),e.install("DOOR",{blocksVision:!0,door:!0,priority:60,ch:"+"}),e.install("SECRET_DOOR",{blocksMove:!0,secretDoor:!0,priority:70,ch:"%"}),e.install("UP_STAIRS",{stairs:!0,priority:80,ch:">"}),e.install("DOWN_STAIRS",{stairs:!0,priority:80,ch:"<"}),e.tileIds.DEEP=e.install("LAKE",{priority:40,liquid:!0,ch:"~"}).index,e.install("SHALLOW",{priority:30,ch:"`"}),e.install("BRIDGE",{priority:45,ch:"="}),e.install("IMPREGNABLE",{priority:200,ch:"%",impregnable:!0,blocksMove:!0,blocksVision:!0}))}use(t){this.plugins.push(t)}getTile(t){let e;if("string"==typeof t){if(e=this.tileIds[t],void 0===e)return null}else e=t;return this.allTiles[e]||null}hasTile(t){return null!==this.getTile(t)}tileId(t){return"number"==typeof t?t:this.tileIds[t]??-1}blocksMove(t){const e=this.getTile(t);return!!e&&e.blocksMove||!1}install(t,e={}){"string"!=typeof t&&(e=t,t=t.id);const i={id:t,index:this.allTiles.length,priority:0,tags:[]};if(e.extends=e.extends||t,e.extends){const s=this.getTile(e.extends);if(s)Object.assign(i,s);else if(e.extends!==t)throw new Error("Cannot extend tile: "+e.extends)}const n=s.object.assignOmitting("priority, extends",i,e);if(n.id=t,n.index=this.allTiles.length,e.tags&&(n.tags=s.tags.make(e.tags)),"string"==typeof e.priority){let t=e.priority.replace(/ /g,""),i=t.search(/[+-]/);if(0==i)n.priority=n.priority+Number.parseInt(t);else if(-1==i)if(0==t.search(/[a-zA-Z]/)){const e=o(t);if(!e)throw new Error("Failed to find tile for priority - "+t+".");n.priority=e.priority}else n.priority=Number.parseInt(t);else{const e=t.substring(0,i),s=Number.parseInt(t.substring(i)),r=o(e);if(!r)throw new Error("Failed to find tile for priority - "+e+".");n.priority=r.priority+s}}else void 0!==e.priority&&(n.priority=e.priority);return void 0===n.blocksPathing&&n.blocksMove&&(n.blocksPathing=!0),this.apply(n,e),this.tileIds[t]?(n.index=this.tileIds[t],this.allTiles[n.index]=n):(this.allTiles.push(n),this.tileIds[t]=n.index),n}apply(t,e){this.plugins.forEach((i=>{i.createTile&&i.createTile(t,e)}))}}const r=new n(!0);function o(t){return r.getTile(t)}function a(t){return r.tileId(t)}const h={};const l={};function c(t,e){l[t]=e}function g(t){if(Array.isArray(t)&&(t=t[0]),t&&"string"!=typeof t&&(t=t.id),!t||!t.length)throw new Error("Feature effect needs ID");return u.bind(void 0,t)}function u(t,e,i,s){const n=h[t];if(!n)throw new Error("Failed to find feature: "+t);return n(e,i,s)}function f(t,e){if(!t)return s.FALSE;if("string"==typeof t){if(!t.length)throw new Error("Cannot create effect from empty string.");if(!e){const i=t.split(":");t=i.shift().toLowerCase(),e=i}0===e.length&&(e=t,t="feature");const i=l[t];if(!i)throw new Error("Failed to find effect - "+t);return i(e||{})}let i;if(Array.isArray(t))i=t.map((t=>f(t))).filter((t=>null!==t));else{if("function"==typeof t)return t;i=Object.entries(t).map((([t,e])=>f(t,e))).filter((t=>null!==t))}return 1===i.length?i[0]:(t,e,s)=>i.every((i=>i(t,e,s)))}function d(t){if(!t)return[];if(Array.isArray(t))return t.map((t=>f(t))).filter((t=>null!==t));if("string"==typeof t){if(!t.length)throw new Error("Cannot create effect from empty string.");const e=t.split(":");t=e.shift().toLowerCase();const i=l[t];return i?[i(e)]:[]}if("function"==typeof t)return[t];return Object.entries(t).map((([t,e])=>f(t,e))).filter((t=>null!==t))}function _(t){if(!t)throw new Error("Tile effect needs configuration.");if("string"==typeof t)t={id:t};else if(Array.isArray(t))t={id:t[0]};else if(!t.id)throw new Error("Tile effect needs configuration with id.");const e=t;return e.id.includes("!")&&(e.superpriority=!0),e.id.includes("~")&&(e.blockedByActors=!0,e.blockedByItems=!0),e.id=e.id.replace(/[!~+]*/g,""),p.bind(void 0,e)}function p(t,e,i,s){return t.machine=0,!!e.setTile(i,s,t.id,t)}function I(t){if(Array.isArray(t)&&(t=t[0]),"object"==typeof t&&(t=t.chance),"string"==typeof t&&(t=t.endsWith("%")?100*Number.parseFloat(t):Number.parseInt(t||"10000")),"number"!=typeof t)throw new Error("Chance effect config must be number or string that can be a number.");return E.bind(void 0,t)}function E(t,e){return e.rng.chance(t,1e4)}c("feature",g),c("effect",g),c("id",g),c("tile",_),c("chance",I);const m=s.flag.fl;var O;function S(...t){let e={};if(!t.length)throw new Error("Must have config to create spread.");if(1===t.length&&("string"==typeof t[0]?t=t[0].split(":").map((t=>t.trim())):Array.isArray(t[0])?t=t[0]:(Object.assign(e,t[0]),t=[e])),t.length>=3)Object.assign(e,t[3]||{}),e.grow=Number.parseInt(t[0]),e.decrement=Number.parseInt(t[1]),e.features=t[2];else if(2===t.length)throw new Error("Must have actions to run for spread.");"number"!=typeof e.grow&&(e.grow=Number.parseInt(e.grow||0)),"number"!=typeof e.decrement&&(e.decrement=Number.parseInt(e.decrement||100)),e.flags=s.flag.from(O,e.flags||0),e.matchTile=e.matchTile||"","string"==typeof e.features&&e.features.indexOf(":")<0&&a(e.features)>=0&&(e.features="TILE:"+e.features);const i=d(e.features);if(!i)throw new Error("Failed to make action for spread.");e.features=i;const n=R.bind(void 0,e);return n.config=e,n}function R(t,e,i,n){const r=!!(t.flags&O.E_ABORT_IF_BLOCKS_MAP),o=e;let a=!1;const h=s.grid.alloc(o.width,o.height);return y(t,h,e,i,n)?r&&L(o,h)?(s.grid.free(h),!1):(t.flags&O.E_EVACUATE_CREATURES&&T(o,h)&&(a=!0),t.flags&O.E_EVACUATE_ITEMS&&B(o,h)&&(a=!0),t.flags&O.E_CLEAR_CELL&&A(o,h,t.flags)&&(a=!0),h.update((t=>t?1:0)),t.features.forEach(((t,i)=>{h.forEach(((s,n,r)=>{s===i+1&&t(e,n,r)&&(a=!0,h.increment(n,r))}))})),a&&(a=!0),s.grid.free(h),a):(s.grid.free(h),!1)}function L(t,e,i=0,n=0){const r=s.grid.alloc(t.width,t.height);let o=!1;s.xy.forRect(t.width,t.height,((s,a)=>{const h=s+i,l=a+n;e.get(h,l)?t.isStairs(s,a)&&(o=!0):t.blocksMove(s,a)||r.set(s,a,1)}));let a=!0;for(let t=0;t<r.width&&!o;++t)for(let e=0;e<r.height&&!o;++e)1==r.get(t,e)&&(a?(r.floodFill(t,e,1,2),a=!1):o=!0);return s.grid.free(r),o}function b(t,e,i,n,r){if(!e.hasXY(i,n))return!1;if(e.isProtected(i,n))return!1;if(e.blocksEffects(i,n)&&!t.matchTile&&!r)return!1;if(t.flags&O.E_BUILD_IN_WALLS){if(!e.isWall(i,n))return!1}else if(t.flags&O.E_MUST_TOUCH_WALLS){let t=!1;if(s.xy.eachNeighbor(i,n,((i,s)=>{e.isWall(i,s)&&(t=!0)}),!0),!t)return!1}else if(t.flags&O.E_NO_TOUCH_WALLS){let t=!0;if(e.isWall(i,n))return!1;if(s.xy.eachNeighbor(i,n,((i,s)=>{e.isWall(i,s)&&(t=!1)}),!0),!t)return!1}return!(t.matchTile&&!r&&!e.hasTile(i,n,t.matchTile))}function y(t,e,i,n,r){let o,a,h,l,c,g,u;const f=i;let d=t.grow||0,_=t.decrement||0;if(e.fill(0),!b(t,f,n,r,!0))return!1;e.set(n,r,1),l=1;let p=1;if(d)for(u=!0,d>=100&&(_=_||100),_<=0&&(_=d);u&&d>0;){for(u=!1,l++,o=0;o<f.width;o++)for(a=0;a<f.height;a++)if(e.get(o,a)==l-1)for(h=0;h<4;h++)c=o+s.xy.DIRS[h][0],g=a+s.xy.DIRS[h][1],e.hasXY(c,g)&&!e.get(c,g)&&f.rng.chance(d)&&b(t,f,c,g,!1)&&(e.set(c,g,l),u=!0,++p);d-=_}return p>0}function A(t,e,i=0){let s=!1;return e.forEach(((e,i,n)=>{e&&(t.clearTile(i,n),s=!0)})),s}function T(t,e){let i=!1;return t.eachActor((s=>{if(!e.get(s.x,s.y))return;const n=t.rng.matchingLocNear(s.x,s.y,((i,n)=>!!t.hasXY(i,n)&&(!e.get(i,n)&&!t.forbidsActor(i,n,s))));n&&n[0]>=0&&n[1]>=0&&(s.y=n[0],s.y=n[1],i=!0)})),i}function B(t,e){let i=!1;return t.eachItem((s=>{if(!e.get(s.x,s.y))return;const n=t.rng.matchingLocNear(s.x,s.y,((i,n)=>!!t.hasXY(i,n)&&(!e.get(i,n)&&!t.forbidsItem(i,n,s))));n&&n[0]>=0&&n[1]>=0&&(s.x=n[0],s.y=n[1],i=!0)})),i}!function(t){t[t.E_TREAT_AS_BLOCKING=m(5)]="E_TREAT_AS_BLOCKING",t[t.E_PERMIT_BLOCKING=m(6)]="E_PERMIT_BLOCKING",t[t.E_ABORT_IF_BLOCKS_MAP=m(7)]="E_ABORT_IF_BLOCKS_MAP",t[t.E_BLOCKED_BY_ITEMS=m(8)]="E_BLOCKED_BY_ITEMS",t[t.E_BLOCKED_BY_ACTORS=m(9)]="E_BLOCKED_BY_ACTORS",t[t.E_BLOCKED_BY_OTHER_LAYERS=m(10)]="E_BLOCKED_BY_OTHER_LAYERS",t[t.E_SUPERPRIORITY=m(11)]="E_SUPERPRIORITY",t[t.E_IGNORE_FOV=m(12)]="E_IGNORE_FOV",t[t.E_EVACUATE_CREATURES=m(15)]="E_EVACUATE_CREATURES",t[t.E_EVACUATE_ITEMS=m(16)]="E_EVACUATE_ITEMS",t[t.E_BUILD_IN_WALLS=m(17)]="E_BUILD_IN_WALLS",t[t.E_MUST_TOUCH_WALLS=m(18)]="E_MUST_TOUCH_WALLS",t[t.E_NO_TOUCH_WALLS=m(19)]="E_NO_TOUCH_WALLS",t[t.E_CLEAR_GROUND=m(21)]="E_CLEAR_GROUND",t[t.E_CLEAR_SURFACE=m(22)]="E_CLEAR_SURFACE",t[t.E_CLEAR_LIQUID=m(23)]="E_CLEAR_LIQUID",t[t.E_CLEAR_GAS=m(24)]="E_CLEAR_GAS",t[t.E_CLEAR_TILE=m(25)]="E_CLEAR_TILE",t[t.E_CLEAR_CELL=t.E_CLEAR_GROUND|t.E_CLEAR_SURFACE|t.E_CLEAR_LIQUID|t.E_CLEAR_GAS]="E_CLEAR_CELL",t[t.E_ONLY_IF_EMPTY=t.E_BLOCKED_BY_ITEMS|t.E_BLOCKED_BY_ACTORS]="E_ONLY_IF_EMPTY"}(O||(O={})),c("spread",S);var w=Object.freeze({__proto__:null,tile:_,tileAction:p,chance:I,chanceAction:E,features:h,install:function(t,e){"function"!=typeof e&&(e=f(e)),h[t]=e},types:l,installType:c,feature:g,featureFeature:u,make:f,makeArray:d,get Flags(){return O},spread:S,spreadFeature:R,mapDisruptedBy:L,computeSpawnMap:y,clearCells:A,evacuateCreatures:T,evacuateItems:B});const N=[];function C(t,e,i){let n;if(i=i||s.random,"string"==typeof e)n=s.tags.makeMatch(e);else{if("id"in e)return N.find((t=>t.id===e.id))||null;n=s.tags.makeMatch(e)}const r=N.filter((t=>n(t.tags)));if(0==r.length)return null;const o=r.map((e=>e.frequency(t)));return r[i.weighted(o)]||null}function D(t,e,i=-1,n=-1,r={}){r.canSpawn=r.canSpawn||s.TRUE,r.rng=r.rng||e.rng,r.machine=r.machine||0;const o=function(t,e,i,s,n){const r={id:t.leader,make:t.make,x:i,y:s,machine:n.machine||0};if(i>=0&&s>=0){if(!e.canSpawnActor(i,s,r))return null}else if([i,s]=function(t,e,i){return i.rng.matchingLoc(e.width,e.height,((s,n)=>!!e.hasXY(s,n)&&(!e.hasActor(s,n)&&(!!i.canSpawn(s,n)&&!!e.canSpawnActor(s,n,t)))))}(r,e,n)||[-1,-1],i<0||s<0)return null;if(!function(t,e,i,s,n){return e.addActor(i,s,t)}(r,e,i,s))return null;return r}(t,e,i,n,r);return o?(function(t,e,i,s){const n=Object.entries(t.members);if(0==n.length)return 0;let r=0;n.forEach((([t,n])=>{const r=n.count.value(s.rng);for(let o=0;o<r;++o)M(t,n,i,e,s)}))}(t,o,e,r),o):null}function M(t,e,i,s,n){const r={id:t,make:e.make,x:-1,y:-1,machine:s.machine},[o,a]=function(t,e,i,s){return s.rng.matchingLocNear(i.x,i.y,((i,n)=>!!e.hasXY(i,n)&&(!e.hasActor(i,n)&&(!!e.canSpawnActor(i,n,t)&&!!s.canSpawn(i,n)))))}(r,i,s,n)||[-1,-1];return o<0||a<0?null:function(t,e,i,s,n,r){return t.leader=n,e.addActor(i,s,t)}(r,i,o,a,s)?r:null}const k=[];function x(t,e,i){if(i=i||s.random,"string"!=typeof e&&"id"in e)return k.find((t=>t.id===e.id))||null;e="string"==typeof e?e:e.tags;const n=s.tags.makeMatch(e),r=k.filter((t=>n(t.tags)));if(0==r.length)return null;const o=r.map((e=>e.frequency(t)));return r[i.weighted(o)]||null}function P(t){return{id:t.id,make:t.make,x:-1,y:-1}}const F=s.xy.DIRS;function Y(t,e,i){let n,r,o,a,h,l;for(r=s.xy.NO_DIRECTION,n=0;n<4;n++)if(o=e+F[n][0],a=i+F[n][1],h=e-F[n][0],l=i-F[n][1],t.hasXY(h,l)&&t.hasXY(o,a)&&t.isFloor(h,l)){if(r!=s.xy.NO_DIRECTION)return s.xy.NO_DIRECTION;r=n}return r}function v(t){let e,i,n,r,o,a,h;const l=[[],[],[],[]],c=t.height,g=t.width;for(e=0;e<g;e++)for(i=0;i<c;i++)if(t.isDiggable(e,i)&&(a=Y(t,e,i),a!=s.xy.NO_DIRECTION)){for(r=e+s.xy.DIRS[a][0],o=i+s.xy.DIRS[a][1],h=!1,n=0;n<10&&t.hasXY(r,o)&&!h;n++)t.isSet(r,o)&&(h=!0),r+=s.xy.DIRS[a][0],o+=s.xy.DIRS[a][1];h||l[a].push([e,i])}let u=[];for(a=0;a<4;a++){const e=t.rng.item(l[a])||[-1,-1];u[a]=[e[0],e[1]]}return u}function U(t,e,i,n={}){if(n.offsetX??=0,n.offsetY??=0,n.machine??=0,s.xy.arcCount(e,i,((e,i)=>t.isPassable(e,i)))<=1)return!1;const r=s.grid.alloc(t.width,t.height);r.set(e,i,1);const o=G(t,r,n);return s.grid.free(r),o}function G(t,e,i={}){i.offsetX??=0,i.offsetY??=0,i.machine??=0;const n=s.grid.alloc(t.width,t.height);let r=!1;if(s.xy.forRect(t.width,t.height,((s,o)=>{const a=s+i.offsetX,h=o+i.offsetY;e.get(a,h)?t.isStairs(s,o)&&(r=!0):!t.isPassable(s,o)||0!=t.getMachine(s,o)&&t.getMachine(s,o)!=i.machine||n.set(s,o,1)})),i.updateWalkable&&!i.updateWalkable(n))return!0;let o=!0;for(let t=0;t<n.width&&!r;++t)for(let e=0;e<n.height&&!r;++e)1==n.get(t,e)&&(o?(n.floodFill(t,e,1,2),o=!1):r=!0);return s.grid.free(n),r}function W(t,e,i=0,n=0){const r=s.grid.alloc(t.width,t.height);let o=0;if(s.xy.forRect(t.width,t.height,((s,a)=>{const h=s+i,l=a+n;e.get(h,l)?t.isStairs(s,a)&&(o=t.width*t.height):t.isPassable(s,a)&&r.set(s,a,1)})),o)return o;let a=!0,h=2,l=t.width*t.height;for(let t=0;t<r.width;++t)for(let e=0;e<r.height;++e)if(1==r.get(t,e)){const i=r.floodFill(t,e,1,h++);l=Math.min(l,i),a?a=!1:o=l}return s.grid.free(r),o}function X(t,e,i,n,r){e.reset(t.width,t.height),e.setGoal(i,n),e.calculate(((e,i)=>t.hasXY(e,i)?t.isPassable(e,i)?s.path.OK:t.blocksDiagonal(e,i)?s.path.OBSTRUCTION:s.path.BLOCKED:s.path.OBSTRUCTION),!1)}function K(t,e){for(let i=0;i<t.width;i++)for(let s=0;s<t.height;s++)t.getMachine(i,s)!=e||t.needsMachine(i,s)||t.setMachine(i,s,0)}function H(t,e=!0){j(t),V(t,e)}function V(t,e){const i=s.grid.alloc(t.width,t.height),n=s.grid.alloc(t.width,t.height);for(let e=0;e<t.width;e++)for(let s=0;s<t.height;s++)t.blocksDiagonal(e,s)?i.set(e,s,2):!t.blocksPathing(e,s)&&!t.blocksMove(e,s)||t.isSecretDoor(e,s)?i.set(e,s,0):i.set(e,s,1);let r;for(let e=1;e<i.width-1;e++)for(let n=1;n<i.height-1;n++)if(t.clearChokepoint(e,n),!i.get(e,n)){if(!t.isInLoop(e,n)){r=0;for(let o=0;o<8;o++){const a=e+s.xy.CLOCK_DIRS[(o+7)%8][0],h=n+s.xy.CLOCK_DIRS[(o+7)%8][1],l=e+s.xy.CLOCK_DIRS[o][0],c=n+s.xy.CLOCK_DIRS[o][1];if((t.hasXY(l,c)&&i.get(l,c)>0)!=(t.hasXY(a,h)&&i.get(a,h)>0)&&++r>2){(i.get(e-1,n)&&i.get(e+1,n)||i.get(e,n-1)&&i.get(e,n+1))&&t.setChokepoint(e,n);break}}}const o=e-1,a=e+1,h=n-1,l=n+1;i.get(e,h)&&i.get(e,l)?i.get(o,n)||i.get(a,n)||i.get(o,h)&&i.get(o,l)&&i.get(a,h)&&i.get(a,l)||t.setGateSite(e,n):i.get(o,n)&&i.get(a,n)&&(i.get(e,h)||i.get(e,l)||i.get(o,h)&&i.get(o,l)&&i.get(a,h)&&i.get(a,l)||t.setGateSite(e,n))}if(e){for(let e=0;e<t.width;e++)for(let i=0;i<t.height;i++)t.setChokeCount(e,i,3e4);for(let e=0;e<t.width;e++)for(let r=0;r<t.height;r++)if(!i.get(e,r)&&t.isChokepoint(e,r))for(let o=0;o<4;o++){const a=e+s.xy.DIRS[o][0],h=r+s.xy.DIRS[o][1];if(t.hasXY(a,h)&&!i.get(a,h)&&!t.isChokepoint(a,h)){n.fill(0),i.set(e,r,1);let s=$(t,n,i,a,h);if(i.set(e,r,0),s>=4){for(let e=0;e<n.width;e++)for(let i=0;i<n.height;i++)n.get(e,i)&&s<t.getChokeCount(e,i)&&t.setChokeCount(e,i,s);s<t.getChokeCount(e,r)&&t.setChokeCount(e,r,s)}}}}s.grid.free(i),s.grid.free(n)}function $(t,e,i,n,r){function o(e,i){let s=1;return t.isAreaMachine(e,i)&&(s=1e4),s}let a=0;const h=[[n,r]],l=[];for(;h.length;){const n=h.pop();l.push(n);const r=n[0],c=n[1];if(!e.get(r,c)){e.set(r,c,1),a+=o(r,c);for(let n=0;n<4;n++){const o=r+s.xy.DIRS[n][0],a=c+s.xy.DIRS[n][1];if(t.hasXY(o,a)&&!i.get(o,a)&&!e.get(o,a)){const t=l.pop()||[-1,-1];t[0]=o,t[1]=a,h.push(t)}}}}return Math.min(a,1e4)}function j(t){z(t),q(t),J(t)}function z(t){s.xy.forRect(t.width,t.height,((e,i)=>{!t.blocksPathing(e,i)&&!t.blocksMove(e,i)||t.isSecretDoor(e,i)?t.setInLoop(e,i):t.clearInLoop(e,i)}))}function q(t){let e,i,n,r,o,a,h,l;const c=s.grid.alloc(t.width,t.height,1);let g=!0;for(;g;)g=!1,c.forEach(((u,f,d)=>{if(u&&(c.set(f,d,0),t.isInLoop(f,d))){for(o=0;o<8&&(i=f+s.xy.CLOCK_DIRS[o][0],n=d+s.xy.CLOCK_DIRS[o][1],!t.hasXY(i,n)||t.isInLoop(i,n));o++);if(8!=o){for(a=h=l=0,e=!1,r=o;r<o+8;r++)if(i=f+s.xy.CLOCK_DIRS[r%8][0],n=d+s.xy.CLOCK_DIRS[r%8][1],t.hasXY(i,n))if(t.isInLoop(i,n)){if(l++,!e&&(a++,e=!0,a>1))break}else e&&(l>h&&(h=l),l=0,e=!1);if(e&&l>h&&(h=l),1==a&&h<=4)for(t.clearInLoop(f,d),r=0;r<8;r++)i=f+s.xy.CLOCK_DIRS[r][0],n=d+s.xy.CLOCK_DIRS[r][1],t.hasXY(i,n)&&t.isInLoop(i,n)&&(c.set(i,n,1),g=!0)}}}))}function Q(t,e){for(let i=0;i<t.width;++i)for(let s=0;s<t.height;++s)(t.isInLoop(i,s)||i>0&&s>0&&t.isInLoop(i,s-1)&&t.isInLoop(i-1,s))&&e.set(i,s,1)}function J(t){const e=s.grid.alloc(t.width,t.height);let i;Q(t,e);for(let n=0;n<e.width;n++)for(let r=0;r<e.height;r++)if(t.isInLoop(n,r)){i=!1;for(let o=0;o<8;o++){let a=n+s.xy.CLOCK_DIRS[o][0],h=r+s.xy.CLOCK_DIRS[o][1];if(t.hasXY(a,h)&&!e.get(a,h)&&!t.isInLoop(a,h)){i=!0;break}}i||(e.set(n,r,1),t.clearInLoop(n,r))}s.grid.free(e)}const Z=s.flag.make(["CHOKEPOINT","GATE_SITE","IN_LOOP","IN_MACHINE","IN_AREA_MACHINE","IMPREGNABLE"]);class tt{constructor(t,e,i={}){this.rng=s.rng.random,this.items=[],this.actors=[],this.depth=0,this.machineCount=0,this.tileFactory=i.tiles||r,this._tiles=s.grid.alloc(t,e),this._doors=s.grid.alloc(t,e),this._flags=s.grid.alloc(t,e),this._machine=s.grid.alloc(t,e),this._chokeCounts=s.grid.alloc(t,e),i.rng&&(this.rng=i.rng)}free(){s.grid.free(this._tiles),s.grid.free(this._doors),s.grid.free(this._flags),s.grid.free(this._machine),s.grid.free(this._chokeCounts)}clear(){this._tiles.fill(0),this._doors.fill(0),this._flags.fill(0),this._machine.fill(0),this._chokeCounts.fill(0),this.machineCount=0}dump(t){if(t)return this._tiles.dump(t);this._tiles.dump((t=>this.tileFactory.getTile(t).ch||"?"))}copy(t){this.depth=t.depth,this.machineCount=t.machineCount,this._tiles.copy(t._tiles),this._doors.copy(t._doors),this._machine.copy(t._machine),this._flags.copy(t._flags),this._chokeCounts.copy(t._chokeCounts),this.rng=t.rng,this.items=t.items.slice(),this.actors=t.actors.slice()}copyTiles(t,e=0,i=0){s.xy.forRect(this.width,this.height,((s,n)=>{const r=s-e,o=n-i,a=t._tiles.get(r,o);a&&this._tiles.set(s,n,a)}))}setSeed(t){this.rng.seed(t)}get width(){return this._tiles.width}get height(){return this._tiles.height}hasXY(t,e){return this._tiles.hasXY(t,e)}isBoundaryXY(t,e){return this._tiles.isBoundaryXY(t,e)}isPassable(t,e){return this.isFloor(t,e)||this.isDoor(t,e)||this.isBridge(t,e)||this.isStairs(t,e)||this.isShallow(t,e)}isNothing(t,e){return this.hasTile(t,e,"NOTHING")}isDiggable(t,e){return this.hasTile(t,e,"NOTHING")||this.hasTile(t,e,"WALL")}isProtected(t,e){return!1}isFloor(t,e){return this.hasTile(t,e,"FLOOR")}isDoor(t,e){return this.hasTile(t,e,"DOOR")}isSecretDoor(t,e){return this.hasTile(t,e,"SECRET_DOOR")}isBridge(t,e){return this.hasTile(t,e,"BRIDGE")}isWall(t,e){return this.blocksMove(t,e)&&this.blocksVision(t,e)}blocksMove(t,e){return this.tileFactory.getTile(this._tiles.get(t,e)).blocksMove||!1}blocksDiagonal(t,e){return this.isNothing(t,e)||this.isWall(t,e)}blocksPathing(t,e){return this.isNothing(t,e)||this.isWall(t,e)||this.isDeep(t,e)||this.isStairs(t,e)}blocksVision(t,e){return this.tileFactory.getTile(this._tiles.get(t,e)).blocksVision||!1}blocksItems(t,e){return this.blocksPathing(t,e)||this.isChokepoint(t,e)||this.isInLoop(t,e)||this.isInMachine(t,e)}blocksEffects(t,e){return this.isWall(t,e)}isStairs(t,e){return this.hasTile(t,e,"UP_STAIRS")||this.hasTile(t,e,"DOWN_STAIRS")}isDeep(t,e){return this.hasTile(t,e,"DEEP")}isShallow(t,e){return this.hasTile(t,e,"SHALLOW")}isAnyLiquid(t,e){return this.isDeep(t,e)||this.isShallow(t,e)}isSet(t,e){return(this._tiles.get(t,e)||0)>0}tileBlocksMove(t){return this.tileFactory.blocksMove(t)}setTile(t,e,i,s={}){return!!this._tiles.hasXY(t,e)&&("string"==typeof i&&(i=this.tileFactory.tileId(i)),this._tiles.set(t,e,i),!0)}clearTile(t,e){this.hasXY(t,e)&&this._tiles.set(t,e,0)}getTile(t,e){const i=this._tiles.get(t,e)||0;return this.tileFactory.getTile(i)}makeImpregnable(t,e){this._flags._data[t][e]|=Z.IMPREGNABLE}isImpregnable(t,e){return!!(this._flags.get(t,e)&Z.IMPREGNABLE)}hasTile(t,e,i){return"string"==typeof i&&(i=this.tileFactory.tileId(i)),this.hasXY(t,e)&&this._tiles.get(t,e)==i}getChokeCount(t,e){return this._chokeCounts.get(t,e)||0}setChokeCount(t,e,i){this._chokeCounts.set(t,e,i)}getFlags(t,e){return this._flags.get(t,e)||0}setChokepoint(t,e){this._flags._data[t][e]|=Z.CHOKEPOINT}isChokepoint(t,e){return!!(this._flags.get(t,e)&Z.CHOKEPOINT)}clearChokepoint(t,e){this._flags._data[t][e]&=~Z.CHOKEPOINT}setGateSite(t,e){this._flags._data[t][e]|=Z.GATE_SITE}isGateSite(t,e){return!!(this._flags.get(t,e)&Z.GATE_SITE)}clearGateSite(t,e){this._flags._data[t][e]&=~Z.GATE_SITE}setInLoop(t,e){this._flags._data[t][e]|=Z.IN_LOOP}isInLoop(t,e){return!!(this._flags.get(t,e)&Z.IN_LOOP)}clearInLoop(t,e){this._flags._data[t][e]&=~Z.IN_LOOP}analyze(t=!0){H(this,t)}snapshot(){const t=new tt(this.width,this.height);return t.copy(this),t}restore(t){this.copy(t)}nextMachineId(){return this.machineCount+=1,this.machineCount}setMachine(t,e,i,s){this._machine.set(t,e,i);const n=s?Z.IN_MACHINE:Z.IN_AREA_MACHINE;this._flags._data[t][e]|=n}isAreaMachine(t,e){return!!(this._machine.get(t,e)&Z.IN_AREA_MACHINE)}isInMachine(t,e){return this._machine.get(t,e)>0}getMachine(t,e){return this._machine.get(t,e)||0}needsMachine(t,e){return!1}updateDoorDirs(){this._doors.update(((t,e,i)=>Y(this,e,i)))}getDoorDir(t,e){return this._doors.get(t,e)||0}isOccupied(t,e){return this.hasActor(t,e)||this.hasItem(t,e)}canSpawnActor(t,e,i){return this.isFloor(t,e)}eachActor(t){this.actors.forEach(t)}addActor(t,e,i){return i.x=t,i.y=e,this.actors.push(i),this.actors.length}getActor(t){return this.actors[t]}forbidsActor(t,e,i){return!this.isFloor(t,e)}hasActor(t,e){return this.actors.some((i=>i.x===t&&i.y===e))}eachItem(t){this.items.forEach(t)}addItem(t,e,i){return i.x=t,i.y=e,this.items.push(i),this.items.length}getItem(t){return this.items[t]}forbidsItem(t,e,i){return!this.isFloor(t,e)}hasItem(t,e){return this.items.some((i=>i.x===t&&i.y===e))}}class et{onDigFirstRoom(){}onRoomCandidate(){}onRoomFailed(){}onRoomSuccess(){}onLoopsAdded(){}onLakesAdded(){}onBridgesAdded(){}onStairsAdded(){}onBuildError(){}onBlueprintPick(){}onBlueprintCandidates(){}onBlueprintStart(){}onBlueprintInterior(){}onBlueprintFail(){}onBlueprintSuccess(){}onStepStart(){}onStepCandidates(){}onStepInstanceSuccess(){}onStepInstanceFail(){}onStepSuccess(){}onStepFail(){}}const it=s.flag.fl;var st,nt;!function(t){t[t.BS_OUTSOURCE_ITEM_TO_MACHINE=it(1)]="BS_OUTSOURCE_ITEM_TO_MACHINE",t[t.BS_BUILD_VESTIBULE=it(2)]="BS_BUILD_VESTIBULE",t[t.BS_ADOPT_ITEM=it(3)]="BS_ADOPT_ITEM",t[t.BS_BUILD_AT_ORIGIN=it(4)]="BS_BUILD_AT_ORIGIN",t[t.BS_PERMIT_BLOCKING=it(5)]="BS_PERMIT_BLOCKING",t[t.BS_TREAT_AS_BLOCKING=it(6)]="BS_TREAT_AS_BLOCKING",t[t.BS_NEAR_ORIGIN=it(7)]="BS_NEAR_ORIGIN",t[t.BS_FAR_FROM_ORIGIN=it(8)]="BS_FAR_FROM_ORIGIN",t[t.BS_IN_VIEW_OF_ORIGIN=it(9)]="BS_IN_VIEW_OF_ORIGIN",t[t.BS_IN_PASSABLE_VIEW_OF_ORIGIN=it(10)]="BS_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BS_HORDE_TAKES_ITEM=it(11)]="BS_HORDE_TAKES_ITEM",t[t.BS_HORDE_SLEEPING=it(12)]="BS_HORDE_SLEEPING",t[t.BS_HORDE_FLEEING=it(13)]="BS_HORDE_FLEEING",t[t.BS_HORDES_DORMANT=it(14)]="BS_HORDES_DORMANT",t[t.BS_ITEM_IS_KEY=it(15)]="BS_ITEM_IS_KEY",t[t.BS_ITEM_IDENTIFIED=it(16)]="BS_ITEM_IDENTIFIED",t[t.BS_ITEM_PLAYER_AVOIDS=it(17)]="BS_ITEM_PLAYER_AVOIDS",t[t.BS_EVERYWHERE=it(18)]="BS_EVERYWHERE",t[t.BS_ALTERNATIVE=it(19)]="BS_ALTERNATIVE",t[t.BS_ALTERNATIVE_2=it(20)]="BS_ALTERNATIVE_2",t[t.BS_BUILD_IN_WALLS=it(21)]="BS_BUILD_IN_WALLS",t[t.BS_BUILD_ANYWHERE_ON_LEVEL=it(22)]="BS_BUILD_ANYWHERE_ON_LEVEL",t[t.BS_REPEAT_UNTIL_NO_PROGRESS=it(23)]="BS_REPEAT_UNTIL_NO_PROGRESS",t[t.BS_IMPREGNABLE=it(24)]="BS_IMPREGNABLE",t[t.BS_NO_BLOCK_ORIGIN=it(25)]="BS_NO_BLOCK_ORIGIN",t[t.BS_NOT_IN_HALLWAY=it(27)]="BS_NOT_IN_HALLWAY",t[t.BS_ALLOW_BOUNDARY=it(28)]="BS_ALLOW_BOUNDARY",t[t.BS_SKELETON_KEY=it(29)]="BS_SKELETON_KEY",t[t.BS_KEY_DISPOSABLE=it(30)]="BS_KEY_DISPOSABLE"}(st||(st={}));class rt{constructor(t={}){if(this.tile=null,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.feature=null,this.chance=0,this.index=-1,this.tile=t.tile||null,t.flags&&(this.flags=s.flag.from(st,t.flags)),t.pad&&(this.pad=t.pad),this.count=s.range.make(t.count||1),"string"==typeof t.item?this.item={tags:t.item}:t.item?(this.item=Object.assign({tags:""},t.item),this.item.feature&&(this.item.feature=f(this.item.feature))):this.item=null,t.horde?!0===t.horde?this.horde={tags:""}:"string"==typeof t.horde?this.horde={tags:t.horde}:(this.horde=Object.assign({tags:""},t.horde),this.horde.feature&&(this.horde.feature=f(this.horde.feature))):this.horde=null,t.feature?this.feature=f(t.feature):this.feature=null,this.item&&this.flags&st.BS_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BS_ADOPT_ITEM.");if(this.buildAtOrigin&&this.count.hi>1)throw new Error("Cannot have count > 1 for step with BS_BUILD_AT_ORIGIN.");if(this.buildAtOrigin&&this.repeatUntilNoProgress)throw new Error("Cannot have BS_BUILD_AT_ORIGIN and BS_REPEAT_UNTIL_NO_PROGRESS together in a build step.");if(this.hordeTakesItem&&!this.horde)throw new Error("Cannot have BS_HORDE_TAKES_ITEM without a horde configured.")}get allowBoundary(){return!!(this.flags&st.BS_ALLOW_BOUNDARY)}get notInHallway(){return!!(this.flags&st.BS_NOT_IN_HALLWAY)}get buildInWalls(){return!!(this.flags&st.BS_BUILD_IN_WALLS)}get buildAnywhere(){return!!(this.flags&st.BS_BUILD_ANYWHERE_ON_LEVEL)}get repeatUntilNoProgress(){return!!(this.flags&st.BS_REPEAT_UNTIL_NO_PROGRESS)}get permitBlocking(){return!!(this.flags&st.BS_PERMIT_BLOCKING)}get treatAsBlocking(){return!!(this.flags&(st.BS_TREAT_AS_BLOCKING|st.BS_NO_BLOCK_ORIGIN))}get noBlockOrigin(){return!!(this.flags&st.BS_NO_BLOCK_ORIGIN)}get adoptItem(){return!!(this.flags&st.BS_ADOPT_ITEM)}get itemIsKey(){return!!(this.flags&st.BS_ITEM_IS_KEY)}get keyIsDisposable(){return!!(this.flags&st.BS_KEY_DISPOSABLE)}get outsourceItem(){return!!(this.flags&st.BS_OUTSOURCE_ITEM_TO_MACHINE)}get impregnable(){return!!(this.flags&st.BS_IMPREGNABLE)}get buildVestibule(){return!!(this.flags&st.BS_BUILD_VESTIBULE)}get hordeTakesItem(){return!!(this.flags&st.BS_HORDE_TAKES_ITEM)}get generateEverywhere(){return!!(this.flags&st.BS_EVERYWHERE&~st.BS_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&st.BS_BUILD_AT_ORIGIN)}get buildsInstances(){return!!(this.feature||this.tile||this.item||this.horde||this.adoptItem)}markCandidates(t,e,i=[0,1e4]){ot(t,this);const s=t.blueprint;let n=0;return e.update(((e,r,o)=>{const a=ht(t,s,this,r,o,i);return a===nt.OK&&n++,a})),n}makePersonalSpace(t,e,i,s){let n=0;if(this.pad<1)return 0;for(let t=e-this.pad;t<=e+this.pad;t++)for(let e=i-this.pad;e<=i+this.pad;e++)s.hasXY(t,e)&&1==s.get(t,e)&&(s.set(t,e,0),++n);return n}toString(){let t=[];return this.tile&&t.push("tile: "+this.tile),this.feature&&t.push("effect: "+JSON.stringify(this.feature)),this.item&&t.push("item: "+JSON.stringify(this.item)),this.horde&&t.push("horde: "+JSON.stringify(this.horde)),this.pad>1&&t.push("pad: "+this.pad),(this.count.lo>1||this.count.hi>1)&&t.push("count: "+this.count.toString()),this.chance&&t.push("chance: "+this.chance),this.flags&&t.push("flags: "+s.flag.toString(st,this.flags)),"{ "+t.join(", ")+" }"}}function ot(t,e){if(e.flags&(st.BS_IN_VIEW_OF_ORIGIN|st.BS_IN_PASSABLE_VIEW_OF_ORIGIN)){const i=t.site;if(e.flags&st.BS_IN_PASSABLE_VIEW_OF_ORIGIN){new s.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e)||i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap.set(e,i,1)}))}else{new s.fov.FOV({isBlocked:(t,e)=>i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap.set(e,i,1)}))}t.viewMap.set(t.originX,t.originY,1)}}function at(t,e){const i=[0,1e4];return e.flags&st.BS_NEAR_ORIGIN&&(i[1]=t.distance25),e.flags&st.BS_FAR_FROM_ORIGIN&&(i[0]=t.distance75),i}function ht(t,e,i,n,r,o){const a=t.site;if(i.notInHallway&&s.xy.arcCount(n,r,((t,e)=>a.hasXY(t,e)&&a.isPassable(t,e)))>1)return nt.IN_HALLWAY;if((0==n||n==a.width-1||0==r||r==a.height-1)&&!i.allowBoundary)return nt.ON_BOUNDARY;if(i.buildAtOrigin)return n==t.originX&&r==t.originY?nt.OK:nt.MUST_BE_ORIGIN;if(e.isRoom&&n==t.originX&&r==t.originY)return nt.NOT_ORIGIN;if(t.occupied.get(n,r))return nt.OCCUPIED;if(i.flags&(st.BS_IN_VIEW_OF_ORIGIN|st.BS_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap.get(n,r))return nt.NOT_IN_VIEW;let h=1e4;if(a.isWall(n,r)?s.xy.eachNeighbor(n,r,((e,i)=>{t.distanceMap.hasXY(e,i)&&!a.blocksPathing(e,i)&&h>t.distanceMap.getDistance(e,i)+1&&(h=t.distanceMap.getDistance(e,i)+1)}),!0):h=t.distanceMap.getDistance(n,r),h>o[1])return nt.TOO_FAR;if(h<o[0])return nt.TOO_CLOSE;if(i.buildInWalls){const e=a.getMachine(n,r);if(!t.interior.get(n,r)&&(!e||e==t.machineNumber)&&a.isWall(n,r)){let e=!1,o=!1;return s.xy.eachNeighbor(n,r,((n,r)=>{if(o)return;if(!a.hasXY(n,r))return;if(!t.interior.get(n,r)&&!i.buildAnywhere)return;const h=a.getMachine(n,r);a.blocksPathing(n,r)||h&&h!=t.machineNumber||n==t.originX&&r==t.originY||(i.notInHallway&&s.xy.arcCount(n,r,((t,e)=>a.hasXY(t,e)&&a.isPassable(t,e)))>1?(o=!0,e=!1):e=!0)}),!0),e?nt.OK:nt.INVALID_WALL}return nt.NOT_CANDIDATE}return a.isWall(n,r)?nt.INVALID_WALL:i.buildAnywhere?i.item&&a.blocksItems(n,r)?nt.BLOCKED:nt.OK:t.interior.get(n,r)?nt.OK:nt.FAILED}!function(t){t[t.NOT_CANDIDATE=0]="NOT_CANDIDATE",t[t.OK=1]="OK",t[t.IN_HALLWAY=2]="IN_HALLWAY",t[t.ON_BOUNDARY=3]="ON_BOUNDARY",t[t.MUST_BE_ORIGIN=4]="MUST_BE_ORIGIN",t[t.NOT_ORIGIN=5]="NOT_ORIGIN",t[t.OCCUPIED=6]="OCCUPIED",t[t.NOT_IN_VIEW=7]="NOT_IN_VIEW",t[t.TOO_FAR=8]="TOO_FAR",t[t.TOO_CLOSE=9]="TOO_CLOSE",t[t.INVALID_WALL=10]="INVALID_WALL",t[t.BLOCKED=11]="BLOCKED",t[t.FAILED=12]="FAILED"}(nt||(nt={}));class lt{onDigFirstRoom(t){console.group("dig first room"),t.dump(),console.groupEnd()}onRoomCandidate(t,e){console.group("room candidate: "+t.toString()),e.dump(),console.groupEnd()}onRoomFailed(t,e,i,s){console.log("Room Failed - ",s)}onRoomSuccess(t,e){console.group("Added Room - "+e.toString()),t.dump(),console.groupEnd()}onLoopsAdded(t){console.log("loops added")}onLakesAdded(t){console.log("lakes added")}onBridgesAdded(t){console.log("bridges added")}onStairsAdded(t){console.log("stairs added")}onBuildError(t){console.log(`onBuildError - error: ${t}`)}onBlueprintPick(t,e,i){console.log(`onBlueprintPick - ${t.blueprint.id}, depth = ${i}, matchingFlags = ${s.flag.toString(st,e)}`)}onBlueprintCandidates(t){const e=`onBlueprintCandidates - ${t.blueprint.id}`;console.group(e),t.candidates.dump(),console.groupEnd()}onBlueprintStart(t){console.group(`onBlueprintStart - ${t.blueprint.id} @ ${t.originX},${t.originY} : stepCount: ${t.blueprint.steps.length}, size: [${t.blueprint.size.toString()}], flags: ${s.flag.toString(st,t.blueprint.flags)}`)}onBlueprintInterior(t){console.group(`onBlueprintInterior - ${t.blueprint.id}`),t.interior.dump(),console.groupEnd()}onBlueprintFail(t,e){console.log(`onBlueprintFail - ${t.blueprint.id} @ ${t.originX},${t.originY} : error: ${e}`),console.groupEnd()}onBlueprintSuccess(t){console.log(`onBlueprintSuccess - ${t.blueprint.id} @ ${t.originX},${t.originY}`),console.groupEnd()}onStepStart(t,e){console.group(`onStepStart - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${s.flag.toString(st,e.flags)}`),console.log(e.toString())}onStepCandidates(t,e,i,s){const n=i.count((t=>1==t));console.log(`onStepCandidates - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : wantCount: ${s}, have: ${n}`),i.dump(),0==n&&(console.log("No candidates - check interior"),t.interior.dump())}onStepInstanceSuccess(t,e,i,s){console.log(`onStepInstance @ ${i},${s}`)}onStepInstanceFail(t,e,i,s,n){console.log(`onStepInstanceFail @ ${i},${s} - error: ${n}`)}onStepSuccess(t,e){console.log(`onStepSuccess - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${s.flag.toString(st,e.flags)}`),console.groupEnd()}onStepFail(t,e,i){console.log(`onStepFail - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : error : ${i}`),console.groupEnd()}}var ct=Object.freeze({__proto__:null,NullLogger:et,ConsoleLogger:lt}),gt=Object.freeze({__proto__:null,log:ct,TileFactory:n,tileFactory:r,installTile:function(...t){return 1==t.length?r.install(t[0]):r.install(t[0],t[1])},getTile:o,tileId:a,blocksMove:function(t){return r.blocksMove(t)},hordes:N,installHorde:function(t){const e={};return e.id=t.id||t.leader,e.leader=t.leader,e.make=t.make||{},e.members={},t.members&&Object.entries(t.members).forEach((([t,i])=>{let n={};"object"==typeof i&&("count"in i||"make"in i)?(n.count=s.range.make(i.count||1),n.make=i.make||{}):n.count=s.range.make(i),e.members[t]=n})),e.tags=[],t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[:|,]/g).map((t=>t.trim()))),e.tags=t.tags),e.frequency=s.frequency.make(t.frequency),e.flags=0,e.requiredTile=t.requiredTile||null,e.feature=t.feature?f(t.feature):null,e.blueprint=t.blueprint||null,N.push(e),e},pickHorde:C,spawnHorde:D,items:k,installItem:function(t,e){const i={};if("string"==typeof t){if(i.id=t,!e)throw new Error("Need a configuration.");t=e}else i.id=t.id;return i.make=t.make||{},i.tags=[],t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[:|,]/g).map((t=>t.trim()))),i.tags=t.tags),i.frequency=s.frequency.make(t.frequency||100),i.flags=0,i.requiredTile=t.requiredTile||null,i.feature=t.feature||null,i.blueprint=t.blueprint||null,k.push(i),i},pickItem:x,makeItem:P,getItemInfo:function(t){return k.find((e=>e.id===t))},Flags:Z,Site:tt,loadSite:function(t,e,i){const s=t.width,n=t.height;e.forEach(((e,r)=>{if(!(r>=n))for(let n=0;n<s&&n<e.length;++n){const s=e[n],o=i[s]||"FLOOR";t.setTile(n,r,o)}}))},directionOfDoorSite:Y,chooseRandomDoorSites:v,fillCostGrid:function(t,e){e.update(((e,i,n)=>t.isPassable(i,n)?1:s.path.OBSTRUCTION))},siteDisruptedByXY:U,siteDisruptedBy:G,siteDisruptedSize:W,computeDistanceMap:X,clearInteriorFlag:K,analyze:H,updateChokepoints:V,floodFillCount:$,updateLoopiness:j,resetLoopiness:z,checkLoopiness:q,fillInnerLoopGrid:Q,cleanLoopiness:J});class ut extends s.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[]}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))}))}}function ft(t,e,i,n=1){const r=s.xy.DIRS[e],o=Math.min(t[0],t[0]+r[0]*(i-1)),a=Math.min(t[1],t[1]+r[1]*(i-1)),h=Math.abs(r[0]*i)||n,l=Math.abs(r[1]*i)||n;return new ut(o,a,h,l)}class dt extends s.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))})),this.hall&&this.hall.translate(t,e)}}function _t(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,i])=>{let n=t[e];if("tile"===e)return void(void 0===n&&(t[e]=i));if(!0===i){if(!n)throw new Error("Missing required config for room digger: "+e)}else n=("number"==typeof i||Array.isArray(i),n||i);const r=s.range.make(n);t[e]=r})),t}class pt{constructor(t,e={}){this.options={},this.doors=[],this._setOptions(t,e)}_setOptions(t,e={}){this.options=_t(t,e)}create(t){const e=this.carve(t);return e&&(e.doors&&0!=e.doors.length&&!e.doors.every((t=>!t||-1==t[0]))||(e.doors=v(t))),e}}var It={};class Et extends pt{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const i=t.choices||e.choices;if(Array.isArray(i))this.randomRoom=t=>t.item(i);else{if("object"!=typeof i)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=t=>t.weighted(i)}}carve(t){let e=this.randomRoom(t.rng);const i=It[e];return i||s.ERROR("Missing room digger choice: "+e),i.create(t)}}class mt extends pt{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),n=this.options.tile||"FLOOR",r=s.grid.alloc(t.width,t.height,0),o=Math.floor(.5*e),a=e,h=Math.floor(.5*i),l=i,c=new s.blob.Blob({rng:t.rng,rounds:5,minWidth:o,minHeight:h,maxWidth:a,maxHeight:l,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(r.width,r.height,((t,e)=>r.set(t,e,1))),g=Math.floor((t.width-c.width)/2),u=g-c.x,f=Math.floor((t.height-c.height)/2),d=f-c.y;return r.forEach(((e,i,s)=>{e&&t.setTile(i+u,s+d,n)})),s.grid.free(r),new dt(g,f,c.width,c.height)}}class Ot extends pt{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),n=this.options.tile||"FLOOR",r=Math.floor(.4*e),o=i,a=e,h=Math.floor(.5*i),l=Math.floor(t.width/2-r/2-1),c=t.height-o-2,g=Math.floor(t.width/2-a/2-1),u=t.height-h-2;s.xy.forRect(l,c,r,o,((e,i)=>t.setTile(e,i,n))),s.xy.forRect(g,u,a,h,((e,i)=>t.setTile(e,i,n)));const f=new dt(Math.min(l,g),Math.min(c,u),Math.max(r,a),Math.max(o,h));return f.doors[s.xy.DOWN]=[Math.floor(t.width/2),t.height-2],f}}class St extends pt{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),n=this.options.tile||"FLOOR",r=e,o=Math.max(3,Math.floor(e*t.rng.range(25,75)/100)),a=Math.max(3,Math.floor(i*t.rng.range(25,75)/100)),h=i,l=Math.floor((t.width-r)/2),c=l+t.rng.range(2,Math.max(2,r-o-2)),g=Math.floor((t.height-h)/2),u=g+t.rng.range(2,Math.max(2,h-a-2));return s.xy.forRect(l,u,r,a,((e,i)=>t.setTile(e,i,n))),s.xy.forRect(c,g,o,h,((e,i)=>t.setTile(e,i,n))),new dt(l,g,Math.max(r,o),Math.max(a,h))}}class Rt extends pt{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),n=this.options.tile||"FLOOR";let r=Math.max(3,Math.floor(e*t.rng.range(25,50)/100)),o=Math.max(3,Math.floor(i*t.rng.range(25,50)/100));const a=Math.floor((t.width-e)/2),h=Math.floor((t.height-o)/2);s.xy.forRect(a,h,e,o,((e,i)=>t.setTile(e,i,n)));const l=Math.floor((t.width-r)/2),c=Math.floor((t.height-i)/2);return s.xy.forRect(l,c,r,i,((e,i)=>t.setTile(e,i,n))),new dt(Math.min(a,l),Math.min(h,c),Math.max(e,r),Math.max(i,o))}}class Lt extends pt{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),n=this.options.tile||"FLOOR",r=Math.floor((t.width-e)/2),o=Math.floor((t.height-i)/2);return s.xy.forRect(r,o,e,i,((e,i)=>t.setTile(e,i,n))),new dt(r,o,e,i)}}class bt extends pt{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(t.rng),i=this.options.tile||"FLOOR",n=Math.floor(t.width/2),r=Math.floor(t.height/2);return e>1&&s.xy.forCircle(n,r,e,((e,s)=>t.setTile(e,s,i))),new dt(n-e,r-e,2*e+1,2*e+1)}}class yt extends pt{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(t.rng),i=this.options.ringMinWidth.value(t.rng),n=this.options.holeMinSize.value(t.rng),r=this.options.tile||"FLOOR",o=Math.floor(t.width/2),a=Math.floor(t.height/2);return s.xy.forCircle(o,a,e,((e,i)=>t.setTile(e,i,r))),e>i+n&&t.rng.chance(this.options.holeChance.value(t.rng))&&s.xy.forCircle(o,a,t.rng.range(n,e-n),((e,i)=>t.clearTile(e,i))),new dt(o-e,a-e,2*e+1,2*e+1)}}class At extends pt{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,i,n,r=this.options.count.value(t.rng);const o=this.options.width.value(t.rng),a=this.options.height.value(t.rng),h=this.options.tile||"FLOOR",l=Math.floor(t.width/2)-Math.floor(o/2),c=Math.floor(t.width/2)+Math.floor(o/2),g=Math.floor(t.height/2)-Math.floor(a/2),u=Math.floor(t.height/2)+Math.floor(a/2);let f=Math.floor(t.width/2),d=f,_=Math.floor(t.height/2),p=_;for(s.xy.forCircle(f,_,2,((e,i)=>t.setTile(e,i,h))),f-=2,d+=2,_-=2,p+=2,e=0;e<r;)if(i=t.rng.range(l,c),n=t.rng.range(g,u),t.isSet(i,n)){if(i-2<l)continue;if(i+2>c)continue;if(n-2<g)continue;if(n+2>u)continue;f=Math.min(i-2,f),d=Math.max(i+2,d),_=Math.min(n-2,_),p=Math.max(n+2,p),s.xy.forCircle(i,n,2,((e,i)=>t.setTile(e,i,h))),e++}return new dt(f,_,d-f+1,p-_+1)}}function Tt(t,e){return It[t]=e,e}Tt("DEFAULT",new Lt);var Bt=Object.freeze({__proto__:null,checkConfig:_t,RoomDigger:pt,rooms:It,ChoiceRoom:Et,choiceRoom:function(t,e){return new Et(t).create(e)},Cavern:mt,cavern:function(t,e){return new mt(t).create(e)},BrogueEntrance:Ot,brogueEntrance:function(t,e){return new Ot(t).create(e)},Cross:St,cross:function(t,e){return new St(t).create(e)},SymmetricalCross:Rt,symmetricalCross:function(t,e){return new Rt(t).create(e)},Rectangular:Lt,rectangular:function(t,e){return new Lt(t).create(e)},Circular:bt,circular:function(t,e){return new bt(t).create(e)},BrogueDonut:yt,brogueDonut:function(t,e){return new yt(t).create(e)},ChunkyRoom:At,chunkyRoom:function(t,e){return new At(t).create(e)},install:Tt});const wt=s.xy.DIRS;function Nt(t,e,i){if(!t.hasXY(e[0],e[1]))return!1;if(!t.isDiggable(e[0],e[1]))return!1;const s=[e[0]-i[0],e[1]-i[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function Ct(t,e){return s.utils.clamp(function(t,e){if(!t)return 1;if("number"==typeof t)return t;if(e=e??s.rng.random,Array.isArray(t))t=e.weighted(t)+1;else if("string"==typeof t)t=s.range.make(t).value(e);else if(t instanceof s.range.Range)t=t.value(e);else{const i=t;t=Number.parseInt(e.weighted(i))}return t}(t,e),1,3)}function Dt(t,e,i){return t==s.xy.UP||t==s.xy.DOWN?e[1].value(i):e[0].value(i)}function Mt(t,e,i){let n=s.xy.NO_DIRECTION;if(n==s.xy.NO_DIRECTION){const r=t.rng.sequence(4);for(let o=0;o<4;o++){n=r[o];const a=i[(o+1)%2].hi,h=e[n];if(h&&-1!=h[0]&&-1!=h[1]){const e=h[0]+Math.floor(wt[n][0]*a),i=h[1]+Math.floor(wt[n][1]*a);if(t.hasXY(e,i))break}n=s.xy.NO_DIRECTION}}return n}function kt(t,e,i,s,n){let r,o;const a=t.rng.chance(n),h=[];for(let n=0;n<4;n++)r=e+wt[n][0],o=i+wt[n][1],n!=s&&!a||!t.hasXY(r,o)||t.isSet(r,o)||(h[n]=[r,o]);return h}class xt{constructor(t={}){this.config={width:1,length:[s.range.make("2-15"),s.range.make("2-9")],tile:"FLOOR",obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=t.width),t.length&&"number"==typeof t.length){const e=s.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,e=[]){if(e=e||v(t),!t.rng.chance(this.config.chance))return null;const i=Mt(t,e,this.config.length);if(i===s.xy.NO_DIRECTION)return null;if(!e[i])return null;const n=Ct(this.config.width,t.rng),r=Dt(i,this.config.length,t.rng),o=e[i];return 1==n?this.dig(t,i,o,r):this.digWide(t,i,o,r,n)}_digLine(t,e,i,s){let n=e[0],r=e[1];const o=this.config.tile;for(let e=0;e<s;e++)t.setTile(n,r,o),n+=i[0],r+=i[1];return n-=i[0],r-=i[1],[n,r]}dig(t,e,i,s){const n=wt[e],[r,o]=this._digLine(t,i,n,s),a=ft(i,e,s);return a.doors=kt(t,r,o,e,this.config.obliqueChance),a}digWide(t,e,i,n,r){const o=s.xy.DIRS[e],a=[i[0]-o[1],i[1]-o[0]],h=[i[0]+o[1],i[1]+o[0]];this._digLine(t,i,o,n);let l=1,c=i[0],g=i[1];l<r&&Nt(t,a,o)&&(this._digLine(t,a,o,n),c=Math.min(a[0],c),g=Math.min(a[1],g),++l),l<r&&Nt(t,h,o)&&(this._digLine(t,h,o,n),c=Math.min(h[0],c),g=Math.min(h[1],g),++l);const u=ft([c,g],e,n,r);return u.doors=[],u.doors[e]=[i[0]+n*o[0],i[1]+n*o[1]],u}}function Pt(t,e,i){return new xt(t).create(e,i)}var Ft={};function Yt(t,e){return Ft[t]=e,e}Yt("DEFAULT",new xt({chance:15}));var vt=Object.freeze({__proto__:null,isDoorLoc:Nt,pickWidth:Ct,pickLength:Dt,pickHallDirection:Mt,pickHallExits:kt,HallDigger:xt,dig:Pt,halls:Ft,install:Yt});class Ut{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:"SHALLOW",wreathChance:50,wreathSize:1,tile:"DEEP"},s.object.assignObject(this.options,t)}create(t){let e,i,n,r,o,a,h,l,c,g,u,f=0;a=this.options.height||15,h=this.options.width||30,l=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,u=this.options.canDisrupt||!1;const d=!!t.rng.chance(this.options.wreathChance),_=this.options.wreathTile||"SHALLOW",p=this.options.wreathSize||1,I=this.options.tile||"DEEP",E=s.grid.alloc(t.width,t.height,0);let m=0;for(;m<g&&f<g;){const O=Math.round((h-l)*(g-m)/g)+l,S=Math.round((a-l)*(g-m)/g)+l,R=new s.blob.Blob({rng:t.rng,rounds:5,minWidth:4,minHeight:4,maxWidth:O,maxHeight:S,percentSeeded:55});E.fill(0);const L=R.carve(E.width,E.height,((t,e)=>E.set(t,e,1)));let b=!1;for(n=0;n<c&&!b;n++)if(r=t.rng.range(1-L.x,E.width-L.width-L.x-2),o=t.rng.range(1-L.y,E.height-L.height-L.y-2),u||!this.isDisruptedBy(t,E,-r,-o)){for(b=!0,e=0;e<L.width;e++)for(i=0;i<L.height;i++)if(E.get(e+L.x,i+L.y)){const n=e+L.x+r,a=i+L.y+o;t.setTile(n,a,I),d&&s.xy.forCircle(n,a,p,((e,i)=>{t.isPassable(e,i)&&!E.get(e-r,i-o)&&t.setTile(e,i,_)}))}break}b?(++f,m=0):++m}return s.grid.free(E),f}isDisruptedBy(t,e,i=0,n=0){const r=s.grid.alloc(t.width,t.height);let o=!1;s.xy.forRect(t.width,t.height,((s,a)=>{const h=s+i,l=a+n;e.get(h,l)?t.isStairs(s,a)&&(o=!0):t.isPassable(s,a)&&r.set(s,a,1)}));let a=!0;for(let t=0;t<r.width&&!o;++t)for(let e=0;e<r.height&&!o;++e)1==r.get(t,e)&&(a?(r.floodFill(t,e,1,2),a=!1):o=!0);return s.grid.free(r),o}}var Gt=Object.freeze({__proto__:null,Lakes:Ut});class Wt{constructor(t={}){this.options={minDistance:20,maxLength:5},s.object.assignObject(this.options,t)}create(t){let e,i,n,r,o,a,h,l=0;const c=this.options.maxLength,g=this.options.minDistance,u=new s.path.DijkstraMap,f=[[1,0],[0,1]],d=t.rng.sequence(t.width*t.height);for(n=0;n<d.length;n++)if(a=Math.floor(d[n]/t.height),h=d[n]%t.height,t.isPassable(a,h)&&(t.isBridge(a,h)||!t.isAnyLiquid(a,h)))for(o=0;o<=1;o++){const n=f[o];if(e=a+n[0],i=h+n[1],r=c,t.isAnyLiquid(e,i)&&!t.isBridge(e,i))for(r=0;r<c&&(e+=n[0],i+=n[1],!t.isBridge(e,i)&&t.isAnyLiquid(e,i));++r);if(t.isPassable(e,i)&&r<c&&(X(t,u,e,i),u.getDistance(a,h)>g&&u.getDistance(a,h)<s.path.BLOCKED)){for(;a!==e||h!==i;)this.isBridgeCandidate(t,a,h,n)?t.setTile(a,h,"BRIDGE"):t.setTile(a,h,"FLOOR"),a+=n[0],h+=n[1];++l;break}}return l}isBridgeCandidate(t,e,i,s){return!!t.isBridge(e,i)||!!t.isAnyLiquid(e,i)}}var Xt=Object.freeze({__proto__:null,Bridges:Wt});class Kt{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:"UP_STAIRS",downTile:"DOWN_STAIRS",wall:"IMPREGNABLE"},s.object.assignObject(this.options,t)}create(t){let e=!1!==this.options.up,i=!1!==this.options.down;const n=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),r={};let o=null,a=null;const h=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?t.rng.matchingLoc(t.width,t.height,h):t.rng.matchingLocNear(s.xy.x(e),s.xy.y(e),h),r.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const e=this.options.up;o=t.rng.matchingLocNear(s.xy.x(e),s.xy.y(e),h);const i=this.options.down;a=t.rng.matchingLocNear(s.xy.x(i),s.xy.y(i),h)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;o=t.rng.matchingLocNear(s.xy.x(e),s.xy.y(e),h),i&&(a=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(s.xy.distanceBetween(t,e,o[0],o[1])<n)&&h(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const i=this.options.down;a=t.rng.matchingLocNear(s.xy.x(i),s.xy.y(i),h),e&&(o=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(s.xy.distanceBetween(t,e,a[0],a[1])<n)&&h(t,e))))}else e?(o=t.rng.matchingLoc(t.width,t.height,h),i&&(a=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(s.xy.distanceBetween(t,e,o[0],o[1])<n)&&h(t,e))))):i&&(a=t.rng.matchingLoc(t.width,t.height,h));return o&&(r.up=o.slice(),this.setupStairs(t,o[0],o[1],this.options.upTile,this.options.wall),"up"===this.options.start?r.start=r.up:r.end=r.up),a&&(r.down=a.slice(),this.setupStairs(t,a[0],a[1],this.options.downTile,this.options.wall),"down"===this.options.start?r.start=r.down:r.end=r.down),o||a?r:null}hasXY(t,e,i){return!(e<0||i<0)&&!(e>=t.width||i>=t.height)}isStairXY(t,e,i){let n=0;if(!this.hasXY(t,e,i)||!t.isDiggable(e,i))return!1;for(let r=0;r<4;++r){const o=s.xy.DIRS[r];if(!this.hasXY(t,e+o[0],i+o[1]))return!1;if(!this.hasXY(t,e-o[0],i-o[1]))return!1;if(t.isFloor(e+o[0],i+o[1])){if(n+=1,!t.isDiggable(e-o[0]+o[1],i-o[1]+o[0]))return!1;if(!t.isDiggable(e-o[0]-o[1],i-o[1]-o[0]))return!1}else if(!t.isDiggable(e+o[0],i+o[1]))return!1}return 1==n}setupStairs(t,e,i,n,r){const o=t.rng.sequence(4);let a=null;for(let n=0;n<o.length;++n){a=s.xy.DIRS[n];const r=e+a[0],o=i+a[1];if(t.isFloor(r,o)&&t.isDiggable(e-a[0],i-a[1]))break;a=null}a||s.ERROR("No stair direction found!"),t.setTile(e,i,n);const h=s.xy.CLOCK_DIRS.findIndex((t=>t[0]==a[0]&&t[1]==a[1]));for(let n=0;n<s.xy.CLOCK_DIRS.length;++n){const o=n?n-1:7,a=(n+1)%8;if(n==h||o==h||a==h)continue;const l=s.xy.CLOCK_DIRS[n];t.setTile(e+l[0],i+l[1],r)}return!0}}var Ht=Object.freeze({__proto__:null,Stairs:Kt});class Vt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},s.object.assignObject(this.options,t)}create(t){let e,i,n,r,o,a,h,l,c;const g=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),u=this.options.maxLength,f=new s.path.DijkstraMap,d=[[1,0],[0,1]];function _(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!t.isSet(e,i)&&(!t.isSet(e+s[1],i+s[0])&&!t.isSet(e-s[1],i-s[0])))))}function p(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!!t.isSet(e,i)||(!!t.isSet(e+s[1],i+s[0])||!!t.isSet(e-s[1],i-s[0])))))}let I=0;const E=t.rng.sequence(t.width*t.height);for(o=0;o<E.length;o++)if(l=Math.floor(E[o]/t.height),c=E[o]%t.height,!t.isSet(l,c))for(h=0;h<=1;h++){let o=d[h];if(_(l,c,o)){if(a=u,t.hasXY(l+o[0],c+o[1])&&t.isPassable(l+o[0],c+o[1])){if(!t.hasXY(l-o[0],c-o[1])||t.isDoor(l-o[0],c-o[1]))continue}else{if(!t.hasXY(l-o[0],c-o[1])||!t.isPassable(l-o[0],c-o[1]))continue;if(!t.hasXY(l+o[0],c+o[1])||t.isDoor(l+o[0],c+o[1]))continue;o=o.map((t=>-1*t))}for(e=l+o[0],i=c+o[1],n=l,r=c,a=0;a<u&&(n-=o[0],r-=o[1],!p(n,r,o));++a);if(a<u&&(X(t,f,e,i),f.getDistance(n,r)>g&&f.getDistance(n,r)<s.path.BLOCKED)){for(;n!==e||r!==i;)t.isNothing(n,r)&&t.setTile(n,r,"FLOOR"),n+=o[0],r+=o[1];const s=t.rng.chance(this.options.doorChance)?"DOOR":"FLOOR";t.setTile(l,c,s),++I;break}}}return I}}var $t=Object.freeze({__proto__:null,LoopDigger:Vt,digLoops:function(t,e={}){return new Vt(e).create(t)}});class jt{constructor(t={},e){this.seed=0,this.rooms={fails:20},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.locations={},this._locs={},this.goesUp=!1,this.seed=t.seed||0,this.tiles=e||r,"number"==typeof t.rooms&&(t.rooms={count:t.rooms}),s.object.setOptions(this.rooms,t.rooms),this.goesUp=t.goesUp||!1,t.startLoc&&(this._locs.start=t.startLoc),t.endLoc&&(this._locs.end=t.endLoc),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),s.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),s.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops?t.loops={}:"number"==typeof t.loops&&(t.loops={maxLength:t.loops}),t.loops=t.loops||{},t.loops.doorChance=t.loops.doorChance??t.doors?.chance,s.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes?t.lakes={}:"number"==typeof t.lakes&&(t.lakes={count:t.lakes}),t.lakes=t.lakes||{},s.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:("number"==typeof t.bridges&&(t.bridges={maxLength:t.bridges}),!0===t.bridges&&(t.bridges={}),s.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:("object"!=typeof t.stairs&&(t.stairs={}),s.object.setOptions(this.stairs,t.stairs),this.stairs.start=this.goesUp?"down":"up"),!0===t.log?this.log=new lt:t.log?this.log=t.log:this.log=new et}_makeRoomSite(t,e){const i=new tt(t,e);return i.rng=this.site.rng,i}_createSite(t,e){this.site=new tt(t,e)}create(...t){let e=!0;if(1==t.length){const i=t[0];i instanceof tt?(this.site=i,e=!1):this._createSite(i.width,i.height)}else this._createSite(t[0],t[1]);const i=this._create(this.site),n=t[2]||null;if(n)s.xy.forRect(this.site.width,this.site.height,((t,e)=>{const i=this.site._tiles.get(t,e);i&&n(t,e,i)}));else if(1==t.length&&e){t[0].copy(this.site._tiles)}return e&&this.site.free(),i}_create(t){return this.start(t),this.addRooms(t),this.loops&&(this.addLoops(t,this.loops),this.log.onLoopsAdded(t)),this.lakes&&(this.addLakes(t,this.lakes),this.log.onLakesAdded(t)),this.bridges&&(this.addBridges(t,this.bridges),this.log.onBridgesAdded(t)),this.stairs&&(this.addStairs(t,this.stairs),this.log.onStairsAdded(t)),this.finish(t),!0}start(t){this.site=t;const e=this.seed||s.rng.random.number();if(t.setSeed(e),t.clear(),this.seq=t.rng.sequence(t.width*t.height),this.locations=Object.assign({},this._locs),!this.locations.start||this.locations.start[0]<0){const e=this.goesUp?"down":"up";this.stairs&&Array.isArray(this.stairs[e])?this.locations.start=this.stairs[e]:(this.locations.start=[Math.floor(t.width/2),t.height-2],this.stairs&&this.stairs[e]&&(this.stairs[e]=this.locations.start))}if(!this.locations.end||this.locations.end[0]<0){const t=this.goesUp?"up":"down";this.stairs&&Array.isArray(this.stairs[t])&&(this.locations.end=this.stairs[t])}}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof pt)return t;if("string"==typeof t){const e=It[t];if(!e)throw new Error("Failed to find digger - "+t);return e}return new Et(t)}addRooms(t){let e=20;for(;--e&&!this.addFirstRoom(t););if(!e)throw new Error("Failed to place first room!");t.updateDoorDirs(),this.log.onDigFirstRoom(t);let i=0,s=1;const n=this.rooms.fails||20;for(;i<n;)if(this.addRoom(t)){if(i=0,t.updateDoorDirs(),t.rng.shuffle(this.seq),this.rooms.count&&++s>=this.rooms.count)break}else++i}addFirstRoom(t){const e=this._makeRoomSite(t.width,t.height);let i=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(e);return i&&!this._attachRoomAtLoc(t,e,i,this.locations.start)&&(i=null),e.free(),i}addRoom(t){const e=this._makeRoomSite(t.width,t.height);let i=this.getDigger(this.rooms.digger||"DEFAULT").create(e);if(i&&this.halls.chance){let t=Pt(this.halls,e,i.doors);t&&(i.hall=t)}return i&&(this.log.onRoomCandidate(i,e),this._attachRoom(t,e,i)?this.log.onRoomSuccess(t,i):(this.log.onRoomFailed(t,i,e,"Did not fit."),i=null)),e.free(),i}_attachRoom(t,e,i){const n=i.hall?i.hall.doors:i.doors;let r=0;const o=this.seq.length;for(r=0;r<o;r++){const o=Math.floor(this.seq[r]/t.height),a=this.seq[r]%t.height,h=t.getDoorDir(o,a);if(h!=s.xy.NO_DIRECTION){const s=(h+2)%4,r=n[s];if(!r)continue;const l=o-r[0],c=a-r[1];if(-1!=r[0]&&this._roomFitsAt(t,e,i,l,c))return t.copyTiles(e,l,c),this._attachDoor(t,i,o,a,s),i.translate(l,c),!0}}return!1}_attachRoomAtLoc(t,e,i,s){const[n,r]=s,o=i.hall?i.hall.doors:i.doors,a=t.rng.sequence(4);for(let s of a){const a=o[(s+2)%4];if(!a||-1==a[0])continue;const h=n-a[0],l=r-a[1];if(this._roomFitsAt(t,e,i,h,l))return t.copyTiles(e,h,l),i.translate(h,l),!0}return!1}_roomFitsAt(t,e,i,s,n){let r,o,a,h,l,c;const g=i.hall||i,u=Math.min(i.left,g.left),f=Math.min(i.top,g.top),d=Math.max(i.right,g.right),_=Math.max(i.bottom,g.bottom);for(r=u;r<=d;r++)for(o=f;o<=_;o++)if(e.isSet(r,o)){if(a=r+s,h=o+n,!t.hasXY(a,h)||t.isBoundaryXY(a,h))return!1;for(l=a-1;l<=a+1;l++)for(c=h-1;c<=h+1;c++)if(!t.isNothing(l,c))return!1}return!0}_attachDoor(t,e,i,n,r){const o=this.doors;let a=!1;o.chance&&t.rng.chance(o.chance)&&(a=!0);const h=a?o.tile||"DOOR":"FLOOR";if(t.setTile(i,n,h),e.hall&&1!=e.hall.width&&1!=e.hall.height)if(r===s.xy.UP||r===s.xy.DOWN){let e=!0,s=1;for(;e;)e=!1,t.isNothing(i-s,n)&&t.isSet(i-s,n-1)&&t.isSet(i-s,n+1)&&(t.setTile(i-s,n,h),e=!0),t.isNothing(i+s,n)&&t.isSet(i+s,n-1)&&t.isSet(i+s,n+1)&&(t.setTile(i+s,n,h),e=!0),++s}else{let e=!0,s=1;for(;e;)e=!1,t.isNothing(i,n-s)&&t.isSet(i-1,n-s)&&t.isSet(i+1,n-s)&&(t.setTile(i,n-s,h),e=!0),t.isNothing(i,n+s)&&t.isSet(i-1,n+s)&&t.isSet(i+1,n+s)&&(t.setTile(i,n+s,h),e=!0),++s}}addLoops(t,e){return new Vt(e).create(t)}addLakes(t,e){return new Ut(e).create(t)}addBridges(t,e){return new Wt(e).create(t)}addStairs(t,e){const i=new Kt(e).create(t);return i&&Object.assign(this.locations,i),!!i}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let e,i,s,n,r,o;do{for(o=!1,e=0;e<t.width-1;e++)for(i=0;i<t.height-1;i++)for(s=0;s<=1;s++)!t.blocksMove(e+s,i)&&t.blocksMove(e+(1-s),i)&&t.blocksDiagonal(e+(1-s),i)&&t.blocksMove(e+s,i+1)&&t.blocksDiagonal(e+s,i+1)&&!t.blocksMove(e+(1-s),i+1)&&(t.rng.chance(50)?(n=e+(1-s),r=i):(n=e+s,r=i+1),o=!0,t.setTile(n,r,"FLOOR"))}while(1==o)}_finishDoors(t){s.xy.forRect(t.width,t.height,((e,i)=>{t.isBoundaryXY(e,i)||t.isDoor(e,i)&&(t.isWall(e+1,i)?1:0)+(t.isWall(e-1,i)?1:0)+(t.isWall(e,i+1)?1:0)+(t.isWall(e,i-1)?1:0)!=2&&t.setTile(e,i,"FLOOR",{superpriority:!0})}))}_finishWalls(t){const e=this.boundary?"IMPREGNABLE":"WALL";s.xy.forRect(t.width,t.height,((i,s)=>{t.isNothing(i,s)&&(t.isBoundaryXY(i,s)?t.setTile(i,s,e):t.setTile(i,s,"WALL"))}))}}class zt{constructor(t,e,i=0){this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.site=t,this.blueprint=e,this.interior=s.grid.alloc(t.width,t.height),this.occupied=s.grid.alloc(t.width,t.height),this.viewMap=s.grid.alloc(t.width,t.height),this.distanceMap=new s.path.DijkstraMap(t.width,t.height),this.candidates=s.grid.alloc(t.width,t.height),this.machineNumber=i}free(){s.grid.free(this.interior),s.grid.free(this.occupied),s.grid.free(this.viewMap),s.grid.free(this.candidates)}get rng(){return this.site.rng}reset(t,e){this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.reset(this.site.width,this.site.height),this.originX=t,this.originY=e,this.distance25=0,this.distance75=0}calcDistances(t){X(this.site,this.distanceMap,this.originX,this.originY);let e=0;const i=new Array(100).fill(0);this.interior.forEach(((t,s,n)=>{if(!t)return;const r=Math.round(this.distanceMap.getDistance(s,n));r<100&&(i[r]++,e++)}));let s=Math.round(e/4),n=Math.round(3*e/4);for(let t=0;t<100;t++){if(s<=i[t]){s=t;break}s-=i[t]}for(let t=0;t<100;t++){if(n<=i[t]){n=t;break}n-=i[t]}this.distance25=s,this.distance75=n}}const qt=s.flag.fl;var Qt;!function(t){t[t.BP_ROOM=qt(0)]="BP_ROOM",t[t.BP_VESTIBULE=qt(1)]="BP_VESTIBULE",t[t.BP_REWARD=qt(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=qt(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=qt(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=qt(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=qt(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=qt(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=qt(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=qt(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=qt(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=qt(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=qt(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=qt(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=qt(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=qt(15)]="BP_NOT_IN_HALLWAY"}(Qt||(Qt={}));class Jt{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=s.frequency.make(t.frequency||100),t.size?(this.size=s.range.make(t.size),this.size.lo<=0&&(this.size.lo=1),this.size.hi<this.size.lo&&(this.size.hi=this.size.lo)):this.size=s.range.make([1,1]),t.flags&&(this.flags=s.flag.from(Qt,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new rt(t))),this.steps.forEach(((t,e)=>t.index=e))),t.id&&(this.id=t.id),this.flags&Qt.BP_ADOPT_ITEM&&!this.steps.some((t=>!!t.adoptItem||!(!t.hordeTakesItem||t.item))))throw new Error("Blueprint calls for BP_ADOPT_ITEM, but has no adoptive step.")}get isRoom(){return!!(this.flags&Qt.BP_ROOM)}get isReward(){return!!(this.flags&Qt.BP_REWARD)}get isVestiblue(){return!!(this.flags&Qt.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&Qt.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&Qt.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&Qt.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&Qt.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&Qt.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&Qt.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&Qt.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&Qt.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&Qt.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&Qt.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&Qt.BP_NO_INTERIOR_FLAG)}get notInHallway(){return!!(this.flags&Qt.BP_NOT_IN_HALLWAY)}qualifies(t,e){return!(e&&e.length&&("string"==typeof e&&(e=e.split(/[,|]/).map((t=>t.trim()))),!e.every((t=>this.tags.includes(t)))))&&!(~this.flags&t||this.flags&Qt.BP_ADOPT_ITEM&~t||this.flags&Qt.BP_VESTIBULE&~t)}pickComponents(t){const e=[st.BS_ALTERNATIVE,st.BS_ALTERNATIVE_2],i=new Array(this.steps.length).fill(!0);for(let s=0;s<=1;s++){let n=0;for(let t=0;t<i.length;t++)this.steps[t].flags&e[s]&&(i[t]=!1,n++);if(n>0){let r=t.range(1,n);for(let t=0;t<i.length;t++)if(this.steps[t].flags&e[s]){if(1==r){i[t]=!0;break}r--}}}return this.steps.filter(((t,e)=>i[e]))}fillInterior(t){const e=t.interior,i=t.site;if(e.fill(0),this.isRoom)return ie(t,t.originX,t.originY);if(this.isVestiblue)return ee(t,this);{let s=t.distanceMap;X(i,s,t.originX,t.originY,this.size.hi);const n=i.rng.sequence(i.width*i.height);let r=0,o=this.size.value();for(let a=0;a<1e3&&r<o;a++)for(let h=0;h<n.length&&r<o;h++){const o=Math.floor(n[h]/i.height),l=n[h]%i.height;if(Math.round(s.getDistance(o,l))==a){e.set(o,l,1),r++;const s=i.getMachine(o,l);if(i.isOccupied(o,l)||s>0&&s!==t.machineNumber)return 0}}return r}}}function Zt(t){const e=t.site,i=t.candidates,n=t.blueprint;if(i.fill(0),n.isRoom)i.update(((t,i,s)=>e.isGateSite(i,s)&&n.size.contains(e.getChokeCount(i,s))?1:0));else{if(n.isVestiblue)throw new Error("ERROR: Attempted to build a vestiblue without a location being provided.");i.update(((t,i,r)=>{if(!e.isPassable(i,r))return 0;if(n.notInHallway){return s.xy.arcCount(i,r,((t,i)=>e.isPassable(t,i)))<=1?1:0}return 1}))}return i.count((t=>1==t))}function te(t){const e=t.site,i=t.candidates,s=e.rng.matchingLoc(e.width,e.height,((t,e)=>1==i.get(t,e)));return!s||s[0]<0||s[1]<0?null:s}function ee(t,e){let i=!0;const n=t.site,r=t.interior;if(r.fill(0),1==e.size.hi)return r.set(t.originX,t.originY,1),1;const o=n.getChokeCount(t.originX,t.originY);if(o>1e4)return 0;const a=[-1,-1];let h=o;s.xy.eachNeighbor(t.originX,t.originY,((t,e)=>{const i=n.getChokeCount(t,e);i!=o&&(i>1e4||i<0||(a[0]=t,a[1]=e,h=i))}),!0);const l=h-o;if(e.size.contains(l)){const t=r.floodFill(a[0],a[1],((t,e,s)=>(n.isOccupied(e,s)&&(i=!1),n.getChokeCount(e,s)===h)),1);if(i&&e.size.contains(t))return l}let c=0;const g=e.size.value(n.rng),u=t.distanceMap;X(n,u,t.originX,t.originY,e.size.hi);const f=n.rng.sequence(n.width*n.height);i=!0;for(let t=0;t<1e3&&c<g;t++)for(let e=0;e<f.length&&c<g;++e){const s=Math.floor(f[e]/n.height),a=f[e]%n.height;Math.round(u.getDistance(s,a))==t&&(n.isOccupied(s,a)&&(i=!1,c=g),n.getChokeCount(s,a)<=o||(r.set(s,a,1),c+=1))}return c}function ie(t,e,i){const n=t.interior,r=t.site;let o=1;n.set(e,i,1);const a=r.getChokeCount(e,i);for(let h=0;h<4;h++){const l=e+s.xy.DIRS[h][0],c=i+s.xy.DIRS[h][1];if(r.hasXY(l,c)&&!n.get(l,c)){if(r.isOccupied(l,c)||r.getMachine(l,c)&&!r.isGateSite(l,c))return 0;if(r.getChokeCount(l,c)<=a&&!r.getMachine(l,c)){let e=ie(t,l,c);if(e<=0)return 0;o+=e}}}return o}function se(t,e=1){const i=t.interior,n=t.site;let r=0,o=!0,a=0,h=t.blueprint.size.hi,l=0;for(;o&&a<h;)o=!1,a=0,++l,i.forEach(((t,h,c)=>{t&&(++a,t==l&&s.xy.eachNeighbor(h,c,((t,h)=>{if(!i.hasXY(t,h)||i.get(t,h))return;if(i.isBoundaryXY(t,h))return;r=0;let c=!0;s.xy.eachNeighbor(t,h,((t,e)=>{i.get(t,e)?++r:n.isWall(t,e)?n.getMachine(t,e)&&(c=!1):c=!1}),!1),!c||r<e||(i.set(t,h,l+1),++a,n.blocksPathing(t,h)&&n.setTile(t,h,"FLOOR"),o=!0)}),!0))}));i.update((t=>t>0?1:0))}function ne(t){const e=t.interior,i=t.site,n=t.blueprint;n.maximizeInterior?se(t,1):n.openInterior&&se(t,4),n.purgeInterior?e.forEach(((t,e,s)=>{t&&i.setTile(e,s,"FLOOR")})):(n.purgeBlockers&&e.forEach(((t,e,s)=>{t&&i.blocksPathing(e,s)&&i.setTile(e,s,"FLOOR")})),n.purgeLiquids&&e.forEach(((t,e,s)=>{t&&i.isAnyLiquid(e,s)&&i.setTile(e,s,"FLOOR")}))),n.surroundWithWalls&&e.forEach(((t,n,r)=>{t&&!i.isGateSite(n,r)&&s.xy.eachNeighbor(n,r,((t,s)=>{e.hasXY(t,s)&&(e.get(t,s)||i.isWall(t,s)||i.isGateSite(t,s)||i.getMachine(t,s)||i.blocksPathing(t,s)||i.setTile(t,s,"WALL"))}),!1)})),n.makeImpregnable&&e.forEach(((t,n,r)=>{t&&!i.isGateSite(n,r)&&(i.makeImpregnable(n,r),s.xy.eachNeighbor(n,r,((t,s)=>{e.hasXY(t,s)&&(e.get(t,s)||i.isGateSite(t,s)||i.makeImpregnable(t,s))}),!1))}));const r=t.machineNumber;e.forEach(((t,e,s)=>{t&&(n.noInteriorFlag||i.setMachine(e,s,r,n.isRoom),i.isSecretDoor(e,s)&&i.setTile(e,s,"DOOR"))}))}const re={};function oe(t){return t instanceof Jt?t:re[t]}class ae{constructor(t={}){this.blueprints=null,t.blueprints&&(Array.isArray(t.blueprints)||(t.blueprints=Object.values(t.blueprints)),this.blueprints=t.blueprints.map((t=>oe(t)))),!0===t.log?this.log=new lt:this.log=t.log||new et,t.seed?this.seed=t.seed:this.seed=0}_pickRandom(t,e,i){i=i||s.rng.random;const n=this.blueprints||Object.values(re),r=n.map((i=>i.qualifies(t)?i.frequency(e):0));return n[i.weighted(r)]||null}buildRandom(t,e=Qt.BP_ROOM,i=-1,n=-1,r=null){const o=t.depth;let a=0;for(;a<10;){const h=this._pickRandom(e,o,t.rng);if(!h)return this.log.onBuildError(`Failed to find matching blueprint: requiredMachineFlags : ${s.flag.toString(Qt,e)}, depth: ${o}`),null;const l=new zt(t,h);if(t.analyze(),this.log.onBlueprintPick(l,e,o),this._buildAt(l,i,n,r))return{x:i,y:n};++a}return null}build(t,e,i=-1,s=-1,n=null){if("string"==typeof e){const t=e;if(!(e=re[t]))throw new Error("Failed to find blueprint - "+t)}this.seed&&t.rng.seed(this.seed);const r=new zt(t,e);return t.analyze(),this._buildAt(r,i,s,n)}_buildAt(t,e=-1,i=-1,s=null){if(e>=0&&i>=0)return this._build(t,e,i,s);let n=this._markCandidates(t);if(!n)return null;let r=20;for(;n--&&r--;){const e=te(t)||!1;if(e&&this._build(t,e[0],e[1],s))return{x:e[0],y:e[1]}}return this.log.onBlueprintFail(t,"No suitable locations found to build blueprint."),null}_build(t,e,i,s=null){if(t.reset(e,i),this.log.onBlueprintStart(t,s),!this._computeInterior(t))return null;const n=t.site.snapshot();t.machineNumber=t.site.nextMachineId(),ne(t),t.calcDistances(t.blueprint.size.hi);const r=t.blueprint.pickComponents(t.site.rng);for(let e=0;e<r.length;e++){const i=r[e];if(!this._buildStep(t,i,s))return this.log.onBlueprintFail(t,`Failed to build step ${i.index+1}/${t.blueprint.steps.length}.`),t.site.restore(n),n.free(),null}return t.blueprint.noInteriorFlag&&K(t.site,t.machineNumber),this.log.onBlueprintSuccess(t),n.free(),{x:e,y:i}}_markCandidates(t){const e=Zt(t);return e<=0?(this.log.onBlueprintFail(t,"No suitable candidate locations found."),0):(this.log.onBlueprintCandidates(t),e)}_computeInterior(t){let e=null,i=t.blueprint.fillInterior(t);return i?t.blueprint.size.contains(i)?t.blueprint.treatAsBlocking&&G(t.site,t.interior,{machine:t.site.machineCount})?e="Interior blocks map.":t.blueprint.requireBlocking&&W(t.site,t.interior)<100&&(e="Interior does not block enough cells."):e=`Interior wrong size - have: ${i}, want: ${t.blueprint.size.toString()}`:e="Interior error.",e?(this.log.onBlueprintFail(t,e),!1):(this.log.onBlueprintInterior(t),!0)}_buildStep(t,e,i){let n=0,r=0;const o=t.site;this.log.onStepStart(t,e,i);const a=at(t,e);let h=0;if(e.buildVestibule){if(!this.buildRandom(t.site,Qt.BP_VESTIBULE,t.originX,t.originY))return this.log.onStepFail(t,e,"Failed to build vestibule"),!1}if(!e.buildsInstances)return this.log.onStepSuccess(t,e),!0;const l=s.grid.alloc(o.width,o.height);let c=!1;do{if(c=!1,e.buildAtOrigin)l.set(t.originX,t.originY,1),h=1,n=1;else if(h=e.markCandidates(t,l,a),n=e.generateEverywhere||e.repeatUntilNoProgress?h:e.count.value(o.rng),this.log.onStepCandidates(t,e,l,n),l.update((t=>1==t?1:0)),!h||h<e.count.lo)return this.log.onStepFail(t,e,`Only ${h} qualifying tiles - want ${e.count.toString()}.`),!1;let s=0,g=0;for(;h>0&&r<n;){e.buildAtOrigin?(s=t.originX,g=t.originY):[s,g]=t.rng.matchingLoc(l.width,l.height,((t,e)=>1==l.get(t,e))),l.set(s,g,0),h--;const n=t.site.snapshot();this._buildStepInstance(t,e,s,g,i)?(h-=e.makePersonalSpace(t,s,g,l),r++,c=!0,n.free()):(t.site.restore(n),n.free())}}while(c&&e.repeatUntilNoProgress);return s.grid.free(l),e.count.contains(r)||e.generateEverywhere||e.repeatUntilNoProgress?(this.log.onStepSuccess(t,e),!0):(this.log.onStepFail(t,e,`Failed to build enough instances - want: ${e.count.toString()}, built: ${r}`),!1)}_buildStepInstance(t,e,i,s,n=null){let r=!0,o=!0;const a=t.site;if(r&&e.treatAsBlocking){const n={machine:a.machineCount};e.noBlockOrigin&&(n.updateWalkable=e=>(e.set(t.originX,t.originY,1),!0)),U(a,i,s,n)&&(this.log.onStepInstanceFail(t,e,i,s,"instance blocks map"),r=!1)}r&&e.feature&&(r=e.feature(a,i,s),o=r,r||this.log.onStepInstanceFail(t,e,i,s,"Failed to build effect - "+JSON.stringify(e.feature))),r&&e.tile&&(e.permitBlocking||!a.tileBlocksMove(e.tile)||e.treatAsBlocking||U(a,i,s,{machine:a.machineCount})&&(this.log.onStepInstanceFail(t,e,i,s,"tile blocks site"),r=!1),r&&(r=a.setTile(i,s,e.tile),o=o||r,r||this.log.onStepInstanceFail(t,e,i,s,"failed to set tile - "+e.tile)));let h=n;if(r&&e.item){const n=x(t.site.depth,e.item);if(n){const l=P(n);if(e.itemIsKey&&(l.key={x:i,y:s,disposable:!!e.keyIsDisposable}),e.outsourceItem){this.buildRandom(t.site,Qt.BP_ADOPT_ITEM,-1,-1,l)?o=!0:(this.log.onStepInstanceFail(t,e,i,s,"Failed to build machine to adopt item - "+l.id),r=!1)}else e.hordeTakesItem?h=l:(r=a.addItem(i,s,l)>0,o=o||r,r||this.log.onStepInstanceFail(t,e,i,s,"Failed to add item to site - "+l.id))}else r=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to make random item - "+JSON.stringify(e.item))}else if(r&&e.adoptItem){if(!n)throw new Error("Failed to build blueprint because there is no adopted item.");r&&(r=a.addItem(i,s,n)>0,r?o=!0:this.log.onStepInstanceFail(t,e,i,s,"Failed to add adopted item to site - "+n.id))}let l=null;if(r&&e.horde){let n=C(t.site.depth,e.horde,a.rng);if(n){if(n.blueprint){const e=oe(n.blueprint),r=new zt(t.site,e,t.machineNumber),o=this._build(r,i,s,null);if(r.free(),!o)return!1}const c=D(n,a,i,s,{machine:a.machineCount});c?(o=!0,h&&e.hordeTakesItem&&(l=c,l.item=h,h.x=-1,h.y=-1),n.feature&&n.feature(a,i,s),e.horde.feature&&e.horde.feature(a,i,s)):(r=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to build horde - "+n))}else r=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to pick horde - "+JSON.stringify(e.horde))}return r&&o&&(t.blueprint.noInteriorFlag||a.setMachine(i,s,t.machineNumber,t.blueprint.isRoom),e.impregnable&&a.makeImpregnable(i,s),this.log.onStepInstanceSuccess(t,e,i,s)),r&&o}}var he=Object.freeze({__proto__:null,BuildData:zt,get StepFlags(){return st},BuildStep:rt,updateViewMap:ot,calcDistanceBound:at,get CandidateType(){return nt},cellIsCandidate:ht,Builder:ae,build:function(t,e,i,s,n){return new ae(n).build(e,t,i,s)},get Flags(){return Qt},Blueprint:Jt,markCandidates:Zt,pickCandidateLoc:te,computeVestibuleInterior:ee,maximizeInterior:se,prepareInterior:ne,blueprints:re,install:function(t,e){return e instanceof Jt||(e=new Jt(e)),re[t]=e,e.id=t,e},random:function(t,e,i){const n=Object.values(re).filter((i=>i.qualifies(t)&&i.frequency(e)));return(i=i||s.rng.random).item(n)},get:oe,make:function(t){return new Jt(t)}});t.Digger=jt,t.Dungeon=class{constructor(t){this.config={levels:1,width:80,height:34,rooms:{fails:20},boundary:!0},this.seeds=[],this.stairLocs=[],s.object.setOptions(this.config,t),this.config.seed&&s.rng.random.seed(this.config.seed),"boolean"!=typeof this.config.stairs&&this.config.stairs||(this.config.stairs={}),this.config.rooms?"number"==typeof this.config.rooms&&(this.config.rooms={count:this.config.rooms}):this.config.rooms={},this._initSeeds(),this._initStairLocs()}get length(){return this.config.levels}_initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=s.rng.random.number(2**32)}_initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const e=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));let i=!1;for(let n=0;n<this.config.levels;++n){let r;this.stairLocs[n]&&this.stairLocs[n][1]&&this.stairLocs[n][1][0]>0?(r=this.stairLocs[n][1],i=s.xy.distanceBetween(t[0],t[1],r[0],r[1])<e):r=s.rng.random.matchingLoc(this.config.width,this.config.height,((i,n)=>s.xy.distanceBetween(t[0],t[1],i,n)>e)),this.stairLocs[n]=[[t[0],t[1]],[r[0],r[1]]],t=r}if(i)for(let t=this.config.levels-1;t>0;--t){let[i,n]=this.stairLocs[t];if(s.xy.distanceBetween(i[0],i[1],n[0],n[1])>e)break;i=s.rng.random.matchingLoc(this.config.width,this.config.height,((t,i)=>s.xy.distanceBetween(n[0],n[1],t,i)>e)),this.stairLocs[t][0]=i,this.stairLocs[t-1][1]=i}}getLevel(t,e){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);const[i,s]=this.stairLocs[t],n=Object.assign({},this.config.stairs);this.config.goesUp?(n.down=i,n.up=s,0==t&&this.config.startTile&&(n.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.upTile=this.config.endTile)):(n.down=s,n.up=i,0==t&&this.config.startTile&&(n.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.downTile=this.config.endTile));const r=Object.assign({},this.config.rooms);0===t&&this.config.entrance&&(r.first=this.config.entrance);let o=this.config.width,a=this.config.height;const h={seed:this.seeds[t],loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:r,stairs:n,boundary:this.config.boundary,goesUp:this.config.goesUp,width:o,height:a};return this._makeLevel(t,h,e)}_makeLevel(t,e,i){const s=new jt(e);let n=!1;return n=s.create(this.config.width,this.config.height,i),this.stairLocs[t]=[s.locations.start,s.locations.end],n}},t.Hall=ut,t.Room=dt,t.blueprint=he,t.bridge=Xt,t.feature=w,t.hall=vt,t.lake=Gt,t.loop=$t,t.makeHall=ft,t.room=Bt,t.site=gt,t.stairs=Ht,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map
